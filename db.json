{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1588775295400},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1588775295400},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1588775295400},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1588775295400},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1588775295400},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1588775295404},{"_id":"themes/next/_config.yml","hash":"92af8d178e98e7ec4524bfa4f67f6c6f0804dece","modified":1588862040950},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1588775295400},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1588775295404},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1588775295404},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1588775295404},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1588775295404},{"_id":"source/_posts/Hexo-Github搭建个人博客.md","hash":"f40206d891a1e1b0e4d6a8e99420be08f693e940","modified":1588859495410},{"_id":"source/_posts/Hexo博客异常问题.md","hash":"df43587407a5906b0f1eb4f582d1e1e3b796ee56","modified":1588860413916},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6.md","hash":"64a0dd20ff5c800d0cefedc8d32f79d236e55d6d","modified":1589638213853},{"_id":"source/_posts/Linux-kernel中的do-execve函数解析.md","hash":"f9ec4aa265e6d5dfade624d7761a1edd6b31f35a","modified":1590323532720},{"_id":"source/_posts/Linux-kernel中的i2c-dev驱动.md","hash":"4157bcc1297d21862fd734da833ef2aef6622821","modified":1588773650614},{"_id":"source/_posts/Linux内核启动流程-基于ARM64.md","hash":"7f3a3df9be4add3b98dde47c6bc99f40376c62df","modified":1588861230640},{"_id":"source/_posts/Linux块设备驱动.md","hash":"ecc7a97b056979d713efb6eaf46ae27ff16f1ef3","modified":1589638197248},{"_id":"source/_posts/Linux设备驱动模型.md","hash":"bde00d9bf6432b59ff266de9afccf929e5d36582","modified":1589638244610},{"_id":"source/_posts/Qemu搭建ARM-vexpress开发环境(一).md","hash":"1269bde73e721ac8171d5504e7cd6460bde86bf6","modified":1588859603523},{"_id":"source/_posts/platform总线设备驱动模型.md","hash":"cc9366c40308ad1a0beb30535380cacae4bf1659","modified":1589683210807},{"_id":"source/_posts/Qemu搭建ARM-vexpress开发环境(二)----u-boot启动kernel.md","hash":"850cea212a1cdfd3c737464e3fefddd6c43a3935","modified":1588859616751},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客.md","hash":"848406a345ec30ec3e15d34aca8000f5c7d5d3f9","modified":1588775572167},{"_id":"source/_posts/hello-world.md","hash":"7ea7a3b7886579784ed8bf9589085bbfc6f9d95b","modified":1588859478269},{"_id":"source/_posts/u-boot引导kernel启动过程.md","hash":"73404c9b0b414450fe40fe52908668cb20897072","modified":1588773650618},{"_id":"source/_posts/阶段性自我反思及学习动员-2019-07-07.md","hash":"e957e3ff93ee34f653ccf5c3bf6290b310c9bd63","modified":1588859660913},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1588775295404},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1588775295404},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1588775295404},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1588775295408},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1588775295404},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1588775295408},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1588775295408},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1588775295408},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1588775295408},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1588775295408},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1588775295408},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1588775295408},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1588775295408},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1588775295408},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1588775295408},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1588775295408},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1588775295408},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1588775295412},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1588775295412},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1588775295412},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1588775295416},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1588775295416},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1588775295416},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1588775295416},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1588775295416},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1588775295416},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1588775295416},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1588775295416},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1588775295416},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1588775295416},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1588775295416},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1588775295416},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1588775295416},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1588775295416},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1588775295416},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1588775295416},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1588775295416},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1588775295420},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1588775295420},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1588775295420},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1588775295420},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1588775295420},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1588775295420},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1588775295420},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1588775295420},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1588775295420},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1588775295420},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1588775295420},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1588775295420},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1588775295444},{"_id":"source/_posts/Linux-kernel中的I2C子系统.md","hash":"249d6b9c7e9719e1589aed1bd69f65d347df7263","modified":1588773650606},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image.png","hash":"4c9acde5395bd807a0eff64c2e28ef4f27f3963c","modified":1588773650598},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image1.png","hash":"79fb6b6167135f771b17b60d737e879962e162ff","modified":1588773650598},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image2.png","hash":"a2d2df595846232e3116bb0daf950f57041937ca","modified":1588773650598},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image4.png","hash":"ff08c87920386dde3a1cc02439d678130820cffa","modified":1588773650602},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image5.png","hash":"b594234bc72084202bebac6e8020edbba2bc8e36","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Address-Register2.png","hash":"87a869119a89dcb45e60815621aff7ba169ac80a","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Control-Register.png","hash":"85dcce26c142ec09b0de042365ffadfe0a5bb329","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Data-IO-Register.png","hash":"621567dfbba9dffc8a2ba1c101fc27ace787bc70","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-memory-map.png","hash":"b4123009a40b75206b387cea92353debcd41cb73","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Status-Register.png","hash":"b8265ecac467e8374aaba3f914622d414c9f57ee","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions3.png","hash":"560e622ddb192a794fd595e8786a740d9bbc7f15","modified":1588773650606},{"_id":"source/_posts/Linux块设备驱动/块设备数据结构间的关系.png","hash":"8e8e41deed481f8214e0b2e38a442dd3ad5fff08","modified":1588773650614},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image1.png","hash":"79fb6b6167135f771b17b60d737e879962e162ff","modified":1588773650618},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image.png","hash":"4c9acde5395bd807a0eff64c2e28ef4f27f3963c","modified":1588773650618},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image2.png","hash":"a2d2df595846232e3116bb0daf950f57041937ca","modified":1588773650618},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image4.png","hash":"ff08c87920386dde3a1cc02439d678130820cffa","modified":1588773650618},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image5.png","hash":"b594234bc72084202bebac6e8020edbba2bc8e36","modified":1588773650618},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1588775295408},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1588775295408},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1588775295408},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1588775295408},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1588775295412},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1588775295412},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1588775295412},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1588775295412},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1588775295412},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1588775295420},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1588775295420},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1588775295420},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1588775295424},{"_id":"themes/next/layout/_partials/footer.swig","hash":"49751ab80ab9ae1a85752c771e1b4c5924abad0a","modified":1590915892386},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1588775295424},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1588775295424},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1588775295424},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1588775295436},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1588775295436},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1588775295436},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1588775295436},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1588775295432},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1588775295432},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1588775295432},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1588775295432},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1588775295432},{"_id":"themes/next/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1588775295444},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1588775295448},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1588775295448},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1588775295448},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1588775295448},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1588775295448},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1588775295448},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1588775295448},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1588775295448},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1588775295448},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1588775295452},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1588775295452},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1588775295452},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1588775295452},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1588775295452},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1588775295452},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1588775295452},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1588775295452},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1588775295452},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1588775295452},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1588775295476},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588775295476},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1588775295476},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1588775295476},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1588775295476},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1588775295476},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1588775295480},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1588775295480},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1588775295480},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1588775295480},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1588775295452},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588775295480},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1588775295472},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1588775295480},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588775295480},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1588775295476},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1588775295480},{"_id":"themes/next/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1588775295480},{"_id":"themes/next/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1588775295480},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1588775295480},{"_id":"themes/next/source/js/local-search.js","hash":"d6673063958127a03881dab2f0376a47f5e08a88","modified":1588775295480},{"_id":"themes/next/source/js/utils.js","hash":"91d174e12c61c332f3b06085d635c2b0f686a758","modified":1588775295480},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1588775295480},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image3.JPG","hash":"6ce9c87f856ca7d52e047e43f412aaa258ab8ae0","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Frequency-Divider-Register.png","hash":"d8268988bd1579d05d8d9393000cfd8a934d5bc1","modified":1588773650602},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions.png","hash":"d6010f464b45c57e3b51bc0b945d17147de16096","modified":1588773650606},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions2.png","hash":"d4ca491f5d814aed6f3a6ecef6bdbf6a74ab0b6f","modified":1588773650606},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C总线层和设备层的关系.png","hash":"b2ac7a8db7f6d7f125c832f89a0596192d21885b","modified":1588773650606},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C数据结构间的关系.png","hash":"b5016c57598322c9617e82e2c611137fac12bd72","modified":1588773650610},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C注册匹配过程.png","hash":"587774ae7656a92f46c94b444b37f766c116bb09","modified":1588773650610},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions.png","hash":"539d03719441e9b4ddcd85ce4499e5c5b9d19871","modified":1588773650606},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions2.png","hash":"c8219ba780486c197f0dbdc2d67705f792a5d654","modified":1588773650606},{"_id":"source/_posts/Linux-kernel中的I2C子系统/Linux的I2C体系结构-1587651297877.png","hash":"03251aa7657b5006a3e7c7797985fca8d8f4378a","modified":1588773650610},{"_id":"source/_posts/Linux-kernel中的I2C子系统/Linux的I2C体系结构.png","hash":"03251aa7657b5006a3e7c7797985fca8d8f4378a","modified":1588773650610},{"_id":"source/_posts/Linux块设备驱动/20141116085400721.png","hash":"b5016c57598322c9617e82e2c611137fac12bd72","modified":1588773650614},{"_id":"source/_posts/Linux块设备驱动/Linux的块IO.png","hash":"4bdf968ca9735e1603b3d6dc87fc6fb906a7e620","modified":1588773650614},{"_id":"source/_posts/Linux块设备驱动/块设备驱动架构图.jpg","hash":"957605cd220d4cf4c6e66f8ee4a5b9af5cabf7fb","modified":1588773650614},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image3.JPG","hash":"6ce9c87f856ca7d52e047e43f412aaa258ab8ae0","modified":1588773650618},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/themes-yilia.png","hash":"156a7b699d623baa577c99dd3cb77107861615ed","modified":1588773650618},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C设备和驱动的关系.png","hash":"7136ce201942f8c29c1b9bea998a13771fdf524c","modified":1588773650610},{"_id":"source/_posts/Linux-kernel中的I2C子系统/Linux的I2C子系统框架.png","hash":"404ef215140424d7c8d05071bed59607138d49a1","modified":1588773650614},{"_id":"source/_posts/Linux-kernel中的i2c-dev驱动/Linux的I2C子系统框架.png","hash":"404ef215140424d7c8d05071bed59607138d49a1","modified":1588773650614},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1588775295424},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1588775295424},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1588775295424},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1588775295424},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1588775295424},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1588775295424},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1588775295424},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1588775295424},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1588775295424},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1588775295428},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1588775295428},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1588775295428},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1588775295428},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1588775295428},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1588775295428},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1588775295428},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1588775295428},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1588775295428},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1588775295436},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1588775295436},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1588775295436},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1588775295436},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1588775295436},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1588775295436},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1588775295436},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1588775295440},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1588775295440},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1588775295440},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1588775295440},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1588775295440},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1588775295440},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1588775295440},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1588775295440},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1588775295440},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1588775295440},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1588775295440},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1588775295440},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1588775295440},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1588775295440},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1588775295440},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1588775295440},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1588775295444},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1588775295444},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1588775295432},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1588775295432},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1588775295432},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1588775295432},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1588775295432},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1588775295444},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1588775295444},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1588775295444},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1588775295444},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1588775295444},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1588775295444},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1588775295448},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1588775295448},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1588775295448},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1588775295448},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1588775295448},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1588775295476},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1588775295476},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1588775295480},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1588775295476},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1588775295476},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588775295488},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588775295488},{"_id":"source/_posts/Linux块设备驱动/块设备驱动系统架构.png","hash":"aea7ac969311b866523a989891f81b074877ce34","modified":1588773650618},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1588775295476},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1588775295480},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1588775295456},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1588775295464},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1588775295472},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1588775295456},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1588775295464},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1588775295460},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1588775295476},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1588775295476},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1588775295472},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1588775295476},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1588775295476},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1588775295476},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1588775295476},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1588775295484},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1588775295476},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1588775295476},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1588775295484},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1588775295484},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1588775295484},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1588775295456},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1588775295460},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1588775295460},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1588775295460},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1588775295464},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1588775295464},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1588775295460},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1588775295468},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1588775295460},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1588775295468},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1588775295464},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1588775295468},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1588775295472},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1588775295472},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1588775295468},{"_id":"public/2019/07/14/hello-world/index.html","hash":"64a3b5547f419f54c83a852b053e5a448187ee06","modified":1598177056394},{"_id":"public/archives/index.html","hash":"047b75a66e65b4b48e80db56a46ae808a7009aa5","modified":1598177056394},{"_id":"public/archives/page/2/index.html","hash":"96e3c9e79c47e70948e31a8885b0175e8de593fb","modified":1598177056394},{"_id":"public/archives/2019/index.html","hash":"a083ccd42f32409283fb2efd4d4fb6d241369aaf","modified":1598177056394},{"_id":"public/archives/2019/07/index.html","hash":"74c82d9f51057f0b9d9a17a993c837a5d595f296","modified":1598177056394},{"_id":"public/archives/2019/08/index.html","hash":"ac0caaf36e59076551996a79f00519a97dc2a863","modified":1598177056394},{"_id":"public/archives/2020/index.html","hash":"5f97a6d42c0139a99466b96cf0d84c043e84cbc8","modified":1598177056394},{"_id":"public/archives/2020/04/index.html","hash":"f7b53375f10e193266bffe7d39806d5e0e617658","modified":1598177056394},{"_id":"public/archives/2020/05/index.html","hash":"987c504e39b1072843ef1ed66ed16c680b34b55c","modified":1598177056394},{"_id":"public/tags/Hexo/index.html","hash":"270e371a2fc186493d95ef4e40835730ff88093b","modified":1598177056394},{"_id":"public/tags/i2c/index.html","hash":"c4eda625b4501b60b9366397099edbc5d71ce4a1","modified":1598177056394},{"_id":"public/tags/Kernel/index.html","hash":"64e1e452dc4ef061e98d4b9a27b30bec936e836f","modified":1598177056394},{"_id":"public/tags/Driver/index.html","hash":"b60a6908cb611f57b2c9133df2539913c7159a1c","modified":1598177056394},{"_id":"public/tags/Qemu/index.html","hash":"4e2ed39376fe74acdcf3681a07b9aca850a054b1","modified":1598177056394},{"_id":"public/tags/u-boot/index.html","hash":"62bd9c4a241ef8e2a174780c378ad571f7d4bfc2","modified":1598177056394},{"_id":"public/2020/05/24/Linux-kernel中的do-execve函数解析/index.html","hash":"ff3cdb41ce6ed7b026852547e4872fba3e528082","modified":1598177056394},{"_id":"public/2020/05/17/platform总线设备驱动模型/index.html","hash":"f5b9020a3156ab51f03372f2d92a460dd1157a6b","modified":1598177056394},{"_id":"public/2020/05/10/Linux设备驱动模型/index.html","hash":"5b1f0584a8c4b8238d44b36ea1b881452c03d528","modified":1598177056394},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/index.html","hash":"d6a33469a7a891e413b9dc72b19e77656da0da8e","modified":1598177056394},{"_id":"public/2020/04/19/Linux内核启动流程-基于ARM64/index.html","hash":"3e694efb620c03a54408fbf8d89838073db416a0","modified":1598177056394},{"_id":"public/2020/04/19/u-boot引导kernel启动过程/index.html","hash":"2df28706d809b2b14d2d07a95a0a79e30f451002","modified":1598177056394},{"_id":"public/2020/04/19/Linux块设备驱动/index.html","hash":"84f6436e1253f88492d286007c959a95bc9c8e20","modified":1598177056394},{"_id":"public/2020/04/12/Linux-kernel中的i2c-dev驱动/index.html","hash":"aece75db566c726bb80cbc3c3701b4c3b20f1756","modified":1598177056394},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/index.html","hash":"721c23ddc04fdb9a0b7937053c4447a5e80579a2","modified":1598177056394},{"_id":"public/2019/08/18/Qemu搭建ARM-vexpress开发环境(二)----u-boot启动kernel/index.html","hash":"4f154f090e7208e1bfe2f7790bee998466220d3b","modified":1598177056394},{"_id":"public/2019/08/11/Qemu搭建ARM-vexpress开发环境(一)/index.html","hash":"38519aaf19df2b719d3984ab9f3ce1167405b84d","modified":1598177056394},{"_id":"public/2019/08/04/Hexo博客异常问题/index.html","hash":"446141bf2acff5a4f1b5b391e83417a651bef768","modified":1598177056394},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/index.html","hash":"daf848d6c8b1e1bf3fd93c52191201bfb38d2a21","modified":1598177056394},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/index.html","hash":"e6c82ca59438eabc40ed17ece16f66554930e2ba","modified":1598177056394},{"_id":"public/2019/07/07/阶段性自我反思及学习动员-2019-07-07/index.html","hash":"8834f47f9f793fd1075eab4a6fb1c762bf6a0f6a","modified":1598177056394},{"_id":"public/index.html","hash":"2a4caf20eb379ae6f09eab0df7153e2bc87094b6","modified":1598177056394},{"_id":"public/page/2/index.html","hash":"cb435fa90f47002f8748a9ff2a9d55a9060a20c4","modified":1598177056394},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1590916205237},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1590916205237},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1590916205237},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1590916205237},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1590916205237},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1590916205237},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1590916205237},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1590916205237},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1590916205237},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1590916205237},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1590916205237},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1590916205237},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1590916205237},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1590916205237},{"_id":"public/2020/04/19/Linux块设备驱动/块设备数据结构间的关系.png","hash":"8e8e41deed481f8214e0b2e38a442dd3ad5fff08","modified":1590916205237},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/Image.png","hash":"4c9acde5395bd807a0eff64c2e28ef4f27f3963c","modified":1590916205237},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/Image1.png","hash":"79fb6b6167135f771b17b60d737e879962e162ff","modified":1590916205237},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/Image2.png","hash":"a2d2df595846232e3116bb0daf950f57041937ca","modified":1590916205237},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/Image4.png","hash":"ff08c87920386dde3a1cc02439d678130820cffa","modified":1590916205237},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/Image5.png","hash":"b594234bc72084202bebac6e8020edbba2bc8e36","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/Image.png","hash":"4c9acde5395bd807a0eff64c2e28ef4f27f3963c","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/Image1.png","hash":"79fb6b6167135f771b17b60d737e879962e162ff","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/Image2.png","hash":"a2d2df595846232e3116bb0daf950f57041937ca","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/Image4.png","hash":"ff08c87920386dde3a1cc02439d678130820cffa","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/Image5.png","hash":"b594234bc72084202bebac6e8020edbba2bc8e36","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Control-Register.png","hash":"85dcce26c142ec09b0de042365ffadfe0a5bb329","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Address-Register2.png","hash":"87a869119a89dcb45e60815621aff7ba169ac80a","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Data-IO-Register.png","hash":"621567dfbba9dffc8a2ba1c101fc27ace787bc70","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Status-Register.png","hash":"b8265ecac467e8374aaba3f914622d414c9f57ee","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-memory-map.png","hash":"b4123009a40b75206b387cea92353debcd41cb73","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions3.png","hash":"560e622ddb192a794fd595e8786a740d9bbc7f15","modified":1590916205237},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1590916205237},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1590916205237},{"_id":"public/2020/04/19/Linux块设备驱动/20141116085400721.png","hash":"b5016c57598322c9617e82e2c611137fac12bd72","modified":1590916205237},{"_id":"public/2020/04/19/Linux块设备驱动/Linux的块IO.png","hash":"4bdf968ca9735e1603b3d6dc87fc6fb906a7e620","modified":1590916205237},{"_id":"public/2020/04/19/Linux块设备驱动/块设备驱动架构图.jpg","hash":"957605cd220d4cf4c6e66f8ee4a5b9af5cabf7fb","modified":1590916205237},{"_id":"public/2019/07/21/Hexo-Github搭建个人博客/Image3.JPG","hash":"6ce9c87f856ca7d52e047e43f412aaa258ab8ae0","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/Image3.JPG","hash":"6ce9c87f856ca7d52e047e43f412aaa258ab8ae0","modified":1590916205237},{"_id":"public/2019/07/28/Ubuntu-Hexo-Github搭建个人博客/themes-yilia.png","hash":"156a7b699d623baa577c99dd3cb77107861615ed","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Frequency-Divider-Register.png","hash":"d8268988bd1579d05d8d9393000cfd8a934d5bc1","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions.png","hash":"d6010f464b45c57e3b51bc0b945d17147de16096","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions2.png","hash":"d4ca491f5d814aed6f3a6ecef6bdbf6a74ab0b6f","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions.png","hash":"539d03719441e9b4ddcd85ce4499e5c5b9d19871","modified":1590916205237},{"_id":"public/2020/04/23/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions2.png","hash":"c8219ba780486c197f0dbdc2d67705f792a5d654","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/I2C总线层和设备层的关系.png","hash":"b2ac7a8db7f6d7f125c832f89a0596192d21885b","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/I2C数据结构间的关系.png","hash":"b5016c57598322c9617e82e2c611137fac12bd72","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/I2C注册匹配过程.png","hash":"587774ae7656a92f46c94b444b37f766c116bb09","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/Linux的I2C体系结构-1587651297877.png","hash":"03251aa7657b5006a3e7c7797985fca8d8f4378a","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/Linux的I2C体系结构.png","hash":"03251aa7657b5006a3e7c7797985fca8d8f4378a","modified":1590916205237},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1590916205237},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1590916205237},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1590916205237},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1590916205237},{"_id":"public/js/local-search.js","hash":"d6673063958127a03881dab2f0376a47f5e08a88","modified":1590916205237},{"_id":"public/js/utils.js","hash":"91d174e12c61c332f3b06085d635c2b0f686a758","modified":1590916205237},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1590916205237},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1590916205237},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1590916205237},{"_id":"public/css/main.css","hash":"ecbd8f0043d7c77bad2bfa9fc7ca20da1eeb1601","modified":1590916205237},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1590916205237},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1590916205237},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1590916205237},{"_id":"public/2020/04/12/Linux-kernel中的i2c-dev驱动/Linux的I2C子系统框架.png","hash":"404ef215140424d7c8d05071bed59607138d49a1","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/I2C设备和驱动的关系.png","hash":"7136ce201942f8c29c1b9bea998a13771fdf524c","modified":1590916205237},{"_id":"public/2020/04/06/Linux-kernel中的I2C子系统/Linux的I2C子系统框架.png","hash":"404ef215140424d7c8d05071bed59607138d49a1","modified":1590916205237},{"_id":"public/2020/04/19/Linux块设备驱动/块设备驱动系统架构.png","hash":"aea7ac969311b866523a989891f81b074877ce34","modified":1590916205237},{"_id":"source/_posts/busybox加载inittab过程分析.md","hash":"5a96e11f2ac231d4910f6bba7ee38713a174d360","modified":1590926986777},{"_id":"public/tags/busybox/index.html","hash":"42e0123130e43c01e4c1538f7ddcbfb7559f073e","modified":1598177056394},{"_id":"public/2020/05/31/busybox加载inittab过程分析/index.html","hash":"977bb30d4b2f57da6828baf92cae17b050d62d24","modified":1598177056394},{"_id":"source/_posts/u-boot的tftp命令解析.md","hash":"712e776cb4f30859c79581c9fc87cb0ff847ed18","modified":1593236555052},{"_id":"source/_posts/u-boot的tftp命令解析/tftp流程.jpg","hash":"b65a66f96930fc111aed8f052d73b65fe0b03666","modified":1593233974675},{"_id":"public/2020/06/27/u-boot的tftp命令解析/index.html","hash":"aecf325a5f61844f7a0d1f973893b82348eac1a3","modified":1598177056394},{"_id":"public/archives/2020/06/index.html","hash":"b22670548cc6cd4d06761a2a191a8005f717121f","modified":1598177056394},{"_id":"public/archives/2020/page/2/index.html","hash":"0f7f0da4ad9cbf2e3654236e4799de312ee66bee","modified":1598177056394},{"_id":"public/2020/06/27/u-boot的tftp命令解析/tftp流程.jpg","hash":"b65a66f96930fc111aed8f052d73b65fe0b03666","modified":1593236418476},{"_id":"source/_posts/linux-kernel中的tty驱动.md","hash":"3ff74f543995d6a92f351fbb14eccad562e51e0a","modified":1598176893406},{"_id":"source/_posts/linux-kernel中的tty驱动/tty层次关系-1598176659466.jpg","hash":"bdd763aa3cdc4a6c534a32eabaf8d3f176dd7873","modified":1598176659474},{"_id":"source/_posts/linux-kernel中的tty驱动/tty层次关系.jpg","hash":"bdd763aa3cdc4a6c534a32eabaf8d3f176dd7873","modified":1598176425666},{"_id":"source/_posts/linux-kernel中的tty驱动/tty读写过程中的函数调用流程-1598176659467.png","hash":"2786a4498d92b7b4403ffadb7c7d1a0271f2937b","modified":1598176659474},{"_id":"source/_posts/linux-kernel中的tty驱动/tty读写过程中的函数调用流程.png","hash":"2786a4498d92b7b4403ffadb7c7d1a0271f2937b","modified":1598176425666},{"_id":"public/2020/08/02/linux-kernel中的tty驱动/index.html","hash":"0759e4cc1249ed3148525f224907c9882d7a054e","modified":1598177056394},{"_id":"public/archives/2020/08/index.html","hash":"a2d12815ac71f1efd3d7492960af364b1c16143b","modified":1598177056394},{"_id":"public/tags/tty/index.html","hash":"e497ce55eb6c8b9c88e9638cc1dfeefcbd4fd6a6","modified":1598177056394},{"_id":"public/2020/08/02/linux-kernel中的tty驱动/tty层次关系-1598176659466.jpg","hash":"bdd763aa3cdc4a6c534a32eabaf8d3f176dd7873","modified":1598176714576},{"_id":"public/2020/08/02/linux-kernel中的tty驱动/tty层次关系.jpg","hash":"bdd763aa3cdc4a6c534a32eabaf8d3f176dd7873","modified":1598176714576},{"_id":"public/2020/08/02/linux-kernel中的tty驱动/tty读写过程中的函数调用流程-1598176659467.png","hash":"2786a4498d92b7b4403ffadb7c7d1a0271f2937b","modified":1598176714576},{"_id":"public/2020/08/02/linux-kernel中的tty驱动/tty读写过程中的函数调用流程.png","hash":"2786a4498d92b7b4403ffadb7c7d1a0271f2937b","modified":1598176714576},{"_id":"source/_posts/控制台驱动中tty-read函数的实现过程.md","hash":"3f4f52b5eb522b63d34c7c4902a2fdbee4b91a68","modified":1598177048176},{"_id":"public/2020/08/09/控制台驱动中tty-read函数的实现过程/index.html","hash":"6e6dfe1d0c5cb80a7120fcbef28a092d2b61f5ea","modified":1598177056394}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hexo博客异常问题","date":"2019-08-04T13:34:20.000Z","_content":"\n\n\n\n\n\n\n本文用于记录Hexo博客搭建过程中遇到问题的解决方法，以备以后再遇到能够尽快解决；由于不是专业人员，对Hexo和前端知识也不懂，对问题解决的原理也一改不懂，见笑！！！\n\n\n\n<!--more-->\n\n\n\n#### 1. Hexo博客引用本地图片无法显示问题\n\n\n\nHexo需要将图片的路径转换到html文件中，这个操作由hexo-asset-image完成；\n\n```\n# sudo npm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n\n\n用以下内容替换/node_modules/hexo-asset-image/index.js文件中的内容；\n\n```\n'use strict';\nvar cheerio = require('cheerio');\n\n// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string\nfunction getPosition(str, m, i) {\n  return str.split(m, i).join(m).length;\n}\n\nvar version = String(hexo.version).split('.');\nhexo.extend.filter.register('after_post_render', function(data){\n  var config = hexo.config;\n  if(config.post_asset_folder){\n    \tvar link = data.permalink;\n\tif(version.length > 0 && Number(version[0]) == 3)\n\t   var beginPos = getPosition(link, '/', 1) + 1;\n\telse\n\t   var beginPos = getPosition(link, '/', 3) + 1;\n\t// In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".\n\tvar endPos = link.lastIndexOf('/') + 1;\n    link = link.substring(beginPos, endPos);\n\n    var toprocess = ['excerpt', 'more', 'content'];\n    for(var i = 0; i < toprocess.length; i++){\n      var key = toprocess[i];\n \n      var $ = cheerio.load(data[key], {\n        ignoreWhitespace: false,\n        xmlMode: false,\n        lowerCaseTags: false,\n        decodeEntities: false\n      });\n\n      $('img').each(function(){\n\t\tif ($(this).attr('src')){\n\t\t\t// For windows style path, we replace '\\' to '/'.\n\t\t\tvar src = $(this).attr('src').replace('\\\\', '/');\n\t\t\tif(!/http[s]*.*|\\/\\/.*/.test(src) &&\n\t\t\t   !/^\\s*\\//.test(src)) {\n\t\t\t  // For \"about\" page, the first part of \"src\" can't be removed.\n\t\t\t  // In addition, to support multi-level local directory.\n\t\t\t  var linkArray = link.split('/').filter(function(elem){\n\t\t\t\treturn elem != '';\n\t\t\t  });\n\t\t\t  var srcArray = src.split('/').filter(function(elem){\n\t\t\t\treturn elem != '' && elem != '.';\n\t\t\t  });\n\t\t\t  if(srcArray.length > 1)\n\t\t\t\tsrcArray.shift();\n\t\t\t  src = srcArray.join('/');\n\t\t\t  $(this).attr('src', config.root + link + src);\n\t\t\t  console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n\t\t\t}\n\t\t}else{\n\t\t\tconsole.info&&console.info(\"no src attr, skipped...\");\n\t\t\tconsole.info&&console.info($(this));\n\t\t}\n      });\n      data[key] = $.html();\n    }\n  }\n});\n```\n\n\n\n修改博客主目录下__config.yml文件：\n\n```\npost_asset_folder: true\n```\n\n\n\n\n\n此时，使用Hexo new \"File\"命令创建博客文件之后，除了在source/_post目录生成一个File.md文件之外，还会生成一个同名的File文件夹，用来保存在File.md文件中引用的本地图片；\n\n\n\n\n\n#### 2. Hexo博客无法显示mermaid流程图问题\n\n\n\nhttps://www.cnblogs.com/icoty23/p/10911231.html\n\n\n\n\n\n\n\n\n\n","source":"_posts/Hexo博客异常问题.md","raw":"---\ntitle: Hexo博客异常问题\ndate: 2019-08-04 21:34:20\ntags: Hexo\n---\n\n\n\n\n\n\n\n本文用于记录Hexo博客搭建过程中遇到问题的解决方法，以备以后再遇到能够尽快解决；由于不是专业人员，对Hexo和前端知识也不懂，对问题解决的原理也一改不懂，见笑！！！\n\n\n\n<!--more-->\n\n\n\n#### 1. Hexo博客引用本地图片无法显示问题\n\n\n\nHexo需要将图片的路径转换到html文件中，这个操作由hexo-asset-image完成；\n\n```\n# sudo npm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n\n\n用以下内容替换/node_modules/hexo-asset-image/index.js文件中的内容；\n\n```\n'use strict';\nvar cheerio = require('cheerio');\n\n// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string\nfunction getPosition(str, m, i) {\n  return str.split(m, i).join(m).length;\n}\n\nvar version = String(hexo.version).split('.');\nhexo.extend.filter.register('after_post_render', function(data){\n  var config = hexo.config;\n  if(config.post_asset_folder){\n    \tvar link = data.permalink;\n\tif(version.length > 0 && Number(version[0]) == 3)\n\t   var beginPos = getPosition(link, '/', 1) + 1;\n\telse\n\t   var beginPos = getPosition(link, '/', 3) + 1;\n\t// In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".\n\tvar endPos = link.lastIndexOf('/') + 1;\n    link = link.substring(beginPos, endPos);\n\n    var toprocess = ['excerpt', 'more', 'content'];\n    for(var i = 0; i < toprocess.length; i++){\n      var key = toprocess[i];\n \n      var $ = cheerio.load(data[key], {\n        ignoreWhitespace: false,\n        xmlMode: false,\n        lowerCaseTags: false,\n        decodeEntities: false\n      });\n\n      $('img').each(function(){\n\t\tif ($(this).attr('src')){\n\t\t\t// For windows style path, we replace '\\' to '/'.\n\t\t\tvar src = $(this).attr('src').replace('\\\\', '/');\n\t\t\tif(!/http[s]*.*|\\/\\/.*/.test(src) &&\n\t\t\t   !/^\\s*\\//.test(src)) {\n\t\t\t  // For \"about\" page, the first part of \"src\" can't be removed.\n\t\t\t  // In addition, to support multi-level local directory.\n\t\t\t  var linkArray = link.split('/').filter(function(elem){\n\t\t\t\treturn elem != '';\n\t\t\t  });\n\t\t\t  var srcArray = src.split('/').filter(function(elem){\n\t\t\t\treturn elem != '' && elem != '.';\n\t\t\t  });\n\t\t\t  if(srcArray.length > 1)\n\t\t\t\tsrcArray.shift();\n\t\t\t  src = srcArray.join('/');\n\t\t\t  $(this).attr('src', config.root + link + src);\n\t\t\t  console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n\t\t\t}\n\t\t}else{\n\t\t\tconsole.info&&console.info(\"no src attr, skipped...\");\n\t\t\tconsole.info&&console.info($(this));\n\t\t}\n      });\n      data[key] = $.html();\n    }\n  }\n});\n```\n\n\n\n修改博客主目录下__config.yml文件：\n\n```\npost_asset_folder: true\n```\n\n\n\n\n\n此时，使用Hexo new \"File\"命令创建博客文件之后，除了在source/_post目录生成一个File.md文件之外，还会生成一个同名的File文件夹，用来保存在File.md文件中引用的本地图片；\n\n\n\n\n\n#### 2. Hexo博客无法显示mermaid流程图问题\n\n\n\nhttps://www.cnblogs.com/icoty23/p/10911231.html\n\n\n\n\n\n\n\n\n\n","slug":"Hexo博客异常问题","published":1,"updated":"2020-05-07T14:06:53.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkue0000dqg111p2755q","content":"<p>本文用于记录Hexo博客搭建过程中遇到问题的解决方法，以备以后再遇到能够尽快解决；由于不是专业人员，对Hexo和前端知识也不懂，对问题解决的原理也一改不懂，见笑！！！</p>\n<a id=\"more\"></a>\n\n\n\n<h4 id=\"1-Hexo博客引用本地图片无法显示问题\"><a href=\"#1-Hexo博客引用本地图片无法显示问题\" class=\"headerlink\" title=\"1. Hexo博客引用本地图片无法显示问题\"></a>1. Hexo博客引用本地图片无法显示问题</h4><p>Hexo需要将图片的路径转换到html文件中，这个操作由hexo-asset-image完成；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n\n\n\n<p>用以下内容替换/node_modules/hexo-asset-image/index.js文件中的内容；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;;</span><br><span class=\"line\">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class=\"line\">function getPosition(str, m, i) &#123;</span><br><span class=\"line\">  return str.split(m, i).join(m).length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class=\"line\">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class=\"line\">  var config &#x3D; hexo.config;</span><br><span class=\"line\">  if(config.post_asset_folder)&#123;</span><br><span class=\"line\">    \tvar link &#x3D; data.permalink;</span><br><span class=\"line\">\tif(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class=\"line\">\t   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class=\"line\">\t&#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class=\"line\">\tvar endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class=\"line\">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class=\"line\"></span><br><span class=\"line\">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class=\"line\">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class=\"line\">      var key &#x3D; toprocess[i];</span><br><span class=\"line\"> </span><br><span class=\"line\">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class=\"line\">        ignoreWhitespace: false,</span><br><span class=\"line\">        xmlMode: false,</span><br><span class=\"line\">        lowerCaseTags: false,</span><br><span class=\"line\">        decodeEntities: false</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      $(&#39;img&#39;).each(function()&#123;</span><br><span class=\"line\">\t\tif ($(this).attr(&#39;src&#39;))&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; For windows style path, we replace &#39;\\&#39; to &#39;&#x2F;&#39;.</span><br><span class=\"line\">\t\t\tvar src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;&#x2F;&#39;);</span><br><span class=\"line\">\t\t\tif(!&#x2F;http[s]*.*|\\&#x2F;\\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class=\"line\">\t\t\t   !&#x2F;^\\s*\\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class=\"line\">\t\t\t  &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class=\"line\">\t\t\t  &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class=\"line\">\t\t\t  var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class=\"line\">\t\t\t\treturn elem !&#x3D; &#39;&#39;;</span><br><span class=\"line\">\t\t\t  &#125;);</span><br><span class=\"line\">\t\t\t  var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class=\"line\">\t\t\t\treturn elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class=\"line\">\t\t\t  &#125;);</span><br><span class=\"line\">\t\t\t  if(srcArray.length &gt; 1)</span><br><span class=\"line\">\t\t\t\tsrcArray.shift();</span><br><span class=\"line\">\t\t\t  src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class=\"line\">\t\t\t  $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class=\"line\">\t\t\t  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tconsole.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class=\"line\">\t\t\tconsole.info&amp;&amp;console.info($(this));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      data[key] &#x3D; $.html();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>修改博客主目录下__config.yml文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>此时，使用Hexo new “File”命令创建博客文件之后，除了在source/_post目录生成一个File.md文件之外，还会生成一个同名的File文件夹，用来保存在File.md文件中引用的本地图片；</p>\n<h4 id=\"2-Hexo博客无法显示mermaid流程图问题\"><a href=\"#2-Hexo博客无法显示mermaid流程图问题\" class=\"headerlink\" title=\"2. Hexo博客无法显示mermaid流程图问题\"></a>2. Hexo博客无法显示mermaid流程图问题</h4><p><a href=\"https://www.cnblogs.com/icoty23/p/10911231.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/icoty23/p/10911231.html</a></p>\n","site":{"data":{}},"excerpt":"<p>本文用于记录Hexo博客搭建过程中遇到问题的解决方法，以备以后再遇到能够尽快解决；由于不是专业人员，对Hexo和前端知识也不懂，对问题解决的原理也一改不懂，见笑！！！</p>","more":"<h4 id=\"1-Hexo博客引用本地图片无法显示问题\"><a href=\"#1-Hexo博客引用本地图片无法显示问题\" class=\"headerlink\" title=\"1. Hexo博客引用本地图片无法显示问题\"></a>1. Hexo博客引用本地图片无法显示问题</h4><p>Hexo需要将图片的路径转换到html文件中，这个操作由hexo-asset-image完成；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n\n\n\n<p>用以下内容替换/node_modules/hexo-asset-image/index.js文件中的内容；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;;</span><br><span class=\"line\">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class=\"line\">function getPosition(str, m, i) &#123;</span><br><span class=\"line\">  return str.split(m, i).join(m).length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class=\"line\">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class=\"line\">  var config &#x3D; hexo.config;</span><br><span class=\"line\">  if(config.post_asset_folder)&#123;</span><br><span class=\"line\">    \tvar link &#x3D; data.permalink;</span><br><span class=\"line\">\tif(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class=\"line\">\t   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class=\"line\">\t&#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class=\"line\">\tvar endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class=\"line\">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class=\"line\"></span><br><span class=\"line\">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class=\"line\">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class=\"line\">      var key &#x3D; toprocess[i];</span><br><span class=\"line\"> </span><br><span class=\"line\">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class=\"line\">        ignoreWhitespace: false,</span><br><span class=\"line\">        xmlMode: false,</span><br><span class=\"line\">        lowerCaseTags: false,</span><br><span class=\"line\">        decodeEntities: false</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      $(&#39;img&#39;).each(function()&#123;</span><br><span class=\"line\">\t\tif ($(this).attr(&#39;src&#39;))&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; For windows style path, we replace &#39;\\&#39; to &#39;&#x2F;&#39;.</span><br><span class=\"line\">\t\t\tvar src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;&#x2F;&#39;);</span><br><span class=\"line\">\t\t\tif(!&#x2F;http[s]*.*|\\&#x2F;\\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class=\"line\">\t\t\t   !&#x2F;^\\s*\\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class=\"line\">\t\t\t  &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class=\"line\">\t\t\t  &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class=\"line\">\t\t\t  var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class=\"line\">\t\t\t\treturn elem !&#x3D; &#39;&#39;;</span><br><span class=\"line\">\t\t\t  &#125;);</span><br><span class=\"line\">\t\t\t  var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class=\"line\">\t\t\t\treturn elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class=\"line\">\t\t\t  &#125;);</span><br><span class=\"line\">\t\t\t  if(srcArray.length &gt; 1)</span><br><span class=\"line\">\t\t\t\tsrcArray.shift();</span><br><span class=\"line\">\t\t\t  src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class=\"line\">\t\t\t  $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class=\"line\">\t\t\t  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tconsole.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class=\"line\">\t\t\tconsole.info&amp;&amp;console.info($(this));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      data[key] &#x3D; $.html();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>修改博客主目录下__config.yml文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>此时，使用Hexo new “File”命令创建博客文件之后，除了在source/_post目录生成一个File.md文件之外，还会生成一个同名的File文件夹，用来保存在File.md文件中引用的本地图片；</p>\n<h4 id=\"2-Hexo博客无法显示mermaid流程图问题\"><a href=\"#2-Hexo博客无法显示mermaid流程图问题\" class=\"headerlink\" title=\"2. Hexo博客无法显示mermaid流程图问题\"></a>2. Hexo博客无法显示mermaid流程图问题</h4><p><a href=\"https://www.cnblogs.com/icoty23/p/10911231.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/icoty23/p/10911231.html</a></p>"},{"title":"Hexo+Github搭建个人博客","date":"2019-07-21T12:24:52.000Z","_content":"\n\n\n### 1. 简介\n\n首次通过Hexo和Github搭建自己的博客，尝试成功，从别人那里借来个yilia主题，看着挺漂亮，索性直接当我的主题用了，虽然还不会太多的配置操作，先把自己搭建博客过程中的主要操作记录下来。\n\n<!--more-->\n\n#### 环境简介\n\n本地电脑环境：\n\n> windows10\n\n\n\n搭建博客需要安装的软件：\n\n> git\n> node.js\n> hexo\n\n安装搭建博客需要的工具：git和node.js；通过一下命令查询：\n\n```shell\n# git --version\ngit version 2.22.0.windows.1\n```\n\n```shell\n# node -v\nv10.16.0\n```\n\n```shell\n# npm config set registry https://registry.npm.taobao.org\n```\n\n\n\n默认已经注册有Github帐号；\n\nHexo软件还未安装，下文会简单讲述Hexo软件的安装；\n\n\n\n\n### 2. Github仓库创建和配置\n\n#### 2.1 创建Git仓库\n\n打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“\nInitialize this repository with a README”；\n\n进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\n\n![Image](Hexo-Github搭建个人博客/Image.png)\n\n![Image2](Hexo-Github搭建个人博客/Image2.png)\n\n#### 2.2 配置git仓库\n\n如果是第一次使用git，就需要先配置git环境，否则可以跳过；\n```shell\n# git config --global user.name \"Mshrimp\"\n# git config --global user.email \"******@outlook.com\"\n```\n\n在没有配置git环境之前，~/.ssh是不存在的\n```shell\n# cd ~/.ssh\nbash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory\n```\n\n使用ssh-keygen生成私钥和公钥\n```shell\n# ssh-keygen -t rsa -C \"chiyuan.ma@outlook.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):\nCreated directory '/c/Users/Kevin-TP/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com\nThe key's randomart image is:\n+---[RSA 3072]----+\n|                 |\n|               . |\n|      . + +   +  |\n|     o B * + * + |\n|      B S + * X  |\n|     . X = * = o |\n|      . B + + o E|\n|      .+ o = o . |\n|     .o...= .    |\n+----[SHA256]-----+\n```\n从以上的操作打印可以知道，生成的密钥和公钥的保存路径\n```\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\n```\n查看生成的密钥和公钥\n```shell\n# cd ~/.ssh\n# ls\nid_rsa  id_rsa.pub\n# cat id_rsa.pub\nssh-rsa \n......\n```\n\n\n#### 2.3 把本地公钥添加到github中\n\n在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；\n\n![Image4](Hexo-Github搭建个人博客/Image4.png)\n\n![Image5](Hexo-Github搭建个人博客/Image5.png)\n\n\n\n使用“ssh -T git@github.com”命令，测试添加ssh是否成功；\n```shell\n# ssh -T git@github.com\n......\nHi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n\n\n### 3. Node安装\n\n\n\n### 4. Hexo安装及配置\n\n先创建一个hexo操作的文件目录\n\n![Image1](Hexo-Github搭建个人博客/Image1.png)\n\n如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；\n\n#### 4.1 安装hexo\n\n```shell\n# npm install hexo -g\n\nC:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\hexo -> \nC:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\node_modules\\hexo\\bin\\hexo\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 \n(node_modules\\hexo\\node_modules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for \nfsevents@2.1.2: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: \n{\"os\":\"win32\",\"arch\":\"x64\"})\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 \n(node_modules\\hexo\\node_modules\\nunjucks\\node_modules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for \nfsevents@1.2.11: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: \n{\"os\":\"win32\",\"arch\":\"x64\"})\n\n+ hexo@4.2.0\nadded 36 packages from 40 contributors, removed 30 packages, updated 58 packages \nand moved 5 packages in 19.178s\n```\n\n检查hexo是否安装成功\n```shell\n# hexo -v\nhexo-cli: 2.0.0\nos: Windows_NT 10.0.18362 win32 x64\nhttp_parser: 2.8.0\nnode: 10.16.0\nv8: 6.8.275.32-node.52\nuv: 1.28.0\nzlib: 1.2.11\nbrotli: 1.0.7\nares: 1.15.0\nmodules: 64\nnghttp2: 1.34.0\nnapi: 4\nopenssl: 1.1.1b\nicu: 64.2\nunicode: 12.1\ncldr: 35.1\ntz: 2019a\n```\n\n\n\n#### 4.2 初始化hexo文件夹\n\n```shell\n# hexo init\nINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\nCloning into 'G:\\hexo_git'...\nremote: Enumerating objects: 9, done.\nremote: Counting objects: 100% (9/9), done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 77 (delta 4), reused 5 (delta 2), pack-reused 68\nUnpacking objects: 100% (77/77), done.\nSubmodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'\nCloning into 'G:/hexo_git/themes/landscape'...\nremote: Enumerating objects: 33, done.\nremote: Counting objects: 100% (33/33), done.\nremote: Compressing objects: 100% (29/29), done.\nremote: Total 929 (delta 12), reused 15 (delta 3), pack-reused 896\nReceiving objects: 100% (929/929), 2.56 MiB | 9.00 KiB/s, done.\nResolving deltas: 100% (492/492), done.\nSubmodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'\nINFO  Install dependencies\nnpm WARN deprecated core-js@1.2.7: core-js@<2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.\nnpm notice created a lockfile as package-lock.json. You should commit this file.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"})\n\nadded 340 packages from 500 contributors and audited 6879 packages in 29.578s\nfound 0 vulnerabilities\n\nINFO  Start blogging with Hexo!\n```\n\n看到“Start blogging with Hexo！”打印，说明初始化完成；\n\n输入npm install，安装所需要的组件\n```shell\n# npm install\n```\n\nhexo已经安装并初始化完成；\n```shell\n# ls\n_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/\n```\n\n到此，hexo环境安装完成。\n\n#### 4.3 Hexo操作\n\n```shell\n# hexo g #generate 生成静态文件\n# hexo s #server 启动服务器。\n// 默认情况下，访问网址为： [http://localhost:4000/]\n```\n在浏览器地址栏输入“http://localhost:4000/”打开页面，是一个空的博客网页；\n\n![Image3](Hexo-Github搭建个人博客/Image3.JPG)\n\n\n\n#### 4.4 将git库和hexo链接起来\n\n\n\n配置Deployment\n\n在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；\n```\ndeploy:\n  type: git\n  repository: git@github.com:Mshrimp/Mshrimp.github.io.git\n  branch: master\n```\n\n\nHexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；\n```shell\n# npm install hexo-deployer-git --save\n\nnpm WARN babel-eslint@10.1.0 requires a peer of eslint@>= 4.12.1 but none is \ninstalled. You must install peer dependencies yourself.\n\n+ hexo-deployer-git@1.0.0\nadded 1 package from 1 contributor, removed 4 packages and updated 14 packages in \n5.684s\n```\n\n修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；\n```shell\n# hexo deploy\n```\n\n\n至此，一个空的博客已经搭建完成，下一步，添加博客文章；\n\n### 5. 创建博客文章\n\n```shell\n# hexo new [layout] <title> #新建文章\n```\n```shell\n// 创建博客：hello-world\n# hexo new post hello-world\nINFO  Created: G:\\hexo\\source\\_posts\\hello-world.md\n```\n创建成功后，会在source/_posts/目录生成hello-world.md文件； \n\n使用编辑器，编辑好hello-world.md文件的内容后，开始在博客中展示；\n\n生成静态文件\n```shell\n# hexo g\nINFO  Start processing\nINFO  Files loaded in 757 ms\nINFO  Generated: archives/2019/index.html\nINFO  Generated: archives/index.html\nINFO  Generated: archives/2019/07/index.html\nINFO  Generated: 2019/07/16/hello-world/index.html\nINFO  Generated: index.html\nINFO  Generated: fonts/iconfont.b322fa.eot\nINFO  Generated: fonts/default-skin.b257fa.svg\nINFO  Generated: fonts/tooltip.4004ff.svg\nINFO  Generated: img/preloader.gif\nINFO  Generated: fonts/iconfont.16acc2.ttf\nINFO  Generated: fonts/iconfont.8c627f.woff\nINFO  Generated: fonts/iconfont.45d7ee.svg\nINFO  Generated: img/default-skin.png\nINFO  Generated: img/scrollbar_arrow.png\nINFO  Generated: slider.e37972.js\nINFO  Generated: main.0cf68a.css\nINFO  Generated: main.0cf68a.js\nINFO  Generated: mobile.992cbe.js\nINFO  18 files generated in 784 ms\n```\n\n```shell\n# ls\n_config.yml  node_modules/  package-lock.json  scaffolds/  themes/\ndb.json      package.json   public/            source/\n```\n\n启动服务器，通过浏览器打开http://localhost:4000查看博客文件效果\n```shell\n# hexo s\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n```\n\n在确定博客文件完成之后，提交博客文件到git库保存\n```shell\n# hexo d\n```\n\n或者直接生成、提交一起操作\n```shell\n# hexo g -d\n```\n\n如果执行过程中出现异常，可以先清楚，再生成、提交\n```shell\n# hexo clean\nINFO  Deleted database.\nINFO  Deleted public folder.\n```\n\n提交之后的博客文件，就可以通过浏览器打开git库名称：mshrimp.github.io来打开了，支持外网访问；\n\n至此，一篇博客文件已经生成；\n\n\n\n\n#### Hexo常用命令\n\nhexo的命令很简单，以下几个是很常用的hexo命令，这些命令需要在当前blog目录下执行\n\n```\nhexo new [layout] <title> #新建文章\n```\n新建文章时可以指定文章的布局(layout)，默认为post，可以通过修改_config.yml中的default_layout: post来指定默认布局；这样创建的文章都会以md格式保存在source/_post目录中；\n\n```\nhexo g #generate 生成静态文件\nhexo s #server 启动服务器。在本地预览效果，默认情况下，访问网址为：http://localhost:4000/\nhexo d #deploy 部署网站同步到github。部署网站前，需要预先生成静态文件\nhexo clean #clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n```\n\n\n\n### 6. 更换主题\n\n不喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先Github中将yilia主题的源码下载到博客目录的themes目录下；\n\n```shell\n# git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n在博客根目录下，修改_config.yml文件的themes：\n\n```\nthemes: yilia\n```\n\n这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；\n\n\n\n\n### 7. 参考文章\n\nhttps://www.jianshu.com/p/1bcad7700c46\n\nhttps://segmentfault.com/a/1190000017986794\n\n","source":"_posts/Hexo-Github搭建个人博客.md","raw":"---\ntitle: Hexo+Github搭建个人博客\ndate: 2019-07-21 20:24:52\ntags: Hexo\n---\n\n\n\n### 1. 简介\n\n首次通过Hexo和Github搭建自己的博客，尝试成功，从别人那里借来个yilia主题，看着挺漂亮，索性直接当我的主题用了，虽然还不会太多的配置操作，先把自己搭建博客过程中的主要操作记录下来。\n\n<!--more-->\n\n#### 环境简介\n\n本地电脑环境：\n\n> windows10\n\n\n\n搭建博客需要安装的软件：\n\n> git\n> node.js\n> hexo\n\n安装搭建博客需要的工具：git和node.js；通过一下命令查询：\n\n```shell\n# git --version\ngit version 2.22.0.windows.1\n```\n\n```shell\n# node -v\nv10.16.0\n```\n\n```shell\n# npm config set registry https://registry.npm.taobao.org\n```\n\n\n\n默认已经注册有Github帐号；\n\nHexo软件还未安装，下文会简单讲述Hexo软件的安装；\n\n\n\n\n### 2. Github仓库创建和配置\n\n#### 2.1 创建Git仓库\n\n打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“\nInitialize this repository with a README”；\n\n进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\n\n![Image](Hexo-Github搭建个人博客/Image.png)\n\n![Image2](Hexo-Github搭建个人博客/Image2.png)\n\n#### 2.2 配置git仓库\n\n如果是第一次使用git，就需要先配置git环境，否则可以跳过；\n```shell\n# git config --global user.name \"Mshrimp\"\n# git config --global user.email \"******@outlook.com\"\n```\n\n在没有配置git环境之前，~/.ssh是不存在的\n```shell\n# cd ~/.ssh\nbash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory\n```\n\n使用ssh-keygen生成私钥和公钥\n```shell\n# ssh-keygen -t rsa -C \"chiyuan.ma@outlook.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):\nCreated directory '/c/Users/Kevin-TP/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com\nThe key's randomart image is:\n+---[RSA 3072]----+\n|                 |\n|               . |\n|      . + +   +  |\n|     o B * + * + |\n|      B S + * X  |\n|     . X = * = o |\n|      . B + + o E|\n|      .+ o = o . |\n|     .o...= .    |\n+----[SHA256]-----+\n```\n从以上的操作打印可以知道，生成的密钥和公钥的保存路径\n```\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\n```\n查看生成的密钥和公钥\n```shell\n# cd ~/.ssh\n# ls\nid_rsa  id_rsa.pub\n# cat id_rsa.pub\nssh-rsa \n......\n```\n\n\n#### 2.3 把本地公钥添加到github中\n\n在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；\n\n![Image4](Hexo-Github搭建个人博客/Image4.png)\n\n![Image5](Hexo-Github搭建个人博客/Image5.png)\n\n\n\n使用“ssh -T git@github.com”命令，测试添加ssh是否成功；\n```shell\n# ssh -T git@github.com\n......\nHi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n\n\n### 3. Node安装\n\n\n\n### 4. Hexo安装及配置\n\n先创建一个hexo操作的文件目录\n\n![Image1](Hexo-Github搭建个人博客/Image1.png)\n\n如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；\n\n#### 4.1 安装hexo\n\n```shell\n# npm install hexo -g\n\nC:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\hexo -> \nC:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\node_modules\\hexo\\bin\\hexo\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 \n(node_modules\\hexo\\node_modules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for \nfsevents@2.1.2: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: \n{\"os\":\"win32\",\"arch\":\"x64\"})\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 \n(node_modules\\hexo\\node_modules\\nunjucks\\node_modules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for \nfsevents@1.2.11: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: \n{\"os\":\"win32\",\"arch\":\"x64\"})\n\n+ hexo@4.2.0\nadded 36 packages from 40 contributors, removed 30 packages, updated 58 packages \nand moved 5 packages in 19.178s\n```\n\n检查hexo是否安装成功\n```shell\n# hexo -v\nhexo-cli: 2.0.0\nos: Windows_NT 10.0.18362 win32 x64\nhttp_parser: 2.8.0\nnode: 10.16.0\nv8: 6.8.275.32-node.52\nuv: 1.28.0\nzlib: 1.2.11\nbrotli: 1.0.7\nares: 1.15.0\nmodules: 64\nnghttp2: 1.34.0\nnapi: 4\nopenssl: 1.1.1b\nicu: 64.2\nunicode: 12.1\ncldr: 35.1\ntz: 2019a\n```\n\n\n\n#### 4.2 初始化hexo文件夹\n\n```shell\n# hexo init\nINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\nCloning into 'G:\\hexo_git'...\nremote: Enumerating objects: 9, done.\nremote: Counting objects: 100% (9/9), done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 77 (delta 4), reused 5 (delta 2), pack-reused 68\nUnpacking objects: 100% (77/77), done.\nSubmodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'\nCloning into 'G:/hexo_git/themes/landscape'...\nremote: Enumerating objects: 33, done.\nremote: Counting objects: 100% (33/33), done.\nremote: Compressing objects: 100% (29/29), done.\nremote: Total 929 (delta 12), reused 15 (delta 3), pack-reused 896\nReceiving objects: 100% (929/929), 2.56 MiB | 9.00 KiB/s, done.\nResolving deltas: 100% (492/492), done.\nSubmodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'\nINFO  Install dependencies\nnpm WARN deprecated core-js@1.2.7: core-js@<2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.\nnpm notice created a lockfile as package-lock.json. You should commit this file.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"})\n\nadded 340 packages from 500 contributors and audited 6879 packages in 29.578s\nfound 0 vulnerabilities\n\nINFO  Start blogging with Hexo!\n```\n\n看到“Start blogging with Hexo！”打印，说明初始化完成；\n\n输入npm install，安装所需要的组件\n```shell\n# npm install\n```\n\nhexo已经安装并初始化完成；\n```shell\n# ls\n_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/\n```\n\n到此，hexo环境安装完成。\n\n#### 4.3 Hexo操作\n\n```shell\n# hexo g #generate 生成静态文件\n# hexo s #server 启动服务器。\n// 默认情况下，访问网址为： [http://localhost:4000/]\n```\n在浏览器地址栏输入“http://localhost:4000/”打开页面，是一个空的博客网页；\n\n![Image3](Hexo-Github搭建个人博客/Image3.JPG)\n\n\n\n#### 4.4 将git库和hexo链接起来\n\n\n\n配置Deployment\n\n在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；\n```\ndeploy:\n  type: git\n  repository: git@github.com:Mshrimp/Mshrimp.github.io.git\n  branch: master\n```\n\n\nHexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；\n```shell\n# npm install hexo-deployer-git --save\n\nnpm WARN babel-eslint@10.1.0 requires a peer of eslint@>= 4.12.1 but none is \ninstalled. You must install peer dependencies yourself.\n\n+ hexo-deployer-git@1.0.0\nadded 1 package from 1 contributor, removed 4 packages and updated 14 packages in \n5.684s\n```\n\n修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；\n```shell\n# hexo deploy\n```\n\n\n至此，一个空的博客已经搭建完成，下一步，添加博客文章；\n\n### 5. 创建博客文章\n\n```shell\n# hexo new [layout] <title> #新建文章\n```\n```shell\n// 创建博客：hello-world\n# hexo new post hello-world\nINFO  Created: G:\\hexo\\source\\_posts\\hello-world.md\n```\n创建成功后，会在source/_posts/目录生成hello-world.md文件； \n\n使用编辑器，编辑好hello-world.md文件的内容后，开始在博客中展示；\n\n生成静态文件\n```shell\n# hexo g\nINFO  Start processing\nINFO  Files loaded in 757 ms\nINFO  Generated: archives/2019/index.html\nINFO  Generated: archives/index.html\nINFO  Generated: archives/2019/07/index.html\nINFO  Generated: 2019/07/16/hello-world/index.html\nINFO  Generated: index.html\nINFO  Generated: fonts/iconfont.b322fa.eot\nINFO  Generated: fonts/default-skin.b257fa.svg\nINFO  Generated: fonts/tooltip.4004ff.svg\nINFO  Generated: img/preloader.gif\nINFO  Generated: fonts/iconfont.16acc2.ttf\nINFO  Generated: fonts/iconfont.8c627f.woff\nINFO  Generated: fonts/iconfont.45d7ee.svg\nINFO  Generated: img/default-skin.png\nINFO  Generated: img/scrollbar_arrow.png\nINFO  Generated: slider.e37972.js\nINFO  Generated: main.0cf68a.css\nINFO  Generated: main.0cf68a.js\nINFO  Generated: mobile.992cbe.js\nINFO  18 files generated in 784 ms\n```\n\n```shell\n# ls\n_config.yml  node_modules/  package-lock.json  scaffolds/  themes/\ndb.json      package.json   public/            source/\n```\n\n启动服务器，通过浏览器打开http://localhost:4000查看博客文件效果\n```shell\n# hexo s\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n```\n\n在确定博客文件完成之后，提交博客文件到git库保存\n```shell\n# hexo d\n```\n\n或者直接生成、提交一起操作\n```shell\n# hexo g -d\n```\n\n如果执行过程中出现异常，可以先清楚，再生成、提交\n```shell\n# hexo clean\nINFO  Deleted database.\nINFO  Deleted public folder.\n```\n\n提交之后的博客文件，就可以通过浏览器打开git库名称：mshrimp.github.io来打开了，支持外网访问；\n\n至此，一篇博客文件已经生成；\n\n\n\n\n#### Hexo常用命令\n\nhexo的命令很简单，以下几个是很常用的hexo命令，这些命令需要在当前blog目录下执行\n\n```\nhexo new [layout] <title> #新建文章\n```\n新建文章时可以指定文章的布局(layout)，默认为post，可以通过修改_config.yml中的default_layout: post来指定默认布局；这样创建的文章都会以md格式保存在source/_post目录中；\n\n```\nhexo g #generate 生成静态文件\nhexo s #server 启动服务器。在本地预览效果，默认情况下，访问网址为：http://localhost:4000/\nhexo d #deploy 部署网站同步到github。部署网站前，需要预先生成静态文件\nhexo clean #clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n```\n\n\n\n### 6. 更换主题\n\n不喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先Github中将yilia主题的源码下载到博客目录的themes目录下；\n\n```shell\n# git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n在博客根目录下，修改_config.yml文件的themes：\n\n```\nthemes: yilia\n```\n\n这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；\n\n\n\n\n### 7. 参考文章\n\nhttps://www.jianshu.com/p/1bcad7700c46\n\nhttps://segmentfault.com/a/1190000017986794\n\n","slug":"Hexo-Github搭建个人博客","published":1,"updated":"2020-05-07T13:51:35.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkul0001dqg1enw8gid2","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首次通过Hexo和Github搭建自己的博客，尝试成功，从别人那里借来个yilia主题，看着挺漂亮，索性直接当我的主题用了，虽然还不会太多的配置操作，先把自己搭建博客过程中的主要操作记录下来。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"环境简介\"><a href=\"#环境简介\" class=\"headerlink\" title=\"环境简介\"></a>环境简介</h4><p>本地电脑环境：</p>\n<blockquote>\n<p>windows10</p>\n</blockquote>\n<p>搭建博客需要安装的软件：</p>\n<blockquote>\n<p>git<br>node.js<br>hexo</p>\n</blockquote>\n<p>安装搭建博客需要的工具：git和node.js；通过一下命令查询：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git --version</span></span><br><span class=\"line\">git version 2.22.0.windows.1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> node -v</span></span><br><span class=\"line\">v10.16.0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认已经注册有Github帐号；</p>\n<p>Hexo软件还未安装，下文会简单讲述Hexo软件的安装；</p>\n<h3 id=\"2-Github仓库创建和配置\"><a href=\"#2-Github仓库创建和配置\" class=\"headerlink\" title=\"2. Github仓库创建和配置\"></a>2. Github仓库创建和配置</h3><h4 id=\"2-1-创建Git仓库\"><a href=\"#2-1-创建Git仓库\" class=\"headerlink\" title=\"2.1 创建Git仓库\"></a>2.1 创建Git仓库</h4><p>打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“<br>Initialize this repository with a README”；</p>\n<p>进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：<a href=\"https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\">https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。</a></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image.png\" alt=\"Image\"></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image2.png\" alt=\"Image2\"></p>\n<h4 id=\"2-2-配置git仓库\"><a href=\"#2-2-配置git仓库\" class=\"headerlink\" title=\"2.2 配置git仓库\"></a>2.2 配置git仓库</h4><p>如果是第一次使用git，就需要先配置git环境，否则可以跳过；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.name <span class=\"string\">\"Mshrimp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.email <span class=\"string\">\"******@outlook.com\"</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在没有配置git环境之前，~/.ssh是不存在的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\">bash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory</span><br></pre></td></tr></table></figure>\n\n<p>使用ssh-keygen生成私钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh-keygen -t rsa -C <span class=\"string\">\"chiyuan.ma@outlook.com\"</span></span></span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):</span><br><span class=\"line\">Created directory '/c/Users/Kevin-TP/.ssh'.</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\">Your identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com</span><br><span class=\"line\">The key's randomart image is:</span><br><span class=\"line\">+---[RSA 3072]----+</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">|               . |</span><br><span class=\"line\">|      . + +   +  |</span><br><span class=\"line\">|     o B * + * + |</span><br><span class=\"line\">|      B S + * X  |</span><br><span class=\"line\">|     . X = * = o |</span><br><span class=\"line\">|      . B + + o E|</span><br><span class=\"line\">|      .+ o = o . |</span><br><span class=\"line\">|     .o...= .    |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>\n<p>从以上的操作打印可以知道，生成的密钥和公钥的保存路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;Kevin-TP&#x2F;.ssh&#x2F;id_rsa.</span><br><span class=\"line\">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;Kevin-TP&#x2F;.ssh&#x2F;id_rsa.pub.</span><br></pre></td></tr></table></figure>\n<p>查看生成的密钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">id_rsa  id_rsa.pub</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat id_rsa.pub</span></span><br><span class=\"line\">ssh-rsa </span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-3-把本地公钥添加到github中\"><a href=\"#2-3-把本地公钥添加到github中\" class=\"headerlink\" title=\"2.3 把本地公钥添加到github中\"></a>2.3 把本地公钥添加到github中</h4><p>在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；</p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image4.png\" alt=\"Image4\"></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image5.png\" alt=\"Image5\"></p>\n<p>使用“ssh -T <a href=\"mailto:git@github.com\">git@github.com</a>”命令，测试添加ssh是否成功；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh -T git@github.com</span></span><br><span class=\"line\">......</span><br><span class=\"line\">Hi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-Node安装\"><a href=\"#3-Node安装\" class=\"headerlink\" title=\"3. Node安装\"></a>3. Node安装</h3><h3 id=\"4-Hexo安装及配置\"><a href=\"#4-Hexo安装及配置\" class=\"headerlink\" title=\"4. Hexo安装及配置\"></a>4. Hexo安装及配置</h3><p>先创建一个hexo操作的文件目录</p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image1.png\" alt=\"Image1\"></p>\n<p>如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；</p>\n<h4 id=\"4-1-安装hexo\"><a href=\"#4-1-安装hexo\" class=\"headerlink\" title=\"4.1 安装hexo\"></a>4.1 安装hexo</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo -g</span></span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\hexo -&gt; </span><br><span class=\"line\">C:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\node_modules\\hexo\\bin\\hexo</span><br><span class=\"line\">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 </span><br><span class=\"line\">(node_modules\\hexo\\node_modules\\fsevents):</span><br><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for </span><br><span class=\"line\">fsevents@2.1.2: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: </span><br><span class=\"line\">&#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)</span><br><span class=\"line\">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 </span><br><span class=\"line\">(node_modules\\hexo\\node_modules\\nunjucks\\node_modules\\fsevents):</span><br><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for </span><br><span class=\"line\">fsevents@1.2.11: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: </span><br><span class=\"line\">&#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">+ hexo@4.2.0</span><br><span class=\"line\">added 36 packages from 40 contributors, removed 30 packages, updated 58 packages </span><br><span class=\"line\">and moved 5 packages in 19.178s</span><br></pre></td></tr></table></figure>\n\n<p>检查hexo是否安装成功</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo -v</span></span><br><span class=\"line\">hexo-cli: 2.0.0</span><br><span class=\"line\">os: Windows_NT 10.0.18362 win32 x64</span><br><span class=\"line\">http_parser: 2.8.0</span><br><span class=\"line\">node: 10.16.0</span><br><span class=\"line\">v8: 6.8.275.32-node.52</span><br><span class=\"line\">uv: 1.28.0</span><br><span class=\"line\">zlib: 1.2.11</span><br><span class=\"line\">brotli: 1.0.7</span><br><span class=\"line\">ares: 1.15.0</span><br><span class=\"line\">modules: 64</span><br><span class=\"line\">nghttp2: 1.34.0</span><br><span class=\"line\">napi: 4</span><br><span class=\"line\">openssl: 1.1.1b</span><br><span class=\"line\">icu: 64.2</span><br><span class=\"line\">unicode: 12.1</span><br><span class=\"line\">cldr: 35.1</span><br><span class=\"line\">tz: 2019a</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-2-初始化hexo文件夹\"><a href=\"#4-2-初始化hexo文件夹\" class=\"headerlink\" title=\"4.2 初始化hexo文件夹\"></a>4.2 初始化hexo文件夹</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br><span class=\"line\">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class=\"line\">Cloning into 'G:\\hexo_git'...</span><br><span class=\"line\">remote: Enumerating objects: 9, done.</span><br><span class=\"line\">remote: Counting objects: 100% (9/9), done.</span><br><span class=\"line\">remote: Compressing objects: 100% (7/7), done.</span><br><span class=\"line\">remote: Total 77 (delta 4), reused 5 (delta 2), pack-reused 68</span><br><span class=\"line\">Unpacking objects: 100% (77/77), done.</span><br><span class=\"line\">Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'</span><br><span class=\"line\">Cloning into 'G:/hexo_git/themes/landscape'...</span><br><span class=\"line\">remote: Enumerating objects: 33, done.</span><br><span class=\"line\">remote: Counting objects: 100% (33/33), done.</span><br><span class=\"line\">remote: Compressing objects: 100% (29/29), done.</span><br><span class=\"line\">remote: Total 929 (delta 12), reused 15 (delta 3), pack-reused 896</span><br><span class=\"line\">Receiving objects: 100% (929/929), 2.56 MiB | 9.00 KiB/s, done.</span><br><span class=\"line\">Resolving deltas: 100% (492/492), done.</span><br><span class=\"line\">Submodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'</span><br><span class=\"line\">INFO  Install dependencies</span><br><span class=\"line\">npm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.</span><br><span class=\"line\">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class=\"line\">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):</span><br><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">added 340 packages from 500 contributors and audited 6879 packages in 29.578s</span><br><span class=\"line\">found 0 vulnerabilities</span><br><span class=\"line\"></span><br><span class=\"line\">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>\n\n<p>看到“Start blogging with Hexo！”打印，说明初始化完成；</p>\n<p>输入npm install，安装所需要的组件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n\n<p>hexo已经安装并初始化完成；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>到此，hexo环境安装完成。</p>\n<h4 id=\"4-3-Hexo操作\"><a href=\"#4-3-Hexo操作\" class=\"headerlink\" title=\"4.3 Hexo操作\"></a>4.3 Hexo操作</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g <span class=\"comment\">#generate 生成静态文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo s <span class=\"comment\">#server 启动服务器。</span></span></span><br><span class=\"line\">// 默认情况下，访问网址为： [http://localhost:4000/]</span><br></pre></td></tr></table></figure>\n<p>在浏览器地址栏输入“<a href=\"http://localhost:4000/”打开页面，是一个空的博客网页；\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/”打开页面，是一个空的博客网页；</a></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image3.JPG\" alt=\"Image3\"></p>\n<h4 id=\"4-4-将git库和hexo链接起来\"><a href=\"#4-4-将git库和hexo链接起来\" class=\"headerlink\" title=\"4.4 将git库和hexo链接起来\"></a>4.4 将git库和hexo链接起来</h4><p>配置Deployment</p>\n<p>在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Mshrimp&#x2F;Mshrimp.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n<p>HexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo-deployer-git --save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN babel-eslint@10.1.0 requires a peer of eslint@&gt;= 4.12.1 but none is </span><br><span class=\"line\">installed. You must install peer dependencies yourself.</span><br><span class=\"line\"></span><br><span class=\"line\">+ hexo-deployer-git@1.0.0</span><br><span class=\"line\">added 1 package from 1 contributor, removed 4 packages and updated 14 packages in </span><br><span class=\"line\">5.684s</span><br></pre></td></tr></table></figure>\n\n<p>修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo deploy</span></span><br></pre></td></tr></table></figure>\n\n\n<p>至此，一个空的博客已经搭建完成，下一步，添加博客文章；</p>\n<h3 id=\"5-创建博客文章\"><a href=\"#5-创建博客文章\" class=\"headerlink\" title=\"5. 创建博客文章\"></a>5. 创建博客文章</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo new [layout] &lt;title&gt; <span class=\"comment\">#新建文章</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建博客：hello-world</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo new post hello-world</span></span><br><span class=\"line\">INFO  Created: G:\\hexo\\source\\_posts\\hello-world.md</span><br></pre></td></tr></table></figure>\n<p>创建成功后，会在source/_posts/目录生成hello-world.md文件； </p>\n<p>使用编辑器，编辑好hello-world.md文件的内容后，开始在博客中展示；</p>\n<p>生成静态文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g</span></span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 757 ms</span><br><span class=\"line\">INFO  Generated: archives/2019/index.html</span><br><span class=\"line\">INFO  Generated: archives/index.html</span><br><span class=\"line\">INFO  Generated: archives/2019/07/index.html</span><br><span class=\"line\">INFO  Generated: 2019/07/16/hello-world/index.html</span><br><span class=\"line\">INFO  Generated: index.html</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.b322fa.eot</span><br><span class=\"line\">INFO  Generated: fonts/default-skin.b257fa.svg</span><br><span class=\"line\">INFO  Generated: fonts/tooltip.4004ff.svg</span><br><span class=\"line\">INFO  Generated: img/preloader.gif</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.16acc2.ttf</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.8c627f.woff</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.45d7ee.svg</span><br><span class=\"line\">INFO  Generated: img/default-skin.png</span><br><span class=\"line\">INFO  Generated: img/scrollbar_arrow.png</span><br><span class=\"line\">INFO  Generated: slider.e37972.js</span><br><span class=\"line\">INFO  Generated: main.0cf68a.css</span><br><span class=\"line\">INFO  Generated: main.0cf68a.js</span><br><span class=\"line\">INFO  Generated: mobile.992cbe.js</span><br><span class=\"line\">INFO  18 files generated in 784 ms</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package-lock.json  scaffolds/  themes/</span><br><span class=\"line\">db.json      package.json   public/            source/</span><br></pre></td></tr></table></figure>\n\n<p>启动服务器，通过浏览器打开<a href=\"http://localhost:4000查看博客文件效果\">http://localhost:4000查看博客文件效果</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo s</span></span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n\n<p>在确定博客文件完成之后，提交博客文件到git库保存</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo d</span></span><br></pre></td></tr></table></figure>\n\n<p>或者直接生成、提交一起操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g -d</span></span><br></pre></td></tr></table></figure>\n\n<p>如果执行过程中出现异常，可以先清楚，再生成、提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo clean</span></span><br><span class=\"line\">INFO  Deleted database.</span><br><span class=\"line\">INFO  Deleted public folder.</span><br></pre></td></tr></table></figure>\n\n<p>提交之后的博客文件，就可以通过浏览器打开git库名称：mshrimp.github.io来打开了，支持外网访问；</p>\n<p>至此，一篇博客文件已经生成；</p>\n<h4 id=\"Hexo常用命令\"><a href=\"#Hexo常用命令\" class=\"headerlink\" title=\"Hexo常用命令\"></a>Hexo常用命令</h4><p>hexo的命令很简单，以下几个是很常用的hexo命令，这些命令需要在当前blog目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt; #新建文章</span><br></pre></td></tr></table></figure>\n<p>新建文章时可以指定文章的布局(layout)，默认为post，可以通过修改_config.yml中的default_layout: post来指定默认布局；这样创建的文章都会以md格式保存在source/_post目录中；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g #generate 生成静态文件</span><br><span class=\"line\">hexo s #server 启动服务器。在本地预览效果，默认情况下，访问网址为：http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br><span class=\"line\">hexo d #deploy 部署网站同步到github。部署网站前，需要预先生成静态文件</span><br><span class=\"line\">hexo clean #clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-更换主题\"><a href=\"#6-更换主题\" class=\"headerlink\" title=\"6. 更换主题\"></a>6. 更换主题</h3><p>不喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先Github中将yilia主题的源码下载到博客目录的themes目录下；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure>\n\n<p>在博客根目录下，修改_config.yml文件的themes：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">themes: yilia</span><br></pre></td></tr></table></figure>\n\n<p>这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；</p>\n<h3 id=\"7-参考文章\"><a href=\"#7-参考文章\" class=\"headerlink\" title=\"7. 参考文章\"></a>7. 参考文章</h3><p><a href=\"https://www.jianshu.com/p/1bcad7700c46\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1bcad7700c46</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000017986794\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017986794</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首次通过Hexo和Github搭建自己的博客，尝试成功，从别人那里借来个yilia主题，看着挺漂亮，索性直接当我的主题用了，虽然还不会太多的配置操作，先把自己搭建博客过程中的主要操作记录下来。</p>","more":"<h4 id=\"环境简介\"><a href=\"#环境简介\" class=\"headerlink\" title=\"环境简介\"></a>环境简介</h4><p>本地电脑环境：</p>\n<blockquote>\n<p>windows10</p>\n</blockquote>\n<p>搭建博客需要安装的软件：</p>\n<blockquote>\n<p>git<br>node.js<br>hexo</p>\n</blockquote>\n<p>安装搭建博客需要的工具：git和node.js；通过一下命令查询：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git --version</span></span><br><span class=\"line\">git version 2.22.0.windows.1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> node -v</span></span><br><span class=\"line\">v10.16.0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认已经注册有Github帐号；</p>\n<p>Hexo软件还未安装，下文会简单讲述Hexo软件的安装；</p>\n<h3 id=\"2-Github仓库创建和配置\"><a href=\"#2-Github仓库创建和配置\" class=\"headerlink\" title=\"2. Github仓库创建和配置\"></a>2. Github仓库创建和配置</h3><h4 id=\"2-1-创建Git仓库\"><a href=\"#2-1-创建Git仓库\" class=\"headerlink\" title=\"2.1 创建Git仓库\"></a>2.1 创建Git仓库</h4><p>打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“<br>Initialize this repository with a README”；</p>\n<p>进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：<a href=\"https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\">https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。</a></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image.png\" alt=\"Image\"></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image2.png\" alt=\"Image2\"></p>\n<h4 id=\"2-2-配置git仓库\"><a href=\"#2-2-配置git仓库\" class=\"headerlink\" title=\"2.2 配置git仓库\"></a>2.2 配置git仓库</h4><p>如果是第一次使用git，就需要先配置git环境，否则可以跳过；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.name <span class=\"string\">\"Mshrimp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.email <span class=\"string\">\"******@outlook.com\"</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在没有配置git环境之前，~/.ssh是不存在的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\">bash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory</span><br></pre></td></tr></table></figure>\n\n<p>使用ssh-keygen生成私钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh-keygen -t rsa -C <span class=\"string\">\"chiyuan.ma@outlook.com\"</span></span></span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):</span><br><span class=\"line\">Created directory '/c/Users/Kevin-TP/.ssh'.</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\">Your identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com</span><br><span class=\"line\">The key's randomart image is:</span><br><span class=\"line\">+---[RSA 3072]----+</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">|               . |</span><br><span class=\"line\">|      . + +   +  |</span><br><span class=\"line\">|     o B * + * + |</span><br><span class=\"line\">|      B S + * X  |</span><br><span class=\"line\">|     . X = * = o |</span><br><span class=\"line\">|      . B + + o E|</span><br><span class=\"line\">|      .+ o = o . |</span><br><span class=\"line\">|     .o...= .    |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>\n<p>从以上的操作打印可以知道，生成的密钥和公钥的保存路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;Kevin-TP&#x2F;.ssh&#x2F;id_rsa.</span><br><span class=\"line\">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;Kevin-TP&#x2F;.ssh&#x2F;id_rsa.pub.</span><br></pre></td></tr></table></figure>\n<p>查看生成的密钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">id_rsa  id_rsa.pub</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat id_rsa.pub</span></span><br><span class=\"line\">ssh-rsa </span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-3-把本地公钥添加到github中\"><a href=\"#2-3-把本地公钥添加到github中\" class=\"headerlink\" title=\"2.3 把本地公钥添加到github中\"></a>2.3 把本地公钥添加到github中</h4><p>在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；</p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image4.png\" alt=\"Image4\"></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image5.png\" alt=\"Image5\"></p>\n<p>使用“ssh -T <a href=\"mailto:git@github.com\">git@github.com</a>”命令，测试添加ssh是否成功；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh -T git@github.com</span></span><br><span class=\"line\">......</span><br><span class=\"line\">Hi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-Node安装\"><a href=\"#3-Node安装\" class=\"headerlink\" title=\"3. Node安装\"></a>3. Node安装</h3><h3 id=\"4-Hexo安装及配置\"><a href=\"#4-Hexo安装及配置\" class=\"headerlink\" title=\"4. Hexo安装及配置\"></a>4. Hexo安装及配置</h3><p>先创建一个hexo操作的文件目录</p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image1.png\" alt=\"Image1\"></p>\n<p>如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；</p>\n<h4 id=\"4-1-安装hexo\"><a href=\"#4-1-安装hexo\" class=\"headerlink\" title=\"4.1 安装hexo\"></a>4.1 安装hexo</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo -g</span></span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\hexo -&gt; </span><br><span class=\"line\">C:\\Users\\Kevin-TP\\AppData\\Roaming\\npm\\node_modules\\hexo\\bin\\hexo</span><br><span class=\"line\">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 </span><br><span class=\"line\">(node_modules\\hexo\\node_modules\\fsevents):</span><br><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for </span><br><span class=\"line\">fsevents@2.1.2: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: </span><br><span class=\"line\">&#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)</span><br><span class=\"line\">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 </span><br><span class=\"line\">(node_modules\\hexo\\node_modules\\nunjucks\\node_modules\\fsevents):</span><br><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for </span><br><span class=\"line\">fsevents@1.2.11: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: </span><br><span class=\"line\">&#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">+ hexo@4.2.0</span><br><span class=\"line\">added 36 packages from 40 contributors, removed 30 packages, updated 58 packages </span><br><span class=\"line\">and moved 5 packages in 19.178s</span><br></pre></td></tr></table></figure>\n\n<p>检查hexo是否安装成功</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo -v</span></span><br><span class=\"line\">hexo-cli: 2.0.0</span><br><span class=\"line\">os: Windows_NT 10.0.18362 win32 x64</span><br><span class=\"line\">http_parser: 2.8.0</span><br><span class=\"line\">node: 10.16.0</span><br><span class=\"line\">v8: 6.8.275.32-node.52</span><br><span class=\"line\">uv: 1.28.0</span><br><span class=\"line\">zlib: 1.2.11</span><br><span class=\"line\">brotli: 1.0.7</span><br><span class=\"line\">ares: 1.15.0</span><br><span class=\"line\">modules: 64</span><br><span class=\"line\">nghttp2: 1.34.0</span><br><span class=\"line\">napi: 4</span><br><span class=\"line\">openssl: 1.1.1b</span><br><span class=\"line\">icu: 64.2</span><br><span class=\"line\">unicode: 12.1</span><br><span class=\"line\">cldr: 35.1</span><br><span class=\"line\">tz: 2019a</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-2-初始化hexo文件夹\"><a href=\"#4-2-初始化hexo文件夹\" class=\"headerlink\" title=\"4.2 初始化hexo文件夹\"></a>4.2 初始化hexo文件夹</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br><span class=\"line\">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class=\"line\">Cloning into 'G:\\hexo_git'...</span><br><span class=\"line\">remote: Enumerating objects: 9, done.</span><br><span class=\"line\">remote: Counting objects: 100% (9/9), done.</span><br><span class=\"line\">remote: Compressing objects: 100% (7/7), done.</span><br><span class=\"line\">remote: Total 77 (delta 4), reused 5 (delta 2), pack-reused 68</span><br><span class=\"line\">Unpacking objects: 100% (77/77), done.</span><br><span class=\"line\">Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'</span><br><span class=\"line\">Cloning into 'G:/hexo_git/themes/landscape'...</span><br><span class=\"line\">remote: Enumerating objects: 33, done.</span><br><span class=\"line\">remote: Counting objects: 100% (33/33), done.</span><br><span class=\"line\">remote: Compressing objects: 100% (29/29), done.</span><br><span class=\"line\">remote: Total 929 (delta 12), reused 15 (delta 3), pack-reused 896</span><br><span class=\"line\">Receiving objects: 100% (929/929), 2.56 MiB | 9.00 KiB/s, done.</span><br><span class=\"line\">Resolving deltas: 100% (492/492), done.</span><br><span class=\"line\">Submodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'</span><br><span class=\"line\">INFO  Install dependencies</span><br><span class=\"line\">npm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.</span><br><span class=\"line\">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class=\"line\">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):</span><br><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">added 340 packages from 500 contributors and audited 6879 packages in 29.578s</span><br><span class=\"line\">found 0 vulnerabilities</span><br><span class=\"line\"></span><br><span class=\"line\">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>\n\n<p>看到“Start blogging with Hexo！”打印，说明初始化完成；</p>\n<p>输入npm install，安装所需要的组件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n\n<p>hexo已经安装并初始化完成；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>到此，hexo环境安装完成。</p>\n<h4 id=\"4-3-Hexo操作\"><a href=\"#4-3-Hexo操作\" class=\"headerlink\" title=\"4.3 Hexo操作\"></a>4.3 Hexo操作</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g <span class=\"comment\">#generate 生成静态文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo s <span class=\"comment\">#server 启动服务器。</span></span></span><br><span class=\"line\">// 默认情况下，访问网址为： [http://localhost:4000/]</span><br></pre></td></tr></table></figure>\n<p>在浏览器地址栏输入“<a href=\"http://localhost:4000/”打开页面，是一个空的博客网页；\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/”打开页面，是一个空的博客网页；</a></p>\n<p><img src=\"/2019/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image3.JPG\" alt=\"Image3\"></p>\n<h4 id=\"4-4-将git库和hexo链接起来\"><a href=\"#4-4-将git库和hexo链接起来\" class=\"headerlink\" title=\"4.4 将git库和hexo链接起来\"></a>4.4 将git库和hexo链接起来</h4><p>配置Deployment</p>\n<p>在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Mshrimp&#x2F;Mshrimp.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n<p>HexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo-deployer-git --save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN babel-eslint@10.1.0 requires a peer of eslint@&gt;= 4.12.1 but none is </span><br><span class=\"line\">installed. You must install peer dependencies yourself.</span><br><span class=\"line\"></span><br><span class=\"line\">+ hexo-deployer-git@1.0.0</span><br><span class=\"line\">added 1 package from 1 contributor, removed 4 packages and updated 14 packages in </span><br><span class=\"line\">5.684s</span><br></pre></td></tr></table></figure>\n\n<p>修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo deploy</span></span><br></pre></td></tr></table></figure>\n\n\n<p>至此，一个空的博客已经搭建完成，下一步，添加博客文章；</p>\n<h3 id=\"5-创建博客文章\"><a href=\"#5-创建博客文章\" class=\"headerlink\" title=\"5. 创建博客文章\"></a>5. 创建博客文章</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo new [layout] &lt;title&gt; <span class=\"comment\">#新建文章</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建博客：hello-world</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo new post hello-world</span></span><br><span class=\"line\">INFO  Created: G:\\hexo\\source\\_posts\\hello-world.md</span><br></pre></td></tr></table></figure>\n<p>创建成功后，会在source/_posts/目录生成hello-world.md文件； </p>\n<p>使用编辑器，编辑好hello-world.md文件的内容后，开始在博客中展示；</p>\n<p>生成静态文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g</span></span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 757 ms</span><br><span class=\"line\">INFO  Generated: archives/2019/index.html</span><br><span class=\"line\">INFO  Generated: archives/index.html</span><br><span class=\"line\">INFO  Generated: archives/2019/07/index.html</span><br><span class=\"line\">INFO  Generated: 2019/07/16/hello-world/index.html</span><br><span class=\"line\">INFO  Generated: index.html</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.b322fa.eot</span><br><span class=\"line\">INFO  Generated: fonts/default-skin.b257fa.svg</span><br><span class=\"line\">INFO  Generated: fonts/tooltip.4004ff.svg</span><br><span class=\"line\">INFO  Generated: img/preloader.gif</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.16acc2.ttf</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.8c627f.woff</span><br><span class=\"line\">INFO  Generated: fonts/iconfont.45d7ee.svg</span><br><span class=\"line\">INFO  Generated: img/default-skin.png</span><br><span class=\"line\">INFO  Generated: img/scrollbar_arrow.png</span><br><span class=\"line\">INFO  Generated: slider.e37972.js</span><br><span class=\"line\">INFO  Generated: main.0cf68a.css</span><br><span class=\"line\">INFO  Generated: main.0cf68a.js</span><br><span class=\"line\">INFO  Generated: mobile.992cbe.js</span><br><span class=\"line\">INFO  18 files generated in 784 ms</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package-lock.json  scaffolds/  themes/</span><br><span class=\"line\">db.json      package.json   public/            source/</span><br></pre></td></tr></table></figure>\n\n<p>启动服务器，通过浏览器打开<a href=\"http://localhost:4000查看博客文件效果\">http://localhost:4000查看博客文件效果</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo s</span></span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n\n<p>在确定博客文件完成之后，提交博客文件到git库保存</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo d</span></span><br></pre></td></tr></table></figure>\n\n<p>或者直接生成、提交一起操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g -d</span></span><br></pre></td></tr></table></figure>\n\n<p>如果执行过程中出现异常，可以先清楚，再生成、提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo clean</span></span><br><span class=\"line\">INFO  Deleted database.</span><br><span class=\"line\">INFO  Deleted public folder.</span><br></pre></td></tr></table></figure>\n\n<p>提交之后的博客文件，就可以通过浏览器打开git库名称：mshrimp.github.io来打开了，支持外网访问；</p>\n<p>至此，一篇博客文件已经生成；</p>\n<h4 id=\"Hexo常用命令\"><a href=\"#Hexo常用命令\" class=\"headerlink\" title=\"Hexo常用命令\"></a>Hexo常用命令</h4><p>hexo的命令很简单，以下几个是很常用的hexo命令，这些命令需要在当前blog目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt; #新建文章</span><br></pre></td></tr></table></figure>\n<p>新建文章时可以指定文章的布局(layout)，默认为post，可以通过修改_config.yml中的default_layout: post来指定默认布局；这样创建的文章都会以md格式保存在source/_post目录中；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g #generate 生成静态文件</span><br><span class=\"line\">hexo s #server 启动服务器。在本地预览效果，默认情况下，访问网址为：http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br><span class=\"line\">hexo d #deploy 部署网站同步到github。部署网站前，需要预先生成静态文件</span><br><span class=\"line\">hexo clean #clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-更换主题\"><a href=\"#6-更换主题\" class=\"headerlink\" title=\"6. 更换主题\"></a>6. 更换主题</h3><p>不喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先Github中将yilia主题的源码下载到博客目录的themes目录下；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure>\n\n<p>在博客根目录下，修改_config.yml文件的themes：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">themes: yilia</span><br></pre></td></tr></table></figure>\n\n<p>这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；</p>\n<h3 id=\"7-参考文章\"><a href=\"#7-参考文章\" class=\"headerlink\" title=\"7. 参考文章\"></a>7. 参考文章</h3><p><a href=\"https://www.jianshu.com/p/1bcad7700c46\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1bcad7700c46</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000017986794\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017986794</a></p>"},{"title":"Linux-kernel中I2C的master_xfer驱动实现----基于imx6","date":"2020-04-23T13:55:34.000Z","_content":"\n\n\n未完成\n\n在I2C驱动中，每个适配器i2c_adapter都有自己的I2C通信方法，在struct i2c_algorithm结构中的master_xfer()函数中实现；i2c_algorithm结构中的关键函数master_xfer()用于产生I2C访问周期需要的信号，以struct i2c_msg结构的格式进行数据传送；\n\n\n\n\n\n<!--more-->\n\n\n\n**注：**本文含有一些从《IMX6SDLRM.pdf》手册中获取的一些数据信息截图，如有侵权，纯属无意，还请告知，立即删除！\n\n\n\n### 目录\n\n[TOC]\n\n### 简介\n\n\n\nhttp://read.pudn.com/downloads664/sourcecode/embedded/2692975/IMX6SDLRM.pdf\n\n\n\n\n\n\n\n\n\n\n\n#### 寄存器描述\n\n![I2C memory map](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-memory-map.png)\n\n\n\n\n\n##### I2C Address Register\n\n![I2C-Address-Register2](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Address-Register2.png)\n\n\n\n##### I2C Frequency Divider Register\n\n![I2C Frequency Divider Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Frequency-Divider-Register.png)\n\n\n\n##### I2C Control Register\n\n![I2C Control Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Control-Register.png)\n\n![I2Cx_I2CR field descriptions](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions.png)\n\n![I2Cx_I2CR field descriptions2](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions2.png)\n\n\n\n##### I2C Status Register\n\n![I2C Status Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Status-Register.png)\n\n![I2Cx_I2SR field descriptions](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions.png)\n\n![I2Cx_I2SR field descriptions2](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions2.png)\n\n![I2Cx_I2SR field descriptions3](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions3.png)\n\n\n\n\n\n##### I2C Data I/O Register\n\n![I2C Data IO Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Data-IO-Register.png)\n\n\n\n","source":"_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6.md","raw":"---\ntitle: Linux-kernel中I2C的master_xfer驱动实现----基于imx6\ndate: 2020-04-23 21:55:34\ntags: i2c\n---\n\n\n\n未完成\n\n在I2C驱动中，每个适配器i2c_adapter都有自己的I2C通信方法，在struct i2c_algorithm结构中的master_xfer()函数中实现；i2c_algorithm结构中的关键函数master_xfer()用于产生I2C访问周期需要的信号，以struct i2c_msg结构的格式进行数据传送；\n\n\n\n\n\n<!--more-->\n\n\n\n**注：**本文含有一些从《IMX6SDLRM.pdf》手册中获取的一些数据信息截图，如有侵权，纯属无意，还请告知，立即删除！\n\n\n\n### 目录\n\n[TOC]\n\n### 简介\n\n\n\nhttp://read.pudn.com/downloads664/sourcecode/embedded/2692975/IMX6SDLRM.pdf\n\n\n\n\n\n\n\n\n\n\n\n#### 寄存器描述\n\n![I2C memory map](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-memory-map.png)\n\n\n\n\n\n##### I2C Address Register\n\n![I2C-Address-Register2](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Address-Register2.png)\n\n\n\n##### I2C Frequency Divider Register\n\n![I2C Frequency Divider Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Frequency-Divider-Register.png)\n\n\n\n##### I2C Control Register\n\n![I2C Control Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Control-Register.png)\n\n![I2Cx_I2CR field descriptions](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions.png)\n\n![I2Cx_I2CR field descriptions2](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions2.png)\n\n\n\n##### I2C Status Register\n\n![I2C Status Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Status-Register.png)\n\n![I2Cx_I2SR field descriptions](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions.png)\n\n![I2Cx_I2SR field descriptions2](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions2.png)\n\n![I2Cx_I2SR field descriptions3](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions3.png)\n\n\n\n\n\n##### I2C Data I/O Register\n\n![I2C Data IO Register](Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Data-IO-Register.png)\n\n\n\n","slug":"Linux-kernel中I2C的master_xfer驱动实现-基于imx6","published":1,"updated":"2020-05-16T14:10:13.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkuo0003dqg19hxs55xt","content":"<p>未完成</p>\n<p>在I2C驱动中，每个适配器i2c_adapter都有自己的I2C通信方法，在struct i2c_algorithm结构中的master_xfer()函数中实现；i2c_algorithm结构中的关键函数master_xfer()用于产生I2C访问周期需要的信号，以struct i2c_msg结构的格式进行数据传送；</p>\n<a id=\"more\"></a>\n\n\n\n<p><strong>注：</strong>本文含有一些从《IMX6SDLRM.pdf》手册中获取的一些数据信息截图，如有侵权，纯属无意，还请告知，立即删除！</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><a href=\"http://read.pudn.com/downloads664/sourcecode/embedded/2692975/IMX6SDLRM.pdf\" target=\"_blank\" rel=\"noopener\">http://read.pudn.com/downloads664/sourcecode/embedded/2692975/IMX6SDLRM.pdf</a></p>\n<h4 id=\"寄存器描述\"><a href=\"#寄存器描述\" class=\"headerlink\" title=\"寄存器描述\"></a>寄存器描述</h4><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-memory-map.png\" alt=\"I2C memory map\"></p>\n<h5 id=\"I2C-Address-Register\"><a href=\"#I2C-Address-Register\" class=\"headerlink\" title=\"I2C Address Register\"></a>I2C Address Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Address-Register2.png\" alt=\"I2C-Address-Register2\"></p>\n<h5 id=\"I2C-Frequency-Divider-Register\"><a href=\"#I2C-Frequency-Divider-Register\" class=\"headerlink\" title=\"I2C Frequency Divider Register\"></a>I2C Frequency Divider Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Frequency-Divider-Register.png\" alt=\"I2C Frequency Divider Register\"></p>\n<h5 id=\"I2C-Control-Register\"><a href=\"#I2C-Control-Register\" class=\"headerlink\" title=\"I2C Control Register\"></a>I2C Control Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Control-Register.png\" alt=\"I2C Control Register\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2CR-field-descriptions.png\" alt=\"I2Cx_I2CR field descriptions\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2CR-field-descriptions2.png\" alt=\"I2Cx_I2CR field descriptions2\"></p>\n<h5 id=\"I2C-Status-Register\"><a href=\"#I2C-Status-Register\" class=\"headerlink\" title=\"I2C Status Register\"></a>I2C Status Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Status-Register.png\" alt=\"I2C Status Register\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2SR-field-descriptions.png\" alt=\"I2Cx_I2SR field descriptions\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2SR-field-descriptions2.png\" alt=\"I2Cx_I2SR field descriptions2\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2SR-field-descriptions3.png\" alt=\"I2Cx_I2SR field descriptions3\"></p>\n<h5 id=\"I2C-Data-I-O-Register\"><a href=\"#I2C-Data-I-O-Register\" class=\"headerlink\" title=\"I2C Data I/O Register\"></a>I2C Data I/O Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Data-IO-Register.png\" alt=\"I2C Data IO Register\"></p>\n","site":{"data":{}},"excerpt":"<p>未完成</p>\n<p>在I2C驱动中，每个适配器i2c_adapter都有自己的I2C通信方法，在struct i2c_algorithm结构中的master_xfer()函数中实现；i2c_algorithm结构中的关键函数master_xfer()用于产生I2C访问周期需要的信号，以struct i2c_msg结构的格式进行数据传送；</p>","more":"<p><strong>注：</strong>本文含有一些从《IMX6SDLRM.pdf》手册中获取的一些数据信息截图，如有侵权，纯属无意，还请告知，立即删除！</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><a href=\"http://read.pudn.com/downloads664/sourcecode/embedded/2692975/IMX6SDLRM.pdf\" target=\"_blank\" rel=\"noopener\">http://read.pudn.com/downloads664/sourcecode/embedded/2692975/IMX6SDLRM.pdf</a></p>\n<h4 id=\"寄存器描述\"><a href=\"#寄存器描述\" class=\"headerlink\" title=\"寄存器描述\"></a>寄存器描述</h4><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-memory-map.png\" alt=\"I2C memory map\"></p>\n<h5 id=\"I2C-Address-Register\"><a href=\"#I2C-Address-Register\" class=\"headerlink\" title=\"I2C Address Register\"></a>I2C Address Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Address-Register2.png\" alt=\"I2C-Address-Register2\"></p>\n<h5 id=\"I2C-Frequency-Divider-Register\"><a href=\"#I2C-Frequency-Divider-Register\" class=\"headerlink\" title=\"I2C Frequency Divider Register\"></a>I2C Frequency Divider Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Frequency-Divider-Register.png\" alt=\"I2C Frequency Divider Register\"></p>\n<h5 id=\"I2C-Control-Register\"><a href=\"#I2C-Control-Register\" class=\"headerlink\" title=\"I2C Control Register\"></a>I2C Control Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Control-Register.png\" alt=\"I2C Control Register\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2CR-field-descriptions.png\" alt=\"I2Cx_I2CR field descriptions\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2CR-field-descriptions2.png\" alt=\"I2Cx_I2CR field descriptions2\"></p>\n<h5 id=\"I2C-Status-Register\"><a href=\"#I2C-Status-Register\" class=\"headerlink\" title=\"I2C Status Register\"></a>I2C Status Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Status-Register.png\" alt=\"I2C Status Register\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2SR-field-descriptions.png\" alt=\"I2Cx_I2SR field descriptions\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2SR-field-descriptions2.png\" alt=\"I2Cx_I2SR field descriptions2\"></p>\n<p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2Cx_I2SR-field-descriptions3.png\" alt=\"I2Cx_I2SR field descriptions3\"></p>\n<h5 id=\"I2C-Data-I-O-Register\"><a href=\"#I2C-Data-I-O-Register\" class=\"headerlink\" title=\"I2C Data I/O Register\"></a>I2C Data I/O Register</h5><p><img src=\"/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/I2C-Data-IO-Register.png\" alt=\"I2C Data IO Register\"></p>"},{"title":"Linux-kernel中的do_execve函数解析","date":"2020-05-24T02:59:03.000Z","_content":"\n\n\n\n\n未完成\n\n#### 简述\n\n在Linux系统中提供了exec开头的一系列函数，这些函数能通过内核调用用户空间的程序，能**用可执行文件所描述的上下文代替进程的上下文**；这些函数都是以exec前缀开始的，这些exec函数都是调用execve()系统调用实现的；而在内核态的sys_execve()函数，是调用do_execve()函数实现的；\n\n<!--more-->\n\n```mermaid\ngraph TB\n\texec类(exec类函数)-->execve(\"execve()\")\n\t-->sys_execve(\"sys_execve()\")\n\t-->do_execve(\"do_execve()\")\n```\n\n\n\n内核中实际执行execv()或execve()系统调用的是do_execve()函数；而do_execve()函数进一步通过do_execveat_common()函数\n\n\n\ndo_execve()函数在fs/exec.c文件中定义；\n\n\n\n```c\n// fs/exec.c\nint do_execve(struct filename *filename,\n    const char __user *const __user *__argv,\n    const char __user *const __user *__envp)\n{\n    struct user_arg_ptr argv = { .ptr.native = __argv };\n    struct user_arg_ptr envp = { .ptr.native = __envp };\n    return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}\n```\n\n\n\n```mermaid\ngraph TB\n\tdo_execve(do_execve)-->do_execveat_common(do_execveat_common)\n```\n\n\n\n#### 参数\n\ndo_execve()函数的参数：\n\n| 参数     | 类型                                | 描述                 |\n| -------- | ----------------------------------- | -------------------- |\n| filename | struct filename                     | 可执行程序的名称信息 |\n| __argv   | const char \\_\\_user *const __user * | 可执行程序的参数信息 |\n| __envp   | const char \\_\\_user *const __user * | 环境变量信息         |\n\n\n\n\n\n```c\n// include/linux/fs.h\nstruct filename {\n    const char      *name;  /* pointer to actual string */\n    const __user char   *uptr;  /* original userland pointer */\n    struct audit_names  *aname;\n    int         refcnt;\n    const char      iname[];\n};\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```c\n// fs/exec.c\nstatic int do_execveat_common(int fd, struct filename *filename,\n                  struct user_arg_ptr argv,\n                  struct user_arg_ptr envp,\n                  int flags)\n{\n    char *pathbuf = NULL;\n    struct linux_binprm *bprm;\n    struct file *file;\n    struct files_struct *displaced;\n    int retval;\n\n    if (IS_ERR(filename)) {\n        printk(\"%s, %d, filename error\\n\", __func__, __LINE__);\n        return PTR_ERR(filename);\n    }\n\n    /*\n     * We move the actual failure in case of RLIMIT_NPROC excess from\n     * set*uid() to execve() because too many poorly written programs\n     * don't check setuid() return code.  Here we additionally recheck\n     * whether NPROC limit is still exceeded.\n     */\n    if ((current->flags & PF_NPROC_EXCEEDED) &&\n        atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n        retval = -EAGAIN;\n        goto out_ret;\n    }\n\n    /* We're below the limit (still or again), so we don't want to make\n     * further execve() calls fail. */\n    current->flags &= ~PF_NPROC_EXCEEDED;\n\n    // 调用unshare_files()为进程复制一份文件表\n    retval = unshare_files(&displaced);\n    if (retval)\n        goto out_ret;\n\n    retval = -ENOMEM;\n    // 调用kzalloc()在堆上分配一份structlinux_binprm结构体\n    bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n    if (!bprm)\n        goto out_files;\n\n    retval = prepare_bprm_creds(bprm);\n    if (retval)\n        goto out_free;\n\n    check_unsafe_exec(bprm);\n    current->in_execve = 1;\n\n    // 调用do_open_execat()查找并打开二进制文件\n    file = do_open_execat(fd, filename, flags);\n    retval = PTR_ERR(file);\n    if (IS_ERR(file)) {\n        printk(\"%s, %d, file error\\n\", __func__, __LINE__);\n        goto out_unmark;\n    }\n\n    // 调用sched_exec()找到最小负载的CPU，用来执行该二进制文件\n    sched_exec();\n\n    // 根据获取的信息，填充struct linux_binprm结构体中的file、filename、interp成员\n    bprm->file = file;\n    if (fd == AT_FDCWD || filename->name[0] == '/') {\n        bprm->filename = filename->name;\n    } else {\n        if (filename->name[0] == '\\0')\n            pathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n        else\n            pathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n                        fd, filename->name);\n        if (!pathbuf) {\n            retval = -ENOMEM;\n            goto out_unmark;\n        }\n        /*\n         * Record that a name derived from an O_CLOEXEC fd will be\n         * inaccessible after exec. Relies on having exclusive access to\n         * current->files (due to unshare_files above).\n         */\n        if (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n            bprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n        bprm->filename = pathbuf;\n    }\n\n    bprm->interp = bprm->filename;\n\n    // 调用bprm_mm_init()创建进程的内存地址空间，并调用init_new_context()检查当前进程是否使用自定义的局部描述符表；如果是，那么分配和准备一个新的LDT；\n    retval = bprm_mm_init(bprm);\n    if (retval)\n        goto out_unmark;\n\n    // 填充struct linux_binprm结构体中的命令行参数argv,环境变量envp\n    bprm->argc = count(argv, MAX_ARG_STRINGS);\n    if ((retval = bprm->argc) < 0)\n        goto out;\n\n    bprm->envc = count(envp, MAX_ARG_STRINGS);\n    if ((retval = bprm->envc) < 0)\n        goto out;\n\n    // 调用prepare_binprm()检查该二进制文件的可执行权限；最后，kernel_read()读取二进制文件的头128字节（这些字节用于识别二进制文件的格式及其他信息，后续会使用到）\n    retval = prepare_binprm(bprm);\n    if (retval < 0)\n        goto out;\n\n    // 调用copy_strings_kernel()从内核空间获取二进制文件的路径名称\n    retval = copy_strings_kernel(1, &bprm->filename, bprm);\n    if (retval < 0)\n        goto out;\n\n    bprm->exec = bprm->p;\n    // 调用copy_string()从用户空间拷贝环境变量\n    retval = copy_strings(bprm->envc, envp, bprm);\n    if (retval < 0)\n        goto out;\n\n    // 调用copy_string()从用户空间拷贝命令行参数\n    retval = copy_strings(bprm->argc, argv, bprm);\n    if (retval < 0)\n        goto out;\n\n    would_dump(bprm, bprm->file);\n\n    // 至此，二进制文件已经被打开，struct linux_binprm结构体中也记录了重要信息；下面需要识别该二进制文件的格式并最终运行该文件；\n    retval = exec_binprm(bprm);\n    if (retval < 0)\n        goto out;\n\n    /* execve succeeded */\n    current->fs->in_exec = 0;\n    current->in_execve = 0;\n    acct_update_integrals(current);\n    task_numa_free(current);\n    free_bprm(bprm);\n    kfree(pathbuf);\n    putname(filename);\n    if (displaced)\n        put_files_struct(displaced);\n    return retval;\n\nout:\n    if (bprm->mm) {\n        acct_arg_size(bprm, 0);\n        mmput(bprm->mm);\n    }\n\nout_unmark:\n    current->fs->in_exec = 0;\n    current->in_execve = 0;\n\nout_free:\n    free_bprm(bprm);\n    kfree(pathbuf);\n\nout_files:\n    if (displaced)\n        reset_files_struct(displaced);\nout_ret:\n    putname(filename);\n    return retval;\n}\n```\n\n\n\n\n\n\n\n#### 参考资料\n\n\n\nhttps://blog.csdn.net/gatieme/article/details/51594439\n\n\n\n\n\n\n\n\n\n","source":"_posts/Linux-kernel中的do-execve函数解析.md","raw":"---\ntitle: Linux-kernel中的do_execve函数解析\ndate: 2020-05-24 10:59:03\ntags:\n---\n\n\n\n\n\n未完成\n\n#### 简述\n\n在Linux系统中提供了exec开头的一系列函数，这些函数能通过内核调用用户空间的程序，能**用可执行文件所描述的上下文代替进程的上下文**；这些函数都是以exec前缀开始的，这些exec函数都是调用execve()系统调用实现的；而在内核态的sys_execve()函数，是调用do_execve()函数实现的；\n\n<!--more-->\n\n```mermaid\ngraph TB\n\texec类(exec类函数)-->execve(\"execve()\")\n\t-->sys_execve(\"sys_execve()\")\n\t-->do_execve(\"do_execve()\")\n```\n\n\n\n内核中实际执行execv()或execve()系统调用的是do_execve()函数；而do_execve()函数进一步通过do_execveat_common()函数\n\n\n\ndo_execve()函数在fs/exec.c文件中定义；\n\n\n\n```c\n// fs/exec.c\nint do_execve(struct filename *filename,\n    const char __user *const __user *__argv,\n    const char __user *const __user *__envp)\n{\n    struct user_arg_ptr argv = { .ptr.native = __argv };\n    struct user_arg_ptr envp = { .ptr.native = __envp };\n    return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}\n```\n\n\n\n```mermaid\ngraph TB\n\tdo_execve(do_execve)-->do_execveat_common(do_execveat_common)\n```\n\n\n\n#### 参数\n\ndo_execve()函数的参数：\n\n| 参数     | 类型                                | 描述                 |\n| -------- | ----------------------------------- | -------------------- |\n| filename | struct filename                     | 可执行程序的名称信息 |\n| __argv   | const char \\_\\_user *const __user * | 可执行程序的参数信息 |\n| __envp   | const char \\_\\_user *const __user * | 环境变量信息         |\n\n\n\n\n\n```c\n// include/linux/fs.h\nstruct filename {\n    const char      *name;  /* pointer to actual string */\n    const __user char   *uptr;  /* original userland pointer */\n    struct audit_names  *aname;\n    int         refcnt;\n    const char      iname[];\n};\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```c\n// fs/exec.c\nstatic int do_execveat_common(int fd, struct filename *filename,\n                  struct user_arg_ptr argv,\n                  struct user_arg_ptr envp,\n                  int flags)\n{\n    char *pathbuf = NULL;\n    struct linux_binprm *bprm;\n    struct file *file;\n    struct files_struct *displaced;\n    int retval;\n\n    if (IS_ERR(filename)) {\n        printk(\"%s, %d, filename error\\n\", __func__, __LINE__);\n        return PTR_ERR(filename);\n    }\n\n    /*\n     * We move the actual failure in case of RLIMIT_NPROC excess from\n     * set*uid() to execve() because too many poorly written programs\n     * don't check setuid() return code.  Here we additionally recheck\n     * whether NPROC limit is still exceeded.\n     */\n    if ((current->flags & PF_NPROC_EXCEEDED) &&\n        atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n        retval = -EAGAIN;\n        goto out_ret;\n    }\n\n    /* We're below the limit (still or again), so we don't want to make\n     * further execve() calls fail. */\n    current->flags &= ~PF_NPROC_EXCEEDED;\n\n    // 调用unshare_files()为进程复制一份文件表\n    retval = unshare_files(&displaced);\n    if (retval)\n        goto out_ret;\n\n    retval = -ENOMEM;\n    // 调用kzalloc()在堆上分配一份structlinux_binprm结构体\n    bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n    if (!bprm)\n        goto out_files;\n\n    retval = prepare_bprm_creds(bprm);\n    if (retval)\n        goto out_free;\n\n    check_unsafe_exec(bprm);\n    current->in_execve = 1;\n\n    // 调用do_open_execat()查找并打开二进制文件\n    file = do_open_execat(fd, filename, flags);\n    retval = PTR_ERR(file);\n    if (IS_ERR(file)) {\n        printk(\"%s, %d, file error\\n\", __func__, __LINE__);\n        goto out_unmark;\n    }\n\n    // 调用sched_exec()找到最小负载的CPU，用来执行该二进制文件\n    sched_exec();\n\n    // 根据获取的信息，填充struct linux_binprm结构体中的file、filename、interp成员\n    bprm->file = file;\n    if (fd == AT_FDCWD || filename->name[0] == '/') {\n        bprm->filename = filename->name;\n    } else {\n        if (filename->name[0] == '\\0')\n            pathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n        else\n            pathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n                        fd, filename->name);\n        if (!pathbuf) {\n            retval = -ENOMEM;\n            goto out_unmark;\n        }\n        /*\n         * Record that a name derived from an O_CLOEXEC fd will be\n         * inaccessible after exec. Relies on having exclusive access to\n         * current->files (due to unshare_files above).\n         */\n        if (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n            bprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n        bprm->filename = pathbuf;\n    }\n\n    bprm->interp = bprm->filename;\n\n    // 调用bprm_mm_init()创建进程的内存地址空间，并调用init_new_context()检查当前进程是否使用自定义的局部描述符表；如果是，那么分配和准备一个新的LDT；\n    retval = bprm_mm_init(bprm);\n    if (retval)\n        goto out_unmark;\n\n    // 填充struct linux_binprm结构体中的命令行参数argv,环境变量envp\n    bprm->argc = count(argv, MAX_ARG_STRINGS);\n    if ((retval = bprm->argc) < 0)\n        goto out;\n\n    bprm->envc = count(envp, MAX_ARG_STRINGS);\n    if ((retval = bprm->envc) < 0)\n        goto out;\n\n    // 调用prepare_binprm()检查该二进制文件的可执行权限；最后，kernel_read()读取二进制文件的头128字节（这些字节用于识别二进制文件的格式及其他信息，后续会使用到）\n    retval = prepare_binprm(bprm);\n    if (retval < 0)\n        goto out;\n\n    // 调用copy_strings_kernel()从内核空间获取二进制文件的路径名称\n    retval = copy_strings_kernel(1, &bprm->filename, bprm);\n    if (retval < 0)\n        goto out;\n\n    bprm->exec = bprm->p;\n    // 调用copy_string()从用户空间拷贝环境变量\n    retval = copy_strings(bprm->envc, envp, bprm);\n    if (retval < 0)\n        goto out;\n\n    // 调用copy_string()从用户空间拷贝命令行参数\n    retval = copy_strings(bprm->argc, argv, bprm);\n    if (retval < 0)\n        goto out;\n\n    would_dump(bprm, bprm->file);\n\n    // 至此，二进制文件已经被打开，struct linux_binprm结构体中也记录了重要信息；下面需要识别该二进制文件的格式并最终运行该文件；\n    retval = exec_binprm(bprm);\n    if (retval < 0)\n        goto out;\n\n    /* execve succeeded */\n    current->fs->in_exec = 0;\n    current->in_execve = 0;\n    acct_update_integrals(current);\n    task_numa_free(current);\n    free_bprm(bprm);\n    kfree(pathbuf);\n    putname(filename);\n    if (displaced)\n        put_files_struct(displaced);\n    return retval;\n\nout:\n    if (bprm->mm) {\n        acct_arg_size(bprm, 0);\n        mmput(bprm->mm);\n    }\n\nout_unmark:\n    current->fs->in_exec = 0;\n    current->in_execve = 0;\n\nout_free:\n    free_bprm(bprm);\n    kfree(pathbuf);\n\nout_files:\n    if (displaced)\n        reset_files_struct(displaced);\nout_ret:\n    putname(filename);\n    return retval;\n}\n```\n\n\n\n\n\n\n\n#### 参考资料\n\n\n\nhttps://blog.csdn.net/gatieme/article/details/51594439\n\n\n\n\n\n\n\n\n\n","slug":"Linux-kernel中的do-execve函数解析","published":1,"updated":"2020-05-24T12:32:12.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkuq0004dqg1hmzz5ij5","content":"<p>未完成</p>\n<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>在Linux系统中提供了exec开头的一系列函数，这些函数能通过内核调用用户空间的程序，能<strong>用可执行文件所描述的上下文代替进程的上下文</strong>；这些函数都是以exec前缀开始的，这些exec函数都是调用execve()系统调用实现的；而在内核态的sys_execve()函数，是调用do_execve()函数实现的；</p>\n<a id=\"more\"></a>\n\n<pre class=\"mermaid\">graph TB\n    exec类(exec类函数)-->execve(\"execve()\")\n    -->sys_execve(\"sys_execve()\")\n    -->do_execve(\"do_execve()\")</pre>\n\n\n\n<p>内核中实际执行execv()或execve()系统调用的是do_execve()函数；而do_execve()函数进一步通过do_execveat_common()函数</p>\n<p>do_execve()函数在fs/exec.c文件中定义；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fs/exec.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_execve</span><span class=\"params\">(struct filename *filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *__argv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *__envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_arg_ptr</span> <span class=\"title\">argv</span> = &#123;</span> .ptr.native = __argv &#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_arg_ptr</span> <span class=\"title\">envp</span> = &#123;</span> .ptr.native = __envp &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_execveat_common(AT_FDCWD, filename, argv, envp, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<pre class=\"mermaid\">graph TB\n    do_execve(do_execve)-->do_execveat_common(do_execveat_common)</pre>\n\n\n\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>do_execve()函数的参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>filename</td>\n<td>struct filename</td>\n<td>可执行程序的名称信息</td>\n</tr>\n<tr>\n<td>__argv</td>\n<td>const char __user *const __user *</td>\n<td>可执行程序的参数信息</td>\n</tr>\n<tr>\n<td>__envp</td>\n<td>const char __user *const __user *</td>\n<td>环境变量信息</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/fs.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filename</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;  <span class=\"comment\">/* pointer to actual string */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> __user <span class=\"keyword\">char</span>   *uptr;  <span class=\"comment\">/* original userland pointer */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">audit_names</span>  *<span class=\"title\">aname</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         refcnt;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      iname[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fs/exec.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">do_execveat_common</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, struct filename *filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct user_arg_ptr argv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct user_arg_ptr envp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  <span class=\"keyword\">int</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *pathbuf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linux_binprm</span> *<span class=\"title\">bprm</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> *<span class=\"title\">file</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">files_struct</span> *<span class=\"title\">displaced</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> retval;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(filename)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, %d, filename error\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PTR_ERR(filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * We move the actual failure in case of RLIMIT_NPROC excess from</span></span><br><span class=\"line\"><span class=\"comment\">     * set*uid() to execve() because too many poorly written programs</span></span><br><span class=\"line\"><span class=\"comment\">     * don't check setuid() return code.  Here we additionally recheck</span></span><br><span class=\"line\"><span class=\"comment\">     * whether NPROC limit is still exceeded.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((current-&gt;flags &amp; PF_NPROC_EXCEEDED) &amp;&amp;</span><br><span class=\"line\">        atomic_read(&amp;current_user()-&gt;processes) &gt; rlimit(RLIMIT_NPROC)) &#123;</span><br><span class=\"line\">        retval = -EAGAIN;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We're below the limit (still or again), so we don't want to make</span></span><br><span class=\"line\"><span class=\"comment\">     * further execve() calls fail. */</span></span><br><span class=\"line\">    current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用unshare_files()为进程复制一份文件表</span></span><br><span class=\"line\">    retval = unshare_files(&amp;displaced);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = -ENOMEM;</span><br><span class=\"line\">    <span class=\"comment\">// 调用kzalloc()在堆上分配一份structlinux_binprm结构体</span></span><br><span class=\"line\">    bprm = kzalloc(<span class=\"keyword\">sizeof</span>(*bprm), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bprm)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_files;</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = prepare_bprm_creds(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_free;</span><br><span class=\"line\"></span><br><span class=\"line\">    check_unsafe_exec(bprm);</span><br><span class=\"line\">    current-&gt;in_execve = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用do_open_execat()查找并打开二进制文件</span></span><br><span class=\"line\">    file = do_open_execat(fd, filename, flags);</span><br><span class=\"line\">    retval = PTR_ERR(file);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(file)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, %d, file error\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_unmark;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用sched_exec()找到最小负载的CPU，用来执行该二进制文件</span></span><br><span class=\"line\">    sched_exec();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据获取的信息，填充struct linux_binprm结构体中的file、filename、interp成员</span></span><br><span class=\"line\">    bprm-&gt;file = file;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd == AT_FDCWD || filename-&gt;name[<span class=\"number\">0</span>] == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">        bprm-&gt;filename = filename-&gt;name;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filename-&gt;name[<span class=\"number\">0</span>] == <span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">            pathbuf = kasprintf(GFP_TEMPORARY, <span class=\"string\">\"/dev/fd/%d\"</span>, fd);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pathbuf = kasprintf(GFP_TEMPORARY, <span class=\"string\">\"/dev/fd/%d/%s\"</span>,</span><br><span class=\"line\">                        fd, filename-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pathbuf) &#123;</span><br><span class=\"line\">            retval = -ENOMEM;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out_unmark;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Record that a name derived from an O_CLOEXEC fd will be</span></span><br><span class=\"line\"><span class=\"comment\">         * inaccessible after exec. Relies on having exclusive access to</span></span><br><span class=\"line\"><span class=\"comment\">         * current-&gt;files (due to unshare_files above).</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (close_on_exec(fd, rcu_dereference_raw(current-&gt;files-&gt;fdt)))</span><br><span class=\"line\">            bprm-&gt;interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;</span><br><span class=\"line\">        bprm-&gt;filename = pathbuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bprm-&gt;interp = bprm-&gt;filename;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用bprm_mm_init()创建进程的内存地址空间，并调用init_new_context()检查当前进程是否使用自定义的局部描述符表；如果是，那么分配和准备一个新的LDT；</span></span><br><span class=\"line\">    retval = bprm_mm_init(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_unmark;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 填充struct linux_binprm结构体中的命令行参数argv,环境变量envp</span></span><br><span class=\"line\">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((retval = bprm-&gt;argc) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((retval = bprm-&gt;envc) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用prepare_binprm()检查该二进制文件的可执行权限；最后，kernel_read()读取二进制文件的头128字节（这些字节用于识别二进制文件的格式及其他信息，后续会使用到）</span></span><br><span class=\"line\">    retval = prepare_binprm(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用copy_strings_kernel()从内核空间获取二进制文件的路径名称</span></span><br><span class=\"line\">    retval = copy_strings_kernel(<span class=\"number\">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    bprm-&gt;exec = bprm-&gt;p;</span><br><span class=\"line\">    <span class=\"comment\">// 调用copy_string()从用户空间拷贝环境变量</span></span><br><span class=\"line\">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用copy_string()从用户空间拷贝命令行参数</span></span><br><span class=\"line\">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    would_dump(bprm, bprm-&gt;file);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 至此，二进制文件已经被打开，struct linux_binprm结构体中也记录了重要信息；下面需要识别该二进制文件的格式并最终运行该文件；</span></span><br><span class=\"line\">    retval = exec_binprm(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* execve succeeded */</span></span><br><span class=\"line\">    current-&gt;fs-&gt;in_exec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    current-&gt;in_execve = <span class=\"number\">0</span>;</span><br><span class=\"line\">    acct_update_integrals(current);</span><br><span class=\"line\">    task_numa_free(current);</span><br><span class=\"line\">    free_bprm(bprm);</span><br><span class=\"line\">    kfree(pathbuf);</span><br><span class=\"line\">    putname(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (displaced)</span><br><span class=\"line\">        put_files_struct(displaced);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\"></span><br><span class=\"line\">out:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bprm-&gt;mm) &#123;</span><br><span class=\"line\">        acct_arg_size(bprm, <span class=\"number\">0</span>);</span><br><span class=\"line\">        mmput(bprm-&gt;mm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">out_unmark:</span><br><span class=\"line\">    current-&gt;fs-&gt;in_exec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    current-&gt;in_execve = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">out_free:</span><br><span class=\"line\">    free_bprm(bprm);</span><br><span class=\"line\">    kfree(pathbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">out_files:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (displaced)</span><br><span class=\"line\">        reset_files_struct(displaced);</span><br><span class=\"line\">out_ret:</span><br><span class=\"line\">    putname(filename);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://blog.csdn.net/gatieme/article/details/51594439\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gatieme/article/details/51594439</a></p>\n","site":{"data":{}},"excerpt":"<p>未完成</p>\n<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>在Linux系统中提供了exec开头的一系列函数，这些函数能通过内核调用用户空间的程序，能<strong>用可执行文件所描述的上下文代替进程的上下文</strong>；这些函数都是以exec前缀开始的，这些exec函数都是调用execve()系统调用实现的；而在内核态的sys_execve()函数，是调用do_execve()函数实现的；</p>","more":"<pre class=\"mermaid\">graph TB\n    exec类(exec类函数)-->execve(\"execve()\")\n    -->sys_execve(\"sys_execve()\")\n    -->do_execve(\"do_execve()\")</pre>\n\n\n\n<p>内核中实际执行execv()或execve()系统调用的是do_execve()函数；而do_execve()函数进一步通过do_execveat_common()函数</p>\n<p>do_execve()函数在fs/exec.c文件中定义；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fs/exec.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_execve</span><span class=\"params\">(struct filename *filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *__argv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *__envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_arg_ptr</span> <span class=\"title\">argv</span> = &#123;</span> .ptr.native = __argv &#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_arg_ptr</span> <span class=\"title\">envp</span> = &#123;</span> .ptr.native = __envp &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_execveat_common(AT_FDCWD, filename, argv, envp, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<pre class=\"mermaid\">graph TB\n    do_execve(do_execve)-->do_execveat_common(do_execveat_common)</pre>\n\n\n\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>do_execve()函数的参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>filename</td>\n<td>struct filename</td>\n<td>可执行程序的名称信息</td>\n</tr>\n<tr>\n<td>__argv</td>\n<td>const char __user *const __user *</td>\n<td>可执行程序的参数信息</td>\n</tr>\n<tr>\n<td>__envp</td>\n<td>const char __user *const __user *</td>\n<td>环境变量信息</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/fs.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filename</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;  <span class=\"comment\">/* pointer to actual string */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> __user <span class=\"keyword\">char</span>   *uptr;  <span class=\"comment\">/* original userland pointer */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">audit_names</span>  *<span class=\"title\">aname</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         refcnt;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      iname[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fs/exec.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">do_execveat_common</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, struct filename *filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct user_arg_ptr argv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct user_arg_ptr envp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  <span class=\"keyword\">int</span> flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *pathbuf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linux_binprm</span> *<span class=\"title\">bprm</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> *<span class=\"title\">file</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">files_struct</span> *<span class=\"title\">displaced</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> retval;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(filename)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, %d, filename error\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PTR_ERR(filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * We move the actual failure in case of RLIMIT_NPROC excess from</span></span><br><span class=\"line\"><span class=\"comment\">     * set*uid() to execve() because too many poorly written programs</span></span><br><span class=\"line\"><span class=\"comment\">     * don't check setuid() return code.  Here we additionally recheck</span></span><br><span class=\"line\"><span class=\"comment\">     * whether NPROC limit is still exceeded.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((current-&gt;flags &amp; PF_NPROC_EXCEEDED) &amp;&amp;</span><br><span class=\"line\">        atomic_read(&amp;current_user()-&gt;processes) &gt; rlimit(RLIMIT_NPROC)) &#123;</span><br><span class=\"line\">        retval = -EAGAIN;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We're below the limit (still or again), so we don't want to make</span></span><br><span class=\"line\"><span class=\"comment\">     * further execve() calls fail. */</span></span><br><span class=\"line\">    current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用unshare_files()为进程复制一份文件表</span></span><br><span class=\"line\">    retval = unshare_files(&amp;displaced);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = -ENOMEM;</span><br><span class=\"line\">    <span class=\"comment\">// 调用kzalloc()在堆上分配一份structlinux_binprm结构体</span></span><br><span class=\"line\">    bprm = kzalloc(<span class=\"keyword\">sizeof</span>(*bprm), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bprm)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_files;</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = prepare_bprm_creds(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_free;</span><br><span class=\"line\"></span><br><span class=\"line\">    check_unsafe_exec(bprm);</span><br><span class=\"line\">    current-&gt;in_execve = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用do_open_execat()查找并打开二进制文件</span></span><br><span class=\"line\">    file = do_open_execat(fd, filename, flags);</span><br><span class=\"line\">    retval = PTR_ERR(file);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(file)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, %d, file error\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_unmark;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用sched_exec()找到最小负载的CPU，用来执行该二进制文件</span></span><br><span class=\"line\">    sched_exec();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据获取的信息，填充struct linux_binprm结构体中的file、filename、interp成员</span></span><br><span class=\"line\">    bprm-&gt;file = file;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd == AT_FDCWD || filename-&gt;name[<span class=\"number\">0</span>] == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">        bprm-&gt;filename = filename-&gt;name;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filename-&gt;name[<span class=\"number\">0</span>] == <span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">            pathbuf = kasprintf(GFP_TEMPORARY, <span class=\"string\">\"/dev/fd/%d\"</span>, fd);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pathbuf = kasprintf(GFP_TEMPORARY, <span class=\"string\">\"/dev/fd/%d/%s\"</span>,</span><br><span class=\"line\">                        fd, filename-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pathbuf) &#123;</span><br><span class=\"line\">            retval = -ENOMEM;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out_unmark;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Record that a name derived from an O_CLOEXEC fd will be</span></span><br><span class=\"line\"><span class=\"comment\">         * inaccessible after exec. Relies on having exclusive access to</span></span><br><span class=\"line\"><span class=\"comment\">         * current-&gt;files (due to unshare_files above).</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (close_on_exec(fd, rcu_dereference_raw(current-&gt;files-&gt;fdt)))</span><br><span class=\"line\">            bprm-&gt;interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;</span><br><span class=\"line\">        bprm-&gt;filename = pathbuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bprm-&gt;interp = bprm-&gt;filename;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用bprm_mm_init()创建进程的内存地址空间，并调用init_new_context()检查当前进程是否使用自定义的局部描述符表；如果是，那么分配和准备一个新的LDT；</span></span><br><span class=\"line\">    retval = bprm_mm_init(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_unmark;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 填充struct linux_binprm结构体中的命令行参数argv,环境变量envp</span></span><br><span class=\"line\">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((retval = bprm-&gt;argc) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((retval = bprm-&gt;envc) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用prepare_binprm()检查该二进制文件的可执行权限；最后，kernel_read()读取二进制文件的头128字节（这些字节用于识别二进制文件的格式及其他信息，后续会使用到）</span></span><br><span class=\"line\">    retval = prepare_binprm(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用copy_strings_kernel()从内核空间获取二进制文件的路径名称</span></span><br><span class=\"line\">    retval = copy_strings_kernel(<span class=\"number\">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    bprm-&gt;exec = bprm-&gt;p;</span><br><span class=\"line\">    <span class=\"comment\">// 调用copy_string()从用户空间拷贝环境变量</span></span><br><span class=\"line\">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用copy_string()从用户空间拷贝命令行参数</span></span><br><span class=\"line\">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    would_dump(bprm, bprm-&gt;file);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 至此，二进制文件已经被打开，struct linux_binprm结构体中也记录了重要信息；下面需要识别该二进制文件的格式并最终运行该文件；</span></span><br><span class=\"line\">    retval = exec_binprm(bprm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* execve succeeded */</span></span><br><span class=\"line\">    current-&gt;fs-&gt;in_exec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    current-&gt;in_execve = <span class=\"number\">0</span>;</span><br><span class=\"line\">    acct_update_integrals(current);</span><br><span class=\"line\">    task_numa_free(current);</span><br><span class=\"line\">    free_bprm(bprm);</span><br><span class=\"line\">    kfree(pathbuf);</span><br><span class=\"line\">    putname(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (displaced)</span><br><span class=\"line\">        put_files_struct(displaced);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\"></span><br><span class=\"line\">out:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bprm-&gt;mm) &#123;</span><br><span class=\"line\">        acct_arg_size(bprm, <span class=\"number\">0</span>);</span><br><span class=\"line\">        mmput(bprm-&gt;mm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">out_unmark:</span><br><span class=\"line\">    current-&gt;fs-&gt;in_exec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    current-&gt;in_execve = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">out_free:</span><br><span class=\"line\">    free_bprm(bprm);</span><br><span class=\"line\">    kfree(pathbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">out_files:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (displaced)</span><br><span class=\"line\">        reset_files_struct(displaced);</span><br><span class=\"line\">out_ret:</span><br><span class=\"line\">    putname(filename);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://blog.csdn.net/gatieme/article/details/51594439\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gatieme/article/details/51594439</a></p>"},{"title":"Linux-kernel中的i2c-dev驱动","date":"2020-04-12T13:43:49.000Z","_content":"\n\n\nI2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；用户态I2C驱动，需要在用户态封装i2c_msg结构体消息，通过内核态i2c_transfer()函数和I2C从设备通信；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n[TOC]\n\n### 0. 简介\n\n\n\nI2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；\n\n用户态驱动，和一般的I2C设备驱动实现原理差不多，都是封装i2c_msg结构体消息，通过i2c_transfer()函数和I2C从设备通信；区别在于，一般的I2C设备驱动，在内核态封装了该功能；而用户态驱动，需要在用户态封装；可以根据实际需要选择合适的I2C驱动实现方法；\n\n\n\n![Linux的I2C子系统框架](Linux-kernel中的i2c-dev驱动/Linux的I2C子系统框架.png)\n\n\n\n在i2c-dev.c文件中，实现了I2C适配器设备文件的功能，每个I2C适配器被分配一个设备节点；通过适配器访问设备文件节点，主设备号为89，次设备号为0～255；应用程序通过生成的设备节点/dev/i2c-X，使用open、close、read、write、ioctl系统调用进行访问；\n\ni2c-dev.c并不是针对特定的设备而设计，只是提供通用的open、close、read、write、ioctl等系统调用接口，应用程序可以通过这些系统调用接口访问挂接在适配器上的I2C设备；\n\n\n内核代码实现在drivers/i2c/i2c-dev.c；\n\n设备文件：/dev/i2c-X，X为序号；\n\n\n\n\n### 1. 内核态实现\n\ni2c-dev驱动的内核态代码实现在drivers/i2c/i2c-dev.c文件中，如果要编译该文件，需要在make menuconfig配置内核时打开CONFIG_I2C_CHARDEV选项；\n\n\n```\n// driver/i2c/Makefile\nobj-$(CONFIG_I2C_CHARDEV)   += i2c-dev.o\n```\n\n\n\n```c\nCONFIG_I2C_CHARDEV=y\n```\n\n\n\n在drivers/i2c/i2c-dev.c文件中建立i2c-dev驱动模块；\n\n```c\n// drivers/i2c/i2c-dev.c\nmodule_init(i2c_dev_init);\nmodule_exit(i2c_dev_exit);\n```\n\n\n\n#### 1.1 init/exit\n\n```c\n// drivers/i2c/i2c-dev.c\nstatic struct class *i2c_dev_class;\nstatic int __init i2c_dev_init(void)\n{\n    int res;\n\n    // 注册字符设备驱动\n    res = register_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS, \"i2c\");\n    \n    i2c_dev_class = class_create(THIS_MODULE, \"i2c-dev\");\n    i2c_dev_class->dev_groups = i2c_groups;\n    \n    /* Keep track of adapters which will be added or removed later */\n    res = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);\n    \n    /* Bind to already existing adapters right away */\n    i2c_for_each_dev(NULL, i2cdev_attach_adapter);\n    \n    return 0;\n\t......\n}\n\nstatic void __exit i2c_dev_exit(void)\n{\n    bus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);\n    i2c_for_each_dev(NULL, i2cdev_detach_adapter);\n    class_destroy(i2c_dev_class);\n    unregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS);\n}\n```\n\nI2C设备的主设备号固定为89；\n\n\n```c\n// include/linux/i2c-dev.h\n#define I2C_MAJOR   89      /* Device major number      */\n```\n\n\n\n\n\n```c\nstatic int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,\n             void *data)\n{\n    struct device *dev = data;\n\n    switch (action) {\n    case BUS_NOTIFY_ADD_DEVICE:\n        return i2cdev_attach_adapter(dev, NULL);\n    case BUS_NOTIFY_DEL_DEVICE:\n        return i2cdev_detach_adapter(dev, NULL);\n    }\n\n    return 0;\n}\n\nstatic struct notifier_block i2cdev_notifier = {\n    .notifier_call = i2cdev_notifier_call,\n};\n```\n\n\n\n\n\n#### 1.2 attach/detach\n\n```c\nstatic int i2cdev_attach_adapter(struct device *dev, void *dummy)\n{\n    struct i2c_adapter *adap;\n    struct i2c_dev *i2c_dev;\n    int res;\n\n    if (dev->type != &i2c_adapter_type)\n        return 0;\n    adap = to_i2c_adapter(dev);\n\n    i2c_dev = get_free_i2c_dev(adap);\n\n    cdev_init(&i2c_dev->cdev, &i2cdev_fops);\n    i2c_dev->cdev.owner = THIS_MODULE;\n    res = cdev_add(&i2c_dev->cdev, MKDEV(I2C_MAJOR, adap->nr), 1);\n\n    /* register this i2c device with the driver core */\n    i2c_dev->dev = device_create(i2c_dev_class, &adap->dev,\n                     MKDEV(I2C_MAJOR, adap->nr), NULL,\n                     \"i2c-%d\", adap->nr);\n\n    return 0;\n\t......\n}\n\nstatic int i2cdev_detach_adapter(struct device *dev, void *dummy)\n{\n    struct i2c_adapter *adap;\n    struct i2c_dev *i2c_dev;\n\n    if (dev->type != &i2c_adapter_type)\n        return 0;\n    adap = to_i2c_adapter(dev);\n\n    i2c_dev = i2c_dev_get_by_minor(adap->nr);\n\n    cdev_del(&i2c_dev->cdev);\n    put_i2c_dev(i2c_dev);\n    device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap->nr));\n\n    return 0;\n}\n```\n\n\n\n\n\ni2c-dev的字符设备操作集\n\n```c\nstatic const struct file_operations i2cdev_fops = {\n    .owner      = THIS_MODULE,\n    .llseek     = no_llseek,\n    .read       = i2cdev_read,\n    .write      = i2cdev_write,\n    .unlocked_ioctl = i2cdev_ioctl,\n    .open       = i2cdev_open,\n    .release    = i2cdev_release,\n};\n```\n\n\n\n#### 1.3 open/release\n\ni2c-dev设备节点的open、release操作；\n\n```c\nstatic int i2cdev_open(struct inode *inode, struct file *file)\n{\n    unsigned int minor = iminor(inode);\n    struct i2c_client *client;\n    struct i2c_adapter *adap;\n\n    adap = i2c_get_adapter(minor);\n\n    client = kzalloc(sizeof(*client), GFP_KERNEL);\n    if (!client) {\n        i2c_put_adapter(adap);\n        return -ENOMEM;\n    }\n    snprintf(client->name, I2C_NAME_SIZE, \"i2c-dev %d\", adap->nr);\n\n    client->adapter = adap;\n    file->private_data = client;\n\n    return 0;\n}\n\nstatic int i2cdev_release(struct inode *inode, struct file *file)\n{\n    struct i2c_client *client = file->private_data;\n\n    i2c_put_adapter(client->adapter);\n    kfree(client);\n    file->private_data = NULL;\n\n    return 0;\n}\n```\n\ni2c-dev在open时，为设备节点建立一个i2c_client；在之后的操作中，该i2c_client会被I2C_SLAVE或I2C_SLAVE_FORCE命令设置一个从设备地址；\n\n但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；\n\n\n\n#### 1.4 read/write\n\ni2c-dev设备节点的read、write操作；\n\n##### read/write\n\n```c\n// drivers/i2c/i2c-dev.c\nstatic ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,\n        loff_t *offset)\n{\n    char *tmp;\n    int ret;\n\n    struct i2c_client *client = file->private_data;\n\n    if (count > 8192)\n        count = 8192;\n\n    tmp = kmalloc(count, GFP_KERNEL);\n    if (tmp == NULL)\n        return -ENOMEM;\n\n    pr_debug(\"i2c-dev: i2c-%d reading %zu bytes.\\n\",\n        iminor(file_inode(file)), count);\n\n    ret = i2c_master_recv(client, tmp, count);\n    if (ret >= 0)\n        ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;\n    kfree(tmp);\n    return ret;\n}\n\nstatic ssize_t i2cdev_write(struct file *file, const char __user *buf,\n        size_t count, loff_t *offset)\n{\n    int ret;\n    char *tmp;\n    struct i2c_client *client = file->private_data;\n\n    if (count > 8192)\n        count = 8192;\n\n    tmp = memdup_user(buf, count);\n    if (IS_ERR(tmp))\n        return PTR_ERR(tmp);\n\n    pr_debug(\"i2c-dev: i2c-%d writing %zu bytes.\\n\",\n        iminor(file_inode(file)), count);\n\n    ret = i2c_master_send(client, tmp, count);\n    kfree(tmp);\n    return ret;\n}\n```\n\n##### 写入数据实例\n\n```c\nunsigned char *data_wr;\nwrite(fd, data_wr, len+2);\n```\n\ni2c-dev的写入操作，通过write()系统调用，将带有从设备寄存器地址的数组写入到i2c-dev内核驱动，数据长度为要写入的寄存器个数加上两个字节寄存器地址；\n\n\n\n##### 读取数据实例\n\n```c\nunsigned char *data_slave;\nunsigned char *data;\nwrite(fd, addr_slave, 2);\nread(fd, data, len);\n```\n\ni2c-dev的读取操作，分两步：\n\n第一步，通过write()系统调用，将要读取的两个字节从设备寄存器地址，写入到i2c-dev内核驱动；\n\n第二步，通过read()系统调用，从i2c-dev内核驱动中读取长度为len的数据，并保存在data内存中；\n\n\n\n#### 1.5 ioctl\n\n##### i2cdev_ioctl\n\n```c\nstatic long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    struct i2c_client *client = file->private_data;\n    unsigned long funcs;\n\n    switch (cmd) {\n    case I2C_SLAVE:\n    case I2C_SLAVE_FORCE:\n        if ((arg > 0x3ff) ||\n            (((client->flags & I2C_M_TEN) == 0) && arg > 0x7f))\n            return -EINVAL;\n        if (cmd == I2C_SLAVE && i2cdev_check_addr(client->adapter, arg))\n            return -EBUSY;\n        client->addr = arg;\n        return 0;\n    case I2C_TENBIT:\n        if (arg)\n            client->flags |= I2C_M_TEN;\n        else\n            client->flags &= ~I2C_M_TEN;\n        return 0;\n    case I2C_PEC:\n        if (arg)\n            client->flags |= I2C_CLIENT_PEC;\n        else\n            client->flags &= ~I2C_CLIENT_PEC;\n        return 0;\n    case I2C_FUNCS:\n        funcs = i2c_get_functionality(client->adapter);\n        return put_user(funcs, (unsigned long __user *)arg);\n\n    case I2C_RDWR:\n        return i2cdev_ioctl_rdwr(client, arg);\n\n    case I2C_SMBUS:\n        return i2cdev_ioctl_smbus(client, arg);\n\n    case I2C_RETRIES:\n        client->adapter->retries = arg;\n        break;\n    case I2C_TIMEOUT:\n        client->adapter->timeout = msecs_to_jiffies(arg * 10);\n        break;\n    default:\n        return -ENOTTY;\n    }\n    return 0;\n}\n```\n\n\n\n##### ioctl支持的功能\n\n| 命令            | 操作               | 备注                         |\n| --------------- | ------------------ | ---------------------------- |\n| I2C_SLAVE       | 设置从设备地址     | 尝试设置                     |\n| I2C_SLAVE_FORCE | 强制设置从设备地址 | 强制设置，不检查是否已经存在 |\n| I2C_TENBIT      |                    |                              |\n| I2C_PEC         |                    |                              |\n| I2C_FUNCS       |                    |                              |\n| I2C_RDWR        | 读写操作           | 参数：i2cdev_ioctl_rdwr      |\n| I2C_SMBUS       |                    |                              |\n| I2C_RETRIES     | 设置重试次数       |                              |\n| I2C_TIMEOUT     | 设置超时时间       | 单位：10ms                   |\n\n\n\n##### ioctl实例\n\n设置从设备地址\n\n```c\nioctl(fd, I2C_SLAVE, SLAVE_ADDR);\nioctl(fd, I2C_SLAVE_FORCE, SLAVE_ADDR);\n```\n\nI2C_SLAVE和I2C_SLAVE_FORCE命令都是设置从设备地址，区别是：I2C_SLAVE命令尝试设置从设备地址，如果该设备地址已经被设置，就返回失败；I2C_SLAVE_FORCE命令，不管该地址是否存在，都强制设置从设备地址；\n\n\n\n设置超时时间\n\n```c\nioctl(fd, I2C_TIMEOUT, 1);\n```\n\n超时时间单位：10ms\n\n\n\n设置重试次数\n\n```c\nioctl(fd, I2C_RETRIES, 1);\n```\n\n\n\nI2C读写操作\n\n```c\nstruct i2c_rdwr_ioctl_data data;\nioctl(fd, I2C_RDWR, (unsigned long)&data);\n```\n\n\n\ni2c-dev的读写操作是通过ioctl系统调用的I2C_RDWR命令完成，将struct i2c_rdwr_ioctl_data结构体的参数传递给内核态；\n\n```c\n// include/uapi/linux/i2c-dev.h\nstruct i2c_rdwr_ioctl_data {\n    struct i2c_msg __user *msgs;    /* pointers to i2c_msgs */\n    __u32 nmsgs;            /* number of i2c_msgs */\n};\n```\n\ni2c_rdwr_ioctl_data结构体包含了指向i2c_msg结构体的消息指针msgs，和i2c_msg消息个数的nmsgs；\n\n\n\nstruct i2c_msg\n\n```c\n// include/uapi/linux/i2c.h\nstruct i2c_msg {\n    __u16 addr; /* slave address            */\n    __u16 flags;\n#define I2C_M_RD        0x0001  /* read data, from slave to master */\n                    /* I2C_M_RD is guaranteed to be 0x0001! */\n#define I2C_M_TEN       0x0010  /* this is a ten bit chip address */\n#define I2C_M_RECV_LEN      0x0400  /* length will be first received byte */\n#define I2C_M_NO_RD_ACK     0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_IGNORE_NAK    0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_REV_DIR_ADDR  0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_NOSTART       0x4000  /* if I2C_FUNC_NOSTART */\n#define I2C_M_STOP      0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n    __u16 len;      /* msg length               */\n    __u8 *buf;      /* pointer to msg data          */\n};\n```\n\nI2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；\n\nI2C读取，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；\n\nI2C写入，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；\n\ni2c_msg消息以数组格式定义，是为了访问连续，因为数组是连续内存存储的；\n\n\n\n##### i2cdev_ioctl_rdwr\n\ni2cdev_ioctl_rdwr()函数，处理通过ioctl()系统调用I2C_RDWR命令的操作，即对从设备读写的操作；\n\n```c\nstatic noinline int i2cdev_ioctl_rdwr(struct i2c_client *client,\n        unsigned long arg)\n{\n    struct i2c_rdwr_ioctl_data rdwr_arg;\n    struct i2c_msg *rdwr_pa;\n    u8 __user **data_ptrs;\n    int i, res;\n\n    if (copy_from_user(&rdwr_arg,\n               (struct i2c_rdwr_ioctl_data __user *)arg,\n               sizeof(rdwr_arg)))\n        return -EFAULT;\n\t......\n    rdwr_pa = memdup_user(rdwr_arg.msgs,\n                  rdwr_arg.nmsgs * sizeof(struct i2c_msg));\n\n\tdata_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);\n\n    res = 0;\n    for (i = 0; i < rdwr_arg.nmsgs; i++) {\n        ......\n        data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;\n        rdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);\n\t\t...... \n    }\n\n    // 重点，I2C消息的收发，都是通过i2c_transfer()函数实现的\n    res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);\n    while (i-- > 0) {\n        if (res >= 0 && (rdwr_pa[i].flags & I2C_M_RD)) {\n            if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,\n                     rdwr_pa[i].len))\n                res = -EFAULT;\n        }\n        kfree(rdwr_pa[i].buf);\n    }   \n\t......\n}\n```\n\ni2cdev_ioctl_rdwr()函数，完成了消息的收发操作；具体操作：\n\n> 将i2c_rdwr_ioctl_data数据从用户空间拷贝到内核空间\n>\n> 将i2c_rdwr_ioctl_data.msgs消息数组从用户空间拷贝到内核空间\n>\n> 将i2c_rdwr_ioctl_data.msgs.buf数组从用户空间拷贝到内核空间\n>\n> 通过i2c_transfer()函数，以i2c_msg消息格式数组和从设备通信\n\n\n\n\n### 2. 用户态实现\n\n#### 2.1 设备节点\n\n\n在Linux内核中，已经注册了的I2C适配器，可以在用户空间进行访问；i2c-dev驱动对每个I2C适配器生成一个设备节点/dev/i2c-X，主设备号固定为89，X为数字，是I2C适配器的编号，从0开始，编号和设备节点的此设备号一致；\n\n\n```shell\n# ls /dev/i2c-* -l\ncrw-rw----    1 root     root       89,   0 Nov  3 22:02 /dev/i2c-0\ncrw-rw----    1 root     root       89,   1 Nov  3 22:02 /dev/i2c-1\ncrw-rw----    1 root     root       89,   2 Nov  3 22:02 /dev/i2c-2\ncrw-rw----    1 root     root       89,   3 Nov  3 22:02 /dev/i2c-3\n```\n\n\n设备节点/dev/i2c-X的编号X和注册次序有关，使用前还是需要通过/sys/class/i2c-dev/来确定编号；\n\n\n```shell\n# ls /sys/class/i2c-dev/ -l\ntotal 0\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-0 -> ../../devices/platform/soc/2000000.i2c/i2c-0/i2c-dev/i2c-0\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-1 -> ../../devices/platform/soc/2010000.i2c/i2c-1/i2c-dev/i2c-1\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-2 -> ../../devices/platform/soc/2030000.i2c/i2c-2/i2c-dev/i2c-2\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-3 -> ../../devices/platform/soc/2050000.i2c/i2c-3/i2c-dev/i2c-3\n```\n\n\n或者\n\n\n```shell\n# cat /sys/class/i2c-dev/i2c-0/name\n2000000.i2c\n# cat /sys/class/i2c-dev/i2c-2/name\n2030000.i2c\n```\n\n\n这些设备节点实现了文件操作接口，用户空间通过这些I2C设备节点访问I2C适配器；对I2C设备进行读写时，可以通过调用read/write或ioctl来实现；在内核态read、write、ioctl系统调用都是通过i2c_transfer()函数实现和I2C设备的通信；\n\n\n\n\n\n#### 2.2 open\n\n\n用户态使用open函数打开对应的I2C设备节点/dev/i2c-X，如：/dev/i2c-2；\n\n\n```c\nint fd = -1;\nfd = open(\"/dev/i2c-2\", O_RDWR);\n```\n\n\ni2c-dev在open时，为设备节点建立一个i2c_client；但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；\n\n\n\n\n#### 2.3 read/write实现\n\n##### 1）发送\n\n\n```c\nint i2c_write_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    unsigned char *data_wr = NULL;\n    int ret = -1;\n\n    data_wr = malloc(len + 2);\n    if (!data_wr) {\n        printf(\"%s, malloc failed!\\n\", __func__);\n        return -1;\n    }\n\n    data_wr[0] = addr / 0xff;\n    data_wr[1] = addr % 0xff;\n    memcpy(&data_wr[2], data, len);\n\n    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);\n    ioctl(fd, I2C_TIMEOUT, 1);\n    ioctl(fd, I2C_RETRIES, 1);\n\n    ret = write(fd, data_wr, len+2);\n    if (ret < 0) {\n        printf(\"%s, write failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    printf(\"%s, write ok, num: %d\\n\", __func__, ret);\n\n    if (data_wr != NULL) {\n        free(data_wr);\n        data_wr = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n##### 2）接收\n\n\n```c\nint i2c_read_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    unsigned char addr_slave[2] = { 0 };\n    int ret = -1;\n\n    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);\n    ioctl(fd, I2C_TIMEOUT, 1);\n    ioctl(fd, I2C_RETRIES, 1);\n\n    addr_slave[0] = addr / 0xff;\n    addr_slave[1] = addr % 0xff;\n\n    ret = write(fd, addr_slave, 2);\n    if (ret < 0) {\n        printf(\"%s, write failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    ret = read(fd, data, len);\n    if (ret < 0) {\n        printf(\"%s, read failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    printf(\"%s, read ok, num: %d\\n\", __func__, ret);\n\n    return ret;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n#### 2.4 ioctl实现\n\n\n\n##### 1）发送\n\n\n```c\nint i2c_write_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    struct i2c_rdwr_ioctl_data data_wr;\n    int ret = -1;\n\n    data_wr.nmsgs = 1;\n    data_wr.msgs = malloc(sizeof(struct i2c_msg) * data_wr.nmsgs);\n    if (!data_wr.msgs) {\n        printf(\"%s, msgs malloc failed!\\n\", __func__);\n        return -1;\n    }\n\n    data_wr.msgs[0].addr = SLAVE_ADDR;\n    data_wr.msgs[0].flags = 0;\n    data_wr.msgs[0].len = len + 2;\n    data_wr.msgs[0].buf = malloc(data_wr.msgs[0].len + 2);\n    if (!data_wr.msgs[0].buf) {\n        printf(\"%s, msgs buf malloc failed!\\n\", __func__);\n        return -1;\n    }\n    data_wr.msgs[0].buf[0] = addr / 0xff;\n    data_wr.msgs[0].buf[1] = addr % 0xff;\n    memcpy(&data_wr.msgs[0].buf[2], data, len);\n\n    ret = ioctl(fd, I2C_RDWR, (unsigned long)&data_wr);\n    if (ret < 0) {\n        printf(\"%s, ioctl failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    if (data_wr.msgs[0].buf != NULL) {\n        free(data_wr.msgs[0].buf);\n        data_wr.msgs[0].buf = NULL;\n    }\n\n    if (data_wr.msgs != NULL) {\n        free(data_wr.msgs);\n        data_wr.msgs = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n\n\n\n\n\n\n##### 2）接收\n\n\n```c\nint i2c_read_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    struct i2c_rdwr_ioctl_data data_rd;\n    int ret = -1;\n    int i = 0;\n\n    data_rd.nmsgs = 2;\n    data_rd.msgs = malloc(sizeof(struct i2c_msg) * data_rd.nmsgs);\n    if (!data_rd.msgs) {\n        printf(\"%s, msgs malloc failed!\\n\", __func__);\n        return -1;\n    }\n\n    data_rd.msgs[0].addr = SLAVE_ADDR;\n    data_rd.msgs[0].flags = 0;\n    data_rd.msgs[0].len = 2;\n    data_rd.msgs[0].buf = malloc(data_rd.msgs[0].len);\n    if (!data_rd.msgs[0].buf) {\n        printf(\"%s, msgs buf malloc failed!\\n\", __func__);\n        return -1;\n    }\n    data_rd.msgs[0].buf[0] = addr / 0xff;\n    data_rd.msgs[0].buf[1] = addr % 0xff;\n\n    data_rd.msgs[1].addr = SLAVE_ADDR;\n    data_rd.msgs[1].flags = I2C_M_RD;\n    data_rd.msgs[1].len = len;\n    data_rd.msgs[1].buf = malloc(data_rd.msgs[1].len);\n    if (!data_rd.msgs[0].buf) {\n        printf(\"%s, msgs buf malloc failed!\\n\", __func__);\n        return -1;\n    }\n    memset(data_rd.msgs[1].buf, 0, data_rd.msgs[1].len);\n\n    ret = ioctl(fd, I2C_RDWR, (unsigned long)&data_rd);\n    if (ret < 0) {\n        printf(\"%s, ioctl failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n    memcpy(data, data_rd.msgs[1].buf, len);\n\n    printf(\"%s, read ok, num: %d\\n\", __func__, ret);\n\n    if (data_rd.msgs[0].buf != NULL) {\n        free(data_rd.msgs[0].buf);\n        data_rd.msgs[0].buf = NULL;\n    }\n    \n    if (data_rd.msgs[1].buf != NULL) {\n        free(data_rd.msgs[1].buf);\n        data_rd.msgs[1].buf = NULL;\n    }\n\n    if (data_rd.msgs != NULL) {\n        free(data_rd.msgs);\n        data_rd.msgs = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 2.5 main函数\n\n\n\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/i2c.h>\n#include <linux/i2c-dev.h>\n\n#define SLAVE_ADDR  0x51\n\nint arr_show(unsigned char *data, int len)\n{\n    int i = 0;\n\n    for (i = 0; i < len; i++) {\n        printf(\"data[%d]: 0x%x\\n\", i, data[i]);\n    }\n\n    return 0;\n}\n\nvoid usage(void)\n{\n    printf(\"xxx -r addr len\\n\");\n    printf(\"xxx -w addr data1 data2 ...\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    int opt;\n    int fd = -1;\n\n    unsigned short addr;\n    unsigned char buf[256] = { 0 };\n    int len = 0;\n    int i = 0;\n\n    if (argc < 4) {\n        usage();\n        return -1;\n    }\n\n    fd = open(\"/dev/i2c-2\", O_RDWR);\n    if (fd < 0) {\n        printf(\"%s, open failed!\\n\", __func__);\n        return -1;\n    }\n\n    while ((opt = getopt(argc, argv, \"w:r:\")) != -1) {\n        printf(\"optarg: %s\\n\", optarg);\n        printf(\"optind: %d\\n\", optind);\n        printf(\"argc: %d\\n\", argc);\n        printf(\"argv[optind]: %s\\n\", argv[optind]);\n\n        addr = (unsigned short)strtol(optarg, NULL, 0);\n        printf(\"addr: %d\\n\", addr);\n        switch(opt) {\n            case 'w':\n                for (len = 0; optind < argc; optind++, len++) {\n                    buf[len] = (unsigned char)strtol(argv[optind], NULL, 0);\n                }\n                printf(\"len: %d\\n\", len);\n\n                i2c_write_bytes(fd, addr, buf, len);\n                break;\n            case 'r':\n                len = (unsigned int)strtol(argv[optind], NULL, 0);\n                printf(\"len: %d\\n\", len);\n\n                i2c_read_bytes(fd, addr, buf, len);\n\n                arr_show(buf, len);\n                break;\n            default:\n                printf(\"Invalid parameter!\\n\");\n                usage;\n                break;\n        }\n    }\n    close(fd);\n\n    return 0;\n}\n```\n\n\n\n\n\n### 3. 总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n[回到目录](!目录)\n\n","source":"_posts/Linux-kernel中的i2c-dev驱动.md","raw":"---\ntitle: Linux-kernel中的i2c-dev驱动\ndate: 2020-04-12 21:43:49\ntags: i2c\n---\n\n\n\nI2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；用户态I2C驱动，需要在用户态封装i2c_msg结构体消息，通过内核态i2c_transfer()函数和I2C从设备通信；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n[TOC]\n\n### 0. 简介\n\n\n\nI2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；\n\n用户态驱动，和一般的I2C设备驱动实现原理差不多，都是封装i2c_msg结构体消息，通过i2c_transfer()函数和I2C从设备通信；区别在于，一般的I2C设备驱动，在内核态封装了该功能；而用户态驱动，需要在用户态封装；可以根据实际需要选择合适的I2C驱动实现方法；\n\n\n\n![Linux的I2C子系统框架](Linux-kernel中的i2c-dev驱动/Linux的I2C子系统框架.png)\n\n\n\n在i2c-dev.c文件中，实现了I2C适配器设备文件的功能，每个I2C适配器被分配一个设备节点；通过适配器访问设备文件节点，主设备号为89，次设备号为0～255；应用程序通过生成的设备节点/dev/i2c-X，使用open、close、read、write、ioctl系统调用进行访问；\n\ni2c-dev.c并不是针对特定的设备而设计，只是提供通用的open、close、read、write、ioctl等系统调用接口，应用程序可以通过这些系统调用接口访问挂接在适配器上的I2C设备；\n\n\n内核代码实现在drivers/i2c/i2c-dev.c；\n\n设备文件：/dev/i2c-X，X为序号；\n\n\n\n\n### 1. 内核态实现\n\ni2c-dev驱动的内核态代码实现在drivers/i2c/i2c-dev.c文件中，如果要编译该文件，需要在make menuconfig配置内核时打开CONFIG_I2C_CHARDEV选项；\n\n\n```\n// driver/i2c/Makefile\nobj-$(CONFIG_I2C_CHARDEV)   += i2c-dev.o\n```\n\n\n\n```c\nCONFIG_I2C_CHARDEV=y\n```\n\n\n\n在drivers/i2c/i2c-dev.c文件中建立i2c-dev驱动模块；\n\n```c\n// drivers/i2c/i2c-dev.c\nmodule_init(i2c_dev_init);\nmodule_exit(i2c_dev_exit);\n```\n\n\n\n#### 1.1 init/exit\n\n```c\n// drivers/i2c/i2c-dev.c\nstatic struct class *i2c_dev_class;\nstatic int __init i2c_dev_init(void)\n{\n    int res;\n\n    // 注册字符设备驱动\n    res = register_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS, \"i2c\");\n    \n    i2c_dev_class = class_create(THIS_MODULE, \"i2c-dev\");\n    i2c_dev_class->dev_groups = i2c_groups;\n    \n    /* Keep track of adapters which will be added or removed later */\n    res = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);\n    \n    /* Bind to already existing adapters right away */\n    i2c_for_each_dev(NULL, i2cdev_attach_adapter);\n    \n    return 0;\n\t......\n}\n\nstatic void __exit i2c_dev_exit(void)\n{\n    bus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);\n    i2c_for_each_dev(NULL, i2cdev_detach_adapter);\n    class_destroy(i2c_dev_class);\n    unregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS);\n}\n```\n\nI2C设备的主设备号固定为89；\n\n\n```c\n// include/linux/i2c-dev.h\n#define I2C_MAJOR   89      /* Device major number      */\n```\n\n\n\n\n\n```c\nstatic int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,\n             void *data)\n{\n    struct device *dev = data;\n\n    switch (action) {\n    case BUS_NOTIFY_ADD_DEVICE:\n        return i2cdev_attach_adapter(dev, NULL);\n    case BUS_NOTIFY_DEL_DEVICE:\n        return i2cdev_detach_adapter(dev, NULL);\n    }\n\n    return 0;\n}\n\nstatic struct notifier_block i2cdev_notifier = {\n    .notifier_call = i2cdev_notifier_call,\n};\n```\n\n\n\n\n\n#### 1.2 attach/detach\n\n```c\nstatic int i2cdev_attach_adapter(struct device *dev, void *dummy)\n{\n    struct i2c_adapter *adap;\n    struct i2c_dev *i2c_dev;\n    int res;\n\n    if (dev->type != &i2c_adapter_type)\n        return 0;\n    adap = to_i2c_adapter(dev);\n\n    i2c_dev = get_free_i2c_dev(adap);\n\n    cdev_init(&i2c_dev->cdev, &i2cdev_fops);\n    i2c_dev->cdev.owner = THIS_MODULE;\n    res = cdev_add(&i2c_dev->cdev, MKDEV(I2C_MAJOR, adap->nr), 1);\n\n    /* register this i2c device with the driver core */\n    i2c_dev->dev = device_create(i2c_dev_class, &adap->dev,\n                     MKDEV(I2C_MAJOR, adap->nr), NULL,\n                     \"i2c-%d\", adap->nr);\n\n    return 0;\n\t......\n}\n\nstatic int i2cdev_detach_adapter(struct device *dev, void *dummy)\n{\n    struct i2c_adapter *adap;\n    struct i2c_dev *i2c_dev;\n\n    if (dev->type != &i2c_adapter_type)\n        return 0;\n    adap = to_i2c_adapter(dev);\n\n    i2c_dev = i2c_dev_get_by_minor(adap->nr);\n\n    cdev_del(&i2c_dev->cdev);\n    put_i2c_dev(i2c_dev);\n    device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap->nr));\n\n    return 0;\n}\n```\n\n\n\n\n\ni2c-dev的字符设备操作集\n\n```c\nstatic const struct file_operations i2cdev_fops = {\n    .owner      = THIS_MODULE,\n    .llseek     = no_llseek,\n    .read       = i2cdev_read,\n    .write      = i2cdev_write,\n    .unlocked_ioctl = i2cdev_ioctl,\n    .open       = i2cdev_open,\n    .release    = i2cdev_release,\n};\n```\n\n\n\n#### 1.3 open/release\n\ni2c-dev设备节点的open、release操作；\n\n```c\nstatic int i2cdev_open(struct inode *inode, struct file *file)\n{\n    unsigned int minor = iminor(inode);\n    struct i2c_client *client;\n    struct i2c_adapter *adap;\n\n    adap = i2c_get_adapter(minor);\n\n    client = kzalloc(sizeof(*client), GFP_KERNEL);\n    if (!client) {\n        i2c_put_adapter(adap);\n        return -ENOMEM;\n    }\n    snprintf(client->name, I2C_NAME_SIZE, \"i2c-dev %d\", adap->nr);\n\n    client->adapter = adap;\n    file->private_data = client;\n\n    return 0;\n}\n\nstatic int i2cdev_release(struct inode *inode, struct file *file)\n{\n    struct i2c_client *client = file->private_data;\n\n    i2c_put_adapter(client->adapter);\n    kfree(client);\n    file->private_data = NULL;\n\n    return 0;\n}\n```\n\ni2c-dev在open时，为设备节点建立一个i2c_client；在之后的操作中，该i2c_client会被I2C_SLAVE或I2C_SLAVE_FORCE命令设置一个从设备地址；\n\n但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；\n\n\n\n#### 1.4 read/write\n\ni2c-dev设备节点的read、write操作；\n\n##### read/write\n\n```c\n// drivers/i2c/i2c-dev.c\nstatic ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,\n        loff_t *offset)\n{\n    char *tmp;\n    int ret;\n\n    struct i2c_client *client = file->private_data;\n\n    if (count > 8192)\n        count = 8192;\n\n    tmp = kmalloc(count, GFP_KERNEL);\n    if (tmp == NULL)\n        return -ENOMEM;\n\n    pr_debug(\"i2c-dev: i2c-%d reading %zu bytes.\\n\",\n        iminor(file_inode(file)), count);\n\n    ret = i2c_master_recv(client, tmp, count);\n    if (ret >= 0)\n        ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;\n    kfree(tmp);\n    return ret;\n}\n\nstatic ssize_t i2cdev_write(struct file *file, const char __user *buf,\n        size_t count, loff_t *offset)\n{\n    int ret;\n    char *tmp;\n    struct i2c_client *client = file->private_data;\n\n    if (count > 8192)\n        count = 8192;\n\n    tmp = memdup_user(buf, count);\n    if (IS_ERR(tmp))\n        return PTR_ERR(tmp);\n\n    pr_debug(\"i2c-dev: i2c-%d writing %zu bytes.\\n\",\n        iminor(file_inode(file)), count);\n\n    ret = i2c_master_send(client, tmp, count);\n    kfree(tmp);\n    return ret;\n}\n```\n\n##### 写入数据实例\n\n```c\nunsigned char *data_wr;\nwrite(fd, data_wr, len+2);\n```\n\ni2c-dev的写入操作，通过write()系统调用，将带有从设备寄存器地址的数组写入到i2c-dev内核驱动，数据长度为要写入的寄存器个数加上两个字节寄存器地址；\n\n\n\n##### 读取数据实例\n\n```c\nunsigned char *data_slave;\nunsigned char *data;\nwrite(fd, addr_slave, 2);\nread(fd, data, len);\n```\n\ni2c-dev的读取操作，分两步：\n\n第一步，通过write()系统调用，将要读取的两个字节从设备寄存器地址，写入到i2c-dev内核驱动；\n\n第二步，通过read()系统调用，从i2c-dev内核驱动中读取长度为len的数据，并保存在data内存中；\n\n\n\n#### 1.5 ioctl\n\n##### i2cdev_ioctl\n\n```c\nstatic long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    struct i2c_client *client = file->private_data;\n    unsigned long funcs;\n\n    switch (cmd) {\n    case I2C_SLAVE:\n    case I2C_SLAVE_FORCE:\n        if ((arg > 0x3ff) ||\n            (((client->flags & I2C_M_TEN) == 0) && arg > 0x7f))\n            return -EINVAL;\n        if (cmd == I2C_SLAVE && i2cdev_check_addr(client->adapter, arg))\n            return -EBUSY;\n        client->addr = arg;\n        return 0;\n    case I2C_TENBIT:\n        if (arg)\n            client->flags |= I2C_M_TEN;\n        else\n            client->flags &= ~I2C_M_TEN;\n        return 0;\n    case I2C_PEC:\n        if (arg)\n            client->flags |= I2C_CLIENT_PEC;\n        else\n            client->flags &= ~I2C_CLIENT_PEC;\n        return 0;\n    case I2C_FUNCS:\n        funcs = i2c_get_functionality(client->adapter);\n        return put_user(funcs, (unsigned long __user *)arg);\n\n    case I2C_RDWR:\n        return i2cdev_ioctl_rdwr(client, arg);\n\n    case I2C_SMBUS:\n        return i2cdev_ioctl_smbus(client, arg);\n\n    case I2C_RETRIES:\n        client->adapter->retries = arg;\n        break;\n    case I2C_TIMEOUT:\n        client->adapter->timeout = msecs_to_jiffies(arg * 10);\n        break;\n    default:\n        return -ENOTTY;\n    }\n    return 0;\n}\n```\n\n\n\n##### ioctl支持的功能\n\n| 命令            | 操作               | 备注                         |\n| --------------- | ------------------ | ---------------------------- |\n| I2C_SLAVE       | 设置从设备地址     | 尝试设置                     |\n| I2C_SLAVE_FORCE | 强制设置从设备地址 | 强制设置，不检查是否已经存在 |\n| I2C_TENBIT      |                    |                              |\n| I2C_PEC         |                    |                              |\n| I2C_FUNCS       |                    |                              |\n| I2C_RDWR        | 读写操作           | 参数：i2cdev_ioctl_rdwr      |\n| I2C_SMBUS       |                    |                              |\n| I2C_RETRIES     | 设置重试次数       |                              |\n| I2C_TIMEOUT     | 设置超时时间       | 单位：10ms                   |\n\n\n\n##### ioctl实例\n\n设置从设备地址\n\n```c\nioctl(fd, I2C_SLAVE, SLAVE_ADDR);\nioctl(fd, I2C_SLAVE_FORCE, SLAVE_ADDR);\n```\n\nI2C_SLAVE和I2C_SLAVE_FORCE命令都是设置从设备地址，区别是：I2C_SLAVE命令尝试设置从设备地址，如果该设备地址已经被设置，就返回失败；I2C_SLAVE_FORCE命令，不管该地址是否存在，都强制设置从设备地址；\n\n\n\n设置超时时间\n\n```c\nioctl(fd, I2C_TIMEOUT, 1);\n```\n\n超时时间单位：10ms\n\n\n\n设置重试次数\n\n```c\nioctl(fd, I2C_RETRIES, 1);\n```\n\n\n\nI2C读写操作\n\n```c\nstruct i2c_rdwr_ioctl_data data;\nioctl(fd, I2C_RDWR, (unsigned long)&data);\n```\n\n\n\ni2c-dev的读写操作是通过ioctl系统调用的I2C_RDWR命令完成，将struct i2c_rdwr_ioctl_data结构体的参数传递给内核态；\n\n```c\n// include/uapi/linux/i2c-dev.h\nstruct i2c_rdwr_ioctl_data {\n    struct i2c_msg __user *msgs;    /* pointers to i2c_msgs */\n    __u32 nmsgs;            /* number of i2c_msgs */\n};\n```\n\ni2c_rdwr_ioctl_data结构体包含了指向i2c_msg结构体的消息指针msgs，和i2c_msg消息个数的nmsgs；\n\n\n\nstruct i2c_msg\n\n```c\n// include/uapi/linux/i2c.h\nstruct i2c_msg {\n    __u16 addr; /* slave address            */\n    __u16 flags;\n#define I2C_M_RD        0x0001  /* read data, from slave to master */\n                    /* I2C_M_RD is guaranteed to be 0x0001! */\n#define I2C_M_TEN       0x0010  /* this is a ten bit chip address */\n#define I2C_M_RECV_LEN      0x0400  /* length will be first received byte */\n#define I2C_M_NO_RD_ACK     0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_IGNORE_NAK    0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_REV_DIR_ADDR  0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_NOSTART       0x4000  /* if I2C_FUNC_NOSTART */\n#define I2C_M_STOP      0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n    __u16 len;      /* msg length               */\n    __u8 *buf;      /* pointer to msg data          */\n};\n```\n\nI2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；\n\nI2C读取，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；\n\nI2C写入，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；\n\ni2c_msg消息以数组格式定义，是为了访问连续，因为数组是连续内存存储的；\n\n\n\n##### i2cdev_ioctl_rdwr\n\ni2cdev_ioctl_rdwr()函数，处理通过ioctl()系统调用I2C_RDWR命令的操作，即对从设备读写的操作；\n\n```c\nstatic noinline int i2cdev_ioctl_rdwr(struct i2c_client *client,\n        unsigned long arg)\n{\n    struct i2c_rdwr_ioctl_data rdwr_arg;\n    struct i2c_msg *rdwr_pa;\n    u8 __user **data_ptrs;\n    int i, res;\n\n    if (copy_from_user(&rdwr_arg,\n               (struct i2c_rdwr_ioctl_data __user *)arg,\n               sizeof(rdwr_arg)))\n        return -EFAULT;\n\t......\n    rdwr_pa = memdup_user(rdwr_arg.msgs,\n                  rdwr_arg.nmsgs * sizeof(struct i2c_msg));\n\n\tdata_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);\n\n    res = 0;\n    for (i = 0; i < rdwr_arg.nmsgs; i++) {\n        ......\n        data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;\n        rdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);\n\t\t...... \n    }\n\n    // 重点，I2C消息的收发，都是通过i2c_transfer()函数实现的\n    res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);\n    while (i-- > 0) {\n        if (res >= 0 && (rdwr_pa[i].flags & I2C_M_RD)) {\n            if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,\n                     rdwr_pa[i].len))\n                res = -EFAULT;\n        }\n        kfree(rdwr_pa[i].buf);\n    }   \n\t......\n}\n```\n\ni2cdev_ioctl_rdwr()函数，完成了消息的收发操作；具体操作：\n\n> 将i2c_rdwr_ioctl_data数据从用户空间拷贝到内核空间\n>\n> 将i2c_rdwr_ioctl_data.msgs消息数组从用户空间拷贝到内核空间\n>\n> 将i2c_rdwr_ioctl_data.msgs.buf数组从用户空间拷贝到内核空间\n>\n> 通过i2c_transfer()函数，以i2c_msg消息格式数组和从设备通信\n\n\n\n\n### 2. 用户态实现\n\n#### 2.1 设备节点\n\n\n在Linux内核中，已经注册了的I2C适配器，可以在用户空间进行访问；i2c-dev驱动对每个I2C适配器生成一个设备节点/dev/i2c-X，主设备号固定为89，X为数字，是I2C适配器的编号，从0开始，编号和设备节点的此设备号一致；\n\n\n```shell\n# ls /dev/i2c-* -l\ncrw-rw----    1 root     root       89,   0 Nov  3 22:02 /dev/i2c-0\ncrw-rw----    1 root     root       89,   1 Nov  3 22:02 /dev/i2c-1\ncrw-rw----    1 root     root       89,   2 Nov  3 22:02 /dev/i2c-2\ncrw-rw----    1 root     root       89,   3 Nov  3 22:02 /dev/i2c-3\n```\n\n\n设备节点/dev/i2c-X的编号X和注册次序有关，使用前还是需要通过/sys/class/i2c-dev/来确定编号；\n\n\n```shell\n# ls /sys/class/i2c-dev/ -l\ntotal 0\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-0 -> ../../devices/platform/soc/2000000.i2c/i2c-0/i2c-dev/i2c-0\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-1 -> ../../devices/platform/soc/2010000.i2c/i2c-1/i2c-dev/i2c-1\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-2 -> ../../devices/platform/soc/2030000.i2c/i2c-2/i2c-dev/i2c-2\nlrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-3 -> ../../devices/platform/soc/2050000.i2c/i2c-3/i2c-dev/i2c-3\n```\n\n\n或者\n\n\n```shell\n# cat /sys/class/i2c-dev/i2c-0/name\n2000000.i2c\n# cat /sys/class/i2c-dev/i2c-2/name\n2030000.i2c\n```\n\n\n这些设备节点实现了文件操作接口，用户空间通过这些I2C设备节点访问I2C适配器；对I2C设备进行读写时，可以通过调用read/write或ioctl来实现；在内核态read、write、ioctl系统调用都是通过i2c_transfer()函数实现和I2C设备的通信；\n\n\n\n\n\n#### 2.2 open\n\n\n用户态使用open函数打开对应的I2C设备节点/dev/i2c-X，如：/dev/i2c-2；\n\n\n```c\nint fd = -1;\nfd = open(\"/dev/i2c-2\", O_RDWR);\n```\n\n\ni2c-dev在open时，为设备节点建立一个i2c_client；但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；\n\n\n\n\n#### 2.3 read/write实现\n\n##### 1）发送\n\n\n```c\nint i2c_write_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    unsigned char *data_wr = NULL;\n    int ret = -1;\n\n    data_wr = malloc(len + 2);\n    if (!data_wr) {\n        printf(\"%s, malloc failed!\\n\", __func__);\n        return -1;\n    }\n\n    data_wr[0] = addr / 0xff;\n    data_wr[1] = addr % 0xff;\n    memcpy(&data_wr[2], data, len);\n\n    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);\n    ioctl(fd, I2C_TIMEOUT, 1);\n    ioctl(fd, I2C_RETRIES, 1);\n\n    ret = write(fd, data_wr, len+2);\n    if (ret < 0) {\n        printf(\"%s, write failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    printf(\"%s, write ok, num: %d\\n\", __func__, ret);\n\n    if (data_wr != NULL) {\n        free(data_wr);\n        data_wr = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n##### 2）接收\n\n\n```c\nint i2c_read_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    unsigned char addr_slave[2] = { 0 };\n    int ret = -1;\n\n    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);\n    ioctl(fd, I2C_TIMEOUT, 1);\n    ioctl(fd, I2C_RETRIES, 1);\n\n    addr_slave[0] = addr / 0xff;\n    addr_slave[1] = addr % 0xff;\n\n    ret = write(fd, addr_slave, 2);\n    if (ret < 0) {\n        printf(\"%s, write failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    ret = read(fd, data, len);\n    if (ret < 0) {\n        printf(\"%s, read failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    printf(\"%s, read ok, num: %d\\n\", __func__, ret);\n\n    return ret;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n#### 2.4 ioctl实现\n\n\n\n##### 1）发送\n\n\n```c\nint i2c_write_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    struct i2c_rdwr_ioctl_data data_wr;\n    int ret = -1;\n\n    data_wr.nmsgs = 1;\n    data_wr.msgs = malloc(sizeof(struct i2c_msg) * data_wr.nmsgs);\n    if (!data_wr.msgs) {\n        printf(\"%s, msgs malloc failed!\\n\", __func__);\n        return -1;\n    }\n\n    data_wr.msgs[0].addr = SLAVE_ADDR;\n    data_wr.msgs[0].flags = 0;\n    data_wr.msgs[0].len = len + 2;\n    data_wr.msgs[0].buf = malloc(data_wr.msgs[0].len + 2);\n    if (!data_wr.msgs[0].buf) {\n        printf(\"%s, msgs buf malloc failed!\\n\", __func__);\n        return -1;\n    }\n    data_wr.msgs[0].buf[0] = addr / 0xff;\n    data_wr.msgs[0].buf[1] = addr % 0xff;\n    memcpy(&data_wr.msgs[0].buf[2], data, len);\n\n    ret = ioctl(fd, I2C_RDWR, (unsigned long)&data_wr);\n    if (ret < 0) {\n        printf(\"%s, ioctl failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n\n    if (data_wr.msgs[0].buf != NULL) {\n        free(data_wr.msgs[0].buf);\n        data_wr.msgs[0].buf = NULL;\n    }\n\n    if (data_wr.msgs != NULL) {\n        free(data_wr.msgs);\n        data_wr.msgs = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n\n\n\n\n\n\n##### 2）接收\n\n\n```c\nint i2c_read_bytes(int fd, unsigned short addr, unsigned char *data, int len)\n{\n    struct i2c_rdwr_ioctl_data data_rd;\n    int ret = -1;\n    int i = 0;\n\n    data_rd.nmsgs = 2;\n    data_rd.msgs = malloc(sizeof(struct i2c_msg) * data_rd.nmsgs);\n    if (!data_rd.msgs) {\n        printf(\"%s, msgs malloc failed!\\n\", __func__);\n        return -1;\n    }\n\n    data_rd.msgs[0].addr = SLAVE_ADDR;\n    data_rd.msgs[0].flags = 0;\n    data_rd.msgs[0].len = 2;\n    data_rd.msgs[0].buf = malloc(data_rd.msgs[0].len);\n    if (!data_rd.msgs[0].buf) {\n        printf(\"%s, msgs buf malloc failed!\\n\", __func__);\n        return -1;\n    }\n    data_rd.msgs[0].buf[0] = addr / 0xff;\n    data_rd.msgs[0].buf[1] = addr % 0xff;\n\n    data_rd.msgs[1].addr = SLAVE_ADDR;\n    data_rd.msgs[1].flags = I2C_M_RD;\n    data_rd.msgs[1].len = len;\n    data_rd.msgs[1].buf = malloc(data_rd.msgs[1].len);\n    if (!data_rd.msgs[0].buf) {\n        printf(\"%s, msgs buf malloc failed!\\n\", __func__);\n        return -1;\n    }\n    memset(data_rd.msgs[1].buf, 0, data_rd.msgs[1].len);\n\n    ret = ioctl(fd, I2C_RDWR, (unsigned long)&data_rd);\n    if (ret < 0) {\n        printf(\"%s, ioctl failed, ret: 0x%x\\n\", __func__, ret);\n        return ret;\n    }\n    memcpy(data, data_rd.msgs[1].buf, len);\n\n    printf(\"%s, read ok, num: %d\\n\", __func__, ret);\n\n    if (data_rd.msgs[0].buf != NULL) {\n        free(data_rd.msgs[0].buf);\n        data_rd.msgs[0].buf = NULL;\n    }\n    \n    if (data_rd.msgs[1].buf != NULL) {\n        free(data_rd.msgs[1].buf);\n        data_rd.msgs[1].buf = NULL;\n    }\n\n    if (data_rd.msgs != NULL) {\n        free(data_rd.msgs);\n        data_rd.msgs = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 2.5 main函数\n\n\n\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/i2c.h>\n#include <linux/i2c-dev.h>\n\n#define SLAVE_ADDR  0x51\n\nint arr_show(unsigned char *data, int len)\n{\n    int i = 0;\n\n    for (i = 0; i < len; i++) {\n        printf(\"data[%d]: 0x%x\\n\", i, data[i]);\n    }\n\n    return 0;\n}\n\nvoid usage(void)\n{\n    printf(\"xxx -r addr len\\n\");\n    printf(\"xxx -w addr data1 data2 ...\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    int opt;\n    int fd = -1;\n\n    unsigned short addr;\n    unsigned char buf[256] = { 0 };\n    int len = 0;\n    int i = 0;\n\n    if (argc < 4) {\n        usage();\n        return -1;\n    }\n\n    fd = open(\"/dev/i2c-2\", O_RDWR);\n    if (fd < 0) {\n        printf(\"%s, open failed!\\n\", __func__);\n        return -1;\n    }\n\n    while ((opt = getopt(argc, argv, \"w:r:\")) != -1) {\n        printf(\"optarg: %s\\n\", optarg);\n        printf(\"optind: %d\\n\", optind);\n        printf(\"argc: %d\\n\", argc);\n        printf(\"argv[optind]: %s\\n\", argv[optind]);\n\n        addr = (unsigned short)strtol(optarg, NULL, 0);\n        printf(\"addr: %d\\n\", addr);\n        switch(opt) {\n            case 'w':\n                for (len = 0; optind < argc; optind++, len++) {\n                    buf[len] = (unsigned char)strtol(argv[optind], NULL, 0);\n                }\n                printf(\"len: %d\\n\", len);\n\n                i2c_write_bytes(fd, addr, buf, len);\n                break;\n            case 'r':\n                len = (unsigned int)strtol(argv[optind], NULL, 0);\n                printf(\"len: %d\\n\", len);\n\n                i2c_read_bytes(fd, addr, buf, len);\n\n                arr_show(buf, len);\n                break;\n            default:\n                printf(\"Invalid parameter!\\n\");\n                usage;\n                break;\n        }\n    }\n    close(fd);\n\n    return 0;\n}\n```\n\n\n\n\n\n### 3. 总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n[回到目录](!目录)\n\n","slug":"Linux-kernel中的i2c-dev驱动","published":1,"updated":"2020-05-06T14:00:50.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkut0005dqg10ofo0yvk","content":"<p>I2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；用户态I2C驱动，需要在用户态封装i2c_msg结构体消息，通过内核态i2c_transfer()函数和I2C从设备通信；</p>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>I2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；</p>\n<p>用户态驱动，和一般的I2C设备驱动实现原理差不多，都是封装i2c_msg结构体消息，通过i2c_transfer()函数和I2C从设备通信；区别在于，一般的I2C设备驱动，在内核态封装了该功能；而用户态驱动，需要在用户态封装；可以根据实际需要选择合适的I2C驱动实现方法；</p>\n<p><img src=\"/2020/04/12/Linux-kernel%E4%B8%AD%E7%9A%84i2c-dev%E9%A9%B1%E5%8A%A8/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png\" alt=\"Linux的I2C子系统框架\"></p>\n<p>在i2c-dev.c文件中，实现了I2C适配器设备文件的功能，每个I2C适配器被分配一个设备节点；通过适配器访问设备文件节点，主设备号为89，次设备号为0～255；应用程序通过生成的设备节点/dev/i2c-X，使用open、close、read、write、ioctl系统调用进行访问；</p>\n<p>i2c-dev.c并不是针对特定的设备而设计，只是提供通用的open、close、read、write、ioctl等系统调用接口，应用程序可以通过这些系统调用接口访问挂接在适配器上的I2C设备；</p>\n<p>内核代码实现在drivers/i2c/i2c-dev.c；</p>\n<p>设备文件：/dev/i2c-X，X为序号；</p>\n<h3 id=\"1-内核态实现\"><a href=\"#1-内核态实现\" class=\"headerlink\" title=\"1. 内核态实现\"></a>1. 内核态实现</h3><p>i2c-dev驱动的内核态代码实现在drivers/i2c/i2c-dev.c文件中，如果要编译该文件，需要在make menuconfig配置内核时打开CONFIG_I2C_CHARDEV选项；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; driver&#x2F;i2c&#x2F;Makefile</span><br><span class=\"line\">obj-$(CONFIG_I2C_CHARDEV)   +&#x3D; i2c-dev.o</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_I2C_CHARDEV=y</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在drivers/i2c/i2c-dev.c文件中建立i2c-dev驱动模块；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-dev.c</span></span><br><span class=\"line\">module_init(i2c_dev_init);</span><br><span class=\"line\">module_exit(i2c_dev_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-init-exit\"><a href=\"#1-1-init-exit\" class=\"headerlink\" title=\"1.1 init/exit\"></a>1.1 init/exit</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-dev.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class</span> *<span class=\"title\">i2c_dev_class</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">i2c_dev_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册字符设备驱动</span></span><br><span class=\"line\">    res = register_chrdev_region(MKDEV(I2C_MAJOR, <span class=\"number\">0</span>), I2C_MINORS, <span class=\"string\">\"i2c\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    i2c_dev_class = class_create(THIS_MODULE, <span class=\"string\">\"i2c-dev\"</span>);</span><br><span class=\"line\">    i2c_dev_class-&gt;dev_groups = i2c_groups;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* Keep track of adapters which will be added or removed later */</span></span><br><span class=\"line\">    res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* Bind to already existing adapters right away */</span></span><br><span class=\"line\">    i2c_for_each_dev(<span class=\"literal\">NULL</span>, i2cdev_attach_adapter);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">i2c_dev_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    bus_unregister_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class=\"line\">    i2c_for_each_dev(<span class=\"literal\">NULL</span>, i2cdev_detach_adapter);</span><br><span class=\"line\">    class_destroy(i2c_dev_class);</span><br><span class=\"line\">    unregister_chrdev_region(MKDEV(I2C_MAJOR, <span class=\"number\">0</span>), I2C_MINORS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>I2C设备的主设备号固定为89；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/i2c-dev.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_MAJOR   89      <span class=\"comment\">/* Device major number      */</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_notifier_call</span><span class=\"params\">(struct notifier_block *nb, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> action,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">void</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span> = <span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_attach_adapter(dev, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_detach_adapter(dev, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">notifier_block</span> <span class=\"title\">i2cdev_notifier</span> = &#123;</span></span><br><span class=\"line\">    .notifier_call = i2cdev_notifier_call,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"1-2-attach-detach\"><a href=\"#1-2-attach-detach\" class=\"headerlink\" title=\"1.2 attach/detach\"></a>1.2 attach/detach</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_attach_adapter</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">void</span> *dummy)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_dev</span> *<span class=\"title\">i2c_dev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    adap = to_i2c_adapter(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_dev = get_free_i2c_dev(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_init(&amp;i2c_dev-&gt;cdev, &amp;i2cdev_fops);</span><br><span class=\"line\">    i2c_dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class=\"line\">    res = cdev_add(&amp;i2c_dev-&gt;cdev, MKDEV(I2C_MAJOR, adap-&gt;nr), <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* register this i2c device with the driver core */</span></span><br><span class=\"line\">    i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class=\"line\">                     MKDEV(I2C_MAJOR, adap-&gt;nr), <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                     <span class=\"string\">\"i2c-%d\"</span>, adap-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_detach_adapter</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">void</span> *dummy)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_dev</span> *<span class=\"title\">i2c_dev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    adap = to_i2c_adapter(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_dev = i2c_dev_get_by_minor(adap-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_del(&amp;i2c_dev-&gt;cdev);</span><br><span class=\"line\">    put_i2c_dev(i2c_dev);</span><br><span class=\"line\">    device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>i2c-dev的字符设备操作集</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">i2cdev_fops</span> = &#123;</span></span><br><span class=\"line\">    .owner      = THIS_MODULE,</span><br><span class=\"line\">    .llseek     = no_llseek,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>       = i2cdev_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>      = i2cdev_write,</span><br><span class=\"line\">    .unlocked_ioctl = i2cdev_ioctl,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span>       = i2cdev_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span>    = i2cdev_release,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-3-open-release\"><a href=\"#1-3-open-release\" class=\"headerlink\" title=\"1.3 open/release\"></a>1.3 open/release</h4><p>i2c-dev设备节点的open、release操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_open</span><span class=\"params\">(struct inode *inode, struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> minor = iminor(inode);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    adap = i2c_get_adapter(minor);</span><br><span class=\"line\"></span><br><span class=\"line\">    client = kzalloc(<span class=\"keyword\">sizeof</span>(*client), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!client) &#123;</span><br><span class=\"line\">        i2c_put_adapter(adap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class=\"string\">\"i2c-dev %d\"</span>, adap-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;adapter = adap;</span><br><span class=\"line\">    file-&gt;private_data = client;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_release</span><span class=\"params\">(struct inode *inode, struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_put_adapter(client-&gt;adapter);</span><br><span class=\"line\">    kfree(client);</span><br><span class=\"line\">    file-&gt;private_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2c-dev在open时，为设备节点建立一个i2c_client；在之后的操作中，该i2c_client会被I2C_SLAVE或I2C_SLAVE_FORCE命令设置一个从设备地址；</p>\n<p>但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；</p>\n<h4 id=\"1-4-read-write\"><a href=\"#1-4-read-write\" class=\"headerlink\" title=\"1.4 read/write\"></a>1.4 read/write</h4><p>i2c-dev设备节点的read、write操作；</p>\n<h5 id=\"read-write\"><a href=\"#read-write\" class=\"headerlink\" title=\"read/write\"></a>read/write</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-dev.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">i2cdev_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">loff_t</span> *offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *tmp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">8192</span>)</span><br><span class=\"line\">        count = <span class=\"number\">8192</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = kmalloc(count, GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"i2c-dev: i2c-%d reading %zu bytes.\\n\"</span>,</span><br><span class=\"line\">        iminor(file_inode(file)), count);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_recv(client, tmp, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;</span><br><span class=\"line\">    kfree(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">i2cdev_write</span><span class=\"params\">(struct file *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *tmp;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">8192</span>)</span><br><span class=\"line\">        count = <span class=\"number\">8192</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = memdup_user(buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(tmp))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PTR_ERR(tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"i2c-dev: i2c-%d writing %zu bytes.\\n\"</span>,</span><br><span class=\"line\">        iminor(file_inode(file)), count);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_send(client, tmp, count);</span><br><span class=\"line\">    kfree(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"写入数据实例\"><a href=\"#写入数据实例\" class=\"headerlink\" title=\"写入数据实例\"></a>写入数据实例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data_wr;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, data_wr, len+<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>i2c-dev的写入操作，通过write()系统调用，将带有从设备寄存器地址的数组写入到i2c-dev内核驱动，数据长度为要写入的寄存器个数加上两个字节寄存器地址；</p>\n<h5 id=\"读取数据实例\"><a href=\"#读取数据实例\" class=\"headerlink\" title=\"读取数据实例\"></a>读取数据实例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data_slave;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, addr_slave, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">read</span>(fd, data, len);</span><br></pre></td></tr></table></figure>\n\n<p>i2c-dev的读取操作，分两步：</p>\n<p>第一步，通过write()系统调用，将要读取的两个字节从设备寄存器地址，写入到i2c-dev内核驱动；</p>\n<p>第二步，通过read()系统调用，从i2c-dev内核驱动中读取长度为len的数据，并保存在data内存中；</p>\n<h4 id=\"1-5-ioctl\"><a href=\"#1-5-ioctl\" class=\"headerlink\" title=\"1.5 ioctl\"></a>1.5 ioctl</h4><h5 id=\"i2cdev-ioctl\"><a href=\"#i2cdev-ioctl\" class=\"headerlink\" title=\"i2cdev_ioctl\"></a>i2cdev_ioctl</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">i2cdev_ioctl</span><span class=\"params\">(struct file *file, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> funcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_SLAVE:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_SLAVE_FORCE:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((arg &gt; <span class=\"number\">0x3ff</span>) ||</span><br><span class=\"line\">            (((client-&gt;flags &amp; I2C_M_TEN) == <span class=\"number\">0</span>) &amp;&amp; arg &gt; <span class=\"number\">0x7f</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmd == I2C_SLAVE &amp;&amp; i2cdev_check_addr(client-&gt;adapter, arg))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EBUSY;</span><br><span class=\"line\">        client-&gt;addr = arg;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_TENBIT:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg)</span><br><span class=\"line\">            client-&gt;flags |= I2C_M_TEN;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            client-&gt;flags &amp;= ~I2C_M_TEN;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_PEC:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg)</span><br><span class=\"line\">            client-&gt;flags |= I2C_CLIENT_PEC;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            client-&gt;flags &amp;= ~I2C_CLIENT_PEC;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_FUNCS:</span><br><span class=\"line\">        funcs = i2c_get_functionality(client-&gt;adapter);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put_user(funcs, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> __user *)arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_RDWR:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_ioctl_rdwr(client, arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_SMBUS:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_ioctl_smbus(client, arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_RETRIES:</span><br><span class=\"line\">        client-&gt;adapter-&gt;retries = arg;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_TIMEOUT:</span><br><span class=\"line\">        client-&gt;adapter-&gt;timeout = msecs_to_jiffies(arg * <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOTTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"ioctl支持的功能\"><a href=\"#ioctl支持的功能\" class=\"headerlink\" title=\"ioctl支持的功能\"></a>ioctl支持的功能</h5><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>操作</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I2C_SLAVE</td>\n<td>设置从设备地址</td>\n<td>尝试设置</td>\n</tr>\n<tr>\n<td>I2C_SLAVE_FORCE</td>\n<td>强制设置从设备地址</td>\n<td>强制设置，不检查是否已经存在</td>\n</tr>\n<tr>\n<td>I2C_TENBIT</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_PEC</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_FUNCS</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_RDWR</td>\n<td>读写操作</td>\n<td>参数：i2cdev_ioctl_rdwr</td>\n</tr>\n<tr>\n<td>I2C_SMBUS</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_RETRIES</td>\n<td>设置重试次数</td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_TIMEOUT</td>\n<td>设置超时时间</td>\n<td>单位：10ms</td>\n</tr>\n</tbody></table>\n<h5 id=\"ioctl实例\"><a href=\"#ioctl实例\" class=\"headerlink\" title=\"ioctl实例\"></a>ioctl实例</h5><p>设置从设备地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, I2C_SLAVE, SLAVE_ADDR);</span><br><span class=\"line\">ioctl(fd, I2C_SLAVE_FORCE, SLAVE_ADDR);</span><br></pre></td></tr></table></figure>\n\n<p>I2C_SLAVE和I2C_SLAVE_FORCE命令都是设置从设备地址，区别是：I2C_SLAVE命令尝试设置从设备地址，如果该设备地址已经被设置，就返回失败；I2C_SLAVE_FORCE命令，不管该地址是否存在，都强制设置从设备地址；</p>\n<p>设置超时时间</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, I2C_TIMEOUT, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>超时时间单位：10ms</p>\n<p>设置重试次数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, I2C_RETRIES, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>I2C读写操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">data</span>;</span></span><br><span class=\"line\">ioctl(fd, I2C_RDWR, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;data);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>i2c-dev的读写操作是通过ioctl系统调用的I2C_RDWR命令完成，将struct i2c_rdwr_ioctl_data结构体的参数传递给内核态；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/uapi/linux/i2c-dev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> __<span class=\"title\">user</span> *<span class=\"title\">msgs</span>;</span>    <span class=\"comment\">/* pointers to i2c_msgs */</span></span><br><span class=\"line\">    __u32 nmsgs;            <span class=\"comment\">/* number of i2c_msgs */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>i2c_rdwr_ioctl_data结构体包含了指向i2c_msg结构体的消息指针msgs，和i2c_msg消息个数的nmsgs；</p>\n<p>struct i2c_msg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/uapi/linux/i2c.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> &#123;</span></span><br><span class=\"line\">    __u16 addr; <span class=\"comment\">/* slave address            */</span></span><br><span class=\"line\">    __u16 flags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RD        0x0001  <span class=\"comment\">/* read data, from slave to master */</span></span></span><br><span class=\"line\">                    <span class=\"comment\">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_TEN       0x0010  <span class=\"comment\">/* this is a ten bit chip address */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RECV_LEN      0x0400  <span class=\"comment\">/* length will be first received byte */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NO_RD_ACK     0x0800  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_IGNORE_NAK    0x1000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NOSTART       0x4000  <span class=\"comment\">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_STOP      0x8000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\">    __u16 len;      <span class=\"comment\">/* msg length               */</span></span><br><span class=\"line\">    __u8 *buf;      <span class=\"comment\">/* pointer to msg data          */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；</p>\n<p>I2C读取，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>\n<p>I2C写入，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；</p>\n<p>i2c_msg消息以数组格式定义，是为了访问连续，因为数组是连续内存存储的；</p>\n<h5 id=\"i2cdev-ioctl-rdwr\"><a href=\"#i2cdev-ioctl-rdwr\" class=\"headerlink\" title=\"i2cdev_ioctl_rdwr\"></a>i2cdev_ioctl_rdwr</h5><p>i2cdev_ioctl_rdwr()函数，处理通过ioctl()系统调用I2C_RDWR命令的操作，即对从设备读写的操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> noinline <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_ioctl_rdwr</span><span class=\"params\">(struct i2c_client *client,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">rdwr_arg</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> *<span class=\"title\">rdwr_pa</span>;</span></span><br><span class=\"line\">    u8 __user **data_ptrs;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy_from_user(&amp;rdwr_arg,</span><br><span class=\"line\">               (struct i2c_rdwr_ioctl_data __user *)arg,</span><br><span class=\"line\">               <span class=\"keyword\">sizeof</span>(rdwr_arg)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    rdwr_pa = memdup_user(rdwr_arg.msgs,</span><br><span class=\"line\">                  rdwr_arg.nmsgs * <span class=\"keyword\">sizeof</span>(struct i2c_msg));</span><br><span class=\"line\"></span><br><span class=\"line\">\tdata_ptrs = kmalloc(rdwr_arg.nmsgs * <span class=\"keyword\">sizeof</span>(u8 __user *), GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">    res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; rdwr_arg.nmsgs; i++) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;</span><br><span class=\"line\">        rdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);</span><br><span class=\"line\">\t\t...... </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重点，I2C消息的收发，都是通过i2c_transfer()函数实现的</span></span><br><span class=\"line\">    res = i2c_transfer(client-&gt;adapter, rdwr_pa, rdwr_arg.nmsgs);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res &gt;= <span class=\"number\">0</span> &amp;&amp; (rdwr_pa[i].flags &amp; I2C_M_RD)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,</span><br><span class=\"line\">                     rdwr_pa[i].len))</span><br><span class=\"line\">                res = -EFAULT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kfree(rdwr_pa[i].buf);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2cdev_ioctl_rdwr()函数，完成了消息的收发操作；具体操作：</p>\n<blockquote>\n<p>将i2c_rdwr_ioctl_data数据从用户空间拷贝到内核空间</p>\n<p>将i2c_rdwr_ioctl_data.msgs消息数组从用户空间拷贝到内核空间</p>\n<p>将i2c_rdwr_ioctl_data.msgs.buf数组从用户空间拷贝到内核空间</p>\n<p>通过i2c_transfer()函数，以i2c_msg消息格式数组和从设备通信</p>\n</blockquote>\n<h3 id=\"2-用户态实现\"><a href=\"#2-用户态实现\" class=\"headerlink\" title=\"2. 用户态实现\"></a>2. 用户态实现</h3><h4 id=\"2-1-设备节点\"><a href=\"#2-1-设备节点\" class=\"headerlink\" title=\"2.1 设备节点\"></a>2.1 设备节点</h4><p>在Linux内核中，已经注册了的I2C适配器，可以在用户空间进行访问；i2c-dev驱动对每个I2C适配器生成一个设备节点/dev/i2c-X，主设备号固定为89，X为数字，是I2C适配器的编号，从0开始，编号和设备节点的此设备号一致；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /dev/i2c-* -l</span></span><br><span class=\"line\">crw-rw----    1 root     root       89,   0 Nov  3 22:02 /dev/i2c-0</span><br><span class=\"line\">crw-rw----    1 root     root       89,   1 Nov  3 22:02 /dev/i2c-1</span><br><span class=\"line\">crw-rw----    1 root     root       89,   2 Nov  3 22:02 /dev/i2c-2</span><br><span class=\"line\">crw-rw----    1 root     root       89,   3 Nov  3 22:02 /dev/i2c-3</span><br></pre></td></tr></table></figure>\n\n\n<p>设备节点/dev/i2c-X的编号X和注册次序有关，使用前还是需要通过/sys/class/i2c-dev/来确定编号；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /sys/class/i2c-dev/ -l</span></span><br><span class=\"line\">total 0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-0 -&gt; ../../devices/platform/soc/2000000.i2c/i2c-0/i2c-dev/i2c-0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-1 -&gt; ../../devices/platform/soc/2010000.i2c/i2c-1/i2c-dev/i2c-1</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-2 -&gt; ../../devices/platform/soc/2030000.i2c/i2c-2/i2c-dev/i2c-2</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-3 -&gt; ../../devices/platform/soc/2050000.i2c/i2c-3/i2c-dev/i2c-3</span><br></pre></td></tr></table></figure>\n\n\n<p>或者</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /sys/class/i2c-dev/i2c-0/name</span></span><br><span class=\"line\">2000000.i2c</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /sys/class/i2c-dev/i2c-2/name</span></span><br><span class=\"line\">2030000.i2c</span><br></pre></td></tr></table></figure>\n\n\n<p>这些设备节点实现了文件操作接口，用户空间通过这些I2C设备节点访问I2C适配器；对I2C设备进行读写时，可以通过调用read/write或ioctl来实现；在内核态read、write、ioctl系统调用都是通过i2c_transfer()函数实现和I2C设备的通信；</p>\n<h4 id=\"2-2-open\"><a href=\"#2-2-open\" class=\"headerlink\" title=\"2.2 open\"></a>2.2 open</h4><p>用户态使用open函数打开对应的I2C设备节点/dev/i2c-X，如：/dev/i2c-2；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/i2c-2\"</span>, O_RDWR);</span><br></pre></td></tr></table></figure>\n\n\n<p>i2c-dev在open时，为设备节点建立一个i2c_client；但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；</p>\n<h4 id=\"2-3-read-write实现\"><a href=\"#2-3-read-write实现\" class=\"headerlink\" title=\"2.3 read/write实现\"></a>2.3 read/write实现</h4><h5 id=\"1）发送\"><a href=\"#1）发送\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_write_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data_wr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr = <span class=\"built_in\">malloc</span>(len + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_wr) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    data_wr[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data_wr[<span class=\"number\">2</span>], data, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);</span><br><span class=\"line\">    ioctl(fd, I2C_TIMEOUT, <span class=\"number\">1</span>);</span><br><span class=\"line\">    ioctl(fd, I2C_RETRIES, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">write</span>(fd, data_wr, len+<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, write failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, write ok, num: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_wr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_wr);</span><br><span class=\"line\">        data_wr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2）接收\"><a href=\"#2）接收\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_read_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> addr_slave[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);</span><br><span class=\"line\">    ioctl(fd, I2C_TIMEOUT, <span class=\"number\">1</span>);</span><br><span class=\"line\">    ioctl(fd, I2C_RETRIES, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    addr_slave[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    addr_slave[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">write</span>(fd, addr_slave, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, write failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">read</span>(fd, data, len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read ok, num: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"2-4-ioctl实现\"><a href=\"#2-4-ioctl实现\" class=\"headerlink\" title=\"2.4 ioctl实现\"></a>2.4 ioctl实现</h4><h5 id=\"1）发送-1\"><a href=\"#1）发送-1\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_write_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">data_wr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr.nmsgs = <span class=\"number\">1</span>;</span><br><span class=\"line\">    data_wr.msgs = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct i2c_msg) * data_wr.nmsgs);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_wr.msgs) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].addr = SLAVE_ADDR;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].len = len + <span class=\"number\">2</span>;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].buf = <span class=\"built_in\">malloc</span>(data_wr.msgs[<span class=\"number\">0</span>].len + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_wr.msgs[<span class=\"number\">0</span>].buf) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs buf malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data_wr.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">2</span>], data, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = ioctl(fd, I2C_RDWR, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;data_wr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, ioctl failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_wr.msgs[<span class=\"number\">0</span>].buf != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_wr.msgs[<span class=\"number\">0</span>].buf);</span><br><span class=\"line\">        data_wr.msgs[<span class=\"number\">0</span>].buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_wr.msgs != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_wr.msgs);</span><br><span class=\"line\">        data_wr.msgs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h5 id=\"2）接收-1\"><a href=\"#2）接收-1\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_read_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">data_rd</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_rd.nmsgs = <span class=\"number\">2</span>;</span><br><span class=\"line\">    data_rd.msgs = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct i2c_msg) * data_rd.nmsgs);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_rd.msgs) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].addr = SLAVE_ADDR;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].len = <span class=\"number\">2</span>;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].buf = <span class=\"built_in\">malloc</span>(data_rd.msgs[<span class=\"number\">0</span>].len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_rd.msgs[<span class=\"number\">0</span>].buf) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs buf malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].addr = SLAVE_ADDR;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].flags = I2C_M_RD;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].len = len;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].buf = <span class=\"built_in\">malloc</span>(data_rd.msgs[<span class=\"number\">1</span>].len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_rd.msgs[<span class=\"number\">0</span>].buf) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs buf malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(data_rd.msgs[<span class=\"number\">1</span>].buf, <span class=\"number\">0</span>, data_rd.msgs[<span class=\"number\">1</span>].len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = ioctl(fd, I2C_RDWR, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;data_rd);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, ioctl failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(data, data_rd.msgs[<span class=\"number\">1</span>].buf, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read ok, num: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_rd.msgs[<span class=\"number\">0</span>].buf != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_rd.msgs[<span class=\"number\">0</span>].buf);</span><br><span class=\"line\">        data_rd.msgs[<span class=\"number\">0</span>].buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_rd.msgs[<span class=\"number\">1</span>].buf != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_rd.msgs[<span class=\"number\">1</span>].buf);</span><br><span class=\"line\">        data_rd.msgs[<span class=\"number\">1</span>].buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_rd.msgs != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_rd.msgs);</span><br><span class=\"line\">        data_rd.msgs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"2-5-main函数\"><a href=\"#2-5-main函数\" class=\"headerlink\" title=\"2.5 main函数\"></a>2.5 main函数</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLAVE_ADDR  0x51</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arr_show</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"data[%d]: 0x%x\\n\"</span>, i, data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"xxx -r addr len\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"xxx -w addr data1 data2 ...\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short addr;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> buf[<span class=\"number\">256</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        usage();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/i2c-2\"</span>, O_RDWR);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, open failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((opt = getopt(argc, argv, <span class=\"string\">\"w:r:\"</span>)) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"optarg: %s\\n\"</span>, optarg);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"optind: %d\\n\"</span>, optind);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"argc: %d\\n\"</span>, argc);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"argv[optind]: %s\\n\"</span>, argv[optind]);</span><br><span class=\"line\"></span><br><span class=\"line\">        addr = (<span class=\"keyword\">unsigned</span> short)strtol(optarg, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"addr: %d\\n\"</span>, addr);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(opt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'w'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (len = <span class=\"number\">0</span>; optind &lt; argc; optind++, len++) &#123;</span><br><span class=\"line\">                    buf[len] = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)strtol(argv[optind], <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"len: %d\\n\"</span>, len);</span><br><span class=\"line\"></span><br><span class=\"line\">                i2c_write_bytes(fd, addr, buf, len);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'r'</span>:</span><br><span class=\"line\">                len = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)strtol(argv[optind], <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"len: %d\\n\"</span>, len);</span><br><span class=\"line\"></span><br><span class=\"line\">                i2c_read_bytes(fd, addr, buf, len);</span><br><span class=\"line\"></span><br><span class=\"line\">                arr_show(buf, len);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"Invalid parameter!\\n\"</span>);</span><br><span class=\"line\">                usage;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h3><p><a href=\"!目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>I2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；用户态I2C驱动，需要在用户态封装i2c_msg结构体消息，通过内核态i2c_transfer()函数和I2C从设备通信；</p>","more":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>I2C设备驱动，可以直接使用内核中i2c-dev.c文件提供的read/write或ioctl操作接口，在应用层通过read/write和ioctl系统调用实现对I2C设备的读写；也就是常说的I2C用户态驱动；</p>\n<p>用户态驱动，和一般的I2C设备驱动实现原理差不多，都是封装i2c_msg结构体消息，通过i2c_transfer()函数和I2C从设备通信；区别在于，一般的I2C设备驱动，在内核态封装了该功能；而用户态驱动，需要在用户态封装；可以根据实际需要选择合适的I2C驱动实现方法；</p>\n<p><img src=\"/2020/04/12/Linux-kernel%E4%B8%AD%E7%9A%84i2c-dev%E9%A9%B1%E5%8A%A8/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png\" alt=\"Linux的I2C子系统框架\"></p>\n<p>在i2c-dev.c文件中，实现了I2C适配器设备文件的功能，每个I2C适配器被分配一个设备节点；通过适配器访问设备文件节点，主设备号为89，次设备号为0～255；应用程序通过生成的设备节点/dev/i2c-X，使用open、close、read、write、ioctl系统调用进行访问；</p>\n<p>i2c-dev.c并不是针对特定的设备而设计，只是提供通用的open、close、read、write、ioctl等系统调用接口，应用程序可以通过这些系统调用接口访问挂接在适配器上的I2C设备；</p>\n<p>内核代码实现在drivers/i2c/i2c-dev.c；</p>\n<p>设备文件：/dev/i2c-X，X为序号；</p>\n<h3 id=\"1-内核态实现\"><a href=\"#1-内核态实现\" class=\"headerlink\" title=\"1. 内核态实现\"></a>1. 内核态实现</h3><p>i2c-dev驱动的内核态代码实现在drivers/i2c/i2c-dev.c文件中，如果要编译该文件，需要在make menuconfig配置内核时打开CONFIG_I2C_CHARDEV选项；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; driver&#x2F;i2c&#x2F;Makefile</span><br><span class=\"line\">obj-$(CONFIG_I2C_CHARDEV)   +&#x3D; i2c-dev.o</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_I2C_CHARDEV=y</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在drivers/i2c/i2c-dev.c文件中建立i2c-dev驱动模块；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-dev.c</span></span><br><span class=\"line\">module_init(i2c_dev_init);</span><br><span class=\"line\">module_exit(i2c_dev_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-init-exit\"><a href=\"#1-1-init-exit\" class=\"headerlink\" title=\"1.1 init/exit\"></a>1.1 init/exit</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-dev.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class</span> *<span class=\"title\">i2c_dev_class</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">i2c_dev_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册字符设备驱动</span></span><br><span class=\"line\">    res = register_chrdev_region(MKDEV(I2C_MAJOR, <span class=\"number\">0</span>), I2C_MINORS, <span class=\"string\">\"i2c\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    i2c_dev_class = class_create(THIS_MODULE, <span class=\"string\">\"i2c-dev\"</span>);</span><br><span class=\"line\">    i2c_dev_class-&gt;dev_groups = i2c_groups;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* Keep track of adapters which will be added or removed later */</span></span><br><span class=\"line\">    res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* Bind to already existing adapters right away */</span></span><br><span class=\"line\">    i2c_for_each_dev(<span class=\"literal\">NULL</span>, i2cdev_attach_adapter);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">i2c_dev_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    bus_unregister_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class=\"line\">    i2c_for_each_dev(<span class=\"literal\">NULL</span>, i2cdev_detach_adapter);</span><br><span class=\"line\">    class_destroy(i2c_dev_class);</span><br><span class=\"line\">    unregister_chrdev_region(MKDEV(I2C_MAJOR, <span class=\"number\">0</span>), I2C_MINORS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>I2C设备的主设备号固定为89；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/i2c-dev.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_MAJOR   89      <span class=\"comment\">/* Device major number      */</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_notifier_call</span><span class=\"params\">(struct notifier_block *nb, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> action,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">void</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span> = <span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_attach_adapter(dev, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_detach_adapter(dev, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">notifier_block</span> <span class=\"title\">i2cdev_notifier</span> = &#123;</span></span><br><span class=\"line\">    .notifier_call = i2cdev_notifier_call,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"1-2-attach-detach\"><a href=\"#1-2-attach-detach\" class=\"headerlink\" title=\"1.2 attach/detach\"></a>1.2 attach/detach</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_attach_adapter</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">void</span> *dummy)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_dev</span> *<span class=\"title\">i2c_dev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    adap = to_i2c_adapter(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_dev = get_free_i2c_dev(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_init(&amp;i2c_dev-&gt;cdev, &amp;i2cdev_fops);</span><br><span class=\"line\">    i2c_dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class=\"line\">    res = cdev_add(&amp;i2c_dev-&gt;cdev, MKDEV(I2C_MAJOR, adap-&gt;nr), <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* register this i2c device with the driver core */</span></span><br><span class=\"line\">    i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class=\"line\">                     MKDEV(I2C_MAJOR, adap-&gt;nr), <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                     <span class=\"string\">\"i2c-%d\"</span>, adap-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_detach_adapter</span><span class=\"params\">(struct device *dev, <span class=\"keyword\">void</span> *dummy)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_dev</span> *<span class=\"title\">i2c_dev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    adap = to_i2c_adapter(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_dev = i2c_dev_get_by_minor(adap-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_del(&amp;i2c_dev-&gt;cdev);</span><br><span class=\"line\">    put_i2c_dev(i2c_dev);</span><br><span class=\"line\">    device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>i2c-dev的字符设备操作集</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">i2cdev_fops</span> = &#123;</span></span><br><span class=\"line\">    .owner      = THIS_MODULE,</span><br><span class=\"line\">    .llseek     = no_llseek,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>       = i2cdev_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>      = i2cdev_write,</span><br><span class=\"line\">    .unlocked_ioctl = i2cdev_ioctl,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span>       = i2cdev_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span>    = i2cdev_release,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-3-open-release\"><a href=\"#1-3-open-release\" class=\"headerlink\" title=\"1.3 open/release\"></a>1.3 open/release</h4><p>i2c-dev设备节点的open、release操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_open</span><span class=\"params\">(struct inode *inode, struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> minor = iminor(inode);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    adap = i2c_get_adapter(minor);</span><br><span class=\"line\"></span><br><span class=\"line\">    client = kzalloc(<span class=\"keyword\">sizeof</span>(*client), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!client) &#123;</span><br><span class=\"line\">        i2c_put_adapter(adap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class=\"string\">\"i2c-dev %d\"</span>, adap-&gt;nr);</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;adapter = adap;</span><br><span class=\"line\">    file-&gt;private_data = client;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_release</span><span class=\"params\">(struct inode *inode, struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_put_adapter(client-&gt;adapter);</span><br><span class=\"line\">    kfree(client);</span><br><span class=\"line\">    file-&gt;private_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2c-dev在open时，为设备节点建立一个i2c_client；在之后的操作中，该i2c_client会被I2C_SLAVE或I2C_SLAVE_FORCE命令设置一个从设备地址；</p>\n<p>但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；</p>\n<h4 id=\"1-4-read-write\"><a href=\"#1-4-read-write\" class=\"headerlink\" title=\"1.4 read/write\"></a>1.4 read/write</h4><p>i2c-dev设备节点的read、write操作；</p>\n<h5 id=\"read-write\"><a href=\"#read-write\" class=\"headerlink\" title=\"read/write\"></a>read/write</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-dev.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">i2cdev_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">loff_t</span> *offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *tmp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">8192</span>)</span><br><span class=\"line\">        count = <span class=\"number\">8192</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = kmalloc(count, GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"i2c-dev: i2c-%d reading %zu bytes.\\n\"</span>,</span><br><span class=\"line\">        iminor(file_inode(file)), count);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_recv(client, tmp, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;</span><br><span class=\"line\">    kfree(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">i2cdev_write</span><span class=\"params\">(struct file *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *offset)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *tmp;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">8192</span>)</span><br><span class=\"line\">        count = <span class=\"number\">8192</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = memdup_user(buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(tmp))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PTR_ERR(tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"i2c-dev: i2c-%d writing %zu bytes.\\n\"</span>,</span><br><span class=\"line\">        iminor(file_inode(file)), count);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_send(client, tmp, count);</span><br><span class=\"line\">    kfree(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"写入数据实例\"><a href=\"#写入数据实例\" class=\"headerlink\" title=\"写入数据实例\"></a>写入数据实例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data_wr;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, data_wr, len+<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>i2c-dev的写入操作，通过write()系统调用，将带有从设备寄存器地址的数组写入到i2c-dev内核驱动，数据长度为要写入的寄存器个数加上两个字节寄存器地址；</p>\n<h5 id=\"读取数据实例\"><a href=\"#读取数据实例\" class=\"headerlink\" title=\"读取数据实例\"></a>读取数据实例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data_slave;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, addr_slave, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">read</span>(fd, data, len);</span><br></pre></td></tr></table></figure>\n\n<p>i2c-dev的读取操作，分两步：</p>\n<p>第一步，通过write()系统调用，将要读取的两个字节从设备寄存器地址，写入到i2c-dev内核驱动；</p>\n<p>第二步，通过read()系统调用，从i2c-dev内核驱动中读取长度为len的数据，并保存在data内存中；</p>\n<h4 id=\"1-5-ioctl\"><a href=\"#1-5-ioctl\" class=\"headerlink\" title=\"1.5 ioctl\"></a>1.5 ioctl</h4><h5 id=\"i2cdev-ioctl\"><a href=\"#i2cdev-ioctl\" class=\"headerlink\" title=\"i2cdev_ioctl\"></a>i2cdev_ioctl</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">i2cdev_ioctl</span><span class=\"params\">(struct file *file, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> = <span class=\"title\">file</span>-&gt;<span class=\"title\">private_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> funcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_SLAVE:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_SLAVE_FORCE:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((arg &gt; <span class=\"number\">0x3ff</span>) ||</span><br><span class=\"line\">            (((client-&gt;flags &amp; I2C_M_TEN) == <span class=\"number\">0</span>) &amp;&amp; arg &gt; <span class=\"number\">0x7f</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmd == I2C_SLAVE &amp;&amp; i2cdev_check_addr(client-&gt;adapter, arg))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EBUSY;</span><br><span class=\"line\">        client-&gt;addr = arg;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_TENBIT:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg)</span><br><span class=\"line\">            client-&gt;flags |= I2C_M_TEN;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            client-&gt;flags &amp;= ~I2C_M_TEN;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_PEC:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg)</span><br><span class=\"line\">            client-&gt;flags |= I2C_CLIENT_PEC;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            client-&gt;flags &amp;= ~I2C_CLIENT_PEC;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_FUNCS:</span><br><span class=\"line\">        funcs = i2c_get_functionality(client-&gt;adapter);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put_user(funcs, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> __user *)arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_RDWR:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_ioctl_rdwr(client, arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_SMBUS:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2cdev_ioctl_smbus(client, arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_RETRIES:</span><br><span class=\"line\">        client-&gt;adapter-&gt;retries = arg;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_TIMEOUT:</span><br><span class=\"line\">        client-&gt;adapter-&gt;timeout = msecs_to_jiffies(arg * <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOTTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"ioctl支持的功能\"><a href=\"#ioctl支持的功能\" class=\"headerlink\" title=\"ioctl支持的功能\"></a>ioctl支持的功能</h5><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>操作</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I2C_SLAVE</td>\n<td>设置从设备地址</td>\n<td>尝试设置</td>\n</tr>\n<tr>\n<td>I2C_SLAVE_FORCE</td>\n<td>强制设置从设备地址</td>\n<td>强制设置，不检查是否已经存在</td>\n</tr>\n<tr>\n<td>I2C_TENBIT</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_PEC</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_FUNCS</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_RDWR</td>\n<td>读写操作</td>\n<td>参数：i2cdev_ioctl_rdwr</td>\n</tr>\n<tr>\n<td>I2C_SMBUS</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_RETRIES</td>\n<td>设置重试次数</td>\n<td></td>\n</tr>\n<tr>\n<td>I2C_TIMEOUT</td>\n<td>设置超时时间</td>\n<td>单位：10ms</td>\n</tr>\n</tbody></table>\n<h5 id=\"ioctl实例\"><a href=\"#ioctl实例\" class=\"headerlink\" title=\"ioctl实例\"></a>ioctl实例</h5><p>设置从设备地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, I2C_SLAVE, SLAVE_ADDR);</span><br><span class=\"line\">ioctl(fd, I2C_SLAVE_FORCE, SLAVE_ADDR);</span><br></pre></td></tr></table></figure>\n\n<p>I2C_SLAVE和I2C_SLAVE_FORCE命令都是设置从设备地址，区别是：I2C_SLAVE命令尝试设置从设备地址，如果该设备地址已经被设置，就返回失败；I2C_SLAVE_FORCE命令，不管该地址是否存在，都强制设置从设备地址；</p>\n<p>设置超时时间</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, I2C_TIMEOUT, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>超时时间单位：10ms</p>\n<p>设置重试次数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, I2C_RETRIES, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>I2C读写操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">data</span>;</span></span><br><span class=\"line\">ioctl(fd, I2C_RDWR, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;data);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>i2c-dev的读写操作是通过ioctl系统调用的I2C_RDWR命令完成，将struct i2c_rdwr_ioctl_data结构体的参数传递给内核态；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/uapi/linux/i2c-dev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> __<span class=\"title\">user</span> *<span class=\"title\">msgs</span>;</span>    <span class=\"comment\">/* pointers to i2c_msgs */</span></span><br><span class=\"line\">    __u32 nmsgs;            <span class=\"comment\">/* number of i2c_msgs */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>i2c_rdwr_ioctl_data结构体包含了指向i2c_msg结构体的消息指针msgs，和i2c_msg消息个数的nmsgs；</p>\n<p>struct i2c_msg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/uapi/linux/i2c.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> &#123;</span></span><br><span class=\"line\">    __u16 addr; <span class=\"comment\">/* slave address            */</span></span><br><span class=\"line\">    __u16 flags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RD        0x0001  <span class=\"comment\">/* read data, from slave to master */</span></span></span><br><span class=\"line\">                    <span class=\"comment\">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_TEN       0x0010  <span class=\"comment\">/* this is a ten bit chip address */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RECV_LEN      0x0400  <span class=\"comment\">/* length will be first received byte */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NO_RD_ACK     0x0800  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_IGNORE_NAK    0x1000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NOSTART       0x4000  <span class=\"comment\">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_STOP      0x8000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\">    __u16 len;      <span class=\"comment\">/* msg length               */</span></span><br><span class=\"line\">    __u8 *buf;      <span class=\"comment\">/* pointer to msg data          */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；</p>\n<p>I2C读取，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>\n<p>I2C写入，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；</p>\n<p>i2c_msg消息以数组格式定义，是为了访问连续，因为数组是连续内存存储的；</p>\n<h5 id=\"i2cdev-ioctl-rdwr\"><a href=\"#i2cdev-ioctl-rdwr\" class=\"headerlink\" title=\"i2cdev_ioctl_rdwr\"></a>i2cdev_ioctl_rdwr</h5><p>i2cdev_ioctl_rdwr()函数，处理通过ioctl()系统调用I2C_RDWR命令的操作，即对从设备读写的操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> noinline <span class=\"keyword\">int</span> <span class=\"title\">i2cdev_ioctl_rdwr</span><span class=\"params\">(struct i2c_client *client,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">rdwr_arg</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> *<span class=\"title\">rdwr_pa</span>;</span></span><br><span class=\"line\">    u8 __user **data_ptrs;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy_from_user(&amp;rdwr_arg,</span><br><span class=\"line\">               (struct i2c_rdwr_ioctl_data __user *)arg,</span><br><span class=\"line\">               <span class=\"keyword\">sizeof</span>(rdwr_arg)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    rdwr_pa = memdup_user(rdwr_arg.msgs,</span><br><span class=\"line\">                  rdwr_arg.nmsgs * <span class=\"keyword\">sizeof</span>(struct i2c_msg));</span><br><span class=\"line\"></span><br><span class=\"line\">\tdata_ptrs = kmalloc(rdwr_arg.nmsgs * <span class=\"keyword\">sizeof</span>(u8 __user *), GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">    res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; rdwr_arg.nmsgs; i++) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;</span><br><span class=\"line\">        rdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);</span><br><span class=\"line\">\t\t...... </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重点，I2C消息的收发，都是通过i2c_transfer()函数实现的</span></span><br><span class=\"line\">    res = i2c_transfer(client-&gt;adapter, rdwr_pa, rdwr_arg.nmsgs);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res &gt;= <span class=\"number\">0</span> &amp;&amp; (rdwr_pa[i].flags &amp; I2C_M_RD)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,</span><br><span class=\"line\">                     rdwr_pa[i].len))</span><br><span class=\"line\">                res = -EFAULT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kfree(rdwr_pa[i].buf);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2cdev_ioctl_rdwr()函数，完成了消息的收发操作；具体操作：</p>\n<blockquote>\n<p>将i2c_rdwr_ioctl_data数据从用户空间拷贝到内核空间</p>\n<p>将i2c_rdwr_ioctl_data.msgs消息数组从用户空间拷贝到内核空间</p>\n<p>将i2c_rdwr_ioctl_data.msgs.buf数组从用户空间拷贝到内核空间</p>\n<p>通过i2c_transfer()函数，以i2c_msg消息格式数组和从设备通信</p>\n</blockquote>\n<h3 id=\"2-用户态实现\"><a href=\"#2-用户态实现\" class=\"headerlink\" title=\"2. 用户态实现\"></a>2. 用户态实现</h3><h4 id=\"2-1-设备节点\"><a href=\"#2-1-设备节点\" class=\"headerlink\" title=\"2.1 设备节点\"></a>2.1 设备节点</h4><p>在Linux内核中，已经注册了的I2C适配器，可以在用户空间进行访问；i2c-dev驱动对每个I2C适配器生成一个设备节点/dev/i2c-X，主设备号固定为89，X为数字，是I2C适配器的编号，从0开始，编号和设备节点的此设备号一致；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /dev/i2c-* -l</span></span><br><span class=\"line\">crw-rw----    1 root     root       89,   0 Nov  3 22:02 /dev/i2c-0</span><br><span class=\"line\">crw-rw----    1 root     root       89,   1 Nov  3 22:02 /dev/i2c-1</span><br><span class=\"line\">crw-rw----    1 root     root       89,   2 Nov  3 22:02 /dev/i2c-2</span><br><span class=\"line\">crw-rw----    1 root     root       89,   3 Nov  3 22:02 /dev/i2c-3</span><br></pre></td></tr></table></figure>\n\n\n<p>设备节点/dev/i2c-X的编号X和注册次序有关，使用前还是需要通过/sys/class/i2c-dev/来确定编号；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /sys/class/i2c-dev/ -l</span></span><br><span class=\"line\">total 0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-0 -&gt; ../../devices/platform/soc/2000000.i2c/i2c-0/i2c-dev/i2c-0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-1 -&gt; ../../devices/platform/soc/2010000.i2c/i2c-1/i2c-dev/i2c-1</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-2 -&gt; ../../devices/platform/soc/2030000.i2c/i2c-2/i2c-dev/i2c-2</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Nov  4 04:01 i2c-3 -&gt; ../../devices/platform/soc/2050000.i2c/i2c-3/i2c-dev/i2c-3</span><br></pre></td></tr></table></figure>\n\n\n<p>或者</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /sys/class/i2c-dev/i2c-0/name</span></span><br><span class=\"line\">2000000.i2c</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /sys/class/i2c-dev/i2c-2/name</span></span><br><span class=\"line\">2030000.i2c</span><br></pre></td></tr></table></figure>\n\n\n<p>这些设备节点实现了文件操作接口，用户空间通过这些I2C设备节点访问I2C适配器；对I2C设备进行读写时，可以通过调用read/write或ioctl来实现；在内核态read、write、ioctl系统调用都是通过i2c_transfer()函数实现和I2C设备的通信；</p>\n<h4 id=\"2-2-open\"><a href=\"#2-2-open\" class=\"headerlink\" title=\"2.2 open\"></a>2.2 open</h4><p>用户态使用open函数打开对应的I2C设备节点/dev/i2c-X，如：/dev/i2c-2；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/i2c-2\"</span>, O_RDWR);</span><br></pre></td></tr></table></figure>\n\n\n<p>i2c-dev在open时，为设备节点建立一个i2c_client；但是这个i2c_client并不加添加到i2c_adapter的client链表中，而是在用户关闭设备节点时，自动释放i2c_client；</p>\n<h4 id=\"2-3-read-write实现\"><a href=\"#2-3-read-write实现\" class=\"headerlink\" title=\"2.3 read/write实现\"></a>2.3 read/write实现</h4><h5 id=\"1）发送\"><a href=\"#1）发送\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_write_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data_wr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr = <span class=\"built_in\">malloc</span>(len + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_wr) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    data_wr[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data_wr[<span class=\"number\">2</span>], data, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);</span><br><span class=\"line\">    ioctl(fd, I2C_TIMEOUT, <span class=\"number\">1</span>);</span><br><span class=\"line\">    ioctl(fd, I2C_RETRIES, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">write</span>(fd, data_wr, len+<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, write failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, write ok, num: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_wr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_wr);</span><br><span class=\"line\">        data_wr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2）接收\"><a href=\"#2）接收\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_read_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> addr_slave[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ioctl(fd, I2C_SLAVE, SLAVE_ADDR);</span><br><span class=\"line\">    ioctl(fd, I2C_TIMEOUT, <span class=\"number\">1</span>);</span><br><span class=\"line\">    ioctl(fd, I2C_RETRIES, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    addr_slave[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    addr_slave[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">write</span>(fd, addr_slave, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, write failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">read</span>(fd, data, len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read ok, num: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"2-4-ioctl实现\"><a href=\"#2-4-ioctl实现\" class=\"headerlink\" title=\"2.4 ioctl实现\"></a>2.4 ioctl实现</h4><h5 id=\"1）发送-1\"><a href=\"#1）发送-1\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_write_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">data_wr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr.nmsgs = <span class=\"number\">1</span>;</span><br><span class=\"line\">    data_wr.msgs = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct i2c_msg) * data_wr.nmsgs);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_wr.msgs) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].addr = SLAVE_ADDR;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].len = len + <span class=\"number\">2</span>;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].buf = <span class=\"built_in\">malloc</span>(data_wr.msgs[<span class=\"number\">0</span>].len + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_wr.msgs[<span class=\"number\">0</span>].buf) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs buf malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    data_wr.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data_wr.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">2</span>], data, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = ioctl(fd, I2C_RDWR, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;data_wr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, ioctl failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_wr.msgs[<span class=\"number\">0</span>].buf != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_wr.msgs[<span class=\"number\">0</span>].buf);</span><br><span class=\"line\">        data_wr.msgs[<span class=\"number\">0</span>].buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_wr.msgs != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_wr.msgs);</span><br><span class=\"line\">        data_wr.msgs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h5 id=\"2）接收-1\"><a href=\"#2）接收-1\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_read_bytes</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">unsigned</span> short addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_rdwr_ioctl_data</span> <span class=\"title\">data_rd</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_rd.nmsgs = <span class=\"number\">2</span>;</span><br><span class=\"line\">    data_rd.msgs = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct i2c_msg) * data_rd.nmsgs);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_rd.msgs) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].addr = SLAVE_ADDR;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].len = <span class=\"number\">2</span>;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].buf = <span class=\"built_in\">malloc</span>(data_rd.msgs[<span class=\"number\">0</span>].len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_rd.msgs[<span class=\"number\">0</span>].buf) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs buf malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">0</span>] = addr / <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">0</span>].buf[<span class=\"number\">1</span>] = addr % <span class=\"number\">0xff</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].addr = SLAVE_ADDR;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].flags = I2C_M_RD;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].len = len;</span><br><span class=\"line\">    data_rd.msgs[<span class=\"number\">1</span>].buf = <span class=\"built_in\">malloc</span>(data_rd.msgs[<span class=\"number\">1</span>].len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_rd.msgs[<span class=\"number\">0</span>].buf) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, msgs buf malloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(data_rd.msgs[<span class=\"number\">1</span>].buf, <span class=\"number\">0</span>, data_rd.msgs[<span class=\"number\">1</span>].len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = ioctl(fd, I2C_RDWR, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;data_rd);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, ioctl failed, ret: 0x%x\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(data, data_rd.msgs[<span class=\"number\">1</span>].buf, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read ok, num: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_rd.msgs[<span class=\"number\">0</span>].buf != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_rd.msgs[<span class=\"number\">0</span>].buf);</span><br><span class=\"line\">        data_rd.msgs[<span class=\"number\">0</span>].buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_rd.msgs[<span class=\"number\">1</span>].buf != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_rd.msgs[<span class=\"number\">1</span>].buf);</span><br><span class=\"line\">        data_rd.msgs[<span class=\"number\">1</span>].buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data_rd.msgs != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(data_rd.msgs);</span><br><span class=\"line\">        data_rd.msgs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"2-5-main函数\"><a href=\"#2-5-main函数\" class=\"headerlink\" title=\"2.5 main函数\"></a>2.5 main函数</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLAVE_ADDR  0x51</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arr_show</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"data[%d]: 0x%x\\n\"</span>, i, data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"xxx -r addr len\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"xxx -w addr data1 data2 ...\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short addr;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> buf[<span class=\"number\">256</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        usage();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/i2c-2\"</span>, O_RDWR);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, open failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((opt = getopt(argc, argv, <span class=\"string\">\"w:r:\"</span>)) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"optarg: %s\\n\"</span>, optarg);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"optind: %d\\n\"</span>, optind);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"argc: %d\\n\"</span>, argc);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"argv[optind]: %s\\n\"</span>, argv[optind]);</span><br><span class=\"line\"></span><br><span class=\"line\">        addr = (<span class=\"keyword\">unsigned</span> short)strtol(optarg, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"addr: %d\\n\"</span>, addr);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(opt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'w'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (len = <span class=\"number\">0</span>; optind &lt; argc; optind++, len++) &#123;</span><br><span class=\"line\">                    buf[len] = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)strtol(argv[optind], <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"len: %d\\n\"</span>, len);</span><br><span class=\"line\"></span><br><span class=\"line\">                i2c_write_bytes(fd, addr, buf, len);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'r'</span>:</span><br><span class=\"line\">                len = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)strtol(argv[optind], <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"len: %d\\n\"</span>, len);</span><br><span class=\"line\"></span><br><span class=\"line\">                i2c_read_bytes(fd, addr, buf, len);</span><br><span class=\"line\"></span><br><span class=\"line\">                arr_show(buf, len);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"Invalid parameter!\\n\"</span>);</span><br><span class=\"line\">                usage;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h3><p><a href=\"!目录\">回到目录</a></p>"},{"title":"Linux内核启动流程-基于ARM64","date":"2020-04-19T15:13:03.000Z","_content":"\n\n\n以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n\n[TOC]\n\n\n### 0. 简述\n\n\n以arm64为例，讲述Linux在ARM64架构设备上的系统启动流程；\n\n\n上电启动，系统启动要经过uboot、kernel、filesystem、ADM几个过程，如下：\n\n\n```mermaid\ngraph LR\n\tuboot(uboot)-->kernel(kernel)\n\t-->filesystem(filesystem)\n\t-->Software(Software)\n```\n\n\n\n\n\n\n在大多数系统中，内核镜像在uboot阶段被加载到内存中，并获得控制权开始内核的启动流程；\n\n\n```mermaid\ngraph LR\n\tuboot(uboot)-->kernel(kernel)\n```\n\n\n\n\nLinux内核版本：\n\n\n```shell\nlinux-4.9.115\n# uname -a\nLinux vexpress 4.9.115 #2 SMP Wed Apr 1 22:49:35 CST 2020 aarch64 GNU/Linux\n```\n\n**说明**：由于Linux内核系统庞大繁杂，要想把内核启动中的每个细节都描述清楚，基本上不可能，更何况作者能力水平也达不到；因此，就在追踪内核启动流程代码的同时，只描述比较重要的几个部分；可以在以后的工作、学习中，随着水平的提高，不断地增加内容；\n\n\n\n\n### 1. 目标文件\n\n\n\n\n内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照vmlinux.lds设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序；\n\n\n\n\n#### 1.1 vmlinux.lds\n\n\nvmlinux.lds文件是在内核编译时生成的，是被禁止编辑的；vmlinux.lds文件是在编译时，由vmlinux.lds.S文件对链接器ld的输出进行排序后生成；vmlinux.lds.S是用来对输出文件中的段进行排序，并定义相关的符号名；\n\n\n```\narch/arm64/kernel/vmlinux.lds.S\n```\n\n\n在项目中通过make时指定的参数-O，将内核编译生成的所有目标文件，包括vmlinux.lds文件重定向输出到以下目录：\n\n\n```shell\narch/arm64/kernel/vmlinux.lds\n```\n\n\nvmlinux.lds文件是链接脚本，在内核编译时，作为Makefile的链接器脚本，参与链接生成内核映像vmlinux；\n\n\n总之：vmlinux是按照vmlinux.lds链接生成的，而vmlinux.lds是由vmlinux.lds.S生成的；\n\n\n```C\n// arch/arm64/kernel/vmlinux.lds\nOUTPUT_ARCH(aarch64)\t// 指定架构为aarch64\nENTRY(_text)\t\t\t// 定义入口为_text\njiffies = jiffies_64;\t// 定义为64位计数器\nSECTIONS\n{\n    ......\n    // 指定链接地址\n    . = ((((0xffffffffffffffff - (1 << (48)) + 1) + (0)) + (0x08000000))) + 0x00080000;\n    ......\n}\n```\n\n\n\n\n关于段的信息\n\n> text段，代码段，用来存放程序执行代码的一块内存区域；大小在程序运行前确定；\n>\n> data段，数据段，用来存放程序中已初始化的全局变量的内存区域；数据段属于静态内存分配；\n>\n> bss段，用来存放程序中未初始化的全局变量和静态变量的一块内存区域；属于静态内存分配；\n>\n> init段，Linux定义的一种初始化过程中才能用到的段；初始化完成后，该段内存会被释放；\n\n\n\n关于地址的信息\n\n> 加载地址：程序中指令和变量等加载到RAM上的地址；\n>\n> 运行地址：CPU执行一条程序的指令时的执行地址，即PC寄存器的值；就是要寻址到一个指令或变量所使用的地址；\n>\n> 链接地址：链接过程中链接器为指令和变量分配的地址；\n\n\n\n#### 1.2 内核映像\n\n\nvmlinux是未压缩的内核，是生成的纯内核二进制文件，具有用户定义的所有内核组件，但是这个vmlinux二进制文件是无法启动系统的；为了将Linux内核映像加载到内存并处于可执行状态，内核构建系统使用objcopy命令清除不必要的节区，压缩ELF格式的vmlinux，通过引导程序加载项和链接，生成可启动的最终的二进制文件zImage；\n\n\nvmlinux通过gzip压缩成piggy.o，和head.o、misc.o链接生成zImage二进制文件；\n\n\nvmlinuz是vmlinux的压缩文件\n\n\nzImage默认的压缩内核映像文件，压缩vmlinux，加上一段解压启动代码，压缩而成；\n\n\nuImage是u-boot使用bootm命令引导的Linux压缩内核映像文件格式，是使用mkimage工具对普通的压缩内核映像文件（zImage）加工而成；\n\n\nuImage是uboot专用的内核映像文件，是在zImage之前加上一个长度为64字节的“头”，说明内核的版本、加载位置、生成时间、大小等信息；在地址0x40之后的部分，和zImage一样；其大小比zImage大64字节；\n\n\n\n\n#### 1.3 设备树文件\n\n\nLinux内核从3.x版本开始引入设备树的概念，用于实现驱动代码与设备信息分离；设备树出现之前，所有关于设备的具体信息都写在驱动中，外围设备变化，驱动代码就要跟着修改甚至是重写；引入设备树之后，驱动代码只负责处理驱动代码的逻辑，而关于设备的具体信息存放到设备树文件中，这样硬件接口信息变化时，只需要修改设备树文件信息，不需要修改驱动代码就可以；\n\n\n一般情况下，在编译设备树之前，先在scripts/dtc/目录下，编译生成dtc工具scripts/dtc/dtc，再使用生成的dtc工具编译设备树源码，生成设备树文件；设备树源码和目标文件在arch/arm64/boot/dts/freescale/目录；\n\n\n在Lx2160板项目中，目标文件会被重定向输出到target目录；\n\n\n\n\n具体的设备树文件的加载、解析过程，会在下文setup_arch部分描述；\n\n\n\n\n### 2. 内核启动第一阶段\n\n\n\n\nLinux内核启动第一阶段，也就是我们常说的汇编阶段，也就是stext函数的实现内容；这部分主要完成的工作：CPU ID检查，machine ID检查，创建初始化页表，设置C代码运行环境，跳转到内核第一个真正的C函数start_kernel执行；\n\n\n\n\n设置为SVC模式，关闭所有中断\n\n\n获取CPUID，提取相应的proc info\n\n\n验证tags或dtb\n\n\n创建页表项\n\n\n\n\n\n\n\n\nhead.S文件中，\n\n\n校验启动合法性\n\n\n建立段式映射的页表并开启MMU\n\n\n构建C运行环境，跳入C阶段\n\n\n\n\n\n\n\n\n#### 2.1 内核启动入口点\n\n\n内核是一个庞大的系统，通过vmlinux反向追踪启动入口点\n\n\nLx2160le板的交叉编译工具链：\n\n\n```shell\nCROSS_COMPILE=aarch64-linux-gnu-\n```\n\n\n\n\n通过对目标文件vmlinux的反向追溯，找到Linux执行的入口；\n\n\n使用readelf命令可以查看vmlinux的入口地址为：0xffff000008080000\n\n\n```shell\n# readelf -h vmlinux\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           AArch64\n  Version:                           0x1\n  Entry point address:               0xffff000008080000\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          267014976 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         4\n  Size of section headers:           64 (bytes)\n  Number of section headers:         39\n  Section header string table index: 36\n```\n\n\n\n\n这个入口地址是怎么来的，对应内核代码中的哪个部分，可以通过反汇编来分析；\n\n\n```shell\n# aarch64-linux-gnu-objdump -dxh vmlinux > vmlinux.s\n```\n\n\n\n\n在得到的汇编文件vmlinux.s中查找入口地址：0xffff000008080000\n\n\n```c\nstart address 0xffff000008080000\n\nDisassembly of section .head.text:\n\nffff000008080000 <_text>:\nffff000008080000:       91005a4d        add     x13, x18, #0x16\nffff000008080004:       14437fff        b       ffff000009160000 <stext>\n```\n\n\n\n\n可以得到，Linux入口的第一条指令为：add     x13, x18, #0x16；对应的符号是：.head.text  _text；\n\n\n而.head.text段，通过include/linux/init.h文件中的宏定义__HEAD来表示：\n\n\n```C\n/* For assembly routines */\n#define __HEAD      .section    \".head.text\",\"ax\"\t// \"ax\"表示所在段区域有可执行权限\n#define __INIT      .section    \".init.text\",\"ax\"\n```\n\n\n\n\n内核启动的入口点，在arch/arm64/kernel/head.S文件中；\n\n\n```c\n    __HEAD\n_head:\n    /*\n     * DO NOT MODIFY. Image header expected by Linux boot-loaders.\n     */\n#ifdef CONFIG_EFI\n    /*\n     * This add instruction has no meaningful effect except that\n     * its opcode forms the magic \"MZ\" signature required by UEFI.\n     */\n    add x13, x18, #0x16\n    b   stext\n#else\n    b   stext               // branch to kernel start, magic\n    .long   0               // reserved\n#endif\n```\n\n\n到此，已经找到，目标文件vmlinux的入口是arch/arm64/kernel/head.S文件中的__HEAD，在执行完第一条语句（add x13, x18, #0x16）之后，跳转到stext函数执行（b   stext）；所以，加载vmlinux后，第一个运行的函数是stext；\n\n\n\n\n#### 2.2 stext函数\n\n\n启动过程中的汇编阶段，是从arch/arm64/kernel/head.S文件开始，执行的起点是stext函数，入口函数是通过vmlinux.lds链接而成，在head.S中ENTRY(stext)指定；\n\n在汇编代码中，宏定义ENTRY和ENDPROC是成对出现的，表示定义的一个函数，同时也要指明当前代码所在的段，如：__INIT；\n\n\n\n\n```c\n// arch/arm64/kernel/head.S\n#define __INIT      .section    \".init.text\",\"ax\"\n\n\t__INIT\nENTRY(stext)\n\t......\nENDPROC(stext)\n```\n\n\n\n\n内核启动的必要条件：MMU关闭，D-cache关闭，x0是传递给FDT blob的物理地址；\n\n\n```c\n * The requirements are:\n *   MMU = off, D-cache = off, I-cache = on or off,\n *   x0 = physical address to the FDT blob.\n```\n\n\n\nstext函数开始执行；\n\n\n```c\n// arch/arm64/kernel/head.S\n\t__INIT\nENTRY(stext)\n    bl  preserve_boot_args\t// Preserve the arguments passed by the bootloader in x0 ... x3\n    bl  el2_setup           // Drop to EL1, w0=cpu_boot_mode\n    adrp    x23, __PHYS_OFFSET\n    and x23, x23, MIN_KIMG_ALIGN - 1    // KASLR offset, defaults to 0\n    bl  set_cpu_boot_mode_flag\n    bl  __create_page_tables\n\n  /*\n   * The following calls CPU setup code, see arch/arm64/mm/proc.S for\n   * details.\n   * On return, the CPU will be ready for the MMU to be turned on and\n   * the TCR will have been set.\n   */\n     bl  __cpu_setup         // initialise processor\n     b   __primary_switch\nENDPROC(stext)\n```\n\n\n\n##### 1. preserve_boot_args\n\n\n保存从bootloader传递过来的x0 ~ x3参数；\n\n\n```c\n// arch/arm64/kernel/head.S\npreserve_boot_args:\n    mov x21, x0\t\t\t\t// 将dtb的地址暂存在x21寄存器，释放出x0使用\n    adr_l   x0, boot_args\t// x0保存boot_args变量的地址\n    stp x21, x1, [x0]\t\t// 将x0、x1的值保存到boot_args[0]、boot_args[1]\n    stp x2, x3, [x0, #16]\t// 将x2、x3的值保存到boot_args[2]、boot_args[3]\n\n    dmb sy              // needed before dc ivac with\n                        // MMU off\n\n    add x1, x0, #0x20\t\t// x0、x1作为nval_cache_range函数的参数\n    b   __inval_cache_range     // tail call\nENDPROC(preserve_boot_args)\n```\n\n\n\n\n##### 2. el2_setup\n\n\n到此，CPU处于哪个exception level？根据ARM64 boot protocol，CPU处于EL2（推荐）或者secure EL1；如果处于EL2，需要将CPU退回到EL1；此部分还没有搞明白，暂时先跳过；\n\n\n```c\n// arch/arm64/kernel/head.S\nENTRY(el2_setup)\n\t......\nENDPROC(el2_setup)\n```\n\n\n\n\n##### 3. set_cpu_boot_mode_flag\n\n\nset_cpu_boot_mode_flag函数，用来设置__boot_cpu_mode flag；需要一个前提条件：w20寄存器中保存了CPU启动时的异常等级（Exception level）；\n\n\n```c\n// arch/arm64/kernel/head.S\nset_cpu_boot_mode_flag:\n    adr_l   x1, __boot_cpu_mode\n    cmp w0, #BOOT_CPU_MODE_EL2\n    b.ne    1f\n    add x1, x1, #4\n1:  str w0, [x1]            // This CPU has booted in EL1\n    dmb sy\n    dc  ivac, x1            // Invalidate potentially stale cache line\n    ret\nENDPROC(set_cpu_boot_mode_flag)\n```\n\n\n由于系统启动之后，需要了解CPU启动时候的Exception level，因此需要一个全局变量__boot_cpu_mode来保存启动时的CPU mode；\n\n\n全局变量__boot_cpu_mode定义：\n\n\n```c\nENTRY(__boot_cpu_mode)\n    .long   BOOT_CPU_MODE_EL2\n    .long   BOOT_CPU_MODE_EL1\n```\n\n\n\n\n##### 4. __create_page_tables\n\n\n建立页表初始化的过程；\n\n\n```c\n// arch/arm64/kernel/head.S\n__create_page_tables:\n\t......\nENDPROC(__create_page_tables)\n```\n\n\n\n\n##### 5. __cpu_setup\n\n\nCPU的初始化设置；\n\n\n```c\n// arch/arm64/mm/proc.S\nENTRY(__cpu_setup)\n\t......\nENDPROC(__cpu_setup)\n```\n\n\n主要的内容包括：\n\n> ```\n> 1、cache和TLB的处理\n> 2、Memory attributes lookup table的创建\n> 3、SCTLR_EL1、TCR_EL1的设定\n> ```\n\n\n\n##### 6. __primary_switch\n\n\n主要工作是为打开MMU做准备；\n\n\n```c\n// arch/arm64/kernel/head.S\n__primary_switch:\n\t......\n\tbl  __enable_mmu\t\t\t// 开启MMU\n\t......\n    ldr x8, =__primary_switched\n    adrp    x0, __PHYS_OFFSET\n    blr x8\nENDPROC(__primary_switch)\n```\n\n\n在函数中通过\\_\\_enable\\_mmu函数来开启MMU，并调用\\_\\_primary_switched函数；\n\n\n```c\n// arch/arm64/kernel/head.S\n__primary_switched:\n\t......\n    b   start_kernel\nENDPROC(__primary_switched)\n```\n\n\n在__primary_switched函数中，进行一些C环境的准备，并在最后，调用执行start_kernel函数，内核的启动进入到C语言环境阶段；\n\n\n```mermaid\ngraph TB\n    subgraph 入口函数\n    A_Explain(保存boot参数)\n    -->\n    B_Explain(EL2设置)\n    -->\n    C_Explain(设置CPU启动模式flag)\n    -->\n    D_Explain(创建页表)\n    -->\n    E_Explain(CPU配置)\n    -->\n    F_Explain(主要的转换操作)\n    -->\n    G_Explain(运行start_kernel函数)\n    end\n \n    subgraph stext\n    A_func(preserve_boot_args)\n    -->\n    B_func(el2_setup)\n    -->\n    C_func(set_cpu_boot_mode_flag)\n    -->\n    D_func(__create_page_tables)\n    -->\n    E_func(__cpu_setup)\n    -->\n    F_func(__primary_switch)\n    -->\n    G_func(start_kernel)\n    end\n```\n\n\n\n\n#### 2.3 参考资料\n\n\nhttps://blog.csdn.net/xiaohua0877/article/details/78615776\n\n\nhttp://www.wowotech.net/sort/armv8a_arch\n\n\n\n\n### 3. 内核启动第二阶段\n\n\nLinux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；\n\n\n```mermaid\ngraph TB\n\tA(start_kernel)-->B(一系列的初始化操作)\n\tsubgraph start_kernel\n\tB(一系列的初始化操作)\n\t-->\n\tC(setup_arch)\n\t-->\n\tD(一系列的初始化操作)\n\t-->\n\tE(rest_init)\n\tend\n```\n\n\n\n\n#### 3.1 start_kernel\n\n\nstart_kernel()函数在init/main.c文件中，主要完成Linux子系统的初始化工作；此部分初始化内容繁多，暂时先略过，此处省略好多字；\n\n\n```c\n// init/main.c\nasmlinkage __visible void __init start_kernel(void)\n{\n\t......\n}\n```\n\n\n\n\n```c\npr_notice(\"%s\", linux_banner);\n```\n\n\n\n\n```c\nconst char linux_banner[] =\n    \"Linux version \" UTS_RELEASE \" (\" LINUX_COMPILE_BY \"@\"\n    LINUX_COMPILE_HOST \") (\" LINUX_COMPILER \") \" UTS_VERSION \"\\n\";\n```\n\n\n执行的效果是，在内核启动初期，打印内核版本号和构建信息：\n\n\n```shell\nLinux version 4.9.115 (root@localhost.localdomain) (gcc version 6.2.0 20170314 ZTE Embsys-TSP V3.06.40 (GCC) ) #2 SMP PREEMPT Tue Mar 10 11:21:00 CST 2020\n```\n\n\n\n\n#### 3.2 setup_arch\n\n\nsetup_arch()函数，是体系结构相关的，该函数根据处理器、硬件平台具体型号设置系统；及解析系统命令行，系统内存管理初始化，统计并注册系统各种资源等；每个体系都有自己的setup_arch()函数，是由顶层Makefile中的ARCH变量定义的，我们使用的是ARCH=arm64，因此，这里的setup_arch()函数，也是arm64的体系结构相关的；参数是未被初始化的内部变量command_line；\n\n\n```c\n// init/main.c\nasmlinkage __visible void __init start_kernel(void)\n{\n\t......\n\tsetup_arch(&command_line);\n\t......\n}\n```\n\n\n\n\nsetup_arch()函数中的初始化内容比较多，目前**只对设备树相关的部分进行简要描述**；\n\n\n```c\n// arch/arm64/kernel/setup.c\nvoid __init setup_arch(char **cmdline_p)\n{\n    ......\n\tsetup_machine_fdt(__fdt_pointer);\n    ......\n    if (acpi_disabled)\n        unflatten_device_tree();\n    ......\n}\n```\n\n\n\n\n```mermaid\ngraph LR\n\tA(setup_arch)-->B(加载设备树)\n\tB(加载设备树)-->C(setup_machine_fdt)\n\tB(加载设备树)-->D(unflatten_device_tree)\n```\n\n\n\n\n##### 1. setup_machine_fdt\n\n\nsetup_machine_fdt()函数的输入参数是设备树（DTB）首地址；uboot启动程序把设备树读取到内存中，之后在启动内核的同时，将设备树首地址传给内核，setup\\_machine\\_fdt()函数的参数\\_\\_fdt_pointer就是uboot传给内核的设备树地址；函数中的fdt(flat device tree)表示，设备树在内存中是在一块连续地址存储的；\n\n\n```c\n// arch/arm64/kernel/setup.c\nstatic void __init setup_machine_fdt(phys_addr_t dt_phys)\n{\n    void *dt_virt = fixmap_remap_fdt(dt_phys);\n\n    if (!dt_virt || !early_init_dt_scan(dt_virt)) {\n\t\t......\n        while (true)\n            cpu_relax();\n    }\n\n    dump_stack_set_arch_desc(\"%s (DT)\", of_flat_dt_get_machine_name());\n}\n```\n\n\n```c\n// arch/arm64/kernel/setup.c\nphys_addr_t __fdt_pointer __initdata;\n```\n\n\n全局变量\\_\\_fdt_pointer指向内存中的DTB，是设备树的物理地址；这个物理地址是由bootloader传递给内核的，在内核中使用，是需要转换为虚拟地址才能访问，而这个转换，由fixmap_remap_fdt()函数来完成；\n\n\n\n\n```c\n// drivers/of/fdt.c\nbool __init early_init_dt_scan(void *params)\n{\n    bool status;\n\n    status = early_init_dt_verify(params);\n    if (!status)\n        return false;\n\n    early_init_dt_scan_nodes();\n    return true;\n}\n```\n\n\n接下来调用的early_init_dt_scan()函数，通过进一步调用early_init_dt_verify()函数来检查DTB数据是否完整，经过内存映射之后，就可以直接访问DTB中的内容了；\n\n\n\n\n##### 2. unflatten_device_tree\n\n\nunflatten_device_tree()函数完成对设备树的解析，所做的工作是将设备树各节点转换成相应的struct device_node结构体；\n\n\n```c\n// drivers/of/fdt.c\nvoid __init unflatten_device_tree(void)\n{\n    __unflatten_device_tree(initial_boot_params, NULL, &of_root,\n                early_init_dt_alloc_memory_arch, false);\n\n    /* Get pointer to \"/chosen\" and \"/aliases\" nodes for use everywhere */\n    of_alias_scan(early_init_dt_alloc_memory_arch);\n}\n```\n\n\n\n\n```c\n// drivers/of/base.c\nstruct device_node *of_root;\n```\n\n\n\n\n```c\nstatic void *__unflatten_device_tree(const void *blob,\n                     struct device_node *dad,\n                     struct device_node **mynodes,\n                     void *(*dt_alloc)(u64 size, u64 align),\n                     bool detached)\n{\n\t......\n    /* First pass, scan for size */\n\tsize = unflatten_dt_nodes(blob, NULL, dad, NULL);\n\t......\n    /* Allocate memory for the expanded device tree */\n\tmem = dt_alloc(size + 4, __alignof__(struct device_node));\n\t......\n    /* Second pass, do actual unflattening */\n\tunflatten_dt_nodes(blob, mem, dad, mynodes);\n\t......\n}\n```\n\n\n\\_\\_unflatten\\_device\\_tree()函数中主要的解析函数是unflatten_dt_nodes()，在这里被调用了两次，第一次是扫描出设备树转换成struct device_node所需要的空间，然后系统申请内存空间，第二次是进行真正解析的工作；\n\n\n```c\n// drivers/of/fdt.c\nstatic int unflatten_dt_nodes(const void *blob,\n                  void *mem,\n                  struct device_node *dad,\n                  struct device_node **nodepp)\n{\n\t......\n\tfor (offset = 0;\n         offset >= 0 && depth >= initial_depth;\n         offset = fdt_next_node(blob, offset, &depth)) {\n\t\tfpsizes[depth+1] = populate_node(blob, offset, &mem,\n                         nps[depth],\n                         fpsizes[depth],\n                         &nps[depth+1], dryrun);\n\t\t......\n\t}\n\t......\n}\n```\n\n\nunflatten_dt_nodes()函数，就是从根节点开始，对子节点依次调用populate_node()，为当前节点申请内存空间，并对node进行初始化；并根据读取到的dtb中的内容，按节点进行填充；设备树由dtb二进制文件，经过解析为每一个节点生成一个struct device_node结构体，就完成了dtb的加载过程；\n\n\n\n\n#### 3.3 console_init\n\n\nconsole_init()函数执行控制台的初始化操作；在console_init()函数执行之前的printk打印信息，需要在console_init()函数执行之后才能打印出来；因为在console_inie()函数之前，printk的打印信息都保存在一个缓存区中，等到console_init()函数执行之后，控制台被初始化完成，就可以将缓冲区中的内容打印出来；\n\n\n\n\n```c\n// drivers/tty/tty_io.c\nvoid __init console_init(void)\n{\n    initcall_t *call;\n\n    /* Setup the default TTY line discipline. */\n    n_tty_init();\n\n    /*\n     * set up the console device so that later boot sequences can\n     * inform about problems etc..\n     */\n    call = __con_initcall_start;\n    while (call < __con_initcall_end) {\n        (*call)();\n        call++;\n    }\n}\n```\n\n\n在console_init()函数中，指定initcall_t类型的函数指针，从\\_\\_con\\_initcall\\_start开始，到\\_\\_con\\_initcall\\_end结束，遍历这个范围之间的函数，依次运行；\n\n\n\\_\\_con\\_initcall\\_start和\\_\\_con\\_initcall\\_end这两个地址，可以在vmlinux.lds文件找到；如下：\n\n\n```c\n// vmlinux.lds\n__con_initcall_start = .;\nKEEP(*(.con_initcall.init))\n__con_initcall_end = .;\n```\n\n\n这两个地址之间，存放的是.con_initcall.init段的内容；\n\n\n```c\n// include/linux/init.h\n#define console_initcall(fn)                    \\\n    static initcall_t __initcall_##fn           \\\n    __used __section(.con_initcall.init) = fn\n```\n\n\n通过宏定义console_initcall(fn)，将initcall_t类型的函数指针fn，存放到.con_initcall.init段；之后在调用console_init()函数时，就会通过遍历_\\_con\\_initcall\\_start到\\_\\_con\\_initcall\\_end的地址区域，依次运行存放在其中的函数fn；\n\n\n```c\n// drivers/tty/serial/8250/8250_core.c\nconsole_initcall(univ8250_console_init);\n```\n\n#### 3.4 rest_init\n\n\n在进行一系列与内核相关的初始化后，在rest_init()函数中，启动了三个进程：idle、kernel_init、kthreadd，来开始操作系统的正式运行；\n\n\n```c\n// init/main.c\nrest_init()\n    kernel_thread(kernel_init, NULL, CLONE_FS);\t// 创建kernel_init内核线程，即init，1号进程；\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\t// 创建kthreadd内核线程，2号进程，用于管理和调度其他内核线程；\n    ......\n    init_idle_bootup_task(current);\t// 设置当前进程（0号进程）为idle进程；\n    schedule_preempt_disabled();\t// 调用进程调度，并禁止内核抢占；\n    /* Call into cpu_idle with preempt disabled */\n    cpu_startup_entry(CPUHP_ONLINE);\t// 0号进程完成kernel初始化工作，进入idle循环，编程idle进程；\n```\n\n\n```mermaid\ngraph TB\n\tA(rest_init)-->B(idle进程)\n\tA(rest_init)-->C(kernel_init进程)\n\tA(rest_init)-->D(kthreadd进程)\n```\n\n\n\n> - idle进程是操作系统的空闲进程，CPU空闲的时候会去运行它；\n> - kernel_init进程最开始只是一个函数，作为进程被启动，init进程是永远存在的，PID是1；\n> - kthreadd是内核守护进程，始终运行在内核空间，负责所有内核线程的调度和管理，PID是2；\n\n也就是说，系统启动后的第一个进程是idle，idle进程是唯一没有通过kernel_thread或fork产生的进程；idle创建了kernel_init进程作为1号进程，创建了kthreadd进程作为2号进程；\n\n\n```mermaid\ngraph TB\n\tA(idle进程)-->B(kernel_init进程)\n\tA(idle进程)-->C(kthreadd进程)\n```\n\n\n\n\n#### 3.5 kernel_init\n\n\nkernel_init()函数在创建kernel_init进程时，作为进程被启动；虽然kernel_init最开始只是一个函数，但是在最后，通过系统调用，将读取根文件系统下的init进程，完成从内核态到用户态的转变，转变为用户态的1号进程；这个init进程是所有用户态进程的父进程，产生了大量的子进程；init进程是1号进程，是永远存在的；\n\n\n```mermaid\ngraph TB\n\tA(kernel_init)-->B(kernel_init_freeable)\n\tsubgraph kernel_init\n        B(kernel_init_freeable)\n        -->C(free_initmem)\n        -->D(ramdisk_execute_command)\n        -->E(execute_command)\n        -->F(用户空间init进程)\n\tend\n```\n\n\n\n\n#### 3.6 kernel_init_freeable\n\n\n等待内核线程kthreadd创建完成、注册内核驱动模块do_basic_setup、启动默认控制台/dev/console\n\n\n完成设备初始化以及模块加载工作；\n\n\n```mermaid\ngraph TB\n\tA(kernel_init_freeable)-->B(wait_for_completion)\n\tsubgraph kernel_init_freeable\n        B(wait_for_completion)\n        -->C(set_mems_allowed)\n        -->D(do_basic_setup)\n        -->E(open console)\t\n        -->X(ramdisk_execute_command)\n\tend\n```\n\n\n\n\n##### 3.6.1 wait_for_completion\n\n\n```c\n// init/main.c\nkernel_init_freeable()\n{\n\twait_for_completion(&kthreadd_done);\n}\n```\n\n\n使用完成量等待kthreadd_done，等待内核线程kthreadd创建完成；虽然kernel_init进程先创建，但是要在kthreadd线程创建完成才能执行；在threadd线程创建完成后才唤醒完成量，开始kernel_init进程的工作；\n\n\n\n\n##### 3.6.2 do_basic_setup\n\n\n```mermaid\ngraph TB\n\tA(do_basic_setup)-->C(driver_init)\n\tsubgraph do_basic_setup\n\tC(driver_init)\n\t-->D(do_initcalls)\n\tend\n```\n\n\n\n\n\n\n\n###### 2. driver_init\n\n\ndriver_init()函数完成与驱动程序相关的所有子系统的构建，实现了Linux设备驱动的一个整体框架，但是它只是建立了目录结构，是设备驱动程序初始化的第一部分，具体驱动模块的装载在do_initcalls()函数中实现；\n\n\n```c\n// drivers/base/init.c\nvoid __init driver_init(void)\n{\n    /* These are the core pieces */\n    devtmpfs_init();\t// 注册devtmpfs文件系统，启动devtmpfsd进程\n    devices_init();\t\t// 初始化驱动模型中的部分子系统，/dev/devices, /dev/char, /dev/block\n    buses_init();\t\t// 初始化驱动模型中的bus子系统\n    classes_init();\t\t// 初始化驱动模型中的class子系统\n    firmware_init();\t// 初始化驱动模型中的firmware子系统\n    hypervisor_init();\t// 初始化驱动模型中的hypervisor子系统\n\n    /* These are also core pieces, but must come after the\n     * core core pieces.\n     */\n    platform_bus_init();\t// 初始化驱动模型中的bus/platform子系统，此节点是所有platform设备和驱动的总线模型；所有platform设备和驱动都会挂载到这个总线上；\n    cpu_dev_init();\t\t// 初始化驱动模型中的device/system/cpu子系统，该节点包含CPU相关属性；\n    memory_dev_init();\t// 初始化驱动模型中的device/system/memory子系统，该节点包含了内存相关属性；\n    container_dev_init();\t// 初始化系统总线类型为容器；\n    of_core_init();\t\t// 初始化创建，访问和结时设备树的过程；\n}\n```\n\n\n\n\n###### 3. do_initcalls\n\n\n\n\n编译器在编译内核时，将一系列模块初始化函数的起始地址按照一定顺序，放在名为section的段中；在内核启动的初始化阶段，do_initcalls()函数中以函数指针的形式取出这些函数的其实地址，依次运行，以完成相应模块的初始化操作，是设备驱动程序初始化的第二部分；由于内核模块可能存在依赖关系，即某些模块的初始化需要依赖其他模块的初始化来完成，因此这些模块的初始化顺序非常重要；\n\n\n\n\n依次调用不同等级的初始化函数：\n\n\n```c\n// init/main.c\nstatic void __init do_initcalls(void)\n{\n    int level;\n\n    // 依次调用不同level等级的初始化函数\n    for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++)\n        do_initcall_level(level);\n}\n```\n\n\n\n\n对于同一个level等级下的函数，依次遍历执行：\n\n\n```c\n// init/main.c\nstatic void __init do_initcall_level(int level)\n{\n    initcall_t *fn;\n\n    strcpy(initcall_command_line, saved_command_line);\n    parse_args(initcall_level_names[level],\n           initcall_command_line, __start___param,\n           __stop___param - __start___param,\n           level, level,\n           NULL, &repair_env_string);\n\n    // 对于同一个level等级下的函数，依次遍历执行；\n    for (fn = initcall_levels[level]; fn < initcall_levels[level+1]; fn++)\n        do_one_initcall(*fn);\n}\n```\n\n\n\n\n开始执行某一个确定的函数：\n\n\n```c\n// init/main.c\nint __init_or_module do_one_initcall(initcall_t fn)\n{\n    int count = preempt_count();\n    int ret;\n    char msgbuf[64];\n\n    if (initcall_blacklisted(fn))\n        return -EPERM;\n\n    if (initcall_debug)\n        ret = do_one_initcall_debug(fn);\n    else\n        ret = fn();\n\n    msgbuf[0] = 0;\n\n    if (preempt_count() != count) {\n        sprintf(msgbuf, \"preemption imbalance \");\n        preempt_count_set(count);\n    }\n    if (irqs_disabled()) {\n        strlcat(msgbuf, \"disabled interrupts \", sizeof(msgbuf));\n        local_irq_enable();\n    }\n    WARN(msgbuf[0], \"initcall %pF returned with %s\\n\", fn, msgbuf);\n\n    add_latent_entropy();\n    return ret;\n}\n```\n\n\n\n\n编译到内核中的模块，是按照执行的level等级，将模块的初始化函数指针地址，分别放到相对应level等级的section中的；\n\n\ninitcall_t是一个函数指针类型：\n\n\n```c\ntypedef int (*initcall_t)(void);\n```\n\n\n\n\n```c\n// include/linux/init.h\n#define __define_initcall(fn, id) \\\n    static initcall_t __initcall_##fn##id __used \\\n    __attribute__((__section__(\".initcall\" #id \".init\"))) = fn;\n```\n\n\n\\_\\_attribute\\_\\_((\\_\\_section__())) 表示把对象放在这个由括号中的名称所指代的section中；\n\n\n\\_\\_define_initcall()宏的含义是：\n\n> 1. 声明一个名称为\\_\\_initcall\\_##fn的函数指针（其中##表示将两边的变量连接为一个变量）；\n> 2. 将这个函数指针初始化为fn；\n> 3. 编译时，要将这个函数指针变量放到名称为\".initcall\" #id \".init\"的section中；（比如：level=\"2\"，表示这个section的名称为\".initcall2.init\"）\n\n\n\n> 举例：\n>\n>  \t\\_\\_define\\_initcall(6, pci\\_init)\n>\n> 含义：\n>\n> 1. 声明一个函数指针，并赋值：\\_\\_initcall\\_pci\\_init = pci\\_init；\n> 2. 2. 编译时要将函数指针变量\\_\\_initcall\\_pci\\_init放到名称为initcall6.init的section中；（其实就是将pci\\_init函数的首地址放到名称为initcall6.init的section中）\n\n__define_initcall()宏并不会直接使用，而是被定义为其他的宏定义形式使用：\n\n\n```c\n// include/linux/init.h\n#define pure_initcall(fn)       __define_initcall(fn, 0)\n\n#define core_initcall(fn)       __define_initcall(fn, 1)\n#define core_initcall_sync(fn)      __define_initcall(fn, 1s)\n#define postcore_initcall(fn)       __define_initcall(fn, 2)\n#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)\n#define arch_initcall(fn)       __define_initcall(fn, 3)\n#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)\n#define subsys_initcall(fn)     __define_initcall(fn, 4)\n#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)\n#define fs_initcall(fn)         __define_initcall(fn, 5)\n#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)\n#define rootfs_initcall(fn)     __define_initcall(fn, rootfs)\n#define device_initcall(fn)     __define_initcall(fn, 6)\n#define device_initcall_sync(fn)    __define_initcall(fn, 6s)\n#define late_initcall(fn)       __define_initcall(fn, 7)\n#define late_initcall_sync(fn)      __define_initcall(fn, 7s)\n```\n\n\n通过core_initcall()来声明的函数指针，将被放到名为.initcall1.init的section中；通过postcore_initcall()来声明的函数指针，将被放到名为.initcall2.init的section中；以此类推；\n\n> 举例：\n>\n>  \tdevice_initcall(pci_init);\n>\n> 含义：\n>\n> 1. 声明一个函数指针，并赋值：\\_\\_initcall\\_pci\\_init = pci\\_init；\n> 2. 编译时要将函数指针变量\\_\\_initcall\\_pci\\_init放到名称为initcall6.init的section中；（其实就是将pci\\_init函数的首地址放到名称为initcall6.init的section中）\n\n在编译生成的vmlinux.lds文件中，可以找到initcall相关的定义：\n\n\n```c\n// tmp/bsp/DBG/BOARDLX2160LE/ARMQORIQLE/kernel/kernels/linux-4.9.115-cgel/arch/arm64/kernel/vmlinux.lds\n  __initcall_start = .; KEEP(*(.initcallearly.init))\n  __initcall0_start = .; KEEP(*(.initcall0.init)) KEEP(*(.initcall0s.init))\n  __initcall1_start = .; KEEP(*(.initcall1.init)) KEEP(*(.initcall1s.init))\n  __initcall2_start = .; KEEP(*(.initcall2.init)) KEEP(*(.initcall2s.init))\n  __initcall3_start = .; KEEP(*(.initcall3.init)) KEEP(*(.initcall3s.init))\n  __initcall4_start = .; KEEP(*(.initcall4.init)) KEEP(*(.initcall4s.init))\n  __initcall5_start = .; KEEP(*(.initcall5.init)) KEEP(*(.initcall5s.init))\n  __initcallrootfs_start = .; KEEP(*(.initcallrootfs.init)) KEEP(*(.init     callrootfss.init))\n  __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init))\n  __initcall7_start = .; KEEP(*(.initcall7.init)) KEEP(*(.initcall7s.init))\n  __initcall_end = .;\n```\n\n\n在这些section中，总的开始位置被标识为\\_\\_initcall\\_start，而在结尾被标识为\\_\\_initcall\\_end；\n\n\n\n\ndo_initcalls()函数，会从这些section中依次取出所有的函数指针，并按顺序调用这些函数指针调用的函数，来分别完成内核中驱动模块的初始化操作；\n\n\n函数指针被放到哪个section中，是由宏定义\\_\\_define\\_initcall(fn, id)的参数id，也就是level决定的，对应level更小的子section的位置更靠前；而位于同一个子section中的函数指针顺序不定，由编译器按照编译顺序随机决定；\n\n\n\n\n```c\n// init/main.c\nstatic initcall_t *initcall_levels[] __initdata = {\n    __initcall0_start,\n    __initcall1_start,\n    __initcall2_start,\n    __initcall3_start,\n    __initcall4_start,\n    __initcall5_start,\n    __initcall6_start,\n    __initcall7_start,\n    __initcall_end,\n};\n```\n\n\n\n\n\n\n##### 3.6.3 ramdisk_execute_command\n\n\n```c\n// init/main.c\n\tif (!ramdisk_execute_command)\n        ramdisk_execute_command = \"/init\";\n```\n\n\nkernel_init_freeable()函数会去判断ramdisk_execute_command是否为空，如果不为空，就直接运行ramdisk_execute_command指定的程序；ramdisk_execute_command的取值分以下情况：\n\n> 1. 如果命令行参数中指定了“rdinit=...”，则ramdisk_execute_command等于这个参数指定的程序；\n> 2. 否则，如果/init程序存在，ramdisk_execute_command=/init；\n> 3. 否则，ramdisk_execute_command为空；\n\n```c\n// init/main.c\nif (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {\n    ramdisk_execute_command = NULL;\n    prepare_namespace();\n}\n```\n\n\n\n\n#### 3.7 free_initmem\n\n\nfree_initmem()函数用来释放所有init.段中的内存；\n\n\n```c\n// arch/arm64/mm/init.c\nvoid free_initmem(void)\n{\n    free_reserved_area(__va(__pa(__init_begin)), __va(__pa(__init_end)),\n               0, \"unused kernel\");\n    /*\n     * Unmap the __init region but leave the VM area in place. This\n     * prevents the region from being reused for kernel modules, which\n     * is not supported by kallsyms.\n     */\n    unmap_kernel_range((u64)__init_begin, (u64)(__init_end - __init_egin));\n}\n```\n\n\n\n\n#### 3.8 启动用户态init进程\n\n\n```c\n// kernel/init/main.c\nkernel_init()\n    if (ramdisk_execute_command) {\n        ret = run_init_process(ramdisk_execute_command);\n        if (!ret)\n            return 0;\n        pr_err(\"Failed to execute %s (error %d)\\n\",\n               ramdisk_execute_command, ret);\n    }\n    if (execute_command) {\n        ret = run_init_process(execute_command);\n        if (!ret)\n            return 0;\n        panic(\"Requested init %s failed (error %d).\",\n              execute_command, ret);\n    }\n    if (!try_to_run_init_process(\"/sbin/init\") ||\n        !try_to_run_init_process(\"/etc/init\") ||\n        !try_to_run_init_process(\"/bin/init\") ||\n        !try_to_run_init_process(\"/bin/sh\"))\n        return 0;\n```\n\n\n\n```c\nstatic int try_to_run_init_process(const char *init_filename)\n{\n    int ret;\n\n    ret = run_init_process(init_filename);\n    return ret;\n}\n```\n\n\n\n\n```c\nstatic int run_init_process(const char *init_filename)\n{\n    argv_init[0] = init_filename;\n    return do_execve(getname_kernel(init_filename),\n        (const char __user *const __user *)argv_init,\n        (const char __user *const __user *)envp_init);\n}\n```\n\n\n在大多数系统中，bootloader会传递参数给内核的main函数，而这些参数中会包含init=/linuxrc参数，于是在kernel_init进程中，如果有execute_command = \"linuxrc\"，在经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行，通过do_execve()函数进入用户态，开始文件系统的初始化init进程；\n\n\n如果boot没有传递init=/linuxrc参数给内核，ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；\n\n\n\n\n```c\npanic(\"No working init found.  Try passing init= option to kernel. \"\n          \"See Linux Documentation/init.txt for guidance.\");\n```\n\n\n出现这种异常错误，可能是以下几个原因造成：\n\n> 1. 启动参数配置错误，指定了init，但是未找到；\n> 2. 文件系统挂载出错；\n> 3. 四个应用程序找不到，或者没有可执行权限；\n\n到此，Linux内核部分启动结束，下一步会在文件系统中启动用户空间的init进程，并进行下一步的启动操作；\n\n\n\n\n### 4. filesystem启动\n\n\n```mermaid\ngraph LR\n\tkernel_init(\"kernel_init()\")--\"init=linuxrc\"-->linuxrc(linuxrc)\n\t--链接-->busybox(\"/bin/busybox\")\n\tkernel_init(\"kernel_init()\")--default-->init(\"/sbin/init\")\n\t--链接-->busybox(\"/bin/busybox\")\n\t--inittab-->rcS(\"/etc/init.d/rcS\")\n```\n\n\n#### 4.1 filesystem构建\n\n\n文件系统可以通过busybox工具来构建；构建成功之后，一般情况下是不需要修改的；我们使用的文件系统，由成研提供；具体的构建方法此处先省略，有时间再补上；\n\n\n#### 4.2 busybox程序\n\n\n在Kernel挂载文件系统后，通过kernel_init()函数，准备运行init进程；\n\n\n在kernel/init/main.c文件中\n\n\n```c\n// kernel/init/main.c\nkernel_init()\n{\n    if (ramdisk_execute_command) {\n        ret = run_init_process(ramdisk_execute_command);\n        if (!ret)\n            return 0;\n        pr_err(\"Failed to execute %s (error %d)\\n\",\n               ramdisk_execute_command, ret);\n    }\n\tif (execute_command) {\n        ret = run_init_process(execute_command);\n        if (!ret)\n            return 0;\n        panic(\"Requested init %s failed (error %d).\",\n              execute_command, ret);\n    }\n\tif (!try_to_run_init_process(\"/sbin/init\") ||\n        !try_to_run_init_process(\"/etc/init\") ||\n        !try_to_run_init_process(\"/bin/init\") ||\n        !try_to_run_init_process(\"/bin/sh\"))\n        return 0;\n}\n```\n\n\n经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行；而linuxrc文件是一个指向/bin/busybox的链接，也就是说，系统启动后运行的第一个程序是/bin/busybox；\n\n\n```shell\n# ls linuxrc -l\nlrwxrwxrwx 1 root root 11 Mar  4 10:04 linuxrc -> bin/busybox\n```\n\n\n如果ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；而/sbin/init文件也是链接到/bin/busybox的，最终还是会执行/bin/busybox程序；创建用户空间运行的第一个进程；\n\n\n```shell\n# ls /sbin/init -l\nlrwxrwxrwx    1 root     root            14 Dec 12  2019 /sbin/init -> ../bin/busybox\n```\n\n\n\n\n#### 4.3 init进程\n\n\nbusybox程序运行，会启动init进程，init进程在Linux系统中是最早运行的进程，也就是1号进程；\n\n\n```shell\n# ps -aux | grep init\nroot         1  0.8  0.0   2080    12 ?        Ss   18:47   0:20 init\n```\n\n\n\n\ninit进程进行的工作：\n\n> 1. 为init设置信号处理过程\n> 2. 初始化控制台\n> 3. 解析/etc/inittab文件\n> 4. 执行系统初始化命令，一般情况下会使用/etc/init.d/rcS\n> 5. 执行所有导致init暂停的inittab命令（动作类型：wait）\n> 6. 执行所有仅执行一次的inittab命令（动作类型：once）\n\n执行完以上工作后，init进程会循环执行以下进程：\n\n> 1.执行所有终止时必须重新启动的inittab命令（动作类型：respawn）\n>\n> 2.执行所有终止时必须重新启动但启动前必须询问用户的inittab命令（动作类型：askfirst）\n\n\n\n\n\n#### 4.4 inittab\n\n\nbusybox程序解析/etc/inittab文件，而/etc/inittab是进行初始化的配置文件；busybox运行时会按照格式解析inittab文件，根据解析内容决定具体工作；\n\n\n```shell\n# cat /etc/inittab\n::sysinit:/etc/init.d/rcS\n#::once:/bin/sw &\n#The followed sentence does't need password.\n::respawn:-/bin/ash\n#The followed sentence does need password.\n#::respawn:-/bin/login\n#tty2::askfirst:-/bin/ash\n::ctrlaltdel:/bin/umount -a -r\n```\n\n\n\n\ninittab的内容以行为单位，行与行之间没有关联，每行都是一个独立的配置项；每一行的配置项都是由3个冒号分隔开的4个配置值组成，冒号是分隔符，分隔开各个部分；\n\n\ninittab文件里的代码格式：\n\n\n\\<id>:\\<runlevels>:\\<action>:\\<process>\n\n\n说明：\n\n> id：/dev/id，用作终端terminal：stdin、stdout、stderr、printf、scanf、err\n>\n> runlevels：\n>\n> action：执行时机；包括：sysinit、respawd、askfirst、wait、once、restart、ctrialtdel、shutdown\n>\n> process：应用程序和脚本\n\n\n\n#### 4.5 rcS\n\n\n在/etc/inittab配置文件中，action为sysinit的行，表示在Linux系统初始化文件系统时执行的第一个脚本，即：/etc/init.d/rcS；\n\n\n```shell\n::sysinit:/etc/init.d/rcS\n```\n\n\n主要进行一些初始化工作：启动交换分区、检查磁盘、设置主机名、检查并挂载文件系统、加载并初始化硬件模块等；\n\n\n\n\n/etc/init.d/rcS文件是Linux运行时非常重要的一个脚本程序；其他的配置在rcS文件中进行，rcS文件中的配置可以根据需求进行扩展；/etc/init.d/rcS完成各个文件系统的挂载（mount），以及文件硬件模块的初始化；\n\n\n\n\n\n\n### 5. 应用进程启动\n\n\n\n\n应用进程，可以在文件系统的/etc/init.d/rcS脚本运行时，调用xxx.sh脚本拉起来的；\n\n\n\n\n\n\n\n[跳转到目录](#目录)","source":"_posts/Linux内核启动流程-基于ARM64.md","raw":"---\ntitle: Linux内核启动流程-基于ARM64\ndate: 2020-04-19 23:13:03\ntags: Kernel\n---\n\n\n\n以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n\n[TOC]\n\n\n### 0. 简述\n\n\n以arm64为例，讲述Linux在ARM64架构设备上的系统启动流程；\n\n\n上电启动，系统启动要经过uboot、kernel、filesystem、ADM几个过程，如下：\n\n\n```mermaid\ngraph LR\n\tuboot(uboot)-->kernel(kernel)\n\t-->filesystem(filesystem)\n\t-->Software(Software)\n```\n\n\n\n\n\n\n在大多数系统中，内核镜像在uboot阶段被加载到内存中，并获得控制权开始内核的启动流程；\n\n\n```mermaid\ngraph LR\n\tuboot(uboot)-->kernel(kernel)\n```\n\n\n\n\nLinux内核版本：\n\n\n```shell\nlinux-4.9.115\n# uname -a\nLinux vexpress 4.9.115 #2 SMP Wed Apr 1 22:49:35 CST 2020 aarch64 GNU/Linux\n```\n\n**说明**：由于Linux内核系统庞大繁杂，要想把内核启动中的每个细节都描述清楚，基本上不可能，更何况作者能力水平也达不到；因此，就在追踪内核启动流程代码的同时，只描述比较重要的几个部分；可以在以后的工作、学习中，随着水平的提高，不断地增加内容；\n\n\n\n\n### 1. 目标文件\n\n\n\n\n内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照vmlinux.lds设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序；\n\n\n\n\n#### 1.1 vmlinux.lds\n\n\nvmlinux.lds文件是在内核编译时生成的，是被禁止编辑的；vmlinux.lds文件是在编译时，由vmlinux.lds.S文件对链接器ld的输出进行排序后生成；vmlinux.lds.S是用来对输出文件中的段进行排序，并定义相关的符号名；\n\n\n```\narch/arm64/kernel/vmlinux.lds.S\n```\n\n\n在项目中通过make时指定的参数-O，将内核编译生成的所有目标文件，包括vmlinux.lds文件重定向输出到以下目录：\n\n\n```shell\narch/arm64/kernel/vmlinux.lds\n```\n\n\nvmlinux.lds文件是链接脚本，在内核编译时，作为Makefile的链接器脚本，参与链接生成内核映像vmlinux；\n\n\n总之：vmlinux是按照vmlinux.lds链接生成的，而vmlinux.lds是由vmlinux.lds.S生成的；\n\n\n```C\n// arch/arm64/kernel/vmlinux.lds\nOUTPUT_ARCH(aarch64)\t// 指定架构为aarch64\nENTRY(_text)\t\t\t// 定义入口为_text\njiffies = jiffies_64;\t// 定义为64位计数器\nSECTIONS\n{\n    ......\n    // 指定链接地址\n    . = ((((0xffffffffffffffff - (1 << (48)) + 1) + (0)) + (0x08000000))) + 0x00080000;\n    ......\n}\n```\n\n\n\n\n关于段的信息\n\n> text段，代码段，用来存放程序执行代码的一块内存区域；大小在程序运行前确定；\n>\n> data段，数据段，用来存放程序中已初始化的全局变量的内存区域；数据段属于静态内存分配；\n>\n> bss段，用来存放程序中未初始化的全局变量和静态变量的一块内存区域；属于静态内存分配；\n>\n> init段，Linux定义的一种初始化过程中才能用到的段；初始化完成后，该段内存会被释放；\n\n\n\n关于地址的信息\n\n> 加载地址：程序中指令和变量等加载到RAM上的地址；\n>\n> 运行地址：CPU执行一条程序的指令时的执行地址，即PC寄存器的值；就是要寻址到一个指令或变量所使用的地址；\n>\n> 链接地址：链接过程中链接器为指令和变量分配的地址；\n\n\n\n#### 1.2 内核映像\n\n\nvmlinux是未压缩的内核，是生成的纯内核二进制文件，具有用户定义的所有内核组件，但是这个vmlinux二进制文件是无法启动系统的；为了将Linux内核映像加载到内存并处于可执行状态，内核构建系统使用objcopy命令清除不必要的节区，压缩ELF格式的vmlinux，通过引导程序加载项和链接，生成可启动的最终的二进制文件zImage；\n\n\nvmlinux通过gzip压缩成piggy.o，和head.o、misc.o链接生成zImage二进制文件；\n\n\nvmlinuz是vmlinux的压缩文件\n\n\nzImage默认的压缩内核映像文件，压缩vmlinux，加上一段解压启动代码，压缩而成；\n\n\nuImage是u-boot使用bootm命令引导的Linux压缩内核映像文件格式，是使用mkimage工具对普通的压缩内核映像文件（zImage）加工而成；\n\n\nuImage是uboot专用的内核映像文件，是在zImage之前加上一个长度为64字节的“头”，说明内核的版本、加载位置、生成时间、大小等信息；在地址0x40之后的部分，和zImage一样；其大小比zImage大64字节；\n\n\n\n\n#### 1.3 设备树文件\n\n\nLinux内核从3.x版本开始引入设备树的概念，用于实现驱动代码与设备信息分离；设备树出现之前，所有关于设备的具体信息都写在驱动中，外围设备变化，驱动代码就要跟着修改甚至是重写；引入设备树之后，驱动代码只负责处理驱动代码的逻辑，而关于设备的具体信息存放到设备树文件中，这样硬件接口信息变化时，只需要修改设备树文件信息，不需要修改驱动代码就可以；\n\n\n一般情况下，在编译设备树之前，先在scripts/dtc/目录下，编译生成dtc工具scripts/dtc/dtc，再使用生成的dtc工具编译设备树源码，生成设备树文件；设备树源码和目标文件在arch/arm64/boot/dts/freescale/目录；\n\n\n在Lx2160板项目中，目标文件会被重定向输出到target目录；\n\n\n\n\n具体的设备树文件的加载、解析过程，会在下文setup_arch部分描述；\n\n\n\n\n### 2. 内核启动第一阶段\n\n\n\n\nLinux内核启动第一阶段，也就是我们常说的汇编阶段，也就是stext函数的实现内容；这部分主要完成的工作：CPU ID检查，machine ID检查，创建初始化页表，设置C代码运行环境，跳转到内核第一个真正的C函数start_kernel执行；\n\n\n\n\n设置为SVC模式，关闭所有中断\n\n\n获取CPUID，提取相应的proc info\n\n\n验证tags或dtb\n\n\n创建页表项\n\n\n\n\n\n\n\n\nhead.S文件中，\n\n\n校验启动合法性\n\n\n建立段式映射的页表并开启MMU\n\n\n构建C运行环境，跳入C阶段\n\n\n\n\n\n\n\n\n#### 2.1 内核启动入口点\n\n\n内核是一个庞大的系统，通过vmlinux反向追踪启动入口点\n\n\nLx2160le板的交叉编译工具链：\n\n\n```shell\nCROSS_COMPILE=aarch64-linux-gnu-\n```\n\n\n\n\n通过对目标文件vmlinux的反向追溯，找到Linux执行的入口；\n\n\n使用readelf命令可以查看vmlinux的入口地址为：0xffff000008080000\n\n\n```shell\n# readelf -h vmlinux\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           AArch64\n  Version:                           0x1\n  Entry point address:               0xffff000008080000\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          267014976 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         4\n  Size of section headers:           64 (bytes)\n  Number of section headers:         39\n  Section header string table index: 36\n```\n\n\n\n\n这个入口地址是怎么来的，对应内核代码中的哪个部分，可以通过反汇编来分析；\n\n\n```shell\n# aarch64-linux-gnu-objdump -dxh vmlinux > vmlinux.s\n```\n\n\n\n\n在得到的汇编文件vmlinux.s中查找入口地址：0xffff000008080000\n\n\n```c\nstart address 0xffff000008080000\n\nDisassembly of section .head.text:\n\nffff000008080000 <_text>:\nffff000008080000:       91005a4d        add     x13, x18, #0x16\nffff000008080004:       14437fff        b       ffff000009160000 <stext>\n```\n\n\n\n\n可以得到，Linux入口的第一条指令为：add     x13, x18, #0x16；对应的符号是：.head.text  _text；\n\n\n而.head.text段，通过include/linux/init.h文件中的宏定义__HEAD来表示：\n\n\n```C\n/* For assembly routines */\n#define __HEAD      .section    \".head.text\",\"ax\"\t// \"ax\"表示所在段区域有可执行权限\n#define __INIT      .section    \".init.text\",\"ax\"\n```\n\n\n\n\n内核启动的入口点，在arch/arm64/kernel/head.S文件中；\n\n\n```c\n    __HEAD\n_head:\n    /*\n     * DO NOT MODIFY. Image header expected by Linux boot-loaders.\n     */\n#ifdef CONFIG_EFI\n    /*\n     * This add instruction has no meaningful effect except that\n     * its opcode forms the magic \"MZ\" signature required by UEFI.\n     */\n    add x13, x18, #0x16\n    b   stext\n#else\n    b   stext               // branch to kernel start, magic\n    .long   0               // reserved\n#endif\n```\n\n\n到此，已经找到，目标文件vmlinux的入口是arch/arm64/kernel/head.S文件中的__HEAD，在执行完第一条语句（add x13, x18, #0x16）之后，跳转到stext函数执行（b   stext）；所以，加载vmlinux后，第一个运行的函数是stext；\n\n\n\n\n#### 2.2 stext函数\n\n\n启动过程中的汇编阶段，是从arch/arm64/kernel/head.S文件开始，执行的起点是stext函数，入口函数是通过vmlinux.lds链接而成，在head.S中ENTRY(stext)指定；\n\n在汇编代码中，宏定义ENTRY和ENDPROC是成对出现的，表示定义的一个函数，同时也要指明当前代码所在的段，如：__INIT；\n\n\n\n\n```c\n// arch/arm64/kernel/head.S\n#define __INIT      .section    \".init.text\",\"ax\"\n\n\t__INIT\nENTRY(stext)\n\t......\nENDPROC(stext)\n```\n\n\n\n\n内核启动的必要条件：MMU关闭，D-cache关闭，x0是传递给FDT blob的物理地址；\n\n\n```c\n * The requirements are:\n *   MMU = off, D-cache = off, I-cache = on or off,\n *   x0 = physical address to the FDT blob.\n```\n\n\n\nstext函数开始执行；\n\n\n```c\n// arch/arm64/kernel/head.S\n\t__INIT\nENTRY(stext)\n    bl  preserve_boot_args\t// Preserve the arguments passed by the bootloader in x0 ... x3\n    bl  el2_setup           // Drop to EL1, w0=cpu_boot_mode\n    adrp    x23, __PHYS_OFFSET\n    and x23, x23, MIN_KIMG_ALIGN - 1    // KASLR offset, defaults to 0\n    bl  set_cpu_boot_mode_flag\n    bl  __create_page_tables\n\n  /*\n   * The following calls CPU setup code, see arch/arm64/mm/proc.S for\n   * details.\n   * On return, the CPU will be ready for the MMU to be turned on and\n   * the TCR will have been set.\n   */\n     bl  __cpu_setup         // initialise processor\n     b   __primary_switch\nENDPROC(stext)\n```\n\n\n\n##### 1. preserve_boot_args\n\n\n保存从bootloader传递过来的x0 ~ x3参数；\n\n\n```c\n// arch/arm64/kernel/head.S\npreserve_boot_args:\n    mov x21, x0\t\t\t\t// 将dtb的地址暂存在x21寄存器，释放出x0使用\n    adr_l   x0, boot_args\t// x0保存boot_args变量的地址\n    stp x21, x1, [x0]\t\t// 将x0、x1的值保存到boot_args[0]、boot_args[1]\n    stp x2, x3, [x0, #16]\t// 将x2、x3的值保存到boot_args[2]、boot_args[3]\n\n    dmb sy              // needed before dc ivac with\n                        // MMU off\n\n    add x1, x0, #0x20\t\t// x0、x1作为nval_cache_range函数的参数\n    b   __inval_cache_range     // tail call\nENDPROC(preserve_boot_args)\n```\n\n\n\n\n##### 2. el2_setup\n\n\n到此，CPU处于哪个exception level？根据ARM64 boot protocol，CPU处于EL2（推荐）或者secure EL1；如果处于EL2，需要将CPU退回到EL1；此部分还没有搞明白，暂时先跳过；\n\n\n```c\n// arch/arm64/kernel/head.S\nENTRY(el2_setup)\n\t......\nENDPROC(el2_setup)\n```\n\n\n\n\n##### 3. set_cpu_boot_mode_flag\n\n\nset_cpu_boot_mode_flag函数，用来设置__boot_cpu_mode flag；需要一个前提条件：w20寄存器中保存了CPU启动时的异常等级（Exception level）；\n\n\n```c\n// arch/arm64/kernel/head.S\nset_cpu_boot_mode_flag:\n    adr_l   x1, __boot_cpu_mode\n    cmp w0, #BOOT_CPU_MODE_EL2\n    b.ne    1f\n    add x1, x1, #4\n1:  str w0, [x1]            // This CPU has booted in EL1\n    dmb sy\n    dc  ivac, x1            // Invalidate potentially stale cache line\n    ret\nENDPROC(set_cpu_boot_mode_flag)\n```\n\n\n由于系统启动之后，需要了解CPU启动时候的Exception level，因此需要一个全局变量__boot_cpu_mode来保存启动时的CPU mode；\n\n\n全局变量__boot_cpu_mode定义：\n\n\n```c\nENTRY(__boot_cpu_mode)\n    .long   BOOT_CPU_MODE_EL2\n    .long   BOOT_CPU_MODE_EL1\n```\n\n\n\n\n##### 4. __create_page_tables\n\n\n建立页表初始化的过程；\n\n\n```c\n// arch/arm64/kernel/head.S\n__create_page_tables:\n\t......\nENDPROC(__create_page_tables)\n```\n\n\n\n\n##### 5. __cpu_setup\n\n\nCPU的初始化设置；\n\n\n```c\n// arch/arm64/mm/proc.S\nENTRY(__cpu_setup)\n\t......\nENDPROC(__cpu_setup)\n```\n\n\n主要的内容包括：\n\n> ```\n> 1、cache和TLB的处理\n> 2、Memory attributes lookup table的创建\n> 3、SCTLR_EL1、TCR_EL1的设定\n> ```\n\n\n\n##### 6. __primary_switch\n\n\n主要工作是为打开MMU做准备；\n\n\n```c\n// arch/arm64/kernel/head.S\n__primary_switch:\n\t......\n\tbl  __enable_mmu\t\t\t// 开启MMU\n\t......\n    ldr x8, =__primary_switched\n    adrp    x0, __PHYS_OFFSET\n    blr x8\nENDPROC(__primary_switch)\n```\n\n\n在函数中通过\\_\\_enable\\_mmu函数来开启MMU，并调用\\_\\_primary_switched函数；\n\n\n```c\n// arch/arm64/kernel/head.S\n__primary_switched:\n\t......\n    b   start_kernel\nENDPROC(__primary_switched)\n```\n\n\n在__primary_switched函数中，进行一些C环境的准备，并在最后，调用执行start_kernel函数，内核的启动进入到C语言环境阶段；\n\n\n```mermaid\ngraph TB\n    subgraph 入口函数\n    A_Explain(保存boot参数)\n    -->\n    B_Explain(EL2设置)\n    -->\n    C_Explain(设置CPU启动模式flag)\n    -->\n    D_Explain(创建页表)\n    -->\n    E_Explain(CPU配置)\n    -->\n    F_Explain(主要的转换操作)\n    -->\n    G_Explain(运行start_kernel函数)\n    end\n \n    subgraph stext\n    A_func(preserve_boot_args)\n    -->\n    B_func(el2_setup)\n    -->\n    C_func(set_cpu_boot_mode_flag)\n    -->\n    D_func(__create_page_tables)\n    -->\n    E_func(__cpu_setup)\n    -->\n    F_func(__primary_switch)\n    -->\n    G_func(start_kernel)\n    end\n```\n\n\n\n\n#### 2.3 参考资料\n\n\nhttps://blog.csdn.net/xiaohua0877/article/details/78615776\n\n\nhttp://www.wowotech.net/sort/armv8a_arch\n\n\n\n\n### 3. 内核启动第二阶段\n\n\nLinux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；\n\n\n```mermaid\ngraph TB\n\tA(start_kernel)-->B(一系列的初始化操作)\n\tsubgraph start_kernel\n\tB(一系列的初始化操作)\n\t-->\n\tC(setup_arch)\n\t-->\n\tD(一系列的初始化操作)\n\t-->\n\tE(rest_init)\n\tend\n```\n\n\n\n\n#### 3.1 start_kernel\n\n\nstart_kernel()函数在init/main.c文件中，主要完成Linux子系统的初始化工作；此部分初始化内容繁多，暂时先略过，此处省略好多字；\n\n\n```c\n// init/main.c\nasmlinkage __visible void __init start_kernel(void)\n{\n\t......\n}\n```\n\n\n\n\n```c\npr_notice(\"%s\", linux_banner);\n```\n\n\n\n\n```c\nconst char linux_banner[] =\n    \"Linux version \" UTS_RELEASE \" (\" LINUX_COMPILE_BY \"@\"\n    LINUX_COMPILE_HOST \") (\" LINUX_COMPILER \") \" UTS_VERSION \"\\n\";\n```\n\n\n执行的效果是，在内核启动初期，打印内核版本号和构建信息：\n\n\n```shell\nLinux version 4.9.115 (root@localhost.localdomain) (gcc version 6.2.0 20170314 ZTE Embsys-TSP V3.06.40 (GCC) ) #2 SMP PREEMPT Tue Mar 10 11:21:00 CST 2020\n```\n\n\n\n\n#### 3.2 setup_arch\n\n\nsetup_arch()函数，是体系结构相关的，该函数根据处理器、硬件平台具体型号设置系统；及解析系统命令行，系统内存管理初始化，统计并注册系统各种资源等；每个体系都有自己的setup_arch()函数，是由顶层Makefile中的ARCH变量定义的，我们使用的是ARCH=arm64，因此，这里的setup_arch()函数，也是arm64的体系结构相关的；参数是未被初始化的内部变量command_line；\n\n\n```c\n// init/main.c\nasmlinkage __visible void __init start_kernel(void)\n{\n\t......\n\tsetup_arch(&command_line);\n\t......\n}\n```\n\n\n\n\nsetup_arch()函数中的初始化内容比较多，目前**只对设备树相关的部分进行简要描述**；\n\n\n```c\n// arch/arm64/kernel/setup.c\nvoid __init setup_arch(char **cmdline_p)\n{\n    ......\n\tsetup_machine_fdt(__fdt_pointer);\n    ......\n    if (acpi_disabled)\n        unflatten_device_tree();\n    ......\n}\n```\n\n\n\n\n```mermaid\ngraph LR\n\tA(setup_arch)-->B(加载设备树)\n\tB(加载设备树)-->C(setup_machine_fdt)\n\tB(加载设备树)-->D(unflatten_device_tree)\n```\n\n\n\n\n##### 1. setup_machine_fdt\n\n\nsetup_machine_fdt()函数的输入参数是设备树（DTB）首地址；uboot启动程序把设备树读取到内存中，之后在启动内核的同时，将设备树首地址传给内核，setup\\_machine\\_fdt()函数的参数\\_\\_fdt_pointer就是uboot传给内核的设备树地址；函数中的fdt(flat device tree)表示，设备树在内存中是在一块连续地址存储的；\n\n\n```c\n// arch/arm64/kernel/setup.c\nstatic void __init setup_machine_fdt(phys_addr_t dt_phys)\n{\n    void *dt_virt = fixmap_remap_fdt(dt_phys);\n\n    if (!dt_virt || !early_init_dt_scan(dt_virt)) {\n\t\t......\n        while (true)\n            cpu_relax();\n    }\n\n    dump_stack_set_arch_desc(\"%s (DT)\", of_flat_dt_get_machine_name());\n}\n```\n\n\n```c\n// arch/arm64/kernel/setup.c\nphys_addr_t __fdt_pointer __initdata;\n```\n\n\n全局变量\\_\\_fdt_pointer指向内存中的DTB，是设备树的物理地址；这个物理地址是由bootloader传递给内核的，在内核中使用，是需要转换为虚拟地址才能访问，而这个转换，由fixmap_remap_fdt()函数来完成；\n\n\n\n\n```c\n// drivers/of/fdt.c\nbool __init early_init_dt_scan(void *params)\n{\n    bool status;\n\n    status = early_init_dt_verify(params);\n    if (!status)\n        return false;\n\n    early_init_dt_scan_nodes();\n    return true;\n}\n```\n\n\n接下来调用的early_init_dt_scan()函数，通过进一步调用early_init_dt_verify()函数来检查DTB数据是否完整，经过内存映射之后，就可以直接访问DTB中的内容了；\n\n\n\n\n##### 2. unflatten_device_tree\n\n\nunflatten_device_tree()函数完成对设备树的解析，所做的工作是将设备树各节点转换成相应的struct device_node结构体；\n\n\n```c\n// drivers/of/fdt.c\nvoid __init unflatten_device_tree(void)\n{\n    __unflatten_device_tree(initial_boot_params, NULL, &of_root,\n                early_init_dt_alloc_memory_arch, false);\n\n    /* Get pointer to \"/chosen\" and \"/aliases\" nodes for use everywhere */\n    of_alias_scan(early_init_dt_alloc_memory_arch);\n}\n```\n\n\n\n\n```c\n// drivers/of/base.c\nstruct device_node *of_root;\n```\n\n\n\n\n```c\nstatic void *__unflatten_device_tree(const void *blob,\n                     struct device_node *dad,\n                     struct device_node **mynodes,\n                     void *(*dt_alloc)(u64 size, u64 align),\n                     bool detached)\n{\n\t......\n    /* First pass, scan for size */\n\tsize = unflatten_dt_nodes(blob, NULL, dad, NULL);\n\t......\n    /* Allocate memory for the expanded device tree */\n\tmem = dt_alloc(size + 4, __alignof__(struct device_node));\n\t......\n    /* Second pass, do actual unflattening */\n\tunflatten_dt_nodes(blob, mem, dad, mynodes);\n\t......\n}\n```\n\n\n\\_\\_unflatten\\_device\\_tree()函数中主要的解析函数是unflatten_dt_nodes()，在这里被调用了两次，第一次是扫描出设备树转换成struct device_node所需要的空间，然后系统申请内存空间，第二次是进行真正解析的工作；\n\n\n```c\n// drivers/of/fdt.c\nstatic int unflatten_dt_nodes(const void *blob,\n                  void *mem,\n                  struct device_node *dad,\n                  struct device_node **nodepp)\n{\n\t......\n\tfor (offset = 0;\n         offset >= 0 && depth >= initial_depth;\n         offset = fdt_next_node(blob, offset, &depth)) {\n\t\tfpsizes[depth+1] = populate_node(blob, offset, &mem,\n                         nps[depth],\n                         fpsizes[depth],\n                         &nps[depth+1], dryrun);\n\t\t......\n\t}\n\t......\n}\n```\n\n\nunflatten_dt_nodes()函数，就是从根节点开始，对子节点依次调用populate_node()，为当前节点申请内存空间，并对node进行初始化；并根据读取到的dtb中的内容，按节点进行填充；设备树由dtb二进制文件，经过解析为每一个节点生成一个struct device_node结构体，就完成了dtb的加载过程；\n\n\n\n\n#### 3.3 console_init\n\n\nconsole_init()函数执行控制台的初始化操作；在console_init()函数执行之前的printk打印信息，需要在console_init()函数执行之后才能打印出来；因为在console_inie()函数之前，printk的打印信息都保存在一个缓存区中，等到console_init()函数执行之后，控制台被初始化完成，就可以将缓冲区中的内容打印出来；\n\n\n\n\n```c\n// drivers/tty/tty_io.c\nvoid __init console_init(void)\n{\n    initcall_t *call;\n\n    /* Setup the default TTY line discipline. */\n    n_tty_init();\n\n    /*\n     * set up the console device so that later boot sequences can\n     * inform about problems etc..\n     */\n    call = __con_initcall_start;\n    while (call < __con_initcall_end) {\n        (*call)();\n        call++;\n    }\n}\n```\n\n\n在console_init()函数中，指定initcall_t类型的函数指针，从\\_\\_con\\_initcall\\_start开始，到\\_\\_con\\_initcall\\_end结束，遍历这个范围之间的函数，依次运行；\n\n\n\\_\\_con\\_initcall\\_start和\\_\\_con\\_initcall\\_end这两个地址，可以在vmlinux.lds文件找到；如下：\n\n\n```c\n// vmlinux.lds\n__con_initcall_start = .;\nKEEP(*(.con_initcall.init))\n__con_initcall_end = .;\n```\n\n\n这两个地址之间，存放的是.con_initcall.init段的内容；\n\n\n```c\n// include/linux/init.h\n#define console_initcall(fn)                    \\\n    static initcall_t __initcall_##fn           \\\n    __used __section(.con_initcall.init) = fn\n```\n\n\n通过宏定义console_initcall(fn)，将initcall_t类型的函数指针fn，存放到.con_initcall.init段；之后在调用console_init()函数时，就会通过遍历_\\_con\\_initcall\\_start到\\_\\_con\\_initcall\\_end的地址区域，依次运行存放在其中的函数fn；\n\n\n```c\n// drivers/tty/serial/8250/8250_core.c\nconsole_initcall(univ8250_console_init);\n```\n\n#### 3.4 rest_init\n\n\n在进行一系列与内核相关的初始化后，在rest_init()函数中，启动了三个进程：idle、kernel_init、kthreadd，来开始操作系统的正式运行；\n\n\n```c\n// init/main.c\nrest_init()\n    kernel_thread(kernel_init, NULL, CLONE_FS);\t// 创建kernel_init内核线程，即init，1号进程；\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\t// 创建kthreadd内核线程，2号进程，用于管理和调度其他内核线程；\n    ......\n    init_idle_bootup_task(current);\t// 设置当前进程（0号进程）为idle进程；\n    schedule_preempt_disabled();\t// 调用进程调度，并禁止内核抢占；\n    /* Call into cpu_idle with preempt disabled */\n    cpu_startup_entry(CPUHP_ONLINE);\t// 0号进程完成kernel初始化工作，进入idle循环，编程idle进程；\n```\n\n\n```mermaid\ngraph TB\n\tA(rest_init)-->B(idle进程)\n\tA(rest_init)-->C(kernel_init进程)\n\tA(rest_init)-->D(kthreadd进程)\n```\n\n\n\n> - idle进程是操作系统的空闲进程，CPU空闲的时候会去运行它；\n> - kernel_init进程最开始只是一个函数，作为进程被启动，init进程是永远存在的，PID是1；\n> - kthreadd是内核守护进程，始终运行在内核空间，负责所有内核线程的调度和管理，PID是2；\n\n也就是说，系统启动后的第一个进程是idle，idle进程是唯一没有通过kernel_thread或fork产生的进程；idle创建了kernel_init进程作为1号进程，创建了kthreadd进程作为2号进程；\n\n\n```mermaid\ngraph TB\n\tA(idle进程)-->B(kernel_init进程)\n\tA(idle进程)-->C(kthreadd进程)\n```\n\n\n\n\n#### 3.5 kernel_init\n\n\nkernel_init()函数在创建kernel_init进程时，作为进程被启动；虽然kernel_init最开始只是一个函数，但是在最后，通过系统调用，将读取根文件系统下的init进程，完成从内核态到用户态的转变，转变为用户态的1号进程；这个init进程是所有用户态进程的父进程，产生了大量的子进程；init进程是1号进程，是永远存在的；\n\n\n```mermaid\ngraph TB\n\tA(kernel_init)-->B(kernel_init_freeable)\n\tsubgraph kernel_init\n        B(kernel_init_freeable)\n        -->C(free_initmem)\n        -->D(ramdisk_execute_command)\n        -->E(execute_command)\n        -->F(用户空间init进程)\n\tend\n```\n\n\n\n\n#### 3.6 kernel_init_freeable\n\n\n等待内核线程kthreadd创建完成、注册内核驱动模块do_basic_setup、启动默认控制台/dev/console\n\n\n完成设备初始化以及模块加载工作；\n\n\n```mermaid\ngraph TB\n\tA(kernel_init_freeable)-->B(wait_for_completion)\n\tsubgraph kernel_init_freeable\n        B(wait_for_completion)\n        -->C(set_mems_allowed)\n        -->D(do_basic_setup)\n        -->E(open console)\t\n        -->X(ramdisk_execute_command)\n\tend\n```\n\n\n\n\n##### 3.6.1 wait_for_completion\n\n\n```c\n// init/main.c\nkernel_init_freeable()\n{\n\twait_for_completion(&kthreadd_done);\n}\n```\n\n\n使用完成量等待kthreadd_done，等待内核线程kthreadd创建完成；虽然kernel_init进程先创建，但是要在kthreadd线程创建完成才能执行；在threadd线程创建完成后才唤醒完成量，开始kernel_init进程的工作；\n\n\n\n\n##### 3.6.2 do_basic_setup\n\n\n```mermaid\ngraph TB\n\tA(do_basic_setup)-->C(driver_init)\n\tsubgraph do_basic_setup\n\tC(driver_init)\n\t-->D(do_initcalls)\n\tend\n```\n\n\n\n\n\n\n\n###### 2. driver_init\n\n\ndriver_init()函数完成与驱动程序相关的所有子系统的构建，实现了Linux设备驱动的一个整体框架，但是它只是建立了目录结构，是设备驱动程序初始化的第一部分，具体驱动模块的装载在do_initcalls()函数中实现；\n\n\n```c\n// drivers/base/init.c\nvoid __init driver_init(void)\n{\n    /* These are the core pieces */\n    devtmpfs_init();\t// 注册devtmpfs文件系统，启动devtmpfsd进程\n    devices_init();\t\t// 初始化驱动模型中的部分子系统，/dev/devices, /dev/char, /dev/block\n    buses_init();\t\t// 初始化驱动模型中的bus子系统\n    classes_init();\t\t// 初始化驱动模型中的class子系统\n    firmware_init();\t// 初始化驱动模型中的firmware子系统\n    hypervisor_init();\t// 初始化驱动模型中的hypervisor子系统\n\n    /* These are also core pieces, but must come after the\n     * core core pieces.\n     */\n    platform_bus_init();\t// 初始化驱动模型中的bus/platform子系统，此节点是所有platform设备和驱动的总线模型；所有platform设备和驱动都会挂载到这个总线上；\n    cpu_dev_init();\t\t// 初始化驱动模型中的device/system/cpu子系统，该节点包含CPU相关属性；\n    memory_dev_init();\t// 初始化驱动模型中的device/system/memory子系统，该节点包含了内存相关属性；\n    container_dev_init();\t// 初始化系统总线类型为容器；\n    of_core_init();\t\t// 初始化创建，访问和结时设备树的过程；\n}\n```\n\n\n\n\n###### 3. do_initcalls\n\n\n\n\n编译器在编译内核时，将一系列模块初始化函数的起始地址按照一定顺序，放在名为section的段中；在内核启动的初始化阶段，do_initcalls()函数中以函数指针的形式取出这些函数的其实地址，依次运行，以完成相应模块的初始化操作，是设备驱动程序初始化的第二部分；由于内核模块可能存在依赖关系，即某些模块的初始化需要依赖其他模块的初始化来完成，因此这些模块的初始化顺序非常重要；\n\n\n\n\n依次调用不同等级的初始化函数：\n\n\n```c\n// init/main.c\nstatic void __init do_initcalls(void)\n{\n    int level;\n\n    // 依次调用不同level等级的初始化函数\n    for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++)\n        do_initcall_level(level);\n}\n```\n\n\n\n\n对于同一个level等级下的函数，依次遍历执行：\n\n\n```c\n// init/main.c\nstatic void __init do_initcall_level(int level)\n{\n    initcall_t *fn;\n\n    strcpy(initcall_command_line, saved_command_line);\n    parse_args(initcall_level_names[level],\n           initcall_command_line, __start___param,\n           __stop___param - __start___param,\n           level, level,\n           NULL, &repair_env_string);\n\n    // 对于同一个level等级下的函数，依次遍历执行；\n    for (fn = initcall_levels[level]; fn < initcall_levels[level+1]; fn++)\n        do_one_initcall(*fn);\n}\n```\n\n\n\n\n开始执行某一个确定的函数：\n\n\n```c\n// init/main.c\nint __init_or_module do_one_initcall(initcall_t fn)\n{\n    int count = preempt_count();\n    int ret;\n    char msgbuf[64];\n\n    if (initcall_blacklisted(fn))\n        return -EPERM;\n\n    if (initcall_debug)\n        ret = do_one_initcall_debug(fn);\n    else\n        ret = fn();\n\n    msgbuf[0] = 0;\n\n    if (preempt_count() != count) {\n        sprintf(msgbuf, \"preemption imbalance \");\n        preempt_count_set(count);\n    }\n    if (irqs_disabled()) {\n        strlcat(msgbuf, \"disabled interrupts \", sizeof(msgbuf));\n        local_irq_enable();\n    }\n    WARN(msgbuf[0], \"initcall %pF returned with %s\\n\", fn, msgbuf);\n\n    add_latent_entropy();\n    return ret;\n}\n```\n\n\n\n\n编译到内核中的模块，是按照执行的level等级，将模块的初始化函数指针地址，分别放到相对应level等级的section中的；\n\n\ninitcall_t是一个函数指针类型：\n\n\n```c\ntypedef int (*initcall_t)(void);\n```\n\n\n\n\n```c\n// include/linux/init.h\n#define __define_initcall(fn, id) \\\n    static initcall_t __initcall_##fn##id __used \\\n    __attribute__((__section__(\".initcall\" #id \".init\"))) = fn;\n```\n\n\n\\_\\_attribute\\_\\_((\\_\\_section__())) 表示把对象放在这个由括号中的名称所指代的section中；\n\n\n\\_\\_define_initcall()宏的含义是：\n\n> 1. 声明一个名称为\\_\\_initcall\\_##fn的函数指针（其中##表示将两边的变量连接为一个变量）；\n> 2. 将这个函数指针初始化为fn；\n> 3. 编译时，要将这个函数指针变量放到名称为\".initcall\" #id \".init\"的section中；（比如：level=\"2\"，表示这个section的名称为\".initcall2.init\"）\n\n\n\n> 举例：\n>\n>  \t\\_\\_define\\_initcall(6, pci\\_init)\n>\n> 含义：\n>\n> 1. 声明一个函数指针，并赋值：\\_\\_initcall\\_pci\\_init = pci\\_init；\n> 2. 2. 编译时要将函数指针变量\\_\\_initcall\\_pci\\_init放到名称为initcall6.init的section中；（其实就是将pci\\_init函数的首地址放到名称为initcall6.init的section中）\n\n__define_initcall()宏并不会直接使用，而是被定义为其他的宏定义形式使用：\n\n\n```c\n// include/linux/init.h\n#define pure_initcall(fn)       __define_initcall(fn, 0)\n\n#define core_initcall(fn)       __define_initcall(fn, 1)\n#define core_initcall_sync(fn)      __define_initcall(fn, 1s)\n#define postcore_initcall(fn)       __define_initcall(fn, 2)\n#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)\n#define arch_initcall(fn)       __define_initcall(fn, 3)\n#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)\n#define subsys_initcall(fn)     __define_initcall(fn, 4)\n#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)\n#define fs_initcall(fn)         __define_initcall(fn, 5)\n#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)\n#define rootfs_initcall(fn)     __define_initcall(fn, rootfs)\n#define device_initcall(fn)     __define_initcall(fn, 6)\n#define device_initcall_sync(fn)    __define_initcall(fn, 6s)\n#define late_initcall(fn)       __define_initcall(fn, 7)\n#define late_initcall_sync(fn)      __define_initcall(fn, 7s)\n```\n\n\n通过core_initcall()来声明的函数指针，将被放到名为.initcall1.init的section中；通过postcore_initcall()来声明的函数指针，将被放到名为.initcall2.init的section中；以此类推；\n\n> 举例：\n>\n>  \tdevice_initcall(pci_init);\n>\n> 含义：\n>\n> 1. 声明一个函数指针，并赋值：\\_\\_initcall\\_pci\\_init = pci\\_init；\n> 2. 编译时要将函数指针变量\\_\\_initcall\\_pci\\_init放到名称为initcall6.init的section中；（其实就是将pci\\_init函数的首地址放到名称为initcall6.init的section中）\n\n在编译生成的vmlinux.lds文件中，可以找到initcall相关的定义：\n\n\n```c\n// tmp/bsp/DBG/BOARDLX2160LE/ARMQORIQLE/kernel/kernels/linux-4.9.115-cgel/arch/arm64/kernel/vmlinux.lds\n  __initcall_start = .; KEEP(*(.initcallearly.init))\n  __initcall0_start = .; KEEP(*(.initcall0.init)) KEEP(*(.initcall0s.init))\n  __initcall1_start = .; KEEP(*(.initcall1.init)) KEEP(*(.initcall1s.init))\n  __initcall2_start = .; KEEP(*(.initcall2.init)) KEEP(*(.initcall2s.init))\n  __initcall3_start = .; KEEP(*(.initcall3.init)) KEEP(*(.initcall3s.init))\n  __initcall4_start = .; KEEP(*(.initcall4.init)) KEEP(*(.initcall4s.init))\n  __initcall5_start = .; KEEP(*(.initcall5.init)) KEEP(*(.initcall5s.init))\n  __initcallrootfs_start = .; KEEP(*(.initcallrootfs.init)) KEEP(*(.init     callrootfss.init))\n  __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init))\n  __initcall7_start = .; KEEP(*(.initcall7.init)) KEEP(*(.initcall7s.init))\n  __initcall_end = .;\n```\n\n\n在这些section中，总的开始位置被标识为\\_\\_initcall\\_start，而在结尾被标识为\\_\\_initcall\\_end；\n\n\n\n\ndo_initcalls()函数，会从这些section中依次取出所有的函数指针，并按顺序调用这些函数指针调用的函数，来分别完成内核中驱动模块的初始化操作；\n\n\n函数指针被放到哪个section中，是由宏定义\\_\\_define\\_initcall(fn, id)的参数id，也就是level决定的，对应level更小的子section的位置更靠前；而位于同一个子section中的函数指针顺序不定，由编译器按照编译顺序随机决定；\n\n\n\n\n```c\n// init/main.c\nstatic initcall_t *initcall_levels[] __initdata = {\n    __initcall0_start,\n    __initcall1_start,\n    __initcall2_start,\n    __initcall3_start,\n    __initcall4_start,\n    __initcall5_start,\n    __initcall6_start,\n    __initcall7_start,\n    __initcall_end,\n};\n```\n\n\n\n\n\n\n##### 3.6.3 ramdisk_execute_command\n\n\n```c\n// init/main.c\n\tif (!ramdisk_execute_command)\n        ramdisk_execute_command = \"/init\";\n```\n\n\nkernel_init_freeable()函数会去判断ramdisk_execute_command是否为空，如果不为空，就直接运行ramdisk_execute_command指定的程序；ramdisk_execute_command的取值分以下情况：\n\n> 1. 如果命令行参数中指定了“rdinit=...”，则ramdisk_execute_command等于这个参数指定的程序；\n> 2. 否则，如果/init程序存在，ramdisk_execute_command=/init；\n> 3. 否则，ramdisk_execute_command为空；\n\n```c\n// init/main.c\nif (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {\n    ramdisk_execute_command = NULL;\n    prepare_namespace();\n}\n```\n\n\n\n\n#### 3.7 free_initmem\n\n\nfree_initmem()函数用来释放所有init.段中的内存；\n\n\n```c\n// arch/arm64/mm/init.c\nvoid free_initmem(void)\n{\n    free_reserved_area(__va(__pa(__init_begin)), __va(__pa(__init_end)),\n               0, \"unused kernel\");\n    /*\n     * Unmap the __init region but leave the VM area in place. This\n     * prevents the region from being reused for kernel modules, which\n     * is not supported by kallsyms.\n     */\n    unmap_kernel_range((u64)__init_begin, (u64)(__init_end - __init_egin));\n}\n```\n\n\n\n\n#### 3.8 启动用户态init进程\n\n\n```c\n// kernel/init/main.c\nkernel_init()\n    if (ramdisk_execute_command) {\n        ret = run_init_process(ramdisk_execute_command);\n        if (!ret)\n            return 0;\n        pr_err(\"Failed to execute %s (error %d)\\n\",\n               ramdisk_execute_command, ret);\n    }\n    if (execute_command) {\n        ret = run_init_process(execute_command);\n        if (!ret)\n            return 0;\n        panic(\"Requested init %s failed (error %d).\",\n              execute_command, ret);\n    }\n    if (!try_to_run_init_process(\"/sbin/init\") ||\n        !try_to_run_init_process(\"/etc/init\") ||\n        !try_to_run_init_process(\"/bin/init\") ||\n        !try_to_run_init_process(\"/bin/sh\"))\n        return 0;\n```\n\n\n\n```c\nstatic int try_to_run_init_process(const char *init_filename)\n{\n    int ret;\n\n    ret = run_init_process(init_filename);\n    return ret;\n}\n```\n\n\n\n\n```c\nstatic int run_init_process(const char *init_filename)\n{\n    argv_init[0] = init_filename;\n    return do_execve(getname_kernel(init_filename),\n        (const char __user *const __user *)argv_init,\n        (const char __user *const __user *)envp_init);\n}\n```\n\n\n在大多数系统中，bootloader会传递参数给内核的main函数，而这些参数中会包含init=/linuxrc参数，于是在kernel_init进程中，如果有execute_command = \"linuxrc\"，在经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行，通过do_execve()函数进入用户态，开始文件系统的初始化init进程；\n\n\n如果boot没有传递init=/linuxrc参数给内核，ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；\n\n\n\n\n```c\npanic(\"No working init found.  Try passing init= option to kernel. \"\n          \"See Linux Documentation/init.txt for guidance.\");\n```\n\n\n出现这种异常错误，可能是以下几个原因造成：\n\n> 1. 启动参数配置错误，指定了init，但是未找到；\n> 2. 文件系统挂载出错；\n> 3. 四个应用程序找不到，或者没有可执行权限；\n\n到此，Linux内核部分启动结束，下一步会在文件系统中启动用户空间的init进程，并进行下一步的启动操作；\n\n\n\n\n### 4. filesystem启动\n\n\n```mermaid\ngraph LR\n\tkernel_init(\"kernel_init()\")--\"init=linuxrc\"-->linuxrc(linuxrc)\n\t--链接-->busybox(\"/bin/busybox\")\n\tkernel_init(\"kernel_init()\")--default-->init(\"/sbin/init\")\n\t--链接-->busybox(\"/bin/busybox\")\n\t--inittab-->rcS(\"/etc/init.d/rcS\")\n```\n\n\n#### 4.1 filesystem构建\n\n\n文件系统可以通过busybox工具来构建；构建成功之后，一般情况下是不需要修改的；我们使用的文件系统，由成研提供；具体的构建方法此处先省略，有时间再补上；\n\n\n#### 4.2 busybox程序\n\n\n在Kernel挂载文件系统后，通过kernel_init()函数，准备运行init进程；\n\n\n在kernel/init/main.c文件中\n\n\n```c\n// kernel/init/main.c\nkernel_init()\n{\n    if (ramdisk_execute_command) {\n        ret = run_init_process(ramdisk_execute_command);\n        if (!ret)\n            return 0;\n        pr_err(\"Failed to execute %s (error %d)\\n\",\n               ramdisk_execute_command, ret);\n    }\n\tif (execute_command) {\n        ret = run_init_process(execute_command);\n        if (!ret)\n            return 0;\n        panic(\"Requested init %s failed (error %d).\",\n              execute_command, ret);\n    }\n\tif (!try_to_run_init_process(\"/sbin/init\") ||\n        !try_to_run_init_process(\"/etc/init\") ||\n        !try_to_run_init_process(\"/bin/init\") ||\n        !try_to_run_init_process(\"/bin/sh\"))\n        return 0;\n}\n```\n\n\n经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行；而linuxrc文件是一个指向/bin/busybox的链接，也就是说，系统启动后运行的第一个程序是/bin/busybox；\n\n\n```shell\n# ls linuxrc -l\nlrwxrwxrwx 1 root root 11 Mar  4 10:04 linuxrc -> bin/busybox\n```\n\n\n如果ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；而/sbin/init文件也是链接到/bin/busybox的，最终还是会执行/bin/busybox程序；创建用户空间运行的第一个进程；\n\n\n```shell\n# ls /sbin/init -l\nlrwxrwxrwx    1 root     root            14 Dec 12  2019 /sbin/init -> ../bin/busybox\n```\n\n\n\n\n#### 4.3 init进程\n\n\nbusybox程序运行，会启动init进程，init进程在Linux系统中是最早运行的进程，也就是1号进程；\n\n\n```shell\n# ps -aux | grep init\nroot         1  0.8  0.0   2080    12 ?        Ss   18:47   0:20 init\n```\n\n\n\n\ninit进程进行的工作：\n\n> 1. 为init设置信号处理过程\n> 2. 初始化控制台\n> 3. 解析/etc/inittab文件\n> 4. 执行系统初始化命令，一般情况下会使用/etc/init.d/rcS\n> 5. 执行所有导致init暂停的inittab命令（动作类型：wait）\n> 6. 执行所有仅执行一次的inittab命令（动作类型：once）\n\n执行完以上工作后，init进程会循环执行以下进程：\n\n> 1.执行所有终止时必须重新启动的inittab命令（动作类型：respawn）\n>\n> 2.执行所有终止时必须重新启动但启动前必须询问用户的inittab命令（动作类型：askfirst）\n\n\n\n\n\n#### 4.4 inittab\n\n\nbusybox程序解析/etc/inittab文件，而/etc/inittab是进行初始化的配置文件；busybox运行时会按照格式解析inittab文件，根据解析内容决定具体工作；\n\n\n```shell\n# cat /etc/inittab\n::sysinit:/etc/init.d/rcS\n#::once:/bin/sw &\n#The followed sentence does't need password.\n::respawn:-/bin/ash\n#The followed sentence does need password.\n#::respawn:-/bin/login\n#tty2::askfirst:-/bin/ash\n::ctrlaltdel:/bin/umount -a -r\n```\n\n\n\n\ninittab的内容以行为单位，行与行之间没有关联，每行都是一个独立的配置项；每一行的配置项都是由3个冒号分隔开的4个配置值组成，冒号是分隔符，分隔开各个部分；\n\n\ninittab文件里的代码格式：\n\n\n\\<id>:\\<runlevels>:\\<action>:\\<process>\n\n\n说明：\n\n> id：/dev/id，用作终端terminal：stdin、stdout、stderr、printf、scanf、err\n>\n> runlevels：\n>\n> action：执行时机；包括：sysinit、respawd、askfirst、wait、once、restart、ctrialtdel、shutdown\n>\n> process：应用程序和脚本\n\n\n\n#### 4.5 rcS\n\n\n在/etc/inittab配置文件中，action为sysinit的行，表示在Linux系统初始化文件系统时执行的第一个脚本，即：/etc/init.d/rcS；\n\n\n```shell\n::sysinit:/etc/init.d/rcS\n```\n\n\n主要进行一些初始化工作：启动交换分区、检查磁盘、设置主机名、检查并挂载文件系统、加载并初始化硬件模块等；\n\n\n\n\n/etc/init.d/rcS文件是Linux运行时非常重要的一个脚本程序；其他的配置在rcS文件中进行，rcS文件中的配置可以根据需求进行扩展；/etc/init.d/rcS完成各个文件系统的挂载（mount），以及文件硬件模块的初始化；\n\n\n\n\n\n\n### 5. 应用进程启动\n\n\n\n\n应用进程，可以在文件系统的/etc/init.d/rcS脚本运行时，调用xxx.sh脚本拉起来的；\n\n\n\n\n\n\n\n[跳转到目录](#目录)","slug":"Linux内核启动流程-基于ARM64","published":1,"updated":"2020-05-07T14:20:30.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkux0008dqg1g7d7hb83","content":"<p>以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；</p>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"0-简述\"><a href=\"#0-简述\" class=\"headerlink\" title=\"0. 简述\"></a>0. 简述</h3><p>以arm64为例，讲述Linux在ARM64架构设备上的系统启动流程；</p>\n<p>上电启动，系统启动要经过uboot、kernel、filesystem、ADM几个过程，如下：</p>\n<pre class=\"mermaid\">graph LR\n    uboot(uboot)-->kernel(kernel)\n    -->filesystem(filesystem)\n    -->Software(Software)</pre>\n\n\n\n\n\n\n<p>在大多数系统中，内核镜像在uboot阶段被加载到内存中，并获得控制权开始内核的启动流程；</p>\n<pre class=\"mermaid\">graph LR\n    uboot(uboot)-->kernel(kernel)</pre>\n\n\n\n\n<p>Linux内核版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linux-4.9.115</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uname -a</span></span><br><span class=\"line\">Linux vexpress 4.9.115 #2 SMP Wed Apr 1 22:49:35 CST 2020 aarch64 GNU/Linux</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明</strong>：由于Linux内核系统庞大繁杂，要想把内核启动中的每个细节都描述清楚，基本上不可能，更何况作者能力水平也达不到；因此，就在追踪内核启动流程代码的同时，只描述比较重要的几个部分；可以在以后的工作、学习中，随着水平的提高，不断地增加内容；</p>\n<h3 id=\"1-目标文件\"><a href=\"#1-目标文件\" class=\"headerlink\" title=\"1. 目标文件\"></a>1. 目标文件</h3><p>内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照vmlinux.lds设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序；</p>\n<h4 id=\"1-1-vmlinux-lds\"><a href=\"#1-1-vmlinux-lds\" class=\"headerlink\" title=\"1.1 vmlinux.lds\"></a>1.1 vmlinux.lds</h4><p>vmlinux.lds文件是在内核编译时生成的，是被禁止编辑的；vmlinux.lds文件是在编译时，由vmlinux.lds.S文件对链接器ld的输出进行排序后生成；vmlinux.lds.S是用来对输出文件中的段进行排序，并定义相关的符号名；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S</span><br></pre></td></tr></table></figure>\n\n\n<p>在项目中通过make时指定的参数-O，将内核编译生成的所有目标文件，包括vmlinux.lds文件重定向输出到以下目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch/arm64/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>\n\n\n<p>vmlinux.lds文件是链接脚本，在内核编译时，作为Makefile的链接器脚本，参与链接生成内核映像vmlinux；</p>\n<p>总之：vmlinux是按照vmlinux.lds链接生成的，而vmlinux.lds是由vmlinux.lds.S生成的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/vmlinux.lds</span></span><br><span class=\"line\">OUTPUT_ARCH(aarch64)\t<span class=\"comment\">// 指定架构为aarch64</span></span><br><span class=\"line\">ENTRY(_text)\t\t\t<span class=\"comment\">// 定义入口为_text</span></span><br><span class=\"line\">jiffies = jiffies_64;\t<span class=\"comment\">// 定义为64位计数器</span></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// 指定链接地址</span></span><br><span class=\"line\">    . = ((((<span class=\"number\">0xffffffffffffffff</span> - (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">48</span>)) + <span class=\"number\">1</span>) + (<span class=\"number\">0</span>)) + (<span class=\"number\">0x08000000</span>))) + <span class=\"number\">0x00080000</span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>关于段的信息</p>\n<blockquote>\n<p>text段，代码段，用来存放程序执行代码的一块内存区域；大小在程序运行前确定；</p>\n<p>data段，数据段，用来存放程序中已初始化的全局变量的内存区域；数据段属于静态内存分配；</p>\n<p>bss段，用来存放程序中未初始化的全局变量和静态变量的一块内存区域；属于静态内存分配；</p>\n<p>init段，Linux定义的一种初始化过程中才能用到的段；初始化完成后，该段内存会被释放；</p>\n</blockquote>\n<p>关于地址的信息</p>\n<blockquote>\n<p>加载地址：程序中指令和变量等加载到RAM上的地址；</p>\n<p>运行地址：CPU执行一条程序的指令时的执行地址，即PC寄存器的值；就是要寻址到一个指令或变量所使用的地址；</p>\n<p>链接地址：链接过程中链接器为指令和变量分配的地址；</p>\n</blockquote>\n<h4 id=\"1-2-内核映像\"><a href=\"#1-2-内核映像\" class=\"headerlink\" title=\"1.2 内核映像\"></a>1.2 内核映像</h4><p>vmlinux是未压缩的内核，是生成的纯内核二进制文件，具有用户定义的所有内核组件，但是这个vmlinux二进制文件是无法启动系统的；为了将Linux内核映像加载到内存并处于可执行状态，内核构建系统使用objcopy命令清除不必要的节区，压缩ELF格式的vmlinux，通过引导程序加载项和链接，生成可启动的最终的二进制文件zImage；</p>\n<p>vmlinux通过gzip压缩成piggy.o，和head.o、misc.o链接生成zImage二进制文件；</p>\n<p>vmlinuz是vmlinux的压缩文件</p>\n<p>zImage默认的压缩内核映像文件，压缩vmlinux，加上一段解压启动代码，压缩而成；</p>\n<p>uImage是u-boot使用bootm命令引导的Linux压缩内核映像文件格式，是使用mkimage工具对普通的压缩内核映像文件（zImage）加工而成；</p>\n<p>uImage是uboot专用的内核映像文件，是在zImage之前加上一个长度为64字节的“头”，说明内核的版本、加载位置、生成时间、大小等信息；在地址0x40之后的部分，和zImage一样；其大小比zImage大64字节；</p>\n<h4 id=\"1-3-设备树文件\"><a href=\"#1-3-设备树文件\" class=\"headerlink\" title=\"1.3 设备树文件\"></a>1.3 设备树文件</h4><p>Linux内核从3.x版本开始引入设备树的概念，用于实现驱动代码与设备信息分离；设备树出现之前，所有关于设备的具体信息都写在驱动中，外围设备变化，驱动代码就要跟着修改甚至是重写；引入设备树之后，驱动代码只负责处理驱动代码的逻辑，而关于设备的具体信息存放到设备树文件中，这样硬件接口信息变化时，只需要修改设备树文件信息，不需要修改驱动代码就可以；</p>\n<p>一般情况下，在编译设备树之前，先在scripts/dtc/目录下，编译生成dtc工具scripts/dtc/dtc，再使用生成的dtc工具编译设备树源码，生成设备树文件；设备树源码和目标文件在arch/arm64/boot/dts/freescale/目录；</p>\n<p>在Lx2160板项目中，目标文件会被重定向输出到target目录；</p>\n<p>具体的设备树文件的加载、解析过程，会在下文setup_arch部分描述；</p>\n<h3 id=\"2-内核启动第一阶段\"><a href=\"#2-内核启动第一阶段\" class=\"headerlink\" title=\"2. 内核启动第一阶段\"></a>2. 内核启动第一阶段</h3><p>Linux内核启动第一阶段，也就是我们常说的汇编阶段，也就是stext函数的实现内容；这部分主要完成的工作：CPU ID检查，machine ID检查，创建初始化页表，设置C代码运行环境，跳转到内核第一个真正的C函数start_kernel执行；</p>\n<p>设置为SVC模式，关闭所有中断</p>\n<p>获取CPUID，提取相应的proc info</p>\n<p>验证tags或dtb</p>\n<p>创建页表项</p>\n<p>head.S文件中，</p>\n<p>校验启动合法性</p>\n<p>建立段式映射的页表并开启MMU</p>\n<p>构建C运行环境，跳入C阶段</p>\n<h4 id=\"2-1-内核启动入口点\"><a href=\"#2-1-内核启动入口点\" class=\"headerlink\" title=\"2.1 内核启动入口点\"></a>2.1 内核启动入口点</h4><p>内核是一个庞大的系统，通过vmlinux反向追踪启动入口点</p>\n<p>Lx2160le板的交叉编译工具链：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>通过对目标文件vmlinux的反向追溯，找到Linux执行的入口；</p>\n<p>使用readelf命令可以查看vmlinux的入口地址为：0xffff000008080000</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> readelf -h vmlinux</span></span><br><span class=\"line\">ELF Header:</span><br><span class=\"line\">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">  Class:                             ELF64</span><br><span class=\"line\">  Data:                              2's complement, little endian</span><br><span class=\"line\">  Version:                           1 (current)</span><br><span class=\"line\">  OS/ABI:                            UNIX - System V</span><br><span class=\"line\">  ABI Version:                       0</span><br><span class=\"line\">  Type:                              EXEC (Executable file)</span><br><span class=\"line\">  Machine:                           AArch64</span><br><span class=\"line\">  Version:                           0x1</span><br><span class=\"line\">  Entry point address:               0xffff000008080000</span><br><span class=\"line\">  Start of program headers:          64 (bytes into file)</span><br><span class=\"line\">  Start of section headers:          267014976 (bytes into file)</span><br><span class=\"line\">  Flags:                             0x0</span><br><span class=\"line\">  Size of this header:               64 (bytes)</span><br><span class=\"line\">  Size of program headers:           56 (bytes)</span><br><span class=\"line\">  Number of program headers:         4</span><br><span class=\"line\">  Size of section headers:           64 (bytes)</span><br><span class=\"line\">  Number of section headers:         39</span><br><span class=\"line\">  Section header string table index: 36</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>这个入口地址是怎么来的，对应内核代码中的哪个部分，可以通过反汇编来分析；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aarch64-linux-gnu-objdump -dxh vmlinux &gt; vmlinux.s</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>在得到的汇编文件vmlinux.s中查找入口地址：0xffff000008080000</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start address <span class=\"number\">0xffff000008080000</span></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .head.<span class=\"built_in\">text</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">ffff000008080000 &lt;_text&gt;:</span><br><span class=\"line\">ffff000008080000:       <span class=\"number\">91005</span>a4d        add     x13, x18, #<span class=\"number\">0x16</span></span><br><span class=\"line\">ffff000008080004:       <span class=\"number\">14437f</span>ff        b       ffff000009160000 &lt;stext&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>可以得到，Linux入口的第一条指令为：add     x13, x18, #0x16；对应的符号是：.head.text  _text；</p>\n<p>而.head.text段，通过include/linux/init.h文件中的宏定义__HEAD来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* For assembly routines */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __HEAD      .section    <span class=\"meta-string\">\".head.text\"</span>,<span class=\"meta-string\">\"ax\"</span>\t<span class=\"comment\">// \"ax\"表示所在段区域有可执行权限</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __INIT      .section    <span class=\"meta-string\">\".init.text\"</span>,<span class=\"meta-string\">\"ax\"</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>内核启动的入口点，在arch/arm64/kernel/head.S文件中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    __HEAD</span><br><span class=\"line\">_head:</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_EFI</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * This add instruction has no meaningful effect except that</span></span><br><span class=\"line\"><span class=\"comment\">     * its opcode forms the magic \"MZ\" signature required by UEFI.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    add x13, x18, #<span class=\"number\">0x16</span></span><br><span class=\"line\">    b   stext</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    b   stext               <span class=\"comment\">// branch to kernel start, magic</span></span><br><span class=\"line\">    .<span class=\"keyword\">long</span>   <span class=\"number\">0</span>               <span class=\"comment\">// reserved</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>到此，已经找到，目标文件vmlinux的入口是arch/arm64/kernel/head.S文件中的__HEAD，在执行完第一条语句（add x13, x18, #0x16）之后，跳转到stext函数执行（b   stext）；所以，加载vmlinux后，第一个运行的函数是stext；</p>\n<h4 id=\"2-2-stext函数\"><a href=\"#2-2-stext函数\" class=\"headerlink\" title=\"2.2 stext函数\"></a>2.2 stext函数</h4><p>启动过程中的汇编阶段，是从arch/arm64/kernel/head.S文件开始，执行的起点是stext函数，入口函数是通过vmlinux.lds链接而成，在head.S中ENTRY(stext)指定；</p>\n<p>在汇编代码中，宏定义ENTRY和ENDPROC是成对出现的，表示定义的一个函数，同时也要指明当前代码所在的段，如：__INIT；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __INIT      .section    <span class=\"meta-string\">\".init.text\"</span>,<span class=\"meta-string\">\"ax\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t__INIT</span><br><span class=\"line\">ENTRY(stext)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(stext)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>内核启动的必要条件：MMU关闭，D-cache关闭，x0是传递给FDT blob的物理地址；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* The requirements are:</span><br><span class=\"line\">*   MMU = off, D-cache = off, I-cache = on <span class=\"keyword\">or</span> off,</span><br><span class=\"line\">*   x0 = physical address to the FDT blob.</span><br></pre></td></tr></table></figure>\n\n\n\n<p>stext函数开始执行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">\t__INIT</span><br><span class=\"line\">ENTRY(stext)</span><br><span class=\"line\">    bl  preserve_boot_args\t<span class=\"comment\">// Preserve the arguments passed by the bootloader in x0 ... x3</span></span><br><span class=\"line\">    bl  el2_setup           <span class=\"comment\">// Drop to EL1, w0=cpu_boot_mode</span></span><br><span class=\"line\">    adrp    x23, __PHYS_OFFSET</span><br><span class=\"line\">    <span class=\"keyword\">and</span> x23, x23, MIN_KIMG_ALIGN - <span class=\"number\">1</span>    <span class=\"comment\">// KASLR offset, defaults to 0</span></span><br><span class=\"line\">    bl  set_cpu_boot_mode_flag</span><br><span class=\"line\">    bl  __create_page_tables</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span></span><br><span class=\"line\"><span class=\"comment\">   * details.</span></span><br><span class=\"line\"><span class=\"comment\">   * On return, the CPU will be ready for the MMU to be turned on and</span></span><br><span class=\"line\"><span class=\"comment\">   * the TCR will have been set.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">     bl  __cpu_setup         <span class=\"comment\">// initialise processor</span></span><br><span class=\"line\">     b   __primary_switch</span><br><span class=\"line\">ENDPROC(stext)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"1-preserve-boot-args\"><a href=\"#1-preserve-boot-args\" class=\"headerlink\" title=\"1. preserve_boot_args\"></a>1. preserve_boot_args</h5><p>保存从bootloader传递过来的x0 ~ x3参数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">preserve_boot_args:</span><br><span class=\"line\">    mov x21, x0\t\t\t\t<span class=\"comment\">// 将dtb的地址暂存在x21寄存器，释放出x0使用</span></span><br><span class=\"line\">    adr_l   x0, boot_args\t<span class=\"comment\">// x0保存boot_args变量的地址</span></span><br><span class=\"line\">    stp x21, x1, [x0]\t\t<span class=\"comment\">// 将x0、x1的值保存到boot_args[0]、boot_args[1]</span></span><br><span class=\"line\">    stp x2, x3, [x0, #<span class=\"number\">16</span>]\t<span class=\"comment\">// 将x2、x3的值保存到boot_args[2]、boot_args[3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dmb sy              <span class=\"comment\">// needed before dc ivac with</span></span><br><span class=\"line\">                        <span class=\"comment\">// MMU off</span></span><br><span class=\"line\"></span><br><span class=\"line\">    add x1, x0, #<span class=\"number\">0x20</span>\t\t<span class=\"comment\">// x0、x1作为nval_cache_range函数的参数</span></span><br><span class=\"line\">    b   __inval_cache_range     <span class=\"comment\">// tail call</span></span><br><span class=\"line\">ENDPROC(preserve_boot_args)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-el2-setup\"><a href=\"#2-el2-setup\" class=\"headerlink\" title=\"2. el2_setup\"></a>2. el2_setup</h5><p>到此，CPU处于哪个exception level？根据ARM64 boot protocol，CPU处于EL2（推荐）或者secure EL1；如果处于EL2，需要将CPU退回到EL1；此部分还没有搞明白，暂时先跳过；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">ENTRY(el2_setup)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(el2_setup)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-set-cpu-boot-mode-flag\"><a href=\"#3-set-cpu-boot-mode-flag\" class=\"headerlink\" title=\"3. set_cpu_boot_mode_flag\"></a>3. set_cpu_boot_mode_flag</h5><p>set_cpu_boot_mode_flag函数，用来设置__boot_cpu_mode flag；需要一个前提条件：w20寄存器中保存了CPU启动时的异常等级（Exception level）；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">set_cpu_boot_mode_flag:</span><br><span class=\"line\">    adr_l   x1, __boot_cpu_mode</span><br><span class=\"line\">    cmp w0, #BOOT_CPU_MODE_EL2</span><br><span class=\"line\">    b.ne    <span class=\"number\">1f</span></span><br><span class=\"line\">    add x1, x1, #<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">1</span>:  str w0, [x1]            <span class=\"comment\">// This CPU has booted in EL1</span></span><br><span class=\"line\">    dmb sy</span><br><span class=\"line\">    dc  ivac, x1            <span class=\"comment\">// Invalidate potentially stale cache line</span></span><br><span class=\"line\">    ret</span><br><span class=\"line\">ENDPROC(set_cpu_boot_mode_flag)</span><br></pre></td></tr></table></figure>\n\n\n<p>由于系统启动之后，需要了解CPU启动时候的Exception level，因此需要一个全局变量__boot_cpu_mode来保存启动时的CPU mode；</p>\n<p>全局变量__boot_cpu_mode定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY(__boot_cpu_mode)</span><br><span class=\"line\">    .<span class=\"keyword\">long</span>   BOOT_CPU_MODE_EL2</span><br><span class=\"line\">    .<span class=\"keyword\">long</span>   BOOT_CPU_MODE_EL1</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4-create-page-tables\"><a href=\"#4-create-page-tables\" class=\"headerlink\" title=\"4. __create_page_tables\"></a>4. __create_page_tables</h5><p>建立页表初始化的过程；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">__create_page_tables:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(__create_page_tables)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"5-cpu-setup\"><a href=\"#5-cpu-setup\" class=\"headerlink\" title=\"5. __cpu_setup\"></a>5. __cpu_setup</h5><p>CPU的初始化设置；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/mm/proc.S</span></span><br><span class=\"line\">ENTRY(__cpu_setup)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(__cpu_setup)</span><br></pre></td></tr></table></figure>\n\n\n<p>主要的内容包括：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、cache和TLB的处理</span><br><span class=\"line\">2、Memory attributes lookup table的创建</span><br><span class=\"line\">3、SCTLR_EL1、TCR_EL1的设定</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"6-primary-switch\"><a href=\"#6-primary-switch\" class=\"headerlink\" title=\"6. __primary_switch\"></a>6. __primary_switch</h5><p>主要工作是为打开MMU做准备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">__primary_switch:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tbl  __enable_mmu\t\t\t<span class=\"comment\">// 开启MMU</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    ldr x8, =__primary_switched</span><br><span class=\"line\">    adrp    x0, __PHYS_OFFSET</span><br><span class=\"line\">    blr x8</span><br><span class=\"line\">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure>\n\n\n<p>在函数中通过__enable_mmu函数来开启MMU，并调用__primary_switched函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">__primary_switched:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    b   start_kernel</span><br><span class=\"line\">ENDPROC(__primary_switched)</span><br></pre></td></tr></table></figure>\n\n\n<p>在__primary_switched函数中，进行一些C环境的准备，并在最后，调用执行start_kernel函数，内核的启动进入到C语言环境阶段；</p>\n<pre class=\"mermaid\">graph TB\n    subgraph 入口函数\n    A_Explain(保存boot参数)\n    -->\n    B_Explain(EL2设置)\n    -->\n    C_Explain(设置CPU启动模式flag)\n    -->\n    D_Explain(创建页表)\n    -->\n    E_Explain(CPU配置)\n    -->\n    F_Explain(主要的转换操作)\n    -->\n    G_Explain(运行start_kernel函数)\n    end\n\n    subgraph stext\n    A_func(preserve_boot_args)\n    -->\n    B_func(el2_setup)\n    -->\n    C_func(set_cpu_boot_mode_flag)\n    -->\n    D_func(__create_page_tables)\n    -->\n    E_func(__cpu_setup)\n    -->\n    F_func(__primary_switch)\n    -->\n    G_func(start_kernel)\n    end</pre>\n\n\n\n\n<h4 id=\"2-3-参考资料\"><a href=\"#2-3-参考资料\" class=\"headerlink\" title=\"2.3 参考资料\"></a>2.3 参考资料</h4><p><a href=\"https://blog.csdn.net/xiaohua0877/article/details/78615776\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiaohua0877/article/details/78615776</a></p>\n<p><a href=\"http://www.wowotech.net/sort/armv8a_arch\" target=\"_blank\" rel=\"noopener\">http://www.wowotech.net/sort/armv8a_arch</a></p>\n<h3 id=\"3-内核启动第二阶段\"><a href=\"#3-内核启动第二阶段\" class=\"headerlink\" title=\"3. 内核启动第二阶段\"></a>3. 内核启动第二阶段</h3><p>Linux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；</p>\n<pre class=\"mermaid\">graph TB\n    A(start_kernel)-->B(一系列的初始化操作)\n    subgraph start_kernel\n    B(一系列的初始化操作)\n    -->\n    C(setup_arch)\n    -->\n    D(一系列的初始化操作)\n    -->\n    E(rest_init)\n    end</pre>\n\n\n\n\n<h4 id=\"3-1-start-kernel\"><a href=\"#3-1-start-kernel\" class=\"headerlink\" title=\"3.1 start_kernel\"></a>3.1 start_kernel</h4><p>start_kernel()函数在init/main.c文件中，主要完成Linux子系统的初始化工作；此部分初始化内容繁多，暂时先略过，此处省略好多字；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\">asmlinkage __visible <span class=\"keyword\">void</span> __init <span class=\"title\">start_kernel</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pr_notice(<span class=\"string\">\"%s\"</span>, linux_banner);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> linux_banner[] =</span><br><span class=\"line\">    <span class=\"string\">\"Linux version \"</span> UTS_RELEASE <span class=\"string\">\" (\"</span> LINUX_COMPILE_BY <span class=\"string\">\"@\"</span></span><br><span class=\"line\">    LINUX_COMPILE_HOST <span class=\"string\">\") (\"</span> LINUX_COMPILER <span class=\"string\">\") \"</span> UTS_VERSION <span class=\"string\">\"\\n\"</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>执行的效果是，在内核启动初期，打印内核版本号和构建信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux version 4.9.115 (root@localhost.localdomain) (gcc version 6.2.0 20170314 ZTE Embsys-TSP V3.06.40 (GCC) ) #2 SMP PREEMPT Tue Mar 10 11:21:00 CST 2020</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-2-setup-arch\"><a href=\"#3-2-setup-arch\" class=\"headerlink\" title=\"3.2 setup_arch\"></a>3.2 setup_arch</h4><p>setup_arch()函数，是体系结构相关的，该函数根据处理器、硬件平台具体型号设置系统；及解析系统命令行，系统内存管理初始化，统计并注册系统各种资源等；每个体系都有自己的setup_arch()函数，是由顶层Makefile中的ARCH变量定义的，我们使用的是ARCH=arm64，因此，这里的setup_arch()函数，也是arm64的体系结构相关的；参数是未被初始化的内部变量command_line；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\">asmlinkage __visible <span class=\"keyword\">void</span> __init <span class=\"title\">start_kernel</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tsetup_arch(&amp;command_line);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>setup_arch()函数中的初始化内容比较多，目前<strong>只对设备树相关的部分进行简要描述</strong>；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/setup.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">setup_arch</span><span class=\"params\">(<span class=\"keyword\">char</span> **cmdline_p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">\tsetup_machine_fdt(__fdt_pointer);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acpi_disabled)</span><br><span class=\"line\">        unflatten_device_tree();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    A(setup_arch)-->B(加载设备树)\n    B(加载设备树)-->C(setup_machine_fdt)\n    B(加载设备树)-->D(unflatten_device_tree)</pre>\n\n\n\n\n<h5 id=\"1-setup-machine-fdt\"><a href=\"#1-setup-machine-fdt\" class=\"headerlink\" title=\"1. setup_machine_fdt\"></a>1. setup_machine_fdt</h5><p>setup_machine_fdt()函数的输入参数是设备树（DTB）首地址；uboot启动程序把设备树读取到内存中，之后在启动内核的同时，将设备树首地址传给内核，setup_machine_fdt()函数的参数__fdt_pointer就是uboot传给内核的设备树地址；函数中的fdt(flat device tree)表示，设备树在内存中是在一块连续地址存储的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/setup.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __init <span class=\"title\">setup_machine_fdt</span><span class=\"params\">(<span class=\"keyword\">phys_addr_t</span> dt_phys)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *dt_virt = fixmap_remap_fdt(dt_phys);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">            cpu_relax();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dump_stack_set_arch_desc(<span class=\"string\">\"%s (DT)\"</span>, of_flat_dt_get_machine_name());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/setup.c</span></span><br><span class=\"line\"><span class=\"keyword\">phys_addr_t</span> __fdt_pointer __initdata;</span><br></pre></td></tr></table></figure>\n\n\n<p>全局变量__fdt_pointer指向内存中的DTB，是设备树的物理地址；这个物理地址是由bootloader传递给内核的，在内核中使用，是需要转换为虚拟地址才能访问，而这个转换，由fixmap_remap_fdt()函数来完成；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/fdt.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> __init <span class=\"title\">early_init_dt_scan</span><span class=\"params\">(<span class=\"keyword\">void</span> *params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> status;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = early_init_dt_verify(params);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!status)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    early_init_dt_scan_nodes();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>接下来调用的early_init_dt_scan()函数，通过进一步调用early_init_dt_verify()函数来检查DTB数据是否完整，经过内存映射之后，就可以直接访问DTB中的内容了；</p>\n<h5 id=\"2-unflatten-device-tree\"><a href=\"#2-unflatten-device-tree\" class=\"headerlink\" title=\"2. unflatten_device_tree\"></a>2. unflatten_device_tree</h5><p>unflatten_device_tree()函数完成对设备树的解析，所做的工作是将设备树各节点转换成相应的struct device_node结构体；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/fdt.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">unflatten_device_tree</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __unflatten_device_tree(initial_boot_params, <span class=\"literal\">NULL</span>, &amp;of_root,</span><br><span class=\"line\">                early_init_dt_alloc_memory_arch, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get pointer to \"/chosen\" and \"/aliases\" nodes for use everywhere */</span></span><br><span class=\"line\">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/base.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_node</span> *<span class=\"title\">of_root</span>;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *__unflatten_device_tree(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *blob,</span><br><span class=\"line\">                     struct device_node *dad,</span><br><span class=\"line\">                     struct device_node **mynodes,</span><br><span class=\"line\">                     <span class=\"keyword\">void</span> *(*dt_alloc)(u64 <span class=\"built_in\">size</span>, u64 align),</span><br><span class=\"line\">                     <span class=\"keyword\">bool</span> detached)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* First pass, scan for size */</span></span><br><span class=\"line\">\t<span class=\"built_in\">size</span> = unflatten_dt_nodes(blob, <span class=\"literal\">NULL</span>, dad, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Allocate memory for the expanded device tree */</span></span><br><span class=\"line\">\tmem = dt_alloc(<span class=\"built_in\">size</span> + <span class=\"number\">4</span>, __alignof__(struct device_node));</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Second pass, do actual unflattening */</span></span><br><span class=\"line\">\tunflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>__unflatten_device_tree()函数中主要的解析函数是unflatten_dt_nodes()，在这里被调用了两次，第一次是扫描出设备树转换成struct device_node所需要的空间，然后系统申请内存空间，第二次是进行真正解析的工作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/fdt.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">unflatten_dt_nodes</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *blob,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  <span class=\"keyword\">void</span> *mem,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct device_node *dad,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct device_node **nodepp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">         offset &gt;= <span class=\"number\">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class=\"line\">         offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class=\"line\">\t\tfpsizes[depth+<span class=\"number\">1</span>] = populate_node(blob, offset, &amp;mem,</span><br><span class=\"line\">                         nps[depth],</span><br><span class=\"line\">                         fpsizes[depth],</span><br><span class=\"line\">                         &amp;nps[depth+<span class=\"number\">1</span>], dryrun);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>unflatten_dt_nodes()函数，就是从根节点开始，对子节点依次调用populate_node()，为当前节点申请内存空间，并对node进行初始化；并根据读取到的dtb中的内容，按节点进行填充；设备树由dtb二进制文件，经过解析为每一个节点生成一个struct device_node结构体，就完成了dtb的加载过程；</p>\n<h4 id=\"3-3-console-init\"><a href=\"#3-3-console-init\" class=\"headerlink\" title=\"3.3 console_init\"></a>3.3 console_init</h4><p>console_init()函数执行控制台的初始化操作；在console_init()函数执行之前的printk打印信息，需要在console_init()函数执行之后才能打印出来；因为在console_inie()函数之前，printk的打印信息都保存在一个缓存区中，等到console_init()函数执行之后，控制台被初始化完成，就可以将缓冲区中的内容打印出来；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">console_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">initcall_t</span> *call;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Setup the default TTY line discipline. */</span></span><br><span class=\"line\">    n_tty_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * set up the console device so that later boot sequences can</span></span><br><span class=\"line\"><span class=\"comment\">     * inform about problems etc..</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    call = __con_initcall_start;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class=\"line\">        (*call)();</span><br><span class=\"line\">        call++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在console_init()函数中，指定initcall_t类型的函数指针，从__con_initcall_start开始，到__con_initcall_end结束，遍历这个范围之间的函数，依次运行；</p>\n<p>__con_initcall_start和__con_initcall_end这两个地址，可以在vmlinux.lds文件找到；如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vmlinux.lds</span></span><br><span class=\"line\">__con_initcall_start = .;</span><br><span class=\"line\">KEEP(*(.con_initcall.init))</span><br><span class=\"line\">__con_initcall_end = .;</span><br></pre></td></tr></table></figure>\n\n\n<p>这两个地址之间，存放的是.con_initcall.init段的内容；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/init.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> console_initcall(fn)                    \\</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">initcall_t</span> __initcall_#<span class=\"meta\">#fn           \\</span></span><br><span class=\"line\">    __used __section(.con_initcall.init) = fn</span><br></pre></td></tr></table></figure>\n\n\n<p>通过宏定义console_initcall(fn)，将initcall_t类型的函数指针fn，存放到.con_initcall.init段；之后在调用console_init()函数时，就会通过遍历<em>\\</em>con_initcall_start到__con_initcall_end的地址区域，依次运行存放在其中的函数fn；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/serial/8250/8250_core.c</span></span><br><span class=\"line\">console_initcall(univ8250_console_init);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-rest-init\"><a href=\"#3-4-rest-init\" class=\"headerlink\" title=\"3.4 rest_init\"></a>3.4 rest_init</h4><p>在进行一系列与内核相关的初始化后，在rest_init()函数中，启动了三个进程：idle、kernel_init、kthreadd，来开始操作系统的正式运行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\">rest_init()</span><br><span class=\"line\">    kernel_thread(kernel_init, <span class=\"literal\">NULL</span>, CLONE_FS);\t<span class=\"comment\">// 创建kernel_init内核线程，即init，1号进程；</span></span><br><span class=\"line\">    pid = kernel_thread(kthreadd, <span class=\"literal\">NULL</span>, CLONE_FS | CLONE_FILES);\t<span class=\"comment\">// 创建kthreadd内核线程，2号进程，用于管理和调度其他内核线程；</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    init_idle_bootup_task(current);\t<span class=\"comment\">// 设置当前进程（0号进程）为idle进程；</span></span><br><span class=\"line\">    schedule_preempt_disabled();\t<span class=\"comment\">// 调用进程调度，并禁止内核抢占；</span></span><br><span class=\"line\">    <span class=\"comment\">/* Call into cpu_idle with preempt disabled */</span></span><br><span class=\"line\">    cpu_startup_entry(CPUHP_ONLINE);\t<span class=\"comment\">// 0号进程完成kernel初始化工作，进入idle循环，编程idle进程；</span></span><br></pre></td></tr></table></figure>\n\n\n<pre class=\"mermaid\">graph TB\n    A(rest_init)-->B(idle进程)\n    A(rest_init)-->C(kernel_init进程)\n    A(rest_init)-->D(kthreadd进程)</pre>\n\n\n\n<blockquote>\n<ul>\n<li>idle进程是操作系统的空闲进程，CPU空闲的时候会去运行它；</li>\n<li>kernel_init进程最开始只是一个函数，作为进程被启动，init进程是永远存在的，PID是1；</li>\n<li>kthreadd是内核守护进程，始终运行在内核空间，负责所有内核线程的调度和管理，PID是2；</li>\n</ul>\n</blockquote>\n<p>也就是说，系统启动后的第一个进程是idle，idle进程是唯一没有通过kernel_thread或fork产生的进程；idle创建了kernel_init进程作为1号进程，创建了kthreadd进程作为2号进程；</p>\n<pre class=\"mermaid\">graph TB\n    A(idle进程)-->B(kernel_init进程)\n    A(idle进程)-->C(kthreadd进程)</pre>\n\n\n\n\n<h4 id=\"3-5-kernel-init\"><a href=\"#3-5-kernel-init\" class=\"headerlink\" title=\"3.5 kernel_init\"></a>3.5 kernel_init</h4><p>kernel_init()函数在创建kernel_init进程时，作为进程被启动；虽然kernel_init最开始只是一个函数，但是在最后，通过系统调用，将读取根文件系统下的init进程，完成从内核态到用户态的转变，转变为用户态的1号进程；这个init进程是所有用户态进程的父进程，产生了大量的子进程；init进程是1号进程，是永远存在的；</p>\n<pre class=\"mermaid\">graph TB\n    A(kernel_init)-->B(kernel_init_freeable)\n    subgraph kernel_init\n        B(kernel_init_freeable)\n        -->C(free_initmem)\n        -->D(ramdisk_execute_command)\n        -->E(execute_command)\n        -->F(用户空间init进程)\n    end</pre>\n\n\n\n\n<h4 id=\"3-6-kernel-init-freeable\"><a href=\"#3-6-kernel-init-freeable\" class=\"headerlink\" title=\"3.6 kernel_init_freeable\"></a>3.6 kernel_init_freeable</h4><p>等待内核线程kthreadd创建完成、注册内核驱动模块do_basic_setup、启动默认控制台/dev/console</p>\n<p>完成设备初始化以及模块加载工作；</p>\n<pre class=\"mermaid\">graph TB\n    A(kernel_init_freeable)-->B(wait_for_completion)\n    subgraph kernel_init_freeable\n        B(wait_for_completion)\n        -->C(set_mems_allowed)\n        -->D(do_basic_setup)\n        -->E(open console)    \n        -->X(ramdisk_execute_command)\n    end</pre>\n\n\n\n\n<h5 id=\"3-6-1-wait-for-completion\"><a href=\"#3-6-1-wait-for-completion\" class=\"headerlink\" title=\"3.6.1 wait_for_completion\"></a>3.6.1 wait_for_completion</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\">kernel_init_freeable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twait_for_completion(&amp;kthreadd_done);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>使用完成量等待kthreadd_done，等待内核线程kthreadd创建完成；虽然kernel_init进程先创建，但是要在kthreadd线程创建完成才能执行；在threadd线程创建完成后才唤醒完成量，开始kernel_init进程的工作；</p>\n<h5 id=\"3-6-2-do-basic-setup\"><a href=\"#3-6-2-do-basic-setup\" class=\"headerlink\" title=\"3.6.2 do_basic_setup\"></a>3.6.2 do_basic_setup</h5><pre class=\"mermaid\">graph TB\n    A(do_basic_setup)-->C(driver_init)\n    subgraph do_basic_setup\n    C(driver_init)\n    -->D(do_initcalls)\n    end</pre>\n\n\n\n\n\n\n\n<h6 id=\"2-driver-init\"><a href=\"#2-driver-init\" class=\"headerlink\" title=\"2. driver_init\"></a>2. driver_init</h6><p>driver_init()函数完成与驱动程序相关的所有子系统的构建，实现了Linux设备驱动的一个整体框架，但是它只是建立了目录结构，是设备驱动程序初始化的第一部分，具体驱动模块的装载在do_initcalls()函数中实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/init.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">driver_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* These are the core pieces */</span></span><br><span class=\"line\">    devtmpfs_init();\t<span class=\"comment\">// 注册devtmpfs文件系统，启动devtmpfsd进程</span></span><br><span class=\"line\">    devices_init();\t\t<span class=\"comment\">// 初始化驱动模型中的部分子系统，/dev/devices, /dev/char, /dev/block</span></span><br><span class=\"line\">    buses_init();\t\t<span class=\"comment\">// 初始化驱动模型中的bus子系统</span></span><br><span class=\"line\">    classes_init();\t\t<span class=\"comment\">// 初始化驱动模型中的class子系统</span></span><br><span class=\"line\">    firmware_init();\t<span class=\"comment\">// 初始化驱动模型中的firmware子系统</span></span><br><span class=\"line\">    hypervisor_init();\t<span class=\"comment\">// 初始化驱动模型中的hypervisor子系统</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* These are also core pieces, but must come after the</span></span><br><span class=\"line\"><span class=\"comment\">     * core core pieces.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    platform_bus_init();\t<span class=\"comment\">// 初始化驱动模型中的bus/platform子系统，此节点是所有platform设备和驱动的总线模型；所有platform设备和驱动都会挂载到这个总线上；</span></span><br><span class=\"line\">    cpu_dev_init();\t\t<span class=\"comment\">// 初始化驱动模型中的device/system/cpu子系统，该节点包含CPU相关属性；</span></span><br><span class=\"line\">    memory_dev_init();\t<span class=\"comment\">// 初始化驱动模型中的device/system/memory子系统，该节点包含了内存相关属性；</span></span><br><span class=\"line\">    container_dev_init();\t<span class=\"comment\">// 初始化系统总线类型为容器；</span></span><br><span class=\"line\">    of_core_init();\t\t<span class=\"comment\">// 初始化创建，访问和结时设备树的过程；</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h6 id=\"3-do-initcalls\"><a href=\"#3-do-initcalls\" class=\"headerlink\" title=\"3. do_initcalls\"></a>3. do_initcalls</h6><p>编译器在编译内核时，将一系列模块初始化函数的起始地址按照一定顺序，放在名为section的段中；在内核启动的初始化阶段，do_initcalls()函数中以函数指针的形式取出这些函数的其实地址，依次运行，以完成相应模块的初始化操作，是设备驱动程序初始化的第二部分；由于内核模块可能存在依赖关系，即某些模块的初始化需要依赖其他模块的初始化来完成，因此这些模块的初始化顺序非常重要；</p>\n<p>依次调用不同等级的初始化函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __init <span class=\"title\">do_initcalls</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 依次调用不同level等级的初始化函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (level = <span class=\"number\">0</span>; level &lt; ARRAY_SIZE(initcall_levels) - <span class=\"number\">1</span>; level++)</span><br><span class=\"line\">        do_initcall_level(level);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>对于同一个level等级下的函数，依次遍历执行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __init <span class=\"title\">do_initcall_level</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">initcall_t</span> *fn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(initcall_command_line, saved_command_line);</span><br><span class=\"line\">    parse_args(initcall_level_names[level],</span><br><span class=\"line\">           initcall_command_line, __start___param,</span><br><span class=\"line\">           __stop___param - __start___param,</span><br><span class=\"line\">           level, level,</span><br><span class=\"line\">           <span class=\"literal\">NULL</span>, &amp;repair_env_string);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对于同一个level等级下的函数，依次遍历执行；</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class=\"number\">1</span>]; fn++)</span><br><span class=\"line\">        do_one_initcall(*fn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>开始执行某一个确定的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __init_or_module <span class=\"title\">do_one_initcall</span><span class=\"params\">(<span class=\"keyword\">initcall_t</span> fn)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = preempt_count();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msgbuf[<span class=\"number\">64</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initcall_blacklisted(fn))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EPERM;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initcall_debug)</span><br><span class=\"line\">        ret = do_one_initcall_debug(fn);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    msgbuf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preempt_count() != count) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(msgbuf, <span class=\"string\">\"preemption imbalance \"</span>);</span><br><span class=\"line\">        preempt_count_set(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (irqs_disabled()) &#123;</span><br><span class=\"line\">        strlcat(msgbuf, <span class=\"string\">\"disabled interrupts \"</span>, <span class=\"keyword\">sizeof</span>(msgbuf));</span><br><span class=\"line\">        local_irq_enable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    WARN(msgbuf[<span class=\"number\">0</span>], <span class=\"string\">\"initcall %pF returned with %s\\n\"</span>, fn, msgbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">    add_latent_entropy();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>编译到内核中的模块，是按照执行的level等级，将模块的初始化函数指针地址，分别放到相对应level等级的section中的；</p>\n<p>initcall_t是一个函数指针类型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*<span class=\"keyword\">initcall_t</span>)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/init.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __define_initcall(fn, id) \\</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">initcall_t</span> __initcall_#<span class=\"meta\">#fn##id __used \\</span></span><br><span class=\"line\">    __attribute__((__section__(<span class=\"string\">\".initcall\"</span> #id <span class=\"string\">\".init\"</span>))) = fn;</span><br></pre></td></tr></table></figure>\n\n\n<p>__attribute__((__section__())) 表示把对象放在这个由括号中的名称所指代的section中；</p>\n<p>__define_initcall()宏的含义是：</p>\n<blockquote>\n<ol>\n<li>声明一个名称为__initcall_##fn的函数指针（其中##表示将两边的变量连接为一个变量）；</li>\n<li>将这个函数指针初始化为fn；</li>\n<li>编译时，要将这个函数指针变量放到名称为”.initcall” #id “.init”的section中；（比如：level=”2”，表示这个section的名称为”.initcall2.init”）</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>举例：</p>\n<pre><code>\\_\\_define\\_initcall(6, pci\\_init)</code></pre><p>含义：</p>\n<ol>\n<li>声明一个函数指针，并赋值：__initcall_pci_init = pci_init；</li>\n<li><ol start=\"2\">\n<li>编译时要将函数指针变量__initcall_pci_init放到名称为initcall6.init的section中；（其实就是将pci_init函数的首地址放到名称为initcall6.init的section中）</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>__define_initcall()宏并不会直接使用，而是被定义为其他的宏定义形式使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/init.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pure_initcall(fn)       __define_initcall(fn, 0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> core_initcall(fn)       __define_initcall(fn, 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> core_initcall_sync(fn)      __define_initcall(fn, 1s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> postcore_initcall(fn)       __define_initcall(fn, 2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> postcore_initcall_sync(fn)  __define_initcall(fn, 2s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arch_initcall(fn)       __define_initcall(fn, 3)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arch_initcall_sync(fn)      __define_initcall(fn, 3s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> subsys_initcall(fn)     __define_initcall(fn, 4)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> subsys_initcall_sync(fn)    __define_initcall(fn, 4s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> fs_initcall(fn)         __define_initcall(fn, 5)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> fs_initcall_sync(fn)        __define_initcall(fn, 5s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rootfs_initcall(fn)     __define_initcall(fn, rootfs)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> device_initcall(fn)     __define_initcall(fn, 6)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> device_initcall_sync(fn)    __define_initcall(fn, 6s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> late_initcall(fn)       __define_initcall(fn, 7)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> late_initcall_sync(fn)      __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>\n\n\n<p>通过core_initcall()来声明的函数指针，将被放到名为.initcall1.init的section中；通过postcore_initcall()来声明的函数指针，将被放到名为.initcall2.init的section中；以此类推；</p>\n<blockquote>\n<p>举例：</p>\n<pre><code>device_initcall(pci_init);</code></pre><p>含义：</p>\n<ol>\n<li>声明一个函数指针，并赋值：__initcall_pci_init = pci_init；</li>\n<li>编译时要将函数指针变量__initcall_pci_init放到名称为initcall6.init的section中；（其实就是将pci_init函数的首地址放到名称为initcall6.init的section中）</li>\n</ol>\n</blockquote>\n<p>在编译生成的vmlinux.lds文件中，可以找到initcall相关的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tmp/bsp/DBG/BOARDLX2160LE/ARMQORIQLE/kernel/kernels/linux-4.9.115-cgel/arch/arm64/kernel/vmlinux.lds</span></span><br><span class=\"line\">  __initcall_start = .; KEEP(*(.initcallearly.init))</span><br><span class=\"line\">  __initcall0_start = .; KEEP(*(.initcall0.init)) KEEP(*(.initcall0s.init))</span><br><span class=\"line\">  __initcall1_start = .; KEEP(*(.initcall1.init)) KEEP(*(.initcall1s.init))</span><br><span class=\"line\">  __initcall2_start = .; KEEP(*(.initcall2.init)) KEEP(*(.initcall2s.init))</span><br><span class=\"line\">  __initcall3_start = .; KEEP(*(.initcall3.init)) KEEP(*(.initcall3s.init))</span><br><span class=\"line\">  __initcall4_start = .; KEEP(*(.initcall4.init)) KEEP(*(.initcall4s.init))</span><br><span class=\"line\">  __initcall5_start = .; KEEP(*(.initcall5.init)) KEEP(*(.initcall5s.init))</span><br><span class=\"line\">  __initcallrootfs_start = .; KEEP(*(.initcallrootfs.init)) KEEP(*(.init     callrootfss.init))</span><br><span class=\"line\">  __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init))</span><br><span class=\"line\">  __initcall7_start = .; KEEP(*(.initcall7.init)) KEEP(*(.initcall7s.init))</span><br><span class=\"line\">  __initcall_end = .;</span><br></pre></td></tr></table></figure>\n\n\n<p>在这些section中，总的开始位置被标识为__initcall_start，而在结尾被标识为__initcall_end；</p>\n<p>do_initcalls()函数，会从这些section中依次取出所有的函数指针，并按顺序调用这些函数指针调用的函数，来分别完成内核中驱动模块的初始化操作；</p>\n<p>函数指针被放到哪个section中，是由宏定义__define_initcall(fn, id)的参数id，也就是level决定的，对应level更小的子section的位置更靠前；而位于同一个子section中的函数指针顺序不定，由编译器按照编译顺序随机决定；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">initcall_t</span> *initcall_levels[] __initdata = &#123;</span><br><span class=\"line\">    __initcall0_start,</span><br><span class=\"line\">    __initcall1_start,</span><br><span class=\"line\">    __initcall2_start,</span><br><span class=\"line\">    __initcall3_start,</span><br><span class=\"line\">    __initcall4_start,</span><br><span class=\"line\">    __initcall5_start,</span><br><span class=\"line\">    __initcall6_start,</span><br><span class=\"line\">    __initcall7_start,</span><br><span class=\"line\">    __initcall_end,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"3-6-3-ramdisk-execute-command\"><a href=\"#3-6-3-ramdisk-execute-command\" class=\"headerlink\" title=\"3.6.3 ramdisk_execute_command\"></a>3.6.3 ramdisk_execute_command</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ramdisk_execute_command)</span><br><span class=\"line\">        ramdisk_execute_command = <span class=\"string\">\"/init\"</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>kernel_init_freeable()函数会去判断ramdisk_execute_command是否为空，如果不为空，就直接运行ramdisk_execute_command指定的程序；ramdisk_execute_command的取值分以下情况：</p>\n<blockquote>\n<ol>\n<li>如果命令行参数中指定了“rdinit=…”，则ramdisk_execute_command等于这个参数指定的程序；</li>\n<li>否则，如果/init程序存在，ramdisk_execute_command=/init；</li>\n<li>否则，ramdisk_execute_command为空；</li>\n</ol>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sys_access((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *) ramdisk_execute_command, <span class=\"number\">0</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ramdisk_execute_command = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    prepare_namespace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-7-free-initmem\"><a href=\"#3-7-free-initmem\" class=\"headerlink\" title=\"3.7 free_initmem\"></a>3.7 free_initmem</h4><p>free_initmem()函数用来释放所有init.段中的内存；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/mm/init.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_initmem</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    free_reserved_area(__va(__pa(__init_begin)), __va(__pa(__init_end)),</span><br><span class=\"line\">               <span class=\"number\">0</span>, <span class=\"string\">\"unused kernel\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Unmap the __init region but leave the VM area in place. This</span></span><br><span class=\"line\"><span class=\"comment\">     * prevents the region from being reused for kernel modules, which</span></span><br><span class=\"line\"><span class=\"comment\">     * is not supported by kallsyms.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    unmap_kernel_range((u64)__init_begin, (u64)(__init_end - __init_egin));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-8-启动用户态init进程\"><a href=\"#3-8-启动用户态init进程\" class=\"headerlink\" title=\"3.8 启动用户态init进程\"></a>3.8 启动用户态init进程</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kernel/init/main.c</span></span><br><span class=\"line\">kernel_init()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ramdisk_execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(ramdisk_execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        pr_err(<span class=\"string\">\"Failed to execute %s (error %d)\\n\"</span>,</span><br><span class=\"line\">               ramdisk_execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        panic(<span class=\"string\">\"Requested init %s failed (error %d).\"</span>,</span><br><span class=\"line\">              execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!try_to_run_init_process(<span class=\"string\">\"/sbin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/etc/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/sh\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">try_to_run_init_process</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init_filename)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = run_init_process(init_filename);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">run_init_process</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init_filename)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    argv_init[<span class=\"number\">0</span>] = init_filename;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_execve(getname_kernel(init_filename),</span><br><span class=\"line\">        (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *)argv_init,</span><br><span class=\"line\">        (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *)envp_init);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在大多数系统中，bootloader会传递参数给内核的main函数，而这些参数中会包含init=/linuxrc参数，于是在kernel_init进程中，如果有execute_command = “linuxrc”，在经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行，通过do_execve()函数进入用户态，开始文件系统的初始化init进程；</p>\n<p>如果boot没有传递init=/linuxrc参数给内核，ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic(<span class=\"string\">\"No working init found.  Try passing init= option to kernel. \"</span></span><br><span class=\"line\">          <span class=\"string\">\"See Linux Documentation/init.txt for guidance.\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>出现这种异常错误，可能是以下几个原因造成：</p>\n<blockquote>\n<ol>\n<li>启动参数配置错误，指定了init，但是未找到；</li>\n<li>文件系统挂载出错；</li>\n<li>四个应用程序找不到，或者没有可执行权限；</li>\n</ol>\n</blockquote>\n<p>到此，Linux内核部分启动结束，下一步会在文件系统中启动用户空间的init进程，并进行下一步的启动操作；</p>\n<h3 id=\"4-filesystem启动\"><a href=\"#4-filesystem启动\" class=\"headerlink\" title=\"4. filesystem启动\"></a>4. filesystem启动</h3><pre class=\"mermaid\">graph LR\n    kernel_init(\"kernel_init()\")--\"init=linuxrc\"-->linuxrc(linuxrc)\n    --链接-->busybox(\"/bin/busybox\")\n    kernel_init(\"kernel_init()\")--default-->init(\"/sbin/init\")\n    --链接-->busybox(\"/bin/busybox\")\n    --inittab-->rcS(\"/etc/init.d/rcS\")</pre>\n\n\n<h4 id=\"4-1-filesystem构建\"><a href=\"#4-1-filesystem构建\" class=\"headerlink\" title=\"4.1 filesystem构建\"></a>4.1 filesystem构建</h4><p>文件系统可以通过busybox工具来构建；构建成功之后，一般情况下是不需要修改的；我们使用的文件系统，由成研提供；具体的构建方法此处先省略，有时间再补上；</p>\n<h4 id=\"4-2-busybox程序\"><a href=\"#4-2-busybox程序\" class=\"headerlink\" title=\"4.2 busybox程序\"></a>4.2 busybox程序</h4><p>在Kernel挂载文件系统后，通过kernel_init()函数，准备运行init进程；</p>\n<p>在kernel/init/main.c文件中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kernel/init/main.c</span></span><br><span class=\"line\">kernel_init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ramdisk_execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(ramdisk_execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        pr_err(<span class=\"string\">\"Failed to execute %s (error %d)\\n\"</span>,</span><br><span class=\"line\">               ramdisk_execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        panic(<span class=\"string\">\"Requested init %s failed (error %d).\"</span>,</span><br><span class=\"line\">              execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!try_to_run_init_process(<span class=\"string\">\"/sbin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/etc/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/sh\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行；而linuxrc文件是一个指向/bin/busybox的链接，也就是说，系统启动后运行的第一个程序是/bin/busybox；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls linuxrc -l</span></span><br><span class=\"line\">lrwxrwxrwx 1 root root 11 Mar  4 10:04 linuxrc -&gt; bin/busybox</span><br></pre></td></tr></table></figure>\n\n\n<p>如果ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；而/sbin/init文件也是链接到/bin/busybox的，最终还是会执行/bin/busybox程序；创建用户空间运行的第一个进程；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /sbin/init -l</span></span><br><span class=\"line\">lrwxrwxrwx    1 root     root            14 Dec 12  2019 /sbin/init -&gt; ../bin/busybox</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"4-3-init进程\"><a href=\"#4-3-init进程\" class=\"headerlink\" title=\"4.3 init进程\"></a>4.3 init进程</h4><p>busybox程序运行，会启动init进程，init进程在Linux系统中是最早运行的进程，也就是1号进程；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ps -aux | grep init</span></span><br><span class=\"line\">root         1  0.8  0.0   2080    12 ?        Ss   18:47   0:20 init</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>init进程进行的工作：</p>\n<blockquote>\n<ol>\n<li>为init设置信号处理过程</li>\n<li>初始化控制台</li>\n<li>解析/etc/inittab文件</li>\n<li>执行系统初始化命令，一般情况下会使用/etc/init.d/rcS</li>\n<li>执行所有导致init暂停的inittab命令（动作类型：wait）</li>\n<li>执行所有仅执行一次的inittab命令（动作类型：once）</li>\n</ol>\n</blockquote>\n<p>执行完以上工作后，init进程会循环执行以下进程：</p>\n<blockquote>\n<p>1.执行所有终止时必须重新启动的inittab命令（动作类型：respawn）</p>\n<p>2.执行所有终止时必须重新启动但启动前必须询问用户的inittab命令（动作类型：askfirst）</p>\n</blockquote>\n<h4 id=\"4-4-inittab\"><a href=\"#4-4-inittab\" class=\"headerlink\" title=\"4.4 inittab\"></a>4.4 inittab</h4><p>busybox程序解析/etc/inittab文件，而/etc/inittab是进行初始化的配置文件；busybox运行时会按照格式解析inittab文件，根据解析内容决定具体工作；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/inittab</span></span><br><span class=\"line\">::sysinit:/etc/init.d/rcS</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">::once:/bin/sw &amp;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">The followed sentence does<span class=\"string\">'t need password.</span></span></span><br><span class=\"line\">::respawn:-/bin/ash</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">The followed sentence does need password.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">::respawn:-/bin/login</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">tty2::askfirst:-/bin/ash</span></span><br><span class=\"line\">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>inittab的内容以行为单位，行与行之间没有关联，每行都是一个独立的配置项；每一行的配置项都是由3个冒号分隔开的4个配置值组成，冒号是分隔符，分隔开各个部分；</p>\n<p>inittab文件里的代码格式：</p>\n<p>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</p>\n<p>说明：</p>\n<blockquote>\n<p>id：/dev/id，用作终端terminal：stdin、stdout、stderr、printf、scanf、err</p>\n<p>runlevels：</p>\n<p>action：执行时机；包括：sysinit、respawd、askfirst、wait、once、restart、ctrialtdel、shutdown</p>\n<p>process：应用程序和脚本</p>\n</blockquote>\n<h4 id=\"4-5-rcS\"><a href=\"#4-5-rcS\" class=\"headerlink\" title=\"4.5 rcS\"></a>4.5 rcS</h4><p>在/etc/inittab配置文件中，action为sysinit的行，表示在Linux系统初始化文件系统时执行的第一个脚本，即：/etc/init.d/rcS；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::sysinit:/etc/init.d/rcS</span><br></pre></td></tr></table></figure>\n\n\n<p>主要进行一些初始化工作：启动交换分区、检查磁盘、设置主机名、检查并挂载文件系统、加载并初始化硬件模块等；</p>\n<p>/etc/init.d/rcS文件是Linux运行时非常重要的一个脚本程序；其他的配置在rcS文件中进行，rcS文件中的配置可以根据需求进行扩展；/etc/init.d/rcS完成各个文件系统的挂载（mount），以及文件硬件模块的初始化；</p>\n<h3 id=\"5-应用进程启动\"><a href=\"#5-应用进程启动\" class=\"headerlink\" title=\"5. 应用进程启动\"></a>5. 应用进程启动</h3><p>应用进程，可以在文件系统的/etc/init.d/rcS脚本运行时，调用xxx.sh脚本拉起来的；</p>\n<p><a href=\"#目录\">跳转到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；</p>","more":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"0-简述\"><a href=\"#0-简述\" class=\"headerlink\" title=\"0. 简述\"></a>0. 简述</h3><p>以arm64为例，讲述Linux在ARM64架构设备上的系统启动流程；</p>\n<p>上电启动，系统启动要经过uboot、kernel、filesystem、ADM几个过程，如下：</p>\n<pre class=\"mermaid\">graph LR\n    uboot(uboot)-->kernel(kernel)\n    -->filesystem(filesystem)\n    -->Software(Software)</pre>\n\n\n\n\n\n\n<p>在大多数系统中，内核镜像在uboot阶段被加载到内存中，并获得控制权开始内核的启动流程；</p>\n<pre class=\"mermaid\">graph LR\n    uboot(uboot)-->kernel(kernel)</pre>\n\n\n\n\n<p>Linux内核版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linux-4.9.115</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uname -a</span></span><br><span class=\"line\">Linux vexpress 4.9.115 #2 SMP Wed Apr 1 22:49:35 CST 2020 aarch64 GNU/Linux</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明</strong>：由于Linux内核系统庞大繁杂，要想把内核启动中的每个细节都描述清楚，基本上不可能，更何况作者能力水平也达不到；因此，就在追踪内核启动流程代码的同时，只描述比较重要的几个部分；可以在以后的工作、学习中，随着水平的提高，不断地增加内容；</p>\n<h3 id=\"1-目标文件\"><a href=\"#1-目标文件\" class=\"headerlink\" title=\"1. 目标文件\"></a>1. 目标文件</h3><p>内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照vmlinux.lds设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序；</p>\n<h4 id=\"1-1-vmlinux-lds\"><a href=\"#1-1-vmlinux-lds\" class=\"headerlink\" title=\"1.1 vmlinux.lds\"></a>1.1 vmlinux.lds</h4><p>vmlinux.lds文件是在内核编译时生成的，是被禁止编辑的；vmlinux.lds文件是在编译时，由vmlinux.lds.S文件对链接器ld的输出进行排序后生成；vmlinux.lds.S是用来对输出文件中的段进行排序，并定义相关的符号名；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S</span><br></pre></td></tr></table></figure>\n\n\n<p>在项目中通过make时指定的参数-O，将内核编译生成的所有目标文件，包括vmlinux.lds文件重定向输出到以下目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch/arm64/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>\n\n\n<p>vmlinux.lds文件是链接脚本，在内核编译时，作为Makefile的链接器脚本，参与链接生成内核映像vmlinux；</p>\n<p>总之：vmlinux是按照vmlinux.lds链接生成的，而vmlinux.lds是由vmlinux.lds.S生成的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/vmlinux.lds</span></span><br><span class=\"line\">OUTPUT_ARCH(aarch64)\t<span class=\"comment\">// 指定架构为aarch64</span></span><br><span class=\"line\">ENTRY(_text)\t\t\t<span class=\"comment\">// 定义入口为_text</span></span><br><span class=\"line\">jiffies = jiffies_64;\t<span class=\"comment\">// 定义为64位计数器</span></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// 指定链接地址</span></span><br><span class=\"line\">    . = ((((<span class=\"number\">0xffffffffffffffff</span> - (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">48</span>)) + <span class=\"number\">1</span>) + (<span class=\"number\">0</span>)) + (<span class=\"number\">0x08000000</span>))) + <span class=\"number\">0x00080000</span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>关于段的信息</p>\n<blockquote>\n<p>text段，代码段，用来存放程序执行代码的一块内存区域；大小在程序运行前确定；</p>\n<p>data段，数据段，用来存放程序中已初始化的全局变量的内存区域；数据段属于静态内存分配；</p>\n<p>bss段，用来存放程序中未初始化的全局变量和静态变量的一块内存区域；属于静态内存分配；</p>\n<p>init段，Linux定义的一种初始化过程中才能用到的段；初始化完成后，该段内存会被释放；</p>\n</blockquote>\n<p>关于地址的信息</p>\n<blockquote>\n<p>加载地址：程序中指令和变量等加载到RAM上的地址；</p>\n<p>运行地址：CPU执行一条程序的指令时的执行地址，即PC寄存器的值；就是要寻址到一个指令或变量所使用的地址；</p>\n<p>链接地址：链接过程中链接器为指令和变量分配的地址；</p>\n</blockquote>\n<h4 id=\"1-2-内核映像\"><a href=\"#1-2-内核映像\" class=\"headerlink\" title=\"1.2 内核映像\"></a>1.2 内核映像</h4><p>vmlinux是未压缩的内核，是生成的纯内核二进制文件，具有用户定义的所有内核组件，但是这个vmlinux二进制文件是无法启动系统的；为了将Linux内核映像加载到内存并处于可执行状态，内核构建系统使用objcopy命令清除不必要的节区，压缩ELF格式的vmlinux，通过引导程序加载项和链接，生成可启动的最终的二进制文件zImage；</p>\n<p>vmlinux通过gzip压缩成piggy.o，和head.o、misc.o链接生成zImage二进制文件；</p>\n<p>vmlinuz是vmlinux的压缩文件</p>\n<p>zImage默认的压缩内核映像文件，压缩vmlinux，加上一段解压启动代码，压缩而成；</p>\n<p>uImage是u-boot使用bootm命令引导的Linux压缩内核映像文件格式，是使用mkimage工具对普通的压缩内核映像文件（zImage）加工而成；</p>\n<p>uImage是uboot专用的内核映像文件，是在zImage之前加上一个长度为64字节的“头”，说明内核的版本、加载位置、生成时间、大小等信息；在地址0x40之后的部分，和zImage一样；其大小比zImage大64字节；</p>\n<h4 id=\"1-3-设备树文件\"><a href=\"#1-3-设备树文件\" class=\"headerlink\" title=\"1.3 设备树文件\"></a>1.3 设备树文件</h4><p>Linux内核从3.x版本开始引入设备树的概念，用于实现驱动代码与设备信息分离；设备树出现之前，所有关于设备的具体信息都写在驱动中，外围设备变化，驱动代码就要跟着修改甚至是重写；引入设备树之后，驱动代码只负责处理驱动代码的逻辑，而关于设备的具体信息存放到设备树文件中，这样硬件接口信息变化时，只需要修改设备树文件信息，不需要修改驱动代码就可以；</p>\n<p>一般情况下，在编译设备树之前，先在scripts/dtc/目录下，编译生成dtc工具scripts/dtc/dtc，再使用生成的dtc工具编译设备树源码，生成设备树文件；设备树源码和目标文件在arch/arm64/boot/dts/freescale/目录；</p>\n<p>在Lx2160板项目中，目标文件会被重定向输出到target目录；</p>\n<p>具体的设备树文件的加载、解析过程，会在下文setup_arch部分描述；</p>\n<h3 id=\"2-内核启动第一阶段\"><a href=\"#2-内核启动第一阶段\" class=\"headerlink\" title=\"2. 内核启动第一阶段\"></a>2. 内核启动第一阶段</h3><p>Linux内核启动第一阶段，也就是我们常说的汇编阶段，也就是stext函数的实现内容；这部分主要完成的工作：CPU ID检查，machine ID检查，创建初始化页表，设置C代码运行环境，跳转到内核第一个真正的C函数start_kernel执行；</p>\n<p>设置为SVC模式，关闭所有中断</p>\n<p>获取CPUID，提取相应的proc info</p>\n<p>验证tags或dtb</p>\n<p>创建页表项</p>\n<p>head.S文件中，</p>\n<p>校验启动合法性</p>\n<p>建立段式映射的页表并开启MMU</p>\n<p>构建C运行环境，跳入C阶段</p>\n<h4 id=\"2-1-内核启动入口点\"><a href=\"#2-1-内核启动入口点\" class=\"headerlink\" title=\"2.1 内核启动入口点\"></a>2.1 内核启动入口点</h4><p>内核是一个庞大的系统，通过vmlinux反向追踪启动入口点</p>\n<p>Lx2160le板的交叉编译工具链：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>通过对目标文件vmlinux的反向追溯，找到Linux执行的入口；</p>\n<p>使用readelf命令可以查看vmlinux的入口地址为：0xffff000008080000</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> readelf -h vmlinux</span></span><br><span class=\"line\">ELF Header:</span><br><span class=\"line\">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">  Class:                             ELF64</span><br><span class=\"line\">  Data:                              2's complement, little endian</span><br><span class=\"line\">  Version:                           1 (current)</span><br><span class=\"line\">  OS/ABI:                            UNIX - System V</span><br><span class=\"line\">  ABI Version:                       0</span><br><span class=\"line\">  Type:                              EXEC (Executable file)</span><br><span class=\"line\">  Machine:                           AArch64</span><br><span class=\"line\">  Version:                           0x1</span><br><span class=\"line\">  Entry point address:               0xffff000008080000</span><br><span class=\"line\">  Start of program headers:          64 (bytes into file)</span><br><span class=\"line\">  Start of section headers:          267014976 (bytes into file)</span><br><span class=\"line\">  Flags:                             0x0</span><br><span class=\"line\">  Size of this header:               64 (bytes)</span><br><span class=\"line\">  Size of program headers:           56 (bytes)</span><br><span class=\"line\">  Number of program headers:         4</span><br><span class=\"line\">  Size of section headers:           64 (bytes)</span><br><span class=\"line\">  Number of section headers:         39</span><br><span class=\"line\">  Section header string table index: 36</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>这个入口地址是怎么来的，对应内核代码中的哪个部分，可以通过反汇编来分析；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aarch64-linux-gnu-objdump -dxh vmlinux &gt; vmlinux.s</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>在得到的汇编文件vmlinux.s中查找入口地址：0xffff000008080000</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start address <span class=\"number\">0xffff000008080000</span></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .head.<span class=\"built_in\">text</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">ffff000008080000 &lt;_text&gt;:</span><br><span class=\"line\">ffff000008080000:       <span class=\"number\">91005</span>a4d        add     x13, x18, #<span class=\"number\">0x16</span></span><br><span class=\"line\">ffff000008080004:       <span class=\"number\">14437f</span>ff        b       ffff000009160000 &lt;stext&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>可以得到，Linux入口的第一条指令为：add     x13, x18, #0x16；对应的符号是：.head.text  _text；</p>\n<p>而.head.text段，通过include/linux/init.h文件中的宏定义__HEAD来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* For assembly routines */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __HEAD      .section    <span class=\"meta-string\">\".head.text\"</span>,<span class=\"meta-string\">\"ax\"</span>\t<span class=\"comment\">// \"ax\"表示所在段区域有可执行权限</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __INIT      .section    <span class=\"meta-string\">\".init.text\"</span>,<span class=\"meta-string\">\"ax\"</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>内核启动的入口点，在arch/arm64/kernel/head.S文件中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    __HEAD</span><br><span class=\"line\">_head:</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_EFI</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * This add instruction has no meaningful effect except that</span></span><br><span class=\"line\"><span class=\"comment\">     * its opcode forms the magic \"MZ\" signature required by UEFI.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    add x13, x18, #<span class=\"number\">0x16</span></span><br><span class=\"line\">    b   stext</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    b   stext               <span class=\"comment\">// branch to kernel start, magic</span></span><br><span class=\"line\">    .<span class=\"keyword\">long</span>   <span class=\"number\">0</span>               <span class=\"comment\">// reserved</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>到此，已经找到，目标文件vmlinux的入口是arch/arm64/kernel/head.S文件中的__HEAD，在执行完第一条语句（add x13, x18, #0x16）之后，跳转到stext函数执行（b   stext）；所以，加载vmlinux后，第一个运行的函数是stext；</p>\n<h4 id=\"2-2-stext函数\"><a href=\"#2-2-stext函数\" class=\"headerlink\" title=\"2.2 stext函数\"></a>2.2 stext函数</h4><p>启动过程中的汇编阶段，是从arch/arm64/kernel/head.S文件开始，执行的起点是stext函数，入口函数是通过vmlinux.lds链接而成，在head.S中ENTRY(stext)指定；</p>\n<p>在汇编代码中，宏定义ENTRY和ENDPROC是成对出现的，表示定义的一个函数，同时也要指明当前代码所在的段，如：__INIT；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __INIT      .section    <span class=\"meta-string\">\".init.text\"</span>,<span class=\"meta-string\">\"ax\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t__INIT</span><br><span class=\"line\">ENTRY(stext)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(stext)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>内核启动的必要条件：MMU关闭，D-cache关闭，x0是传递给FDT blob的物理地址；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* The requirements are:</span><br><span class=\"line\">*   MMU = off, D-cache = off, I-cache = on <span class=\"keyword\">or</span> off,</span><br><span class=\"line\">*   x0 = physical address to the FDT blob.</span><br></pre></td></tr></table></figure>\n\n\n\n<p>stext函数开始执行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">\t__INIT</span><br><span class=\"line\">ENTRY(stext)</span><br><span class=\"line\">    bl  preserve_boot_args\t<span class=\"comment\">// Preserve the arguments passed by the bootloader in x0 ... x3</span></span><br><span class=\"line\">    bl  el2_setup           <span class=\"comment\">// Drop to EL1, w0=cpu_boot_mode</span></span><br><span class=\"line\">    adrp    x23, __PHYS_OFFSET</span><br><span class=\"line\">    <span class=\"keyword\">and</span> x23, x23, MIN_KIMG_ALIGN - <span class=\"number\">1</span>    <span class=\"comment\">// KASLR offset, defaults to 0</span></span><br><span class=\"line\">    bl  set_cpu_boot_mode_flag</span><br><span class=\"line\">    bl  __create_page_tables</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span></span><br><span class=\"line\"><span class=\"comment\">   * details.</span></span><br><span class=\"line\"><span class=\"comment\">   * On return, the CPU will be ready for the MMU to be turned on and</span></span><br><span class=\"line\"><span class=\"comment\">   * the TCR will have been set.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">     bl  __cpu_setup         <span class=\"comment\">// initialise processor</span></span><br><span class=\"line\">     b   __primary_switch</span><br><span class=\"line\">ENDPROC(stext)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"1-preserve-boot-args\"><a href=\"#1-preserve-boot-args\" class=\"headerlink\" title=\"1. preserve_boot_args\"></a>1. preserve_boot_args</h5><p>保存从bootloader传递过来的x0 ~ x3参数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">preserve_boot_args:</span><br><span class=\"line\">    mov x21, x0\t\t\t\t<span class=\"comment\">// 将dtb的地址暂存在x21寄存器，释放出x0使用</span></span><br><span class=\"line\">    adr_l   x0, boot_args\t<span class=\"comment\">// x0保存boot_args变量的地址</span></span><br><span class=\"line\">    stp x21, x1, [x0]\t\t<span class=\"comment\">// 将x0、x1的值保存到boot_args[0]、boot_args[1]</span></span><br><span class=\"line\">    stp x2, x3, [x0, #<span class=\"number\">16</span>]\t<span class=\"comment\">// 将x2、x3的值保存到boot_args[2]、boot_args[3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dmb sy              <span class=\"comment\">// needed before dc ivac with</span></span><br><span class=\"line\">                        <span class=\"comment\">// MMU off</span></span><br><span class=\"line\"></span><br><span class=\"line\">    add x1, x0, #<span class=\"number\">0x20</span>\t\t<span class=\"comment\">// x0、x1作为nval_cache_range函数的参数</span></span><br><span class=\"line\">    b   __inval_cache_range     <span class=\"comment\">// tail call</span></span><br><span class=\"line\">ENDPROC(preserve_boot_args)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-el2-setup\"><a href=\"#2-el2-setup\" class=\"headerlink\" title=\"2. el2_setup\"></a>2. el2_setup</h5><p>到此，CPU处于哪个exception level？根据ARM64 boot protocol，CPU处于EL2（推荐）或者secure EL1；如果处于EL2，需要将CPU退回到EL1；此部分还没有搞明白，暂时先跳过；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">ENTRY(el2_setup)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(el2_setup)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-set-cpu-boot-mode-flag\"><a href=\"#3-set-cpu-boot-mode-flag\" class=\"headerlink\" title=\"3. set_cpu_boot_mode_flag\"></a>3. set_cpu_boot_mode_flag</h5><p>set_cpu_boot_mode_flag函数，用来设置__boot_cpu_mode flag；需要一个前提条件：w20寄存器中保存了CPU启动时的异常等级（Exception level）；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">set_cpu_boot_mode_flag:</span><br><span class=\"line\">    adr_l   x1, __boot_cpu_mode</span><br><span class=\"line\">    cmp w0, #BOOT_CPU_MODE_EL2</span><br><span class=\"line\">    b.ne    <span class=\"number\">1f</span></span><br><span class=\"line\">    add x1, x1, #<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">1</span>:  str w0, [x1]            <span class=\"comment\">// This CPU has booted in EL1</span></span><br><span class=\"line\">    dmb sy</span><br><span class=\"line\">    dc  ivac, x1            <span class=\"comment\">// Invalidate potentially stale cache line</span></span><br><span class=\"line\">    ret</span><br><span class=\"line\">ENDPROC(set_cpu_boot_mode_flag)</span><br></pre></td></tr></table></figure>\n\n\n<p>由于系统启动之后，需要了解CPU启动时候的Exception level，因此需要一个全局变量__boot_cpu_mode来保存启动时的CPU mode；</p>\n<p>全局变量__boot_cpu_mode定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY(__boot_cpu_mode)</span><br><span class=\"line\">    .<span class=\"keyword\">long</span>   BOOT_CPU_MODE_EL2</span><br><span class=\"line\">    .<span class=\"keyword\">long</span>   BOOT_CPU_MODE_EL1</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4-create-page-tables\"><a href=\"#4-create-page-tables\" class=\"headerlink\" title=\"4. __create_page_tables\"></a>4. __create_page_tables</h5><p>建立页表初始化的过程；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">__create_page_tables:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(__create_page_tables)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"5-cpu-setup\"><a href=\"#5-cpu-setup\" class=\"headerlink\" title=\"5. __cpu_setup\"></a>5. __cpu_setup</h5><p>CPU的初始化设置；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/mm/proc.S</span></span><br><span class=\"line\">ENTRY(__cpu_setup)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">ENDPROC(__cpu_setup)</span><br></pre></td></tr></table></figure>\n\n\n<p>主要的内容包括：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、cache和TLB的处理</span><br><span class=\"line\">2、Memory attributes lookup table的创建</span><br><span class=\"line\">3、SCTLR_EL1、TCR_EL1的设定</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"6-primary-switch\"><a href=\"#6-primary-switch\" class=\"headerlink\" title=\"6. __primary_switch\"></a>6. __primary_switch</h5><p>主要工作是为打开MMU做准备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">__primary_switch:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tbl  __enable_mmu\t\t\t<span class=\"comment\">// 开启MMU</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    ldr x8, =__primary_switched</span><br><span class=\"line\">    adrp    x0, __PHYS_OFFSET</span><br><span class=\"line\">    blr x8</span><br><span class=\"line\">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure>\n\n\n<p>在函数中通过__enable_mmu函数来开启MMU，并调用__primary_switched函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/head.S</span></span><br><span class=\"line\">__primary_switched:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    b   start_kernel</span><br><span class=\"line\">ENDPROC(__primary_switched)</span><br></pre></td></tr></table></figure>\n\n\n<p>在__primary_switched函数中，进行一些C环境的准备，并在最后，调用执行start_kernel函数，内核的启动进入到C语言环境阶段；</p>\n<pre class=\"mermaid\">graph TB\n    subgraph 入口函数\n    A_Explain(保存boot参数)\n    -->\n    B_Explain(EL2设置)\n    -->\n    C_Explain(设置CPU启动模式flag)\n    -->\n    D_Explain(创建页表)\n    -->\n    E_Explain(CPU配置)\n    -->\n    F_Explain(主要的转换操作)\n    -->\n    G_Explain(运行start_kernel函数)\n    end\n\n    subgraph stext\n    A_func(preserve_boot_args)\n    -->\n    B_func(el2_setup)\n    -->\n    C_func(set_cpu_boot_mode_flag)\n    -->\n    D_func(__create_page_tables)\n    -->\n    E_func(__cpu_setup)\n    -->\n    F_func(__primary_switch)\n    -->\n    G_func(start_kernel)\n    end</pre>\n\n\n\n\n<h4 id=\"2-3-参考资料\"><a href=\"#2-3-参考资料\" class=\"headerlink\" title=\"2.3 参考资料\"></a>2.3 参考资料</h4><p><a href=\"https://blog.csdn.net/xiaohua0877/article/details/78615776\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiaohua0877/article/details/78615776</a></p>\n<p><a href=\"http://www.wowotech.net/sort/armv8a_arch\" target=\"_blank\" rel=\"noopener\">http://www.wowotech.net/sort/armv8a_arch</a></p>\n<h3 id=\"3-内核启动第二阶段\"><a href=\"#3-内核启动第二阶段\" class=\"headerlink\" title=\"3. 内核启动第二阶段\"></a>3. 内核启动第二阶段</h3><p>Linux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；</p>\n<pre class=\"mermaid\">graph TB\n    A(start_kernel)-->B(一系列的初始化操作)\n    subgraph start_kernel\n    B(一系列的初始化操作)\n    -->\n    C(setup_arch)\n    -->\n    D(一系列的初始化操作)\n    -->\n    E(rest_init)\n    end</pre>\n\n\n\n\n<h4 id=\"3-1-start-kernel\"><a href=\"#3-1-start-kernel\" class=\"headerlink\" title=\"3.1 start_kernel\"></a>3.1 start_kernel</h4><p>start_kernel()函数在init/main.c文件中，主要完成Linux子系统的初始化工作；此部分初始化内容繁多，暂时先略过，此处省略好多字；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\">asmlinkage __visible <span class=\"keyword\">void</span> __init <span class=\"title\">start_kernel</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pr_notice(<span class=\"string\">\"%s\"</span>, linux_banner);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> linux_banner[] =</span><br><span class=\"line\">    <span class=\"string\">\"Linux version \"</span> UTS_RELEASE <span class=\"string\">\" (\"</span> LINUX_COMPILE_BY <span class=\"string\">\"@\"</span></span><br><span class=\"line\">    LINUX_COMPILE_HOST <span class=\"string\">\") (\"</span> LINUX_COMPILER <span class=\"string\">\") \"</span> UTS_VERSION <span class=\"string\">\"\\n\"</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>执行的效果是，在内核启动初期，打印内核版本号和构建信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux version 4.9.115 (root@localhost.localdomain) (gcc version 6.2.0 20170314 ZTE Embsys-TSP V3.06.40 (GCC) ) #2 SMP PREEMPT Tue Mar 10 11:21:00 CST 2020</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-2-setup-arch\"><a href=\"#3-2-setup-arch\" class=\"headerlink\" title=\"3.2 setup_arch\"></a>3.2 setup_arch</h4><p>setup_arch()函数，是体系结构相关的，该函数根据处理器、硬件平台具体型号设置系统；及解析系统命令行，系统内存管理初始化，统计并注册系统各种资源等；每个体系都有自己的setup_arch()函数，是由顶层Makefile中的ARCH变量定义的，我们使用的是ARCH=arm64，因此，这里的setup_arch()函数，也是arm64的体系结构相关的；参数是未被初始化的内部变量command_line；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\">asmlinkage __visible <span class=\"keyword\">void</span> __init <span class=\"title\">start_kernel</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tsetup_arch(&amp;command_line);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>setup_arch()函数中的初始化内容比较多，目前<strong>只对设备树相关的部分进行简要描述</strong>；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/setup.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">setup_arch</span><span class=\"params\">(<span class=\"keyword\">char</span> **cmdline_p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">\tsetup_machine_fdt(__fdt_pointer);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acpi_disabled)</span><br><span class=\"line\">        unflatten_device_tree();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    A(setup_arch)-->B(加载设备树)\n    B(加载设备树)-->C(setup_machine_fdt)\n    B(加载设备树)-->D(unflatten_device_tree)</pre>\n\n\n\n\n<h5 id=\"1-setup-machine-fdt\"><a href=\"#1-setup-machine-fdt\" class=\"headerlink\" title=\"1. setup_machine_fdt\"></a>1. setup_machine_fdt</h5><p>setup_machine_fdt()函数的输入参数是设备树（DTB）首地址；uboot启动程序把设备树读取到内存中，之后在启动内核的同时，将设备树首地址传给内核，setup_machine_fdt()函数的参数__fdt_pointer就是uboot传给内核的设备树地址；函数中的fdt(flat device tree)表示，设备树在内存中是在一块连续地址存储的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/setup.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __init <span class=\"title\">setup_machine_fdt</span><span class=\"params\">(<span class=\"keyword\">phys_addr_t</span> dt_phys)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *dt_virt = fixmap_remap_fdt(dt_phys);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">            cpu_relax();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dump_stack_set_arch_desc(<span class=\"string\">\"%s (DT)\"</span>, of_flat_dt_get_machine_name());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/kernel/setup.c</span></span><br><span class=\"line\"><span class=\"keyword\">phys_addr_t</span> __fdt_pointer __initdata;</span><br></pre></td></tr></table></figure>\n\n\n<p>全局变量__fdt_pointer指向内存中的DTB，是设备树的物理地址；这个物理地址是由bootloader传递给内核的，在内核中使用，是需要转换为虚拟地址才能访问，而这个转换，由fixmap_remap_fdt()函数来完成；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/fdt.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> __init <span class=\"title\">early_init_dt_scan</span><span class=\"params\">(<span class=\"keyword\">void</span> *params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> status;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = early_init_dt_verify(params);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!status)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    early_init_dt_scan_nodes();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>接下来调用的early_init_dt_scan()函数，通过进一步调用early_init_dt_verify()函数来检查DTB数据是否完整，经过内存映射之后，就可以直接访问DTB中的内容了；</p>\n<h5 id=\"2-unflatten-device-tree\"><a href=\"#2-unflatten-device-tree\" class=\"headerlink\" title=\"2. unflatten_device_tree\"></a>2. unflatten_device_tree</h5><p>unflatten_device_tree()函数完成对设备树的解析，所做的工作是将设备树各节点转换成相应的struct device_node结构体；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/fdt.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">unflatten_device_tree</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __unflatten_device_tree(initial_boot_params, <span class=\"literal\">NULL</span>, &amp;of_root,</span><br><span class=\"line\">                early_init_dt_alloc_memory_arch, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get pointer to \"/chosen\" and \"/aliases\" nodes for use everywhere */</span></span><br><span class=\"line\">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/base.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_node</span> *<span class=\"title\">of_root</span>;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *__unflatten_device_tree(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *blob,</span><br><span class=\"line\">                     struct device_node *dad,</span><br><span class=\"line\">                     struct device_node **mynodes,</span><br><span class=\"line\">                     <span class=\"keyword\">void</span> *(*dt_alloc)(u64 <span class=\"built_in\">size</span>, u64 align),</span><br><span class=\"line\">                     <span class=\"keyword\">bool</span> detached)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* First pass, scan for size */</span></span><br><span class=\"line\">\t<span class=\"built_in\">size</span> = unflatten_dt_nodes(blob, <span class=\"literal\">NULL</span>, dad, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Allocate memory for the expanded device tree */</span></span><br><span class=\"line\">\tmem = dt_alloc(<span class=\"built_in\">size</span> + <span class=\"number\">4</span>, __alignof__(struct device_node));</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Second pass, do actual unflattening */</span></span><br><span class=\"line\">\tunflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>__unflatten_device_tree()函数中主要的解析函数是unflatten_dt_nodes()，在这里被调用了两次，第一次是扫描出设备树转换成struct device_node所需要的空间，然后系统申请内存空间，第二次是进行真正解析的工作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/fdt.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">unflatten_dt_nodes</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *blob,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  <span class=\"keyword\">void</span> *mem,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct device_node *dad,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  struct device_node **nodepp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">         offset &gt;= <span class=\"number\">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class=\"line\">         offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class=\"line\">\t\tfpsizes[depth+<span class=\"number\">1</span>] = populate_node(blob, offset, &amp;mem,</span><br><span class=\"line\">                         nps[depth],</span><br><span class=\"line\">                         fpsizes[depth],</span><br><span class=\"line\">                         &amp;nps[depth+<span class=\"number\">1</span>], dryrun);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>unflatten_dt_nodes()函数，就是从根节点开始，对子节点依次调用populate_node()，为当前节点申请内存空间，并对node进行初始化；并根据读取到的dtb中的内容，按节点进行填充；设备树由dtb二进制文件，经过解析为每一个节点生成一个struct device_node结构体，就完成了dtb的加载过程；</p>\n<h4 id=\"3-3-console-init\"><a href=\"#3-3-console-init\" class=\"headerlink\" title=\"3.3 console_init\"></a>3.3 console_init</h4><p>console_init()函数执行控制台的初始化操作；在console_init()函数执行之前的printk打印信息，需要在console_init()函数执行之后才能打印出来；因为在console_inie()函数之前，printk的打印信息都保存在一个缓存区中，等到console_init()函数执行之后，控制台被初始化完成，就可以将缓冲区中的内容打印出来；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">console_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">initcall_t</span> *call;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Setup the default TTY line discipline. */</span></span><br><span class=\"line\">    n_tty_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * set up the console device so that later boot sequences can</span></span><br><span class=\"line\"><span class=\"comment\">     * inform about problems etc..</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    call = __con_initcall_start;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class=\"line\">        (*call)();</span><br><span class=\"line\">        call++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在console_init()函数中，指定initcall_t类型的函数指针，从__con_initcall_start开始，到__con_initcall_end结束，遍历这个范围之间的函数，依次运行；</p>\n<p>__con_initcall_start和__con_initcall_end这两个地址，可以在vmlinux.lds文件找到；如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vmlinux.lds</span></span><br><span class=\"line\">__con_initcall_start = .;</span><br><span class=\"line\">KEEP(*(.con_initcall.init))</span><br><span class=\"line\">__con_initcall_end = .;</span><br></pre></td></tr></table></figure>\n\n\n<p>这两个地址之间，存放的是.con_initcall.init段的内容；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/init.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> console_initcall(fn)                    \\</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">initcall_t</span> __initcall_#<span class=\"meta\">#fn           \\</span></span><br><span class=\"line\">    __used __section(.con_initcall.init) = fn</span><br></pre></td></tr></table></figure>\n\n\n<p>通过宏定义console_initcall(fn)，将initcall_t类型的函数指针fn，存放到.con_initcall.init段；之后在调用console_init()函数时，就会通过遍历<em>\\</em>con_initcall_start到__con_initcall_end的地址区域，依次运行存放在其中的函数fn；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/serial/8250/8250_core.c</span></span><br><span class=\"line\">console_initcall(univ8250_console_init);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-rest-init\"><a href=\"#3-4-rest-init\" class=\"headerlink\" title=\"3.4 rest_init\"></a>3.4 rest_init</h4><p>在进行一系列与内核相关的初始化后，在rest_init()函数中，启动了三个进程：idle、kernel_init、kthreadd，来开始操作系统的正式运行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\">rest_init()</span><br><span class=\"line\">    kernel_thread(kernel_init, <span class=\"literal\">NULL</span>, CLONE_FS);\t<span class=\"comment\">// 创建kernel_init内核线程，即init，1号进程；</span></span><br><span class=\"line\">    pid = kernel_thread(kthreadd, <span class=\"literal\">NULL</span>, CLONE_FS | CLONE_FILES);\t<span class=\"comment\">// 创建kthreadd内核线程，2号进程，用于管理和调度其他内核线程；</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    init_idle_bootup_task(current);\t<span class=\"comment\">// 设置当前进程（0号进程）为idle进程；</span></span><br><span class=\"line\">    schedule_preempt_disabled();\t<span class=\"comment\">// 调用进程调度，并禁止内核抢占；</span></span><br><span class=\"line\">    <span class=\"comment\">/* Call into cpu_idle with preempt disabled */</span></span><br><span class=\"line\">    cpu_startup_entry(CPUHP_ONLINE);\t<span class=\"comment\">// 0号进程完成kernel初始化工作，进入idle循环，编程idle进程；</span></span><br></pre></td></tr></table></figure>\n\n\n<pre class=\"mermaid\">graph TB\n    A(rest_init)-->B(idle进程)\n    A(rest_init)-->C(kernel_init进程)\n    A(rest_init)-->D(kthreadd进程)</pre>\n\n\n\n<blockquote>\n<ul>\n<li>idle进程是操作系统的空闲进程，CPU空闲的时候会去运行它；</li>\n<li>kernel_init进程最开始只是一个函数，作为进程被启动，init进程是永远存在的，PID是1；</li>\n<li>kthreadd是内核守护进程，始终运行在内核空间，负责所有内核线程的调度和管理，PID是2；</li>\n</ul>\n</blockquote>\n<p>也就是说，系统启动后的第一个进程是idle，idle进程是唯一没有通过kernel_thread或fork产生的进程；idle创建了kernel_init进程作为1号进程，创建了kthreadd进程作为2号进程；</p>\n<pre class=\"mermaid\">graph TB\n    A(idle进程)-->B(kernel_init进程)\n    A(idle进程)-->C(kthreadd进程)</pre>\n\n\n\n\n<h4 id=\"3-5-kernel-init\"><a href=\"#3-5-kernel-init\" class=\"headerlink\" title=\"3.5 kernel_init\"></a>3.5 kernel_init</h4><p>kernel_init()函数在创建kernel_init进程时，作为进程被启动；虽然kernel_init最开始只是一个函数，但是在最后，通过系统调用，将读取根文件系统下的init进程，完成从内核态到用户态的转变，转变为用户态的1号进程；这个init进程是所有用户态进程的父进程，产生了大量的子进程；init进程是1号进程，是永远存在的；</p>\n<pre class=\"mermaid\">graph TB\n    A(kernel_init)-->B(kernel_init_freeable)\n    subgraph kernel_init\n        B(kernel_init_freeable)\n        -->C(free_initmem)\n        -->D(ramdisk_execute_command)\n        -->E(execute_command)\n        -->F(用户空间init进程)\n    end</pre>\n\n\n\n\n<h4 id=\"3-6-kernel-init-freeable\"><a href=\"#3-6-kernel-init-freeable\" class=\"headerlink\" title=\"3.6 kernel_init_freeable\"></a>3.6 kernel_init_freeable</h4><p>等待内核线程kthreadd创建完成、注册内核驱动模块do_basic_setup、启动默认控制台/dev/console</p>\n<p>完成设备初始化以及模块加载工作；</p>\n<pre class=\"mermaid\">graph TB\n    A(kernel_init_freeable)-->B(wait_for_completion)\n    subgraph kernel_init_freeable\n        B(wait_for_completion)\n        -->C(set_mems_allowed)\n        -->D(do_basic_setup)\n        -->E(open console)    \n        -->X(ramdisk_execute_command)\n    end</pre>\n\n\n\n\n<h5 id=\"3-6-1-wait-for-completion\"><a href=\"#3-6-1-wait-for-completion\" class=\"headerlink\" title=\"3.6.1 wait_for_completion\"></a>3.6.1 wait_for_completion</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\">kernel_init_freeable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twait_for_completion(&amp;kthreadd_done);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>使用完成量等待kthreadd_done，等待内核线程kthreadd创建完成；虽然kernel_init进程先创建，但是要在kthreadd线程创建完成才能执行；在threadd线程创建完成后才唤醒完成量，开始kernel_init进程的工作；</p>\n<h5 id=\"3-6-2-do-basic-setup\"><a href=\"#3-6-2-do-basic-setup\" class=\"headerlink\" title=\"3.6.2 do_basic_setup\"></a>3.6.2 do_basic_setup</h5><pre class=\"mermaid\">graph TB\n    A(do_basic_setup)-->C(driver_init)\n    subgraph do_basic_setup\n    C(driver_init)\n    -->D(do_initcalls)\n    end</pre>\n\n\n\n\n\n\n\n<h6 id=\"2-driver-init\"><a href=\"#2-driver-init\" class=\"headerlink\" title=\"2. driver_init\"></a>2. driver_init</h6><p>driver_init()函数完成与驱动程序相关的所有子系统的构建，实现了Linux设备驱动的一个整体框架，但是它只是建立了目录结构，是设备驱动程序初始化的第一部分，具体驱动模块的装载在do_initcalls()函数中实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/init.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">driver_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* These are the core pieces */</span></span><br><span class=\"line\">    devtmpfs_init();\t<span class=\"comment\">// 注册devtmpfs文件系统，启动devtmpfsd进程</span></span><br><span class=\"line\">    devices_init();\t\t<span class=\"comment\">// 初始化驱动模型中的部分子系统，/dev/devices, /dev/char, /dev/block</span></span><br><span class=\"line\">    buses_init();\t\t<span class=\"comment\">// 初始化驱动模型中的bus子系统</span></span><br><span class=\"line\">    classes_init();\t\t<span class=\"comment\">// 初始化驱动模型中的class子系统</span></span><br><span class=\"line\">    firmware_init();\t<span class=\"comment\">// 初始化驱动模型中的firmware子系统</span></span><br><span class=\"line\">    hypervisor_init();\t<span class=\"comment\">// 初始化驱动模型中的hypervisor子系统</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* These are also core pieces, but must come after the</span></span><br><span class=\"line\"><span class=\"comment\">     * core core pieces.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    platform_bus_init();\t<span class=\"comment\">// 初始化驱动模型中的bus/platform子系统，此节点是所有platform设备和驱动的总线模型；所有platform设备和驱动都会挂载到这个总线上；</span></span><br><span class=\"line\">    cpu_dev_init();\t\t<span class=\"comment\">// 初始化驱动模型中的device/system/cpu子系统，该节点包含CPU相关属性；</span></span><br><span class=\"line\">    memory_dev_init();\t<span class=\"comment\">// 初始化驱动模型中的device/system/memory子系统，该节点包含了内存相关属性；</span></span><br><span class=\"line\">    container_dev_init();\t<span class=\"comment\">// 初始化系统总线类型为容器；</span></span><br><span class=\"line\">    of_core_init();\t\t<span class=\"comment\">// 初始化创建，访问和结时设备树的过程；</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h6 id=\"3-do-initcalls\"><a href=\"#3-do-initcalls\" class=\"headerlink\" title=\"3. do_initcalls\"></a>3. do_initcalls</h6><p>编译器在编译内核时，将一系列模块初始化函数的起始地址按照一定顺序，放在名为section的段中；在内核启动的初始化阶段，do_initcalls()函数中以函数指针的形式取出这些函数的其实地址，依次运行，以完成相应模块的初始化操作，是设备驱动程序初始化的第二部分；由于内核模块可能存在依赖关系，即某些模块的初始化需要依赖其他模块的初始化来完成，因此这些模块的初始化顺序非常重要；</p>\n<p>依次调用不同等级的初始化函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __init <span class=\"title\">do_initcalls</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 依次调用不同level等级的初始化函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (level = <span class=\"number\">0</span>; level &lt; ARRAY_SIZE(initcall_levels) - <span class=\"number\">1</span>; level++)</span><br><span class=\"line\">        do_initcall_level(level);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>对于同一个level等级下的函数，依次遍历执行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __init <span class=\"title\">do_initcall_level</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">initcall_t</span> *fn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(initcall_command_line, saved_command_line);</span><br><span class=\"line\">    parse_args(initcall_level_names[level],</span><br><span class=\"line\">           initcall_command_line, __start___param,</span><br><span class=\"line\">           __stop___param - __start___param,</span><br><span class=\"line\">           level, level,</span><br><span class=\"line\">           <span class=\"literal\">NULL</span>, &amp;repair_env_string);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对于同一个level等级下的函数，依次遍历执行；</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class=\"number\">1</span>]; fn++)</span><br><span class=\"line\">        do_one_initcall(*fn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>开始执行某一个确定的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __init_or_module <span class=\"title\">do_one_initcall</span><span class=\"params\">(<span class=\"keyword\">initcall_t</span> fn)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = preempt_count();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msgbuf[<span class=\"number\">64</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initcall_blacklisted(fn))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EPERM;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initcall_debug)</span><br><span class=\"line\">        ret = do_one_initcall_debug(fn);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    msgbuf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preempt_count() != count) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(msgbuf, <span class=\"string\">\"preemption imbalance \"</span>);</span><br><span class=\"line\">        preempt_count_set(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (irqs_disabled()) &#123;</span><br><span class=\"line\">        strlcat(msgbuf, <span class=\"string\">\"disabled interrupts \"</span>, <span class=\"keyword\">sizeof</span>(msgbuf));</span><br><span class=\"line\">        local_irq_enable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    WARN(msgbuf[<span class=\"number\">0</span>], <span class=\"string\">\"initcall %pF returned with %s\\n\"</span>, fn, msgbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">    add_latent_entropy();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>编译到内核中的模块，是按照执行的level等级，将模块的初始化函数指针地址，分别放到相对应level等级的section中的；</p>\n<p>initcall_t是一个函数指针类型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*<span class=\"keyword\">initcall_t</span>)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/init.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __define_initcall(fn, id) \\</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">initcall_t</span> __initcall_#<span class=\"meta\">#fn##id __used \\</span></span><br><span class=\"line\">    __attribute__((__section__(<span class=\"string\">\".initcall\"</span> #id <span class=\"string\">\".init\"</span>))) = fn;</span><br></pre></td></tr></table></figure>\n\n\n<p>__attribute__((__section__())) 表示把对象放在这个由括号中的名称所指代的section中；</p>\n<p>__define_initcall()宏的含义是：</p>\n<blockquote>\n<ol>\n<li>声明一个名称为__initcall_##fn的函数指针（其中##表示将两边的变量连接为一个变量）；</li>\n<li>将这个函数指针初始化为fn；</li>\n<li>编译时，要将这个函数指针变量放到名称为”.initcall” #id “.init”的section中；（比如：level=”2”，表示这个section的名称为”.initcall2.init”）</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>举例：</p>\n<pre><code>\\_\\_define\\_initcall(6, pci\\_init)</code></pre><p>含义：</p>\n<ol>\n<li>声明一个函数指针，并赋值：__initcall_pci_init = pci_init；</li>\n<li><ol start=\"2\">\n<li>编译时要将函数指针变量__initcall_pci_init放到名称为initcall6.init的section中；（其实就是将pci_init函数的首地址放到名称为initcall6.init的section中）</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>__define_initcall()宏并不会直接使用，而是被定义为其他的宏定义形式使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/init.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pure_initcall(fn)       __define_initcall(fn, 0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> core_initcall(fn)       __define_initcall(fn, 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> core_initcall_sync(fn)      __define_initcall(fn, 1s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> postcore_initcall(fn)       __define_initcall(fn, 2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> postcore_initcall_sync(fn)  __define_initcall(fn, 2s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arch_initcall(fn)       __define_initcall(fn, 3)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arch_initcall_sync(fn)      __define_initcall(fn, 3s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> subsys_initcall(fn)     __define_initcall(fn, 4)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> subsys_initcall_sync(fn)    __define_initcall(fn, 4s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> fs_initcall(fn)         __define_initcall(fn, 5)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> fs_initcall_sync(fn)        __define_initcall(fn, 5s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rootfs_initcall(fn)     __define_initcall(fn, rootfs)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> device_initcall(fn)     __define_initcall(fn, 6)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> device_initcall_sync(fn)    __define_initcall(fn, 6s)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> late_initcall(fn)       __define_initcall(fn, 7)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> late_initcall_sync(fn)      __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>\n\n\n<p>通过core_initcall()来声明的函数指针，将被放到名为.initcall1.init的section中；通过postcore_initcall()来声明的函数指针，将被放到名为.initcall2.init的section中；以此类推；</p>\n<blockquote>\n<p>举例：</p>\n<pre><code>device_initcall(pci_init);</code></pre><p>含义：</p>\n<ol>\n<li>声明一个函数指针，并赋值：__initcall_pci_init = pci_init；</li>\n<li>编译时要将函数指针变量__initcall_pci_init放到名称为initcall6.init的section中；（其实就是将pci_init函数的首地址放到名称为initcall6.init的section中）</li>\n</ol>\n</blockquote>\n<p>在编译生成的vmlinux.lds文件中，可以找到initcall相关的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tmp/bsp/DBG/BOARDLX2160LE/ARMQORIQLE/kernel/kernels/linux-4.9.115-cgel/arch/arm64/kernel/vmlinux.lds</span></span><br><span class=\"line\">  __initcall_start = .; KEEP(*(.initcallearly.init))</span><br><span class=\"line\">  __initcall0_start = .; KEEP(*(.initcall0.init)) KEEP(*(.initcall0s.init))</span><br><span class=\"line\">  __initcall1_start = .; KEEP(*(.initcall1.init)) KEEP(*(.initcall1s.init))</span><br><span class=\"line\">  __initcall2_start = .; KEEP(*(.initcall2.init)) KEEP(*(.initcall2s.init))</span><br><span class=\"line\">  __initcall3_start = .; KEEP(*(.initcall3.init)) KEEP(*(.initcall3s.init))</span><br><span class=\"line\">  __initcall4_start = .; KEEP(*(.initcall4.init)) KEEP(*(.initcall4s.init))</span><br><span class=\"line\">  __initcall5_start = .; KEEP(*(.initcall5.init)) KEEP(*(.initcall5s.init))</span><br><span class=\"line\">  __initcallrootfs_start = .; KEEP(*(.initcallrootfs.init)) KEEP(*(.init     callrootfss.init))</span><br><span class=\"line\">  __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init))</span><br><span class=\"line\">  __initcall7_start = .; KEEP(*(.initcall7.init)) KEEP(*(.initcall7s.init))</span><br><span class=\"line\">  __initcall_end = .;</span><br></pre></td></tr></table></figure>\n\n\n<p>在这些section中，总的开始位置被标识为__initcall_start，而在结尾被标识为__initcall_end；</p>\n<p>do_initcalls()函数，会从这些section中依次取出所有的函数指针，并按顺序调用这些函数指针调用的函数，来分别完成内核中驱动模块的初始化操作；</p>\n<p>函数指针被放到哪个section中，是由宏定义__define_initcall(fn, id)的参数id，也就是level决定的，对应level更小的子section的位置更靠前；而位于同一个子section中的函数指针顺序不定，由编译器按照编译顺序随机决定；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">initcall_t</span> *initcall_levels[] __initdata = &#123;</span><br><span class=\"line\">    __initcall0_start,</span><br><span class=\"line\">    __initcall1_start,</span><br><span class=\"line\">    __initcall2_start,</span><br><span class=\"line\">    __initcall3_start,</span><br><span class=\"line\">    __initcall4_start,</span><br><span class=\"line\">    __initcall5_start,</span><br><span class=\"line\">    __initcall6_start,</span><br><span class=\"line\">    __initcall7_start,</span><br><span class=\"line\">    __initcall_end,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"3-6-3-ramdisk-execute-command\"><a href=\"#3-6-3-ramdisk-execute-command\" class=\"headerlink\" title=\"3.6.3 ramdisk_execute_command\"></a>3.6.3 ramdisk_execute_command</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ramdisk_execute_command)</span><br><span class=\"line\">        ramdisk_execute_command = <span class=\"string\">\"/init\"</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>kernel_init_freeable()函数会去判断ramdisk_execute_command是否为空，如果不为空，就直接运行ramdisk_execute_command指定的程序；ramdisk_execute_command的取值分以下情况：</p>\n<blockquote>\n<ol>\n<li>如果命令行参数中指定了“rdinit=…”，则ramdisk_execute_command等于这个参数指定的程序；</li>\n<li>否则，如果/init程序存在，ramdisk_execute_command=/init；</li>\n<li>否则，ramdisk_execute_command为空；</li>\n</ol>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/main.c</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sys_access((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *) ramdisk_execute_command, <span class=\"number\">0</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ramdisk_execute_command = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    prepare_namespace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-7-free-initmem\"><a href=\"#3-7-free-initmem\" class=\"headerlink\" title=\"3.7 free_initmem\"></a>3.7 free_initmem</h4><p>free_initmem()函数用来释放所有init.段中的内存；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm64/mm/init.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_initmem</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    free_reserved_area(__va(__pa(__init_begin)), __va(__pa(__init_end)),</span><br><span class=\"line\">               <span class=\"number\">0</span>, <span class=\"string\">\"unused kernel\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Unmap the __init region but leave the VM area in place. This</span></span><br><span class=\"line\"><span class=\"comment\">     * prevents the region from being reused for kernel modules, which</span></span><br><span class=\"line\"><span class=\"comment\">     * is not supported by kallsyms.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    unmap_kernel_range((u64)__init_begin, (u64)(__init_end - __init_egin));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-8-启动用户态init进程\"><a href=\"#3-8-启动用户态init进程\" class=\"headerlink\" title=\"3.8 启动用户态init进程\"></a>3.8 启动用户态init进程</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kernel/init/main.c</span></span><br><span class=\"line\">kernel_init()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ramdisk_execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(ramdisk_execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        pr_err(<span class=\"string\">\"Failed to execute %s (error %d)\\n\"</span>,</span><br><span class=\"line\">               ramdisk_execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        panic(<span class=\"string\">\"Requested init %s failed (error %d).\"</span>,</span><br><span class=\"line\">              execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!try_to_run_init_process(<span class=\"string\">\"/sbin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/etc/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/sh\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">try_to_run_init_process</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init_filename)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = run_init_process(init_filename);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">run_init_process</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init_filename)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    argv_init[<span class=\"number\">0</span>] = init_filename;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_execve(getname_kernel(init_filename),</span><br><span class=\"line\">        (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *)argv_init,</span><br><span class=\"line\">        (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *)envp_init);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在大多数系统中，bootloader会传递参数给内核的main函数，而这些参数中会包含init=/linuxrc参数，于是在kernel_init进程中，如果有execute_command = “linuxrc”，在经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行，通过do_execve()函数进入用户态，开始文件系统的初始化init进程；</p>\n<p>如果boot没有传递init=/linuxrc参数给内核，ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic(<span class=\"string\">\"No working init found.  Try passing init= option to kernel. \"</span></span><br><span class=\"line\">          <span class=\"string\">\"See Linux Documentation/init.txt for guidance.\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>出现这种异常错误，可能是以下几个原因造成：</p>\n<blockquote>\n<ol>\n<li>启动参数配置错误，指定了init，但是未找到；</li>\n<li>文件系统挂载出错；</li>\n<li>四个应用程序找不到，或者没有可执行权限；</li>\n</ol>\n</blockquote>\n<p>到此，Linux内核部分启动结束，下一步会在文件系统中启动用户空间的init进程，并进行下一步的启动操作；</p>\n<h3 id=\"4-filesystem启动\"><a href=\"#4-filesystem启动\" class=\"headerlink\" title=\"4. filesystem启动\"></a>4. filesystem启动</h3><pre class=\"mermaid\">graph LR\n    kernel_init(\"kernel_init()\")--\"init=linuxrc\"-->linuxrc(linuxrc)\n    --链接-->busybox(\"/bin/busybox\")\n    kernel_init(\"kernel_init()\")--default-->init(\"/sbin/init\")\n    --链接-->busybox(\"/bin/busybox\")\n    --inittab-->rcS(\"/etc/init.d/rcS\")</pre>\n\n\n<h4 id=\"4-1-filesystem构建\"><a href=\"#4-1-filesystem构建\" class=\"headerlink\" title=\"4.1 filesystem构建\"></a>4.1 filesystem构建</h4><p>文件系统可以通过busybox工具来构建；构建成功之后，一般情况下是不需要修改的；我们使用的文件系统，由成研提供；具体的构建方法此处先省略，有时间再补上；</p>\n<h4 id=\"4-2-busybox程序\"><a href=\"#4-2-busybox程序\" class=\"headerlink\" title=\"4.2 busybox程序\"></a>4.2 busybox程序</h4><p>在Kernel挂载文件系统后，通过kernel_init()函数，准备运行init进程；</p>\n<p>在kernel/init/main.c文件中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kernel/init/main.c</span></span><br><span class=\"line\">kernel_init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ramdisk_execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(ramdisk_execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        pr_err(<span class=\"string\">\"Failed to execute %s (error %d)\\n\"</span>,</span><br><span class=\"line\">               ramdisk_execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (execute_command) &#123;</span><br><span class=\"line\">        ret = run_init_process(execute_command);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        panic(<span class=\"string\">\"Requested init %s failed (error %d).\"</span>,</span><br><span class=\"line\">              execute_command, ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!try_to_run_init_process(<span class=\"string\">\"/sbin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/etc/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/init\"</span>) ||</span><br><span class=\"line\">        !try_to_run_init_process(<span class=\"string\">\"/bin/sh\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行；而linuxrc文件是一个指向/bin/busybox的链接，也就是说，系统启动后运行的第一个程序是/bin/busybox；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls linuxrc -l</span></span><br><span class=\"line\">lrwxrwxrwx 1 root root 11 Mar  4 10:04 linuxrc -&gt; bin/busybox</span><br></pre></td></tr></table></figure>\n\n\n<p>如果ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；而/sbin/init文件也是链接到/bin/busybox的，最终还是会执行/bin/busybox程序；创建用户空间运行的第一个进程；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /sbin/init -l</span></span><br><span class=\"line\">lrwxrwxrwx    1 root     root            14 Dec 12  2019 /sbin/init -&gt; ../bin/busybox</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"4-3-init进程\"><a href=\"#4-3-init进程\" class=\"headerlink\" title=\"4.3 init进程\"></a>4.3 init进程</h4><p>busybox程序运行，会启动init进程，init进程在Linux系统中是最早运行的进程，也就是1号进程；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ps -aux | grep init</span></span><br><span class=\"line\">root         1  0.8  0.0   2080    12 ?        Ss   18:47   0:20 init</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>init进程进行的工作：</p>\n<blockquote>\n<ol>\n<li>为init设置信号处理过程</li>\n<li>初始化控制台</li>\n<li>解析/etc/inittab文件</li>\n<li>执行系统初始化命令，一般情况下会使用/etc/init.d/rcS</li>\n<li>执行所有导致init暂停的inittab命令（动作类型：wait）</li>\n<li>执行所有仅执行一次的inittab命令（动作类型：once）</li>\n</ol>\n</blockquote>\n<p>执行完以上工作后，init进程会循环执行以下进程：</p>\n<blockquote>\n<p>1.执行所有终止时必须重新启动的inittab命令（动作类型：respawn）</p>\n<p>2.执行所有终止时必须重新启动但启动前必须询问用户的inittab命令（动作类型：askfirst）</p>\n</blockquote>\n<h4 id=\"4-4-inittab\"><a href=\"#4-4-inittab\" class=\"headerlink\" title=\"4.4 inittab\"></a>4.4 inittab</h4><p>busybox程序解析/etc/inittab文件，而/etc/inittab是进行初始化的配置文件；busybox运行时会按照格式解析inittab文件，根据解析内容决定具体工作；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/inittab</span></span><br><span class=\"line\">::sysinit:/etc/init.d/rcS</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">::once:/bin/sw &amp;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">The followed sentence does<span class=\"string\">'t need password.</span></span></span><br><span class=\"line\">::respawn:-/bin/ash</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">The followed sentence does need password.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">::respawn:-/bin/login</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">tty2::askfirst:-/bin/ash</span></span><br><span class=\"line\">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>inittab的内容以行为单位，行与行之间没有关联，每行都是一个独立的配置项；每一行的配置项都是由3个冒号分隔开的4个配置值组成，冒号是分隔符，分隔开各个部分；</p>\n<p>inittab文件里的代码格式：</p>\n<p>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</p>\n<p>说明：</p>\n<blockquote>\n<p>id：/dev/id，用作终端terminal：stdin、stdout、stderr、printf、scanf、err</p>\n<p>runlevels：</p>\n<p>action：执行时机；包括：sysinit、respawd、askfirst、wait、once、restart、ctrialtdel、shutdown</p>\n<p>process：应用程序和脚本</p>\n</blockquote>\n<h4 id=\"4-5-rcS\"><a href=\"#4-5-rcS\" class=\"headerlink\" title=\"4.5 rcS\"></a>4.5 rcS</h4><p>在/etc/inittab配置文件中，action为sysinit的行，表示在Linux系统初始化文件系统时执行的第一个脚本，即：/etc/init.d/rcS；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::sysinit:/etc/init.d/rcS</span><br></pre></td></tr></table></figure>\n\n\n<p>主要进行一些初始化工作：启动交换分区、检查磁盘、设置主机名、检查并挂载文件系统、加载并初始化硬件模块等；</p>\n<p>/etc/init.d/rcS文件是Linux运行时非常重要的一个脚本程序；其他的配置在rcS文件中进行，rcS文件中的配置可以根据需求进行扩展；/etc/init.d/rcS完成各个文件系统的挂载（mount），以及文件硬件模块的初始化；</p>\n<h3 id=\"5-应用进程启动\"><a href=\"#5-应用进程启动\" class=\"headerlink\" title=\"5. 应用进程启动\"></a>5. 应用进程启动</h3><p>应用进程，可以在文件系统的/etc/init.d/rcS脚本运行时，调用xxx.sh脚本拉起来的；</p>\n<p><a href=\"#目录\">跳转到目录</a></p>"},{"title":"Linux块设备驱动","date":"2020-04-19T02:40:13.000Z","_content":"\n\n\n\n\n未完成\n\n\n\nLinux块设备驱动\n\n\n\n<!--more-->\n\n\n\n\n### 目录\n\n\n[TOC]\n\n\n### 0. 简介\n\n\n\n\n字符设备\n\n\n字符设备是一种顺序的数据流设备，对字符设备的读写是以字节为单位进行的，这些字符连续地形成一个数据流，字符设备没有缓存区，对于字符设备的读写是实时的；\n\n\n\n\n块设备\n\n\n块设备是一种具有一定结构的随机存取设备，对块设备的读写是以块为单位进行的，块设备使用缓存区来存放数据，待条件满足后，将数据从缓存区一次性写入到设备，或者从设备一次性读取到缓存区；\n\n\n\n|       字符设备       |       块设备       |\n| :------------------: | :----------------: |\n|       顺序访问       |      随机访问      |\n|      数据流设备      |      存储设备      |\n|     以字节为单位     |     以块为单位     |\n| 没有缓存区，实时读写 |  有缓存区，非实时  |\n|   由应用层程序调用   | 由文件系统程序调用 |\n\n\n\n\n\n\n为了创建一个块设备驱动程序，实现一个基于内存的块设备驱动程序；\n\n\n\n\n#### 1. 块设备结构\n\n\n**段（Segments）**：由若干个块组成；是Linux内存管理机制中一个内存页或内存页的一部分；\n\n\n**块（Blocks）**：由Linux制定对内核或文件系统等数据处理的基本单位；通常通常为4096个字节，由1个或多个扇区组成；\n\n\n**扇区（Sectors）**：块设备的基本单位，是一个固定的硬件单位，制定了设备最少能够传输的数据量；通常在512字节到32768字节之间，默认：512字节；\n\n\n块是连续扇区的序列，块长度总是扇区长度的整数倍；块的最大长度，受特定体系结构的内存页长度限制；\n\n\n\n\n块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备；\n\n![Linux的块IO](Linux块设备驱动/Linux的块IO.png)\n\n\n\n#### 2. 块设备驱动框架\n\n\n\n![块设备驱动架构图](Linux块设备驱动/块设备驱动架构图.jpg)\n\n\n\n\n\n\n\n\n### 1. 重要结构及操作\n\n\n\n\n#### 1. 注册块设备驱动程序\n\n\n向内核注册块设备驱动程序\n\n\n```c\n#include <linux/fs.h>\nint register_blkdev(unsigned int major, const char *name);\n```\n\n\n\n> name：设备名字，是在/proc/devices中显示的名字\n>\n> major：设备的主设备号，如果major=0，则分配一个主设备号\n\n该函数的调用是可选的，完成的工作：\n\n> 1. 如果需要的话分配一个动态的主设备号\n> 2. 在/proc/devices中创建一个入口项\n\n\n\n注销块设备驱动程序\n\n\n```c\n#include <linux/fs.h>\nvoid unregister_blkdev(unsigned int major, const char *name);\n```\n\n\n\n\n如下用例：\n\n\n```c\n#include <linux/fs.h>\nint sbull_major = 0;\nsbull_major = register_blkdev(sbull_major, \"sbull\");\nif (sbull_major < 0) {\n\tprintk(KERN_WARNNING \"sbull: unable to get major number\\n\");\n\treturn -EBUSY;\n}\n```\n\n\n\n\n```c\n// include/linux/fs.h\nstruct block_device {\n    dev_t           bd_dev;  /* not a kdev_t - it's a search key */\n    int         bd_openers;\n    struct inode *      bd_inode;   /* will die */\n    struct super_block *    bd_super;\n    struct mutex        bd_mutex;   /* open/close mutex */\n    void *          bd_claiming;\n    void *          bd_holder;\n    int         bd_holders;\n    bool            bd_write_holder;\n#ifdef CONFIG_SYSFS\n    struct list_head    bd_holder_disks;\n#endif\n    struct block_device *   bd_contains;\n    unsigned        bd_block_size;\n    struct hd_struct *  bd_part;\n    /* number of times partitions within this device have been opened. */\n    unsigned        bd_part_count;\n    int         bd_invalidated;\n    struct gendisk *    bd_disk;\n    struct request_queue *  bd_queue;\n    struct list_head    bd_list;\n    /*\n     * Private data.  You must have bd_claim'ed the block_device\n     * to use this.  NOTE:  bd_claim allows an owner to claim\n     * the same device multiple times, the owner must take special\n     * care to not mess up bd_private for that case.\n     */\n    unsigned long       bd_private;\n\n    /* The counter of freeze processes */\n    int         bd_fsfreeze_count;\n    /* Mutex for freeze */\n    struct mutex        bd_fsfreeze_mutex;\n};\n```\n\n\n\n\n\n\n\n\n#### 2. 块设备操作\n\n\n\n\n字符设备使用file_operations结构，来告诉系统字符设备驱动的操作接口；\n\n\n块设备使用block_device_operations结构，来告诉系统块设备驱动的操作接口；\n\n\n```c\n// include/linux/blkdev.h\nstruct block_device_operations {\n    int (*open) (struct block_device *, fmode_t);\n    void (*release) (struct gendisk *, fmode_t);\n    int (*rw_page)(struct block_device *, sector_t, struct page *, bool);\n    int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n    int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n\t......\n    /* ->media_changed() is DEPRECATED, use ->check_events() instead */\n    int (*media_changed) (struct gendisk *);\n    int (*getgeo)(struct block_device *, struct hd_geometry *);\n\t......\n};\n```\n\n\n和字符设备驱动不同，块设备驱动的block_device_operations操作集中没有负责读和写数据的函数；在块设备驱动中，这些操作是由request函数处理的；\n\n\n\n\n#### 3. 注册磁盘\n\n\n为了管理独立的磁盘，需要使用struct gendisk结构体，内核使用gendisk结构表示一个独立的磁盘设备，还可以表示分区；\n\n\n```c\n// include/linux/genhd.h\nstruct gendisk {\n    int major;          /* major number of driver */\n    int first_minor;\n    int minors;                     /* maximum number of minors, =1 for\n                                         * disks that can't be partitioned. */\n    char disk_name[DISK_NAME_LEN];  /* name of major driver */\n    char *(*devnode)(struct gendisk *gd, umode_t *mode);\n\n    struct hd_struct part0;\n\n    const struct block_device_operations *fops;\n    struct request_queue *queue;\n\t......\n};\n```\n\n\nmajor：指定驱动程序的主设备号\n\n\nfirst_minor和minors：从设备号的可能范围\n\n\ndisk_name：磁盘名称，在/proc/partitions 和 sysfs 中表示该磁盘\n\n\n\n\n```c\nchar disk_name[DISK_NAME_LEN];\n```\n\n\n显示在/proc/partitions 和 sysfs 中\n\n\n\n\n对于每一个分区来说，都有一个hd_struct结构体，用于描述该分区\n\n\n```c\n// include/linux/genhd.h\nstruct hd_struct {\n    sector_t start_sect;\n    sector_t nr_sects;\n    seqcount_t nr_sects_seq;\n\t......\n    struct partition_meta_info *info;\n\t......\n};\n```\n\n\nstart_sect和nr_sects：定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区\n\n\n\n\n拥有了设备内存和请求队列，就可以分配、初始化及安装gendisk结构；在struct gendisk是动态分配的结构，需要内核进行初始化，驱动必须通过alloc_disk分配：\n\n\n```c\n# include <linux/genhd.h>\nstruct gendisk *alloc_disk(int minors);\n```\n\n> minors：是该磁盘使用的从设备号的数目；\n\n\n\n卸载磁盘\n\n\n```c\nvoid del_gendisk(struct gendisk *disk)\n```\n\n\ngendisk是一个引用计数结构，get_disk和put_disk函数负责处理引用计数；调用del_gendisk后，该结构可能继续存在；\n\n\n\n\n为了使gendisk结构的磁盘设备生效，需要初始化结构，并将磁盘或分区信息添加到内核链表；\n\n\n```c\nvoid add_disk(struct gendisk *gd);\n```\n\n\n调用add_disk后，磁盘设备将被激活，并随时会调用它提供的操作方法，因此在驱动程序完全被初始化并且能够响应对磁盘的请求前，不要调用add_disk；\n\n\n\n\n#### 4. 请求队列\n\n\n\n块设备驱动程序的核心是请求函数，包含请求处理过程；\n\n有I/O调度类设备，使用blk_init_queue()函数：\n\n```c\n// block/blk-core.c\nstruct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock)\n```\n\n无I/O调度类设备，使用blk_alloc_queue()函数：\n\n```c\n// block/blk-core.c\nstruct request_queue *blk_alloc_queue(gfp_t gfp_mask)\n// block/blk-settings.c\nvoid blk_queue_make_request(struct request_queue *q, make_request_fn *mfn)\n```\n\n从请求队列中提取请求：\n\n```c\n// block/blk-core.c\nstruct request *blk_fetch_request(struct request_queue *q)\n```\n\n在卸载函数中使用的清除请求队列：\n\n```c\n// block/blk-core.c\nvoid blk_cleanup_queue(struct request_queue *q)\n```\n\n\n\n\n块设备的读写请求放置在请求队列中，在struct gendisk中，通过struct request_queue *queue指针指向请求队列；请求队列用数据结构struct request_queue表示；\n\n\n```c\n// include/linux/blkdev.h\nstruct request_queue {\n    struct list_head    queue_head;\n    struct request      *last_merge;\n    struct elevator_queue   *elevator;\n\t......\n    request_fn_proc     *request_fn;\n    make_request_fn     *make_request_fn;\n\t......\n    void            *queuedata;\n    struct list_head    icq_list;\n    struct queue_limits limits;\n    struct blk_flush_queue  *fq;\n    struct list_head    requeue_list;\n    spinlock_t      requeue_lock;\n    struct delayed_work requeue_work;\n\t......\n};\n```\n\n\nqueue_head：表头，用于构建一个IO请求的双链表；链表每个元素代表向块设备读取数据的一个请求；内核会重排该链表，以得到更好的IO性能；\n\n\n\n\n与每个块设备驱动程序相关的I/O请求队列用request_queue结构体描述，而每个request_queue队列中的请求用request结构体描述；\n\n\n```c\n// include/linux/blkdev.h\nstruct request {\n    struct list_head queuelist;\n\n    struct request_queue *q;\n    struct blk_mq_ctx *mq_ctx;\n\n    /* the following two fields are internal, NEVER access directly */\n    unsigned int __data_len;    /* total data len */\n    sector_t __sector;      /* sector cursor */\n\n    struct bio *bio;\n    struct bio *biotail;\n\n\tstruct request *next_rq;\n    ......\n}\n```\n\n\n\n\nrequest结构体关联了struct bio，struct bio结构体是块I/O操作在页级粒度的底层描述；\n\n\n```c\n// include/linux/blk_types.h\nstruct bio {\n    struct bio      *bi_next;   /* request queue link */\n    struct block_device *bi_bdev;\n    int         bi_error;\n\n    unsigned short      bi_flags;   /* status, command, etc */\n    unsigned short      bi_ioprio;\n\n    struct bvec_iter    bi_iter;\n\n    atomic_t        __bi_remaining;\n    bio_end_io_t        *bi_end_io;\n    \n    unsigned short      bi_vcnt;    /* how many bio_vec's */\n    unsigned short      bi_max_vecs;    /* max bvl_vecs we can hold */\n    struct bio_vec      *bi_io_vec; /* the actual vec list */\n\t......\n}\n```\n\n\n块数据通过bio_vec结构体数组在内部被表示成I/O向量；每个bio_vec数组元素由三元组组成（即，页、页偏移、长度），表示该块I/O的一个段；\n\n```c\n// include/linux/bvec.h\nstruct bio_vec {\n    struct page *bv_page;\t// 页指针\n    unsigned int    bv_len;\t// 传输的字节数\n    unsigned int    bv_offset;\t// 偏移位置\n};\n```\n\nstruct bvec_iter结构体用来记录当前bvec被处理的情况，用于遍历bio；\n\n```c\n// include/linux/bvec.h\nstruct bvec_iter {\n    sector_t        bi_sector;  /* device address in 512 byte sectors */\n    unsigned int\tbi_size;    /* residual I/O count */\n    unsigned int\tbi_idx;     /* current index into bvl_vec */\n    unsigned int\tbi_bvec_done;   /* number of bytes completed in current bvec */\n};\n```\n\n\n\n#### 5. 数据结构间的关系\n\n| 数据结构      | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| request_queue | 表示针对一个gendisk对象的所有请求的队列，是对应gendisk结构的一个成员； |\n| request       | 表示经过I/O调度之后的针对gendisk的一个请求，是request_queue结构队列的一个节点，多个request构成了一个request_queue队列； |\n| bio           | 表示应用程序对一个gendisk原始的访问请求；一个bio由多个bio_vec组成，多个bio经过I/O调度和合并形成一个request； |\n| bio_vec       | 描述的应用层准备读写一个gendisk时需要使用的内存页（page）的一部分；多个bio_vec形成一个bio； |\n| bvec_iter     | 描述一个bio_vec结构中的一个sector信息；                      |\n\n\n\n块设备数据结构间的关系如下所示：\n\n![块设备数据结构间的关系](Linux块设备驱动/块设备数据结构间的关系.png)\n\n\n\n\n### 2. 块设备驱动的初始化\n\n\n\n#### 2.1 块设备的注册过程\n\n注册一个块设备驱动，需要以下步骤：\n\n\n\n> 创建一个块设备 \n>\n> 分配一个申请队列\n>\n> 分配一个gendisk结构体\n>\n> 设置gendisk结构体成员\n>\n> 注册gendisk结构体\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tA(\"注册设备(register_blkdev)(可选)\")-->B(\"分配磁盘(alloc_disk)\")\n\tB--有I/O调度-->C(\"不使用请求队列(blk_init_queue)\")-->E\n\tB--无I/O调度-->D(\"使用请求队列(blk_alloc_queue)\")-->E\n\tE(\"设置磁盘属性(gendisk)\")-->F(\"激活磁盘(add_disk)\")\n```\n\n\n1. 通过register_blkdev()函数注册设备，是个可选操作；\n\n2. 使用alloc_disk()函数分配通用磁盘gendisk结构体；\n\n3. 根据是否需要I/O调度，分两种情况，一种是使用请求队列进行数据传输，一种是不使用请求队列进行数据传输；\n\n4. 初始化gendisk结构体的数据成员，包括：major、fops、queue等；\n\n5. 使用add_disk()函数激活磁盘设备，调用该函数之前要做好所有的准备工作；\n\n\n\n\n\n\n分配一个gendisk结构体\n\n\n设置一个队列，将访问请求放到队列里\n\n\n设置gendisk结构体的属性，如：名称、容量、操作集等\n\n\n添加gendisk结构体\n\n\n另外分配一块内存空间，当做块设备，在request函数中使用memcpy访问，模仿块设备读写\n\n\n\n\n```c\nmodule_init(sbull_blkdev_init);\nmodule_exit(sbull_blkdev_exit);\n```\n\n\n\n\n块设备驱动程序的初始化方法在sbull_blkdev_init()函数中；\n\n\n\n\n##### 1）注册块设备\n\n\n```c\nstatic int major = 0;\nmajor = register_blkdev(major, \"sbull_blkdev\");\n```\n\n\n为块设备驱动分配一个未使用的主设备号，并在/proc/devies中添加一个入口；\n\n\n\n\n##### 2）注册请求队列\n\n\n注册请求队列的操作，将一个请求的操作方法与该设备相关联，通过blk_init_queue()函数实现；\n\n\n```c\nstatic struct request_queue *sbull_blkdev_request = NULL;\nstatic DEFINE_SPINLOCK(sbull_blkdev_lock);\nsbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &sbull_blkdev_lock);\n```\n\nblk_init_queue()函数返回请求队列request_queue，将sbull_blkdev_request()函数指针方式关联到该设备；\n\n第一个参数是函数指针，用来指定请求队列的处理函数；\n\n第二个参数是自旋锁，用来保护request_queue队列不被同时访问；\n\n\n\n\n##### 3）设置读写块大小\n\n\n硬件执行磁盘是以扇区为单位的，而文件系统是以块为单位处理数据；通常，扇区大小为512字节，块大小为4096字节；需要将硬件支持的扇区大小和驱动程序在一次请求中能接收的最大扇区数通知块层；\n\n\n```c\n// include/linux/blkdev.h\nint sbull_blkdev_sect_size = 512;\nint sbull_blkdev_size = 16 * 1024 * 1024;\n// blk_queue_hardsect_size(blkdev_queue, my_blkdev_sect_size);\nblk_queue_logical_block_size(sbull_blkdev_queue, sbull_blkdev_sect_size);\n```\n\n\n\n\n##### 4）创建磁盘\n\n\n使用alloc_disk()函数分配一个与设备对应的磁盘gendisk结构体，并初始化其成员；需要初始化的成员有：block_device_operations、存储容量（单位是扇区）、请求队列、主设备号、磁盘名称等；设置存储容量通过set_capacity()函数来完成；\n\n\n调用add_disk()函数将磁盘添加到块I/O层；\n\n\n```c\nsbull_blkdev_disk = alloc_disk(1);\n\nsprintf(sbull_blkdev_disk->disk_name, \"sbull_blkdev_disk\");\nsbull_blkdev_disk->fops = &sbull_blkdev_fops;\nsbull_blkdev_disk->queue = sbull_blkdev_queue;\nsbull_blkdev_disk->major = major;\nsbull_blkdev_disk->first_minor = 0;\nset_capacity(sbull_blkdev_disk, sbull_blkdev_size);\n\nadd_disk(sbull_blkdev_disk);\n```\n\n\n\n\n到这里，设备/dev/sbull_blkdev_disk就可以使用了，如果设备支持多个磁盘分区，会显示为/dev/sbull_blkdev_diskX，X是分区号；\n\n\n```c\n# ls /dev/sbull_blkdev_disk -l\nbrw-rw----    1 root     root      253,   0 Oct 21 08:18 /dev/sbull_blkdev_disk\n```\n\n\n\n##### 5）块设备初始化实例\n\n\n\n\n```c\nstruct block_device_operations sbull_blkdev_fops = {\n    .owner = THIS_MODULE,\n    .open = sbull_blkdev_open,\n    .release = sbull_blkdev_release,\n    .ioctl = sbull_blkdev_ioctl,\n};\n```\n\n\n\n请求处理函数，具体实现内容，后边补充；\n\n```c\nvoid sbull_blkdev_request(struct request_queue *q)\n{\n    printk(\"%s: %d\\n\", __func__, __LINE__);\n\n    return;\n}\n```\n\n\n\n\n```c\nstatic int major = 0;\nstatic struct request_queue *sbull_blkdev_queue = NULL;\nstatic struct gendisk *sbull_blkdev_disk = NULL;\nstatic DEFINE_SPINLOCK(sbull_blkdev_lock);\n\nint sbull_blkdev_size = 256 * 1024;\nint sbull_blkdev_sect_size = 512;\n\nstatic int sbull_blkdev_init(void)\n{\n    major = register_blkdev(major, \"mcy_blk\");\n    if (major < 0) {\n        printk(\"%s, register_blkdev failed, major: %d\\n\", __func__, major);\n        goto register_blkdev_err;\n    }\n    printk(\"%s, major: %d\\n\", __func__, major);\n\n    sbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &sbull_blkdev_lock);\n    if (!sbull_blkdev_queue) {\n        printk(\"%s, blk_init_queue failed!\\n\", __func__);\n        goto init_queue_err;\n    }\n\n    sbull_blkdev_disk = alloc_disk(1);\n    if (!sbull_blkdev_disk) {\n        printk(\"%s, alloc_disk failed!\\n\", __func__);\n        goto alloc_disk_err;\n    }\n\n    sprintf(sbull_blkdev_disk->disk_name, \"sbull_blkdev_disk\");\n    sbull_blkdev_disk->fops = &sbull_blkdev_fops;\n    sbull_blkdev_disk->queue = sbull_blkdev_queue;\n    sbull_blkdev_disk->major = major;\n    sbull_blkdev_disk->first_minor = 0;\n    set_capacity(sbull_blkdev_disk, sbull_blkdev_size * 2);\n\n    add_disk(sbull_blkdev_disk);\n    printk(\"%s, sbull_blkdev_disk add success!\\n\", __func__);\n\n    return 0;\nalloc_disk_err:\n    blk_cleanup_queue(sbull_blkdev_queue);\ninit_queue_err:\n    unregister_blkdev(major, \"sbull_blkdev\");\nregister_blkdev_err:\n    return -EBUSY;\n}\n```\n\n\n\n#### 2.2 块设备的卸载过程\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tA(\"删除gendisk(del_gendisk)\")-->\n\tB(\"删除gendisk的引用(put_disk)\")-->\n\tC(\"清除请求队列(blk_cleanup_queue)\")-->\n\tD(\"注销块设备(unregister_blkdev)\")\n```\n\n\n1. 使用del_gendisk()函数删除gendisk设备（磁盘）；\n\n2. 使用put_disk()函数删除gendisk设备的引用；\n\n3. 使用blk_cleanup_queue()函数清除请求队列，释放请求队列占用的资源；\n\n4. 使用unregister_blkdev()函数注销设备，并释放对设备的引用，可选操作，与register_blkdev()函数配合使用；\n\n\n\n\n```c\nstatic void sbull_blkdev_exit(void)\n{\n    del_gendisk(sbull_blkdev_disk);\n    put_disk(sbull_blkdev_disk);\n    blk_cleanup_queue(sbull_blkdev_queue);\n    unregister_blkdev(major, \"sbull_blkdev\");\n}\n```\n\n\n\n```c\nmodule_init(sbull_blkdev_init);\nmodule_exit(sbull_blkdev_exit);\nMODULE_LICENSE(\"GPL\");\n```\n\n\n\n\n\n#### 2.3 封装块设备信息\n\n为了在一些函数中能够访问块设备驱动的一些信息（比如：请求队列，硬盘分区，硬盘尺寸等）参数，可以定义一个块设备驱动设备结构体，给每一个块设备定义一个信息描述，如下：\n\n```c\ntypedef struct sbull_dev {\n    int major;\n    unsigned long size;\n    void *data;\n    struct request_queue *queue;\n    struct gendisk *disk;\n    spinlock_t lock;\n    struct timer_list timer;\n} blkdev_t;\n\nblkdev_t *blkdev = NULL;\n```\n\n同时，定义了一些必要的宏定义：\n\n```c\n#define SBULL_BLKDEV_SIZE   (16 * 1024 * 1024)\t// 指定块设备硬盘的大小为16M\n#define SBULL_BLKDEV_SECTOR_SIZE    (512)\t// 设置块设备的sector为512字节\n#define SBULL_BLKDEV_MAX_PARTITIONS (16)\t// 设置块设备最大的分区数\n```\n\n这样在块设备中只需要通过blkdev指针就可以获取到设备的所有需要的参数信息；而相应的初始化操作也需要相应地修改：\n\n```c\nblkdev = kmalloc(sizeof(blkdev_t), GFP_KERNEL);\nif (!blkdev) {\n    printk(\"%s, blkdev kmalloc failed\\n\", __func__);\n    goto blkdev_kmalloc_err;\n}\nmemset(blkdev, 0, sizeof(blkdev_t));\n\nspin_lock_init(&blkdev->lock);\nblkdev->queue = blk_alloc_queue(GFP_KERNEL);\nblkdev->size = SBULL_BLKDEV_SIZE;\nblkdev->data = sbull_blkdev_data;\n\nblkdev->disk = alloc_disk(SBULL_BLKDEV_MAX_PARTITIONS);\nsprintf(blkdev->disk->disk_name, SBULL_BLKDEV_NAME);\nblkdev->disk->fops = &sbull_blkdev_fops;\nblkdev->disk->queue = blkdev->queue;\nblkdev->disk->major = major;\nblkdev->disk->first_minor = 0;\nset_capacity(blkdev->disk, SBULL_BLKDEV_SIZE / SBULL_BLKDEV_SECTOR_SIZE);\nadd_disk(blkdev->disk);\n```\n\n这个块设备的结构体信息，可以通过gendisk结构体中的private_data指针保存，也可以通过request_queue结构体中的queuedata指针保存；\n\n```c\nblkdev->queue->queuedata = blkdev;\nblkdev->disk->private_data = blkdev;\n```\n\n在需要使用这些信息时可以通过queue->queuedata或disk->private_data指针快速获取到块设备信息；\n\n\n\n### 3. 队列请求\n\n\n\n这主要是由于该版本适用于2.6.29内核，从2.6.31内核开始，一些API发生变化（见linux/include/blkdev.h）；用到的几个API修改如下：\n\n| 老版本内核接口              | 新版本内核接口                      | 意义               |\n| --------------------------- | ----------------------------------- | ------------------ |\n| request -> sectors          | blk_rq_pos(request)                 | 获取请求的开始扇区 |\n| request -> nr_sectors       | blk_rq_nr_sectors(request)          | 获取请求的扇区数   |\n| elev_next_request(request)  | blk_fetch_request(request)          |                    |\n| end_request(request, error) | blk_end_request_all(request, error) |                    |\n\n\n\n每个块设备，都有一个请求队列，当请求队列生成时，请求函数request()就与该队列绑定，这个操作根据有无有I/O调度，分两种方法实现；\n\n#### 3.1 blk_init_queue\n\n第一种是有I/O调度类设备，通过blk_init_queue()函数完成；\n\n\n```c\n// block/blk-core.c\nstruct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock)\n{\n    return blk_init_queue_node(rfn, lock, NUMA_NO_NODE);\n}\nEXPORT_SYMBOL(blk_init_queue);\n```\n\n\n\nblk_init_queue()函数的调用关系：\n\n\n```c\nblk_init_queue\n\tblk_init_queue_node\n\t\tblk_alloc_queue_node\n\t\t\tkmem_cache_alloc_node\n\t\t\tida_simple_get\n\t\t\tbioset_create\n\t\t\tbdi_init\n\t\t\tpercpu_ref_init\n\t\t\tblkcg_init_queue\n\t\tblk_init_allocated_queue\n\t\t\tblk_alloc_flush_queue\n\t\t\tblk_init_rl\n\t\t\tblk_queue_make_request\n\t\t\televator_init\n```\n\n\n\n实现方法\n\n```c\nblkdev->queue = blk_init_queue(sbull_blkdev_request, &blkdev->lock);\n```\n\n\n\n\n\n```c\nvoid sbull_blkdev_request(struct request_queue *q)\n{\n    struct request *req = NULL;\n    blkdev_t *dev = q->queuedata;\n    unsigned long sect_pos = 0;\n    unsigned long sect_count = 0;\n    unsigned long start = 0;\n    unsigned long len = 0;\n    void *buffer = NULL;\n    int err = 0;\n\n    req = blk_fetch_request(q);\n    while (req != NULL) {\n        sect_pos = blk_rq_pos(req);\n        sect_count = blk_rq_cur_sectors(req);\n        start = sect_pos << 9;\n        len = blk_rq_cur_bytes(req);\n\n        if (start + len > dev->size) {\n            printk(\"%s, bad access, block: 0x%llx, count: 0x%lx\\n\", __func__, (unsigned long long)sect_pos, sect_count);\n            err = -EIO;\n            goto done;\n        }\n\n        buffer = bio_data(req->bio);\n        if (!buffer) {\n            printk(\"%s, bio_data buffer is null\\n\", __func__);\n            goto done;\n        }\n        sbull_transfer(dev, sect_pos, sect_count, buffer, rq_data_dir(req) == WRITE);\ndone:\n        if (!__blk_end_request_cur(req, err)) {\n            req = blk_fetch_request(q);\n        }\n    }\n\n    return;\n}\n```\n\n\n\n```c\nvoid sbull_transfer(blkdev_t *dev, unsigned long sector, unsigned long nsect, char *buffer, int write)\n{\n    unsigned long offset = sector * SBULL_BLKDEV_SECTOR_SIZE;\n    unsigned long nbytes = nsect * SBULL_BLKDEV_SECTOR_SIZE;\n\n    if (offset + nbytes > dev->size) {\n        printk(\"%s, over range, size: 0x%lx, offset: 0x%lx, nbytes: 0x%lx\", __func__, dev->size, offset, nbytes);\n        return;\n    }\n\n    if (write) {\n        memcpy(dev->data + offset, buffer, nbytes);\n    } else {\n        memcpy(buffer, dev->data + offset, nbytes);\n    }\n\n    return;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 3.2 blk_alloc_queue\n\n\n\n第二种是无I/O调度类设备，通过blk_alloc_queue()函数完成；\n\n实现方法：\n\n```c\nblkdev->queue = blk_alloc_queue(GFP_KERNEL);\nblk_queue_make_request(blkdev->queue, sbull_blkdev_make_request);\n```\n\n\n\n\n\n```c\nunsigned int sbull_blkdev_make_request(struct request_queue *q, struct bio *bio)\n{\n    blkdev_t *dev = q->queuedata;\n    int status = 0;\n\n    status = sbull_xfer_bio(dev, bio);\n    bio_endio(bio);\n\n    return 0;\n}\n\nint sbull_xfer_bio(blkdev_t *dev, struct bio *bio)\n{\n    struct bvec_iter iter;\n    struct bio_vec bvec;\n    sector_t sector = bio->bi_iter.bi_sector;\n    char *buffer = NULL;\n\n    bio_for_each_segment(bvec, bio, iter) {\n        buffer = __bio_kmap_atomic(bio, iter);\n        if (!buffer) {\n            printk(\"%s, buffer is null\\n\", __func__);\n            return -1;\n        }\n        sbull_transfer(dev, sector, bio_cur_bytes(bio)>>9, buffer, bio_data_dir(bio) == WRITE);\n        sector += bio_cur_bytes(bio)>>9;\n        __bio_kunmap_atomic(bio);\n    }\n\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n```c\n// include/linux/blkdev.h\nstruct request {\n\n    \n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```c\nblk_queue_max_hw_sectors(blkdev->queue, 255);\n```\n\n\nblk_queue_max_hw_sectors()函数，用来通知通用块层和I/O调度器，该请求队列的每个请求中能够包含的最大扇区数；\n\n\n```c\nblk_queue_logical_block_size(blkdev->queue, sbull_sect_size);\n```\n\n\nblk_queue_logical_block_size()函数，用于告知该请求队列的逻辑块大小；\n\n\n\n\n\n\n\n\nbio的一些接口：\n\n\n```c\n// include/linux/fs.h\nstatic inline int bio_data_dir(struct bio *bio)\n{\n    return op_is_write(bio_op(bio)) ? WRITE : READ;\n}\n\n#ifdef CONFIG_BLOCK\nstatic inline bool op_is_write(unsigned int op)\n{\n    return op == REQ_OP_READ ? false : true;\n}\n```\n\n\nreturn：READ/WRITE\n\n\n\n\n```c\n// include/linux/bio.h\n#define BIO_MAX_PAGES       256\n\n#define bio_prio(bio)           (bio)->bi_ioprio\n#define bio_set_prio(bio, prio)     ((bio)->bi_ioprio = prio)\n\n#define bio_iter_iovec(bio, iter)               \\\n    bvec_iter_bvec((bio)->bi_io_vec, (iter))\n\n#define bio_iter_page(bio, iter)                \\\n    bvec_iter_page((bio)->bi_io_vec, (iter))\n#define bio_iter_len(bio, iter)                 \\\n    bvec_iter_len((bio)->bi_io_vec, (iter))\n#define bio_iter_offset(bio, iter)              \\\n    bvec_iter_offset((bio)->bi_io_vec, (iter))\n\n#define bio_page(bio)       bio_iter_page((bio), (bio)->bi_iter)\n#define bio_offset(bio)     bio_iter_offset((bio), (bio)->bi_iter)\n#define bio_iovec(bio)      bio_iter_iovec((bio), (bio)->bi_iter)\n\n#define bio_multiple_segments(bio)              \\\n    ((bio)->bi_iter.bi_size != bio_iovec(bio).bv_len)\n#define bio_sectors(bio)    ((bio)->bi_iter.bi_size >> 9)\n#define bio_end_sector(bio) ((bio)->bi_iter.bi_sector + bio_sectors((bio)))\n```\n\n\n\n\n```c\n// include/linux/bio.h\nstatic inline unsigned int bio_cur_bytes(struct bio *bio)\n{\n    if (bio_has_data(bio))\n        return bio_iovec(bio).bv_len;\n    else /* dataless requests such as discard */\n        return bio->bi_iter.bi_size;\n}\n\n// 数据缓冲区的内核虚拟地址\nstatic inline void *bio_data(struct bio *bio)\n{\n    if (bio_has_data(bio))\n        return page_address(bio_page(bio)) + bio_offset(bio);\n\n    return NULL;\n}\n```\n\n\n\n\n\n\n```c\n// include/linux/bio.h\n// 获取给定bio的第i个缓冲区的虚拟地址\n#define __bio_kmap_atomic(bio, iter)                \\\n    (kmap_atomic(bio_iter_iovec((bio), (iter)).bv_page) +   \\\n        bio_iter_iovec((bio), (iter)).bv_offset)\n\n// 释放缓冲区的虚拟地址\n#define __bio_kunmap_atomic(addr)   kunmap_atomic(addr)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n```c\n// include/linux/blkdev.h\n#define rq_data_dir(rq)     (op_is_write(req_op(rq)) ? WRITE : READ)\n\n#define REQ_OP_SHIFT (8 * sizeof(u64) - REQ_OP_BITS)\n#define req_op(req)  ((req)->cmd_flags >> REQ_OP_SHIFT)\n\n// include/linux/blk_types.h\n#define REQ_OP_BITS 3\n```\n\n\n\n\n\n\n```c\n// include/linux/blkdev.h\n/*\n * blk_rq_pos()         : the current sector\n * blk_rq_bytes()       : bytes left in the entire request\n * blk_rq_cur_bytes()       : bytes left in the current segment\n * blk_rq_err_bytes()       : bytes left till the next error boundary\n * blk_rq_sectors()     : sectors left in the entire request\n * blk_rq_cur_sectors()     : sectors left in the current segment\n */\nstatic inline sector_t blk_rq_pos(const struct request *rq)\n{\n    return rq->__sector;\n}\n\nstatic inline unsigned int blk_rq_bytes(const struct request *rq)\n{\n    return rq->__data_len;\n}\n\nstatic inline int blk_rq_cur_bytes(const struct request *rq)\n{\n    return rq->bio ? bio_cur_bytes(rq->bio) : 0;\n}\n\nstatic inline unsigned int blk_rq_sectors(const struct request *rq)\n{\n    return blk_rq_bytes(rq) >> 9;\n}\n\nstatic inline unsigned int blk_rq_cur_sectors(const struct request *rq)\n{\n    return blk_rq_cur_bytes(rq) >> 9;\n}\n\nstatic inline unsigned int blk_rq_count_bios(struct request *rq)\n{\n    unsigned int nr_bios = 0;\n    struct bio *bio;\n\n    __rq_for_each_bio(bio, rq)\n        nr_bios++;\n\n    return nr_bios;\n}\n```\n\n\n\n\n\n#### 3.3 两种队列请求的区别\n\n\n\n\n\n\n\n\n\n\n\n\n#### 3.4 I/O调度器\n\n\nI/O调度器可以通过合并请求、重排块设备操作顺序等方式提高块设备访问的顺序；\n\n\nI/O调度器四种\n\n\n\n\n\n\n```c\n# cat /sys/block/sbull_disk/queue/scheduler\nnoop [cfq]\n```\n\n\n\n\n对于大多数基于物理磁盘的块设备驱动，使用适合的I/O调度器能提高性能；\n\n\n\n\n无I/O调度器\n\n\n```c\n# cat /sys/block/sbull_disk/queue/scheduler\nnone\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 8. 测试验证\n\n\n\n\n\n\n测试步骤：\n\n> 加载驱动：insmod ramblock.ko\n>\n> 格式化：mkdosfs /dev/ramblock\n>\n> 挂载：mount /dev/ramblock /mnt\n>\n> 读写文件：cd /mnt，创建文件\n>\n> 卸载：umount /mnt\n>\n> cat /dev/ramblock > /mnt/ramblock.bin\n>\n> 在PC上查看/mnt/ramblock.bin，sudo mount -o loop ramblock.bin /mnt\n\n\n\n\n\n### 9. 总结\n\n\n\n\n\n\n### 参考资料\n\n\nhttps://www.cnblogs.com/big-devil/p/8590007.html\n\nhttps://www.cnblogs.com/xiaojiang1025/p/6500557.html\n\n\n\n\n\n\n\n[回到目录](#目录)\n\n","source":"_posts/Linux块设备驱动.md","raw":"---\ntitle: Linux块设备驱动\ndate: 2020-04-19 10:40:13\ntags: Driver\n---\n\n\n\n\n\n未完成\n\n\n\nLinux块设备驱动\n\n\n\n<!--more-->\n\n\n\n\n### 目录\n\n\n[TOC]\n\n\n### 0. 简介\n\n\n\n\n字符设备\n\n\n字符设备是一种顺序的数据流设备，对字符设备的读写是以字节为单位进行的，这些字符连续地形成一个数据流，字符设备没有缓存区，对于字符设备的读写是实时的；\n\n\n\n\n块设备\n\n\n块设备是一种具有一定结构的随机存取设备，对块设备的读写是以块为单位进行的，块设备使用缓存区来存放数据，待条件满足后，将数据从缓存区一次性写入到设备，或者从设备一次性读取到缓存区；\n\n\n\n|       字符设备       |       块设备       |\n| :------------------: | :----------------: |\n|       顺序访问       |      随机访问      |\n|      数据流设备      |      存储设备      |\n|     以字节为单位     |     以块为单位     |\n| 没有缓存区，实时读写 |  有缓存区，非实时  |\n|   由应用层程序调用   | 由文件系统程序调用 |\n\n\n\n\n\n\n为了创建一个块设备驱动程序，实现一个基于内存的块设备驱动程序；\n\n\n\n\n#### 1. 块设备结构\n\n\n**段（Segments）**：由若干个块组成；是Linux内存管理机制中一个内存页或内存页的一部分；\n\n\n**块（Blocks）**：由Linux制定对内核或文件系统等数据处理的基本单位；通常通常为4096个字节，由1个或多个扇区组成；\n\n\n**扇区（Sectors）**：块设备的基本单位，是一个固定的硬件单位，制定了设备最少能够传输的数据量；通常在512字节到32768字节之间，默认：512字节；\n\n\n块是连续扇区的序列，块长度总是扇区长度的整数倍；块的最大长度，受特定体系结构的内存页长度限制；\n\n\n\n\n块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备；\n\n![Linux的块IO](Linux块设备驱动/Linux的块IO.png)\n\n\n\n#### 2. 块设备驱动框架\n\n\n\n![块设备驱动架构图](Linux块设备驱动/块设备驱动架构图.jpg)\n\n\n\n\n\n\n\n\n### 1. 重要结构及操作\n\n\n\n\n#### 1. 注册块设备驱动程序\n\n\n向内核注册块设备驱动程序\n\n\n```c\n#include <linux/fs.h>\nint register_blkdev(unsigned int major, const char *name);\n```\n\n\n\n> name：设备名字，是在/proc/devices中显示的名字\n>\n> major：设备的主设备号，如果major=0，则分配一个主设备号\n\n该函数的调用是可选的，完成的工作：\n\n> 1. 如果需要的话分配一个动态的主设备号\n> 2. 在/proc/devices中创建一个入口项\n\n\n\n注销块设备驱动程序\n\n\n```c\n#include <linux/fs.h>\nvoid unregister_blkdev(unsigned int major, const char *name);\n```\n\n\n\n\n如下用例：\n\n\n```c\n#include <linux/fs.h>\nint sbull_major = 0;\nsbull_major = register_blkdev(sbull_major, \"sbull\");\nif (sbull_major < 0) {\n\tprintk(KERN_WARNNING \"sbull: unable to get major number\\n\");\n\treturn -EBUSY;\n}\n```\n\n\n\n\n```c\n// include/linux/fs.h\nstruct block_device {\n    dev_t           bd_dev;  /* not a kdev_t - it's a search key */\n    int         bd_openers;\n    struct inode *      bd_inode;   /* will die */\n    struct super_block *    bd_super;\n    struct mutex        bd_mutex;   /* open/close mutex */\n    void *          bd_claiming;\n    void *          bd_holder;\n    int         bd_holders;\n    bool            bd_write_holder;\n#ifdef CONFIG_SYSFS\n    struct list_head    bd_holder_disks;\n#endif\n    struct block_device *   bd_contains;\n    unsigned        bd_block_size;\n    struct hd_struct *  bd_part;\n    /* number of times partitions within this device have been opened. */\n    unsigned        bd_part_count;\n    int         bd_invalidated;\n    struct gendisk *    bd_disk;\n    struct request_queue *  bd_queue;\n    struct list_head    bd_list;\n    /*\n     * Private data.  You must have bd_claim'ed the block_device\n     * to use this.  NOTE:  bd_claim allows an owner to claim\n     * the same device multiple times, the owner must take special\n     * care to not mess up bd_private for that case.\n     */\n    unsigned long       bd_private;\n\n    /* The counter of freeze processes */\n    int         bd_fsfreeze_count;\n    /* Mutex for freeze */\n    struct mutex        bd_fsfreeze_mutex;\n};\n```\n\n\n\n\n\n\n\n\n#### 2. 块设备操作\n\n\n\n\n字符设备使用file_operations结构，来告诉系统字符设备驱动的操作接口；\n\n\n块设备使用block_device_operations结构，来告诉系统块设备驱动的操作接口；\n\n\n```c\n// include/linux/blkdev.h\nstruct block_device_operations {\n    int (*open) (struct block_device *, fmode_t);\n    void (*release) (struct gendisk *, fmode_t);\n    int (*rw_page)(struct block_device *, sector_t, struct page *, bool);\n    int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n    int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n\t......\n    /* ->media_changed() is DEPRECATED, use ->check_events() instead */\n    int (*media_changed) (struct gendisk *);\n    int (*getgeo)(struct block_device *, struct hd_geometry *);\n\t......\n};\n```\n\n\n和字符设备驱动不同，块设备驱动的block_device_operations操作集中没有负责读和写数据的函数；在块设备驱动中，这些操作是由request函数处理的；\n\n\n\n\n#### 3. 注册磁盘\n\n\n为了管理独立的磁盘，需要使用struct gendisk结构体，内核使用gendisk结构表示一个独立的磁盘设备，还可以表示分区；\n\n\n```c\n// include/linux/genhd.h\nstruct gendisk {\n    int major;          /* major number of driver */\n    int first_minor;\n    int minors;                     /* maximum number of minors, =1 for\n                                         * disks that can't be partitioned. */\n    char disk_name[DISK_NAME_LEN];  /* name of major driver */\n    char *(*devnode)(struct gendisk *gd, umode_t *mode);\n\n    struct hd_struct part0;\n\n    const struct block_device_operations *fops;\n    struct request_queue *queue;\n\t......\n};\n```\n\n\nmajor：指定驱动程序的主设备号\n\n\nfirst_minor和minors：从设备号的可能范围\n\n\ndisk_name：磁盘名称，在/proc/partitions 和 sysfs 中表示该磁盘\n\n\n\n\n```c\nchar disk_name[DISK_NAME_LEN];\n```\n\n\n显示在/proc/partitions 和 sysfs 中\n\n\n\n\n对于每一个分区来说，都有一个hd_struct结构体，用于描述该分区\n\n\n```c\n// include/linux/genhd.h\nstruct hd_struct {\n    sector_t start_sect;\n    sector_t nr_sects;\n    seqcount_t nr_sects_seq;\n\t......\n    struct partition_meta_info *info;\n\t......\n};\n```\n\n\nstart_sect和nr_sects：定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区\n\n\n\n\n拥有了设备内存和请求队列，就可以分配、初始化及安装gendisk结构；在struct gendisk是动态分配的结构，需要内核进行初始化，驱动必须通过alloc_disk分配：\n\n\n```c\n# include <linux/genhd.h>\nstruct gendisk *alloc_disk(int minors);\n```\n\n> minors：是该磁盘使用的从设备号的数目；\n\n\n\n卸载磁盘\n\n\n```c\nvoid del_gendisk(struct gendisk *disk)\n```\n\n\ngendisk是一个引用计数结构，get_disk和put_disk函数负责处理引用计数；调用del_gendisk后，该结构可能继续存在；\n\n\n\n\n为了使gendisk结构的磁盘设备生效，需要初始化结构，并将磁盘或分区信息添加到内核链表；\n\n\n```c\nvoid add_disk(struct gendisk *gd);\n```\n\n\n调用add_disk后，磁盘设备将被激活，并随时会调用它提供的操作方法，因此在驱动程序完全被初始化并且能够响应对磁盘的请求前，不要调用add_disk；\n\n\n\n\n#### 4. 请求队列\n\n\n\n块设备驱动程序的核心是请求函数，包含请求处理过程；\n\n有I/O调度类设备，使用blk_init_queue()函数：\n\n```c\n// block/blk-core.c\nstruct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock)\n```\n\n无I/O调度类设备，使用blk_alloc_queue()函数：\n\n```c\n// block/blk-core.c\nstruct request_queue *blk_alloc_queue(gfp_t gfp_mask)\n// block/blk-settings.c\nvoid blk_queue_make_request(struct request_queue *q, make_request_fn *mfn)\n```\n\n从请求队列中提取请求：\n\n```c\n// block/blk-core.c\nstruct request *blk_fetch_request(struct request_queue *q)\n```\n\n在卸载函数中使用的清除请求队列：\n\n```c\n// block/blk-core.c\nvoid blk_cleanup_queue(struct request_queue *q)\n```\n\n\n\n\n块设备的读写请求放置在请求队列中，在struct gendisk中，通过struct request_queue *queue指针指向请求队列；请求队列用数据结构struct request_queue表示；\n\n\n```c\n// include/linux/blkdev.h\nstruct request_queue {\n    struct list_head    queue_head;\n    struct request      *last_merge;\n    struct elevator_queue   *elevator;\n\t......\n    request_fn_proc     *request_fn;\n    make_request_fn     *make_request_fn;\n\t......\n    void            *queuedata;\n    struct list_head    icq_list;\n    struct queue_limits limits;\n    struct blk_flush_queue  *fq;\n    struct list_head    requeue_list;\n    spinlock_t      requeue_lock;\n    struct delayed_work requeue_work;\n\t......\n};\n```\n\n\nqueue_head：表头，用于构建一个IO请求的双链表；链表每个元素代表向块设备读取数据的一个请求；内核会重排该链表，以得到更好的IO性能；\n\n\n\n\n与每个块设备驱动程序相关的I/O请求队列用request_queue结构体描述，而每个request_queue队列中的请求用request结构体描述；\n\n\n```c\n// include/linux/blkdev.h\nstruct request {\n    struct list_head queuelist;\n\n    struct request_queue *q;\n    struct blk_mq_ctx *mq_ctx;\n\n    /* the following two fields are internal, NEVER access directly */\n    unsigned int __data_len;    /* total data len */\n    sector_t __sector;      /* sector cursor */\n\n    struct bio *bio;\n    struct bio *biotail;\n\n\tstruct request *next_rq;\n    ......\n}\n```\n\n\n\n\nrequest结构体关联了struct bio，struct bio结构体是块I/O操作在页级粒度的底层描述；\n\n\n```c\n// include/linux/blk_types.h\nstruct bio {\n    struct bio      *bi_next;   /* request queue link */\n    struct block_device *bi_bdev;\n    int         bi_error;\n\n    unsigned short      bi_flags;   /* status, command, etc */\n    unsigned short      bi_ioprio;\n\n    struct bvec_iter    bi_iter;\n\n    atomic_t        __bi_remaining;\n    bio_end_io_t        *bi_end_io;\n    \n    unsigned short      bi_vcnt;    /* how many bio_vec's */\n    unsigned short      bi_max_vecs;    /* max bvl_vecs we can hold */\n    struct bio_vec      *bi_io_vec; /* the actual vec list */\n\t......\n}\n```\n\n\n块数据通过bio_vec结构体数组在内部被表示成I/O向量；每个bio_vec数组元素由三元组组成（即，页、页偏移、长度），表示该块I/O的一个段；\n\n```c\n// include/linux/bvec.h\nstruct bio_vec {\n    struct page *bv_page;\t// 页指针\n    unsigned int    bv_len;\t// 传输的字节数\n    unsigned int    bv_offset;\t// 偏移位置\n};\n```\n\nstruct bvec_iter结构体用来记录当前bvec被处理的情况，用于遍历bio；\n\n```c\n// include/linux/bvec.h\nstruct bvec_iter {\n    sector_t        bi_sector;  /* device address in 512 byte sectors */\n    unsigned int\tbi_size;    /* residual I/O count */\n    unsigned int\tbi_idx;     /* current index into bvl_vec */\n    unsigned int\tbi_bvec_done;   /* number of bytes completed in current bvec */\n};\n```\n\n\n\n#### 5. 数据结构间的关系\n\n| 数据结构      | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| request_queue | 表示针对一个gendisk对象的所有请求的队列，是对应gendisk结构的一个成员； |\n| request       | 表示经过I/O调度之后的针对gendisk的一个请求，是request_queue结构队列的一个节点，多个request构成了一个request_queue队列； |\n| bio           | 表示应用程序对一个gendisk原始的访问请求；一个bio由多个bio_vec组成，多个bio经过I/O调度和合并形成一个request； |\n| bio_vec       | 描述的应用层准备读写一个gendisk时需要使用的内存页（page）的一部分；多个bio_vec形成一个bio； |\n| bvec_iter     | 描述一个bio_vec结构中的一个sector信息；                      |\n\n\n\n块设备数据结构间的关系如下所示：\n\n![块设备数据结构间的关系](Linux块设备驱动/块设备数据结构间的关系.png)\n\n\n\n\n### 2. 块设备驱动的初始化\n\n\n\n#### 2.1 块设备的注册过程\n\n注册一个块设备驱动，需要以下步骤：\n\n\n\n> 创建一个块设备 \n>\n> 分配一个申请队列\n>\n> 分配一个gendisk结构体\n>\n> 设置gendisk结构体成员\n>\n> 注册gendisk结构体\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tA(\"注册设备(register_blkdev)(可选)\")-->B(\"分配磁盘(alloc_disk)\")\n\tB--有I/O调度-->C(\"不使用请求队列(blk_init_queue)\")-->E\n\tB--无I/O调度-->D(\"使用请求队列(blk_alloc_queue)\")-->E\n\tE(\"设置磁盘属性(gendisk)\")-->F(\"激活磁盘(add_disk)\")\n```\n\n\n1. 通过register_blkdev()函数注册设备，是个可选操作；\n\n2. 使用alloc_disk()函数分配通用磁盘gendisk结构体；\n\n3. 根据是否需要I/O调度，分两种情况，一种是使用请求队列进行数据传输，一种是不使用请求队列进行数据传输；\n\n4. 初始化gendisk结构体的数据成员，包括：major、fops、queue等；\n\n5. 使用add_disk()函数激活磁盘设备，调用该函数之前要做好所有的准备工作；\n\n\n\n\n\n\n分配一个gendisk结构体\n\n\n设置一个队列，将访问请求放到队列里\n\n\n设置gendisk结构体的属性，如：名称、容量、操作集等\n\n\n添加gendisk结构体\n\n\n另外分配一块内存空间，当做块设备，在request函数中使用memcpy访问，模仿块设备读写\n\n\n\n\n```c\nmodule_init(sbull_blkdev_init);\nmodule_exit(sbull_blkdev_exit);\n```\n\n\n\n\n块设备驱动程序的初始化方法在sbull_blkdev_init()函数中；\n\n\n\n\n##### 1）注册块设备\n\n\n```c\nstatic int major = 0;\nmajor = register_blkdev(major, \"sbull_blkdev\");\n```\n\n\n为块设备驱动分配一个未使用的主设备号，并在/proc/devies中添加一个入口；\n\n\n\n\n##### 2）注册请求队列\n\n\n注册请求队列的操作，将一个请求的操作方法与该设备相关联，通过blk_init_queue()函数实现；\n\n\n```c\nstatic struct request_queue *sbull_blkdev_request = NULL;\nstatic DEFINE_SPINLOCK(sbull_blkdev_lock);\nsbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &sbull_blkdev_lock);\n```\n\nblk_init_queue()函数返回请求队列request_queue，将sbull_blkdev_request()函数指针方式关联到该设备；\n\n第一个参数是函数指针，用来指定请求队列的处理函数；\n\n第二个参数是自旋锁，用来保护request_queue队列不被同时访问；\n\n\n\n\n##### 3）设置读写块大小\n\n\n硬件执行磁盘是以扇区为单位的，而文件系统是以块为单位处理数据；通常，扇区大小为512字节，块大小为4096字节；需要将硬件支持的扇区大小和驱动程序在一次请求中能接收的最大扇区数通知块层；\n\n\n```c\n// include/linux/blkdev.h\nint sbull_blkdev_sect_size = 512;\nint sbull_blkdev_size = 16 * 1024 * 1024;\n// blk_queue_hardsect_size(blkdev_queue, my_blkdev_sect_size);\nblk_queue_logical_block_size(sbull_blkdev_queue, sbull_blkdev_sect_size);\n```\n\n\n\n\n##### 4）创建磁盘\n\n\n使用alloc_disk()函数分配一个与设备对应的磁盘gendisk结构体，并初始化其成员；需要初始化的成员有：block_device_operations、存储容量（单位是扇区）、请求队列、主设备号、磁盘名称等；设置存储容量通过set_capacity()函数来完成；\n\n\n调用add_disk()函数将磁盘添加到块I/O层；\n\n\n```c\nsbull_blkdev_disk = alloc_disk(1);\n\nsprintf(sbull_blkdev_disk->disk_name, \"sbull_blkdev_disk\");\nsbull_blkdev_disk->fops = &sbull_blkdev_fops;\nsbull_blkdev_disk->queue = sbull_blkdev_queue;\nsbull_blkdev_disk->major = major;\nsbull_blkdev_disk->first_minor = 0;\nset_capacity(sbull_blkdev_disk, sbull_blkdev_size);\n\nadd_disk(sbull_blkdev_disk);\n```\n\n\n\n\n到这里，设备/dev/sbull_blkdev_disk就可以使用了，如果设备支持多个磁盘分区，会显示为/dev/sbull_blkdev_diskX，X是分区号；\n\n\n```c\n# ls /dev/sbull_blkdev_disk -l\nbrw-rw----    1 root     root      253,   0 Oct 21 08:18 /dev/sbull_blkdev_disk\n```\n\n\n\n##### 5）块设备初始化实例\n\n\n\n\n```c\nstruct block_device_operations sbull_blkdev_fops = {\n    .owner = THIS_MODULE,\n    .open = sbull_blkdev_open,\n    .release = sbull_blkdev_release,\n    .ioctl = sbull_blkdev_ioctl,\n};\n```\n\n\n\n请求处理函数，具体实现内容，后边补充；\n\n```c\nvoid sbull_blkdev_request(struct request_queue *q)\n{\n    printk(\"%s: %d\\n\", __func__, __LINE__);\n\n    return;\n}\n```\n\n\n\n\n```c\nstatic int major = 0;\nstatic struct request_queue *sbull_blkdev_queue = NULL;\nstatic struct gendisk *sbull_blkdev_disk = NULL;\nstatic DEFINE_SPINLOCK(sbull_blkdev_lock);\n\nint sbull_blkdev_size = 256 * 1024;\nint sbull_blkdev_sect_size = 512;\n\nstatic int sbull_blkdev_init(void)\n{\n    major = register_blkdev(major, \"mcy_blk\");\n    if (major < 0) {\n        printk(\"%s, register_blkdev failed, major: %d\\n\", __func__, major);\n        goto register_blkdev_err;\n    }\n    printk(\"%s, major: %d\\n\", __func__, major);\n\n    sbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &sbull_blkdev_lock);\n    if (!sbull_blkdev_queue) {\n        printk(\"%s, blk_init_queue failed!\\n\", __func__);\n        goto init_queue_err;\n    }\n\n    sbull_blkdev_disk = alloc_disk(1);\n    if (!sbull_blkdev_disk) {\n        printk(\"%s, alloc_disk failed!\\n\", __func__);\n        goto alloc_disk_err;\n    }\n\n    sprintf(sbull_blkdev_disk->disk_name, \"sbull_blkdev_disk\");\n    sbull_blkdev_disk->fops = &sbull_blkdev_fops;\n    sbull_blkdev_disk->queue = sbull_blkdev_queue;\n    sbull_blkdev_disk->major = major;\n    sbull_blkdev_disk->first_minor = 0;\n    set_capacity(sbull_blkdev_disk, sbull_blkdev_size * 2);\n\n    add_disk(sbull_blkdev_disk);\n    printk(\"%s, sbull_blkdev_disk add success!\\n\", __func__);\n\n    return 0;\nalloc_disk_err:\n    blk_cleanup_queue(sbull_blkdev_queue);\ninit_queue_err:\n    unregister_blkdev(major, \"sbull_blkdev\");\nregister_blkdev_err:\n    return -EBUSY;\n}\n```\n\n\n\n#### 2.2 块设备的卸载过程\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tA(\"删除gendisk(del_gendisk)\")-->\n\tB(\"删除gendisk的引用(put_disk)\")-->\n\tC(\"清除请求队列(blk_cleanup_queue)\")-->\n\tD(\"注销块设备(unregister_blkdev)\")\n```\n\n\n1. 使用del_gendisk()函数删除gendisk设备（磁盘）；\n\n2. 使用put_disk()函数删除gendisk设备的引用；\n\n3. 使用blk_cleanup_queue()函数清除请求队列，释放请求队列占用的资源；\n\n4. 使用unregister_blkdev()函数注销设备，并释放对设备的引用，可选操作，与register_blkdev()函数配合使用；\n\n\n\n\n```c\nstatic void sbull_blkdev_exit(void)\n{\n    del_gendisk(sbull_blkdev_disk);\n    put_disk(sbull_blkdev_disk);\n    blk_cleanup_queue(sbull_blkdev_queue);\n    unregister_blkdev(major, \"sbull_blkdev\");\n}\n```\n\n\n\n```c\nmodule_init(sbull_blkdev_init);\nmodule_exit(sbull_blkdev_exit);\nMODULE_LICENSE(\"GPL\");\n```\n\n\n\n\n\n#### 2.3 封装块设备信息\n\n为了在一些函数中能够访问块设备驱动的一些信息（比如：请求队列，硬盘分区，硬盘尺寸等）参数，可以定义一个块设备驱动设备结构体，给每一个块设备定义一个信息描述，如下：\n\n```c\ntypedef struct sbull_dev {\n    int major;\n    unsigned long size;\n    void *data;\n    struct request_queue *queue;\n    struct gendisk *disk;\n    spinlock_t lock;\n    struct timer_list timer;\n} blkdev_t;\n\nblkdev_t *blkdev = NULL;\n```\n\n同时，定义了一些必要的宏定义：\n\n```c\n#define SBULL_BLKDEV_SIZE   (16 * 1024 * 1024)\t// 指定块设备硬盘的大小为16M\n#define SBULL_BLKDEV_SECTOR_SIZE    (512)\t// 设置块设备的sector为512字节\n#define SBULL_BLKDEV_MAX_PARTITIONS (16)\t// 设置块设备最大的分区数\n```\n\n这样在块设备中只需要通过blkdev指针就可以获取到设备的所有需要的参数信息；而相应的初始化操作也需要相应地修改：\n\n```c\nblkdev = kmalloc(sizeof(blkdev_t), GFP_KERNEL);\nif (!blkdev) {\n    printk(\"%s, blkdev kmalloc failed\\n\", __func__);\n    goto blkdev_kmalloc_err;\n}\nmemset(blkdev, 0, sizeof(blkdev_t));\n\nspin_lock_init(&blkdev->lock);\nblkdev->queue = blk_alloc_queue(GFP_KERNEL);\nblkdev->size = SBULL_BLKDEV_SIZE;\nblkdev->data = sbull_blkdev_data;\n\nblkdev->disk = alloc_disk(SBULL_BLKDEV_MAX_PARTITIONS);\nsprintf(blkdev->disk->disk_name, SBULL_BLKDEV_NAME);\nblkdev->disk->fops = &sbull_blkdev_fops;\nblkdev->disk->queue = blkdev->queue;\nblkdev->disk->major = major;\nblkdev->disk->first_minor = 0;\nset_capacity(blkdev->disk, SBULL_BLKDEV_SIZE / SBULL_BLKDEV_SECTOR_SIZE);\nadd_disk(blkdev->disk);\n```\n\n这个块设备的结构体信息，可以通过gendisk结构体中的private_data指针保存，也可以通过request_queue结构体中的queuedata指针保存；\n\n```c\nblkdev->queue->queuedata = blkdev;\nblkdev->disk->private_data = blkdev;\n```\n\n在需要使用这些信息时可以通过queue->queuedata或disk->private_data指针快速获取到块设备信息；\n\n\n\n### 3. 队列请求\n\n\n\n这主要是由于该版本适用于2.6.29内核，从2.6.31内核开始，一些API发生变化（见linux/include/blkdev.h）；用到的几个API修改如下：\n\n| 老版本内核接口              | 新版本内核接口                      | 意义               |\n| --------------------------- | ----------------------------------- | ------------------ |\n| request -> sectors          | blk_rq_pos(request)                 | 获取请求的开始扇区 |\n| request -> nr_sectors       | blk_rq_nr_sectors(request)          | 获取请求的扇区数   |\n| elev_next_request(request)  | blk_fetch_request(request)          |                    |\n| end_request(request, error) | blk_end_request_all(request, error) |                    |\n\n\n\n每个块设备，都有一个请求队列，当请求队列生成时，请求函数request()就与该队列绑定，这个操作根据有无有I/O调度，分两种方法实现；\n\n#### 3.1 blk_init_queue\n\n第一种是有I/O调度类设备，通过blk_init_queue()函数完成；\n\n\n```c\n// block/blk-core.c\nstruct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock)\n{\n    return blk_init_queue_node(rfn, lock, NUMA_NO_NODE);\n}\nEXPORT_SYMBOL(blk_init_queue);\n```\n\n\n\nblk_init_queue()函数的调用关系：\n\n\n```c\nblk_init_queue\n\tblk_init_queue_node\n\t\tblk_alloc_queue_node\n\t\t\tkmem_cache_alloc_node\n\t\t\tida_simple_get\n\t\t\tbioset_create\n\t\t\tbdi_init\n\t\t\tpercpu_ref_init\n\t\t\tblkcg_init_queue\n\t\tblk_init_allocated_queue\n\t\t\tblk_alloc_flush_queue\n\t\t\tblk_init_rl\n\t\t\tblk_queue_make_request\n\t\t\televator_init\n```\n\n\n\n实现方法\n\n```c\nblkdev->queue = blk_init_queue(sbull_blkdev_request, &blkdev->lock);\n```\n\n\n\n\n\n```c\nvoid sbull_blkdev_request(struct request_queue *q)\n{\n    struct request *req = NULL;\n    blkdev_t *dev = q->queuedata;\n    unsigned long sect_pos = 0;\n    unsigned long sect_count = 0;\n    unsigned long start = 0;\n    unsigned long len = 0;\n    void *buffer = NULL;\n    int err = 0;\n\n    req = blk_fetch_request(q);\n    while (req != NULL) {\n        sect_pos = blk_rq_pos(req);\n        sect_count = blk_rq_cur_sectors(req);\n        start = sect_pos << 9;\n        len = blk_rq_cur_bytes(req);\n\n        if (start + len > dev->size) {\n            printk(\"%s, bad access, block: 0x%llx, count: 0x%lx\\n\", __func__, (unsigned long long)sect_pos, sect_count);\n            err = -EIO;\n            goto done;\n        }\n\n        buffer = bio_data(req->bio);\n        if (!buffer) {\n            printk(\"%s, bio_data buffer is null\\n\", __func__);\n            goto done;\n        }\n        sbull_transfer(dev, sect_pos, sect_count, buffer, rq_data_dir(req) == WRITE);\ndone:\n        if (!__blk_end_request_cur(req, err)) {\n            req = blk_fetch_request(q);\n        }\n    }\n\n    return;\n}\n```\n\n\n\n```c\nvoid sbull_transfer(blkdev_t *dev, unsigned long sector, unsigned long nsect, char *buffer, int write)\n{\n    unsigned long offset = sector * SBULL_BLKDEV_SECTOR_SIZE;\n    unsigned long nbytes = nsect * SBULL_BLKDEV_SECTOR_SIZE;\n\n    if (offset + nbytes > dev->size) {\n        printk(\"%s, over range, size: 0x%lx, offset: 0x%lx, nbytes: 0x%lx\", __func__, dev->size, offset, nbytes);\n        return;\n    }\n\n    if (write) {\n        memcpy(dev->data + offset, buffer, nbytes);\n    } else {\n        memcpy(buffer, dev->data + offset, nbytes);\n    }\n\n    return;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 3.2 blk_alloc_queue\n\n\n\n第二种是无I/O调度类设备，通过blk_alloc_queue()函数完成；\n\n实现方法：\n\n```c\nblkdev->queue = blk_alloc_queue(GFP_KERNEL);\nblk_queue_make_request(blkdev->queue, sbull_blkdev_make_request);\n```\n\n\n\n\n\n```c\nunsigned int sbull_blkdev_make_request(struct request_queue *q, struct bio *bio)\n{\n    blkdev_t *dev = q->queuedata;\n    int status = 0;\n\n    status = sbull_xfer_bio(dev, bio);\n    bio_endio(bio);\n\n    return 0;\n}\n\nint sbull_xfer_bio(blkdev_t *dev, struct bio *bio)\n{\n    struct bvec_iter iter;\n    struct bio_vec bvec;\n    sector_t sector = bio->bi_iter.bi_sector;\n    char *buffer = NULL;\n\n    bio_for_each_segment(bvec, bio, iter) {\n        buffer = __bio_kmap_atomic(bio, iter);\n        if (!buffer) {\n            printk(\"%s, buffer is null\\n\", __func__);\n            return -1;\n        }\n        sbull_transfer(dev, sector, bio_cur_bytes(bio)>>9, buffer, bio_data_dir(bio) == WRITE);\n        sector += bio_cur_bytes(bio)>>9;\n        __bio_kunmap_atomic(bio);\n    }\n\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n```c\n// include/linux/blkdev.h\nstruct request {\n\n    \n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```c\nblk_queue_max_hw_sectors(blkdev->queue, 255);\n```\n\n\nblk_queue_max_hw_sectors()函数，用来通知通用块层和I/O调度器，该请求队列的每个请求中能够包含的最大扇区数；\n\n\n```c\nblk_queue_logical_block_size(blkdev->queue, sbull_sect_size);\n```\n\n\nblk_queue_logical_block_size()函数，用于告知该请求队列的逻辑块大小；\n\n\n\n\n\n\n\n\nbio的一些接口：\n\n\n```c\n// include/linux/fs.h\nstatic inline int bio_data_dir(struct bio *bio)\n{\n    return op_is_write(bio_op(bio)) ? WRITE : READ;\n}\n\n#ifdef CONFIG_BLOCK\nstatic inline bool op_is_write(unsigned int op)\n{\n    return op == REQ_OP_READ ? false : true;\n}\n```\n\n\nreturn：READ/WRITE\n\n\n\n\n```c\n// include/linux/bio.h\n#define BIO_MAX_PAGES       256\n\n#define bio_prio(bio)           (bio)->bi_ioprio\n#define bio_set_prio(bio, prio)     ((bio)->bi_ioprio = prio)\n\n#define bio_iter_iovec(bio, iter)               \\\n    bvec_iter_bvec((bio)->bi_io_vec, (iter))\n\n#define bio_iter_page(bio, iter)                \\\n    bvec_iter_page((bio)->bi_io_vec, (iter))\n#define bio_iter_len(bio, iter)                 \\\n    bvec_iter_len((bio)->bi_io_vec, (iter))\n#define bio_iter_offset(bio, iter)              \\\n    bvec_iter_offset((bio)->bi_io_vec, (iter))\n\n#define bio_page(bio)       bio_iter_page((bio), (bio)->bi_iter)\n#define bio_offset(bio)     bio_iter_offset((bio), (bio)->bi_iter)\n#define bio_iovec(bio)      bio_iter_iovec((bio), (bio)->bi_iter)\n\n#define bio_multiple_segments(bio)              \\\n    ((bio)->bi_iter.bi_size != bio_iovec(bio).bv_len)\n#define bio_sectors(bio)    ((bio)->bi_iter.bi_size >> 9)\n#define bio_end_sector(bio) ((bio)->bi_iter.bi_sector + bio_sectors((bio)))\n```\n\n\n\n\n```c\n// include/linux/bio.h\nstatic inline unsigned int bio_cur_bytes(struct bio *bio)\n{\n    if (bio_has_data(bio))\n        return bio_iovec(bio).bv_len;\n    else /* dataless requests such as discard */\n        return bio->bi_iter.bi_size;\n}\n\n// 数据缓冲区的内核虚拟地址\nstatic inline void *bio_data(struct bio *bio)\n{\n    if (bio_has_data(bio))\n        return page_address(bio_page(bio)) + bio_offset(bio);\n\n    return NULL;\n}\n```\n\n\n\n\n\n\n```c\n// include/linux/bio.h\n// 获取给定bio的第i个缓冲区的虚拟地址\n#define __bio_kmap_atomic(bio, iter)                \\\n    (kmap_atomic(bio_iter_iovec((bio), (iter)).bv_page) +   \\\n        bio_iter_iovec((bio), (iter)).bv_offset)\n\n// 释放缓冲区的虚拟地址\n#define __bio_kunmap_atomic(addr)   kunmap_atomic(addr)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n```c\n// include/linux/blkdev.h\n#define rq_data_dir(rq)     (op_is_write(req_op(rq)) ? WRITE : READ)\n\n#define REQ_OP_SHIFT (8 * sizeof(u64) - REQ_OP_BITS)\n#define req_op(req)  ((req)->cmd_flags >> REQ_OP_SHIFT)\n\n// include/linux/blk_types.h\n#define REQ_OP_BITS 3\n```\n\n\n\n\n\n\n```c\n// include/linux/blkdev.h\n/*\n * blk_rq_pos()         : the current sector\n * blk_rq_bytes()       : bytes left in the entire request\n * blk_rq_cur_bytes()       : bytes left in the current segment\n * blk_rq_err_bytes()       : bytes left till the next error boundary\n * blk_rq_sectors()     : sectors left in the entire request\n * blk_rq_cur_sectors()     : sectors left in the current segment\n */\nstatic inline sector_t blk_rq_pos(const struct request *rq)\n{\n    return rq->__sector;\n}\n\nstatic inline unsigned int blk_rq_bytes(const struct request *rq)\n{\n    return rq->__data_len;\n}\n\nstatic inline int blk_rq_cur_bytes(const struct request *rq)\n{\n    return rq->bio ? bio_cur_bytes(rq->bio) : 0;\n}\n\nstatic inline unsigned int blk_rq_sectors(const struct request *rq)\n{\n    return blk_rq_bytes(rq) >> 9;\n}\n\nstatic inline unsigned int blk_rq_cur_sectors(const struct request *rq)\n{\n    return blk_rq_cur_bytes(rq) >> 9;\n}\n\nstatic inline unsigned int blk_rq_count_bios(struct request *rq)\n{\n    unsigned int nr_bios = 0;\n    struct bio *bio;\n\n    __rq_for_each_bio(bio, rq)\n        nr_bios++;\n\n    return nr_bios;\n}\n```\n\n\n\n\n\n#### 3.3 两种队列请求的区别\n\n\n\n\n\n\n\n\n\n\n\n\n#### 3.4 I/O调度器\n\n\nI/O调度器可以通过合并请求、重排块设备操作顺序等方式提高块设备访问的顺序；\n\n\nI/O调度器四种\n\n\n\n\n\n\n```c\n# cat /sys/block/sbull_disk/queue/scheduler\nnoop [cfq]\n```\n\n\n\n\n对于大多数基于物理磁盘的块设备驱动，使用适合的I/O调度器能提高性能；\n\n\n\n\n无I/O调度器\n\n\n```c\n# cat /sys/block/sbull_disk/queue/scheduler\nnone\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 8. 测试验证\n\n\n\n\n\n\n测试步骤：\n\n> 加载驱动：insmod ramblock.ko\n>\n> 格式化：mkdosfs /dev/ramblock\n>\n> 挂载：mount /dev/ramblock /mnt\n>\n> 读写文件：cd /mnt，创建文件\n>\n> 卸载：umount /mnt\n>\n> cat /dev/ramblock > /mnt/ramblock.bin\n>\n> 在PC上查看/mnt/ramblock.bin，sudo mount -o loop ramblock.bin /mnt\n\n\n\n\n\n### 9. 总结\n\n\n\n\n\n\n### 参考资料\n\n\nhttps://www.cnblogs.com/big-devil/p/8590007.html\n\nhttps://www.cnblogs.com/xiaojiang1025/p/6500557.html\n\n\n\n\n\n\n\n[回到目录](#目录)\n\n","slug":"Linux块设备驱动","published":1,"updated":"2020-05-16T14:09:57.248Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkuy0009dqg1bhvqhda8","content":"<p>未完成</p>\n<p>Linux块设备驱动</p>\n<a id=\"more\"></a>\n\n\n\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>字符设备</p>\n<p>字符设备是一种顺序的数据流设备，对字符设备的读写是以字节为单位进行的，这些字符连续地形成一个数据流，字符设备没有缓存区，对于字符设备的读写是实时的；</p>\n<p>块设备</p>\n<p>块设备是一种具有一定结构的随机存取设备，对块设备的读写是以块为单位进行的，块设备使用缓存区来存放数据，待条件满足后，将数据从缓存区一次性写入到设备，或者从设备一次性读取到缓存区；</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符设备</th>\n<th align=\"center\">块设备</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">顺序访问</td>\n<td align=\"center\">随机访问</td>\n</tr>\n<tr>\n<td align=\"center\">数据流设备</td>\n<td align=\"center\">存储设备</td>\n</tr>\n<tr>\n<td align=\"center\">以字节为单位</td>\n<td align=\"center\">以块为单位</td>\n</tr>\n<tr>\n<td align=\"center\">没有缓存区，实时读写</td>\n<td align=\"center\">有缓存区，非实时</td>\n</tr>\n<tr>\n<td align=\"center\">由应用层程序调用</td>\n<td align=\"center\">由文件系统程序调用</td>\n</tr>\n</tbody></table>\n<p>为了创建一个块设备驱动程序，实现一个基于内存的块设备驱动程序；</p>\n<h4 id=\"1-块设备结构\"><a href=\"#1-块设备结构\" class=\"headerlink\" title=\"1. 块设备结构\"></a>1. 块设备结构</h4><p><strong>段（Segments）</strong>：由若干个块组成；是Linux内存管理机制中一个内存页或内存页的一部分；</p>\n<p><strong>块（Blocks）</strong>：由Linux制定对内核或文件系统等数据处理的基本单位；通常通常为4096个字节，由1个或多个扇区组成；</p>\n<p><strong>扇区（Sectors）</strong>：块设备的基本单位，是一个固定的硬件单位，制定了设备最少能够传输的数据量；通常在512字节到32768字节之间，默认：512字节；</p>\n<p>块是连续扇区的序列，块长度总是扇区长度的整数倍；块的最大长度，受特定体系结构的内存页长度限制；</p>\n<p>块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备；</p>\n<p><img src=\"/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E7%9A%84%E5%9D%97IO.png\" alt=\"Linux的块IO\"></p>\n<h4 id=\"2-块设备驱动框架\"><a href=\"#2-块设备驱动框架\" class=\"headerlink\" title=\"2. 块设备驱动框架\"></a>2. 块设备驱动框架</h4><p><img src=\"/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"块设备驱动架构图\"></p>\n<h3 id=\"1-重要结构及操作\"><a href=\"#1-重要结构及操作\" class=\"headerlink\" title=\"1. 重要结构及操作\"></a>1. 重要结构及操作</h3><h4 id=\"1-注册块设备驱动程序\"><a href=\"#1-注册块设备驱动程序\" class=\"headerlink\" title=\"1. 注册块设备驱动程序\"></a>1. 注册块设备驱动程序</h4><p>向内核注册块设备驱动程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_blkdev</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> major, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>name：设备名字，是在/proc/devices中显示的名字</p>\n<p>major：设备的主设备号，如果major=0，则分配一个主设备号</p>\n</blockquote>\n<p>该函数的调用是可选的，完成的工作：</p>\n<blockquote>\n<ol>\n<li>如果需要的话分配一个动态的主设备号</li>\n<li>在/proc/devices中创建一个入口项</li>\n</ol>\n</blockquote>\n<p>注销块设备驱动程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unregister_blkdev</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> major, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>如下用例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_major = <span class=\"number\">0</span>;</span><br><span class=\"line\">sbull_major = register_blkdev(sbull_major, <span class=\"string\">\"sbull\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sbull_major &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\tprintk(KERN_WARNNING <span class=\"string\">\"sbull: unable to get major number\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -EBUSY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/fs.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>           bd_dev;  <span class=\"comment\">/* not a kdev_t - it's a search key */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_openers;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *      <span class=\"title\">bd_inode</span>;</span>   <span class=\"comment\">/* will die */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_block</span> *    <span class=\"title\">bd_super</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span>        <span class=\"title\">bd_mutex</span>;</span>   <span class=\"comment\">/* open/close mutex */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *          bd_claiming;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *          bd_holder;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_holders;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span>            bd_write_holder;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SYSFS</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">bd_holder_disks</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device</span> *   <span class=\"title\">bd_contains</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span>        bd_block_size;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hd_struct</span> *  <span class=\"title\">bd_part</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* number of times partitions within this device have been opened. */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span>        bd_part_count;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_invalidated;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> *    <span class=\"title\">bd_disk</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *  <span class=\"title\">bd_queue</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">bd_list</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private data.  You must have bd_claim'ed the block_device</span></span><br><span class=\"line\"><span class=\"comment\">     * to use this.  <span class=\"doctag\">NOTE:</span>  bd_claim allows an owner to claim</span></span><br><span class=\"line\"><span class=\"comment\">     * the same device multiple times, the owner must take special</span></span><br><span class=\"line\"><span class=\"comment\">     * care to not mess up bd_private for that case.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>       bd_private;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* The counter of freeze processes */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_fsfreeze_count;</span><br><span class=\"line\">    <span class=\"comment\">/* Mutex for freeze */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span>        <span class=\"title\">bd_fsfreeze_mutex</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h4 id=\"2-块设备操作\"><a href=\"#2-块设备操作\" class=\"headerlink\" title=\"2. 块设备操作\"></a>2. 块设备操作</h4><p>字符设备使用file_operations结构，来告诉系统字符设备驱动的操作接口；</p>\n<p>块设备使用block_device_operations结构，来告诉系统块设备驱动的操作接口；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device_operations</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">open</span>) (struct block_device *, <span class=\"keyword\">fmode_t</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">release</span>) (struct gendisk *, <span class=\"keyword\">fmode_t</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*rw_page)(struct block_device *, <span class=\"keyword\">sector_t</span>, struct page *, <span class=\"keyword\">bool</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*ioctl) (struct block_device *, <span class=\"keyword\">fmode_t</span>, <span class=\"keyword\">unsigned</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*compat_ioctl) (struct block_device *, <span class=\"keyword\">fmode_t</span>, <span class=\"keyword\">unsigned</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*media_changed) (struct gendisk *);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*getgeo)(struct block_device *, struct hd_geometry *);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>和字符设备驱动不同，块设备驱动的block_device_operations操作集中没有负责读和写数据的函数；在块设备驱动中，这些操作是由request函数处理的；</p>\n<h4 id=\"3-注册磁盘\"><a href=\"#3-注册磁盘\" class=\"headerlink\" title=\"3. 注册磁盘\"></a>3. 注册磁盘</h4><p>为了管理独立的磁盘，需要使用struct gendisk结构体，内核使用gendisk结构表示一个独立的磁盘设备，还可以表示分区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/genhd.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> major;          <span class=\"comment\">/* major number of driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first_minor;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minors;                     <span class=\"comment\">/* maximum number of minors, =1 for</span></span><br><span class=\"line\"><span class=\"comment\">                                         * disks that can't be partitioned. */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> disk_name[DISK_NAME_LEN];  <span class=\"comment\">/* name of major driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *(*devnode)(struct gendisk *gd, <span class=\"keyword\">umode_t</span> *mode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hd_struct</span> <span class=\"title\">part0</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device_operations</span> *<span class=\"title\">fops</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">queue</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>major：指定驱动程序的主设备号</p>\n<p>first_minor和minors：从设备号的可能范围</p>\n<p>disk_name：磁盘名称，在/proc/partitions 和 sysfs 中表示该磁盘</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> disk_name[DISK_NAME_LEN];</span><br></pre></td></tr></table></figure>\n\n\n<p>显示在/proc/partitions 和 sysfs 中</p>\n<p>对于每一个分区来说，都有一个hd_struct结构体，用于描述该分区</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/genhd.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hd_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> start_sect;</span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> nr_sects;</span><br><span class=\"line\">    <span class=\"keyword\">seqcount_t</span> nr_sects_seq;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">partition_meta_info</span> *<span class=\"title\">info</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>start_sect和nr_sects：定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区</p>\n<p>拥有了设备内存和请求队列，就可以分配、初始化及安装gendisk结构；在struct gendisk是动态分配的结构，需要内核进行初始化，驱动必须通过alloc_disk分配：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/genhd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">struct gendisk *<span class=\"title\">alloc_disk</span><span class=\"params\">(<span class=\"keyword\">int</span> minors)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>minors：是该磁盘使用的从设备号的数目；</p>\n</blockquote>\n<p>卸载磁盘</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del_gendisk</span><span class=\"params\">(struct gendisk *disk)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>gendisk是一个引用计数结构，get_disk和put_disk函数负责处理引用计数；调用del_gendisk后，该结构可能继续存在；</p>\n<p>为了使gendisk结构的磁盘设备生效，需要初始化结构，并将磁盘或分区信息添加到内核链表；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_disk</span><span class=\"params\">(struct gendisk *gd)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>调用add_disk后，磁盘设备将被激活，并随时会调用它提供的操作方法，因此在驱动程序完全被初始化并且能够响应对磁盘的请求前，不要调用add_disk；</p>\n<h4 id=\"4-请求队列\"><a href=\"#4-请求队列\" class=\"headerlink\" title=\"4. 请求队列\"></a>4. 请求队列</h4><p>块设备驱动程序的核心是请求函数，包含请求处理过程；</p>\n<p>有I/O调度类设备，使用blk_init_queue()函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request_queue *<span class=\"title\">blk_init_queue</span><span class=\"params\">(request_fn_proc *rfn, <span class=\"keyword\">spinlock_t</span> *lock)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>无I/O调度类设备，使用blk_alloc_queue()函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request_queue *<span class=\"title\">blk_alloc_queue</span><span class=\"params\">(<span class=\"keyword\">gfp_t</span> gfp_mask)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// block/blk-settings.c</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">blk_queue_make_request</span><span class=\"params\">(struct request_queue *q, make_request_fn *mfn)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>从请求队列中提取请求：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request *<span class=\"title\">blk_fetch_request</span><span class=\"params\">(struct request_queue *q)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在卸载函数中使用的清除请求队列：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">blk_cleanup_queue</span><span class=\"params\">(struct request_queue *q)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>块设备的读写请求放置在请求队列中，在struct gendisk中，通过struct request_queue *queue指针指向请求队列；请求队列用数据结构struct request_queue表示；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">queue_head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span>      *<span class=\"title\">last_merge</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">elevator_queue</span>   *<span class=\"title\">elevator</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    request_fn_proc     *request_fn;</span><br><span class=\"line\">    make_request_fn     *make_request_fn;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">void</span>            *queuedata;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">icq_list</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue_limits</span> <span class=\"title\">limits</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_flush_queue</span>  *<span class=\"title\">fq</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">requeue_list</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span>      requeue_lock;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">delayed_work</span> <span class=\"title\">requeue_work</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>queue_head：表头，用于构建一个IO请求的双链表；链表每个元素代表向块设备读取数据的一个请求；内核会重排该链表，以得到更好的IO性能；</p>\n<p>与每个块设备驱动程序相关的I/O请求队列用request_queue结构体描述，而每个request_queue队列中的请求用request结构体描述；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">queuelist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">q</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_mq_ctx</span> *<span class=\"title\">mq_ctx</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* the following two fields are internal, NEVER access directly */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> __data_len;    <span class=\"comment\">/* total data len */</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> __sector;      <span class=\"comment\">/* sector cursor */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> *<span class=\"title\">bio</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> *<span class=\"title\">biotail</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> *<span class=\"title\">next_rq</span>;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>request结构体关联了struct bio，struct bio结构体是块I/O操作在页级粒度的底层描述；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blk_types.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span>      *<span class=\"title\">bi_next</span>;</span>   <span class=\"comment\">/* request queue link */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device</span> *<span class=\"title\">bi_bdev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bi_error;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_flags;   <span class=\"comment\">/* status, command, etc */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_ioprio;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bvec_iter</span>    <span class=\"title\">bi_iter</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">atomic_t</span>        __bi_remaining;</span><br><span class=\"line\">    <span class=\"keyword\">bio_end_io_t</span>        *bi_end_io;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_vcnt;    <span class=\"comment\">/* how many bio_vec's */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_max_vecs;    <span class=\"comment\">/* max bvl_vecs we can hold */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio_vec</span>      *<span class=\"title\">bi_io_vec</span>;</span> <span class=\"comment\">/* the actual vec list */</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>块数据通过bio_vec结构体数组在内部被表示成I/O向量；每个bio_vec数组元素由三元组组成（即，页、页偏移、长度），表示该块I/O的一个段；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bvec.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio_vec</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">bv_page</span>;</span>\t<span class=\"comment\">// 页指针</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>    bv_len;\t<span class=\"comment\">// 传输的字节数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>    bv_offset;\t<span class=\"comment\">// 偏移位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>struct bvec_iter结构体用来记录当前bvec被处理的情况，用于遍历bio；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bvec.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bvec_iter</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span>        bi_sector;  <span class=\"comment\">/* device address in 512 byte sectors */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tbi_size;    <span class=\"comment\">/* residual I/O count */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tbi_idx;     <span class=\"comment\">/* current index into bvl_vec */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tbi_bvec_done;   <span class=\"comment\">/* number of bytes completed in current bvec */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-数据结构间的关系\"><a href=\"#5-数据结构间的关系\" class=\"headerlink\" title=\"5. 数据结构间的关系\"></a>5. 数据结构间的关系</h4><table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>request_queue</td>\n<td>表示针对一个gendisk对象的所有请求的队列，是对应gendisk结构的一个成员；</td>\n</tr>\n<tr>\n<td>request</td>\n<td>表示经过I/O调度之后的针对gendisk的一个请求，是request_queue结构队列的一个节点，多个request构成了一个request_queue队列；</td>\n</tr>\n<tr>\n<td>bio</td>\n<td>表示应用程序对一个gendisk原始的访问请求；一个bio由多个bio_vec组成，多个bio经过I/O调度和合并形成一个request；</td>\n</tr>\n<tr>\n<td>bio_vec</td>\n<td>描述的应用层准备读写一个gendisk时需要使用的内存页（page）的一部分；多个bio_vec形成一个bio；</td>\n</tr>\n<tr>\n<td>bvec_iter</td>\n<td>描述一个bio_vec结构中的一个sector信息；</td>\n</tr>\n</tbody></table>\n<p>块设备数据结构间的关系如下所示：</p>\n<p><img src=\"/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%9D%97%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"块设备数据结构间的关系\"></p>\n<h3 id=\"2-块设备驱动的初始化\"><a href=\"#2-块设备驱动的初始化\" class=\"headerlink\" title=\"2. 块设备驱动的初始化\"></a>2. 块设备驱动的初始化</h3><h4 id=\"2-1-块设备的注册过程\"><a href=\"#2-1-块设备的注册过程\" class=\"headerlink\" title=\"2.1 块设备的注册过程\"></a>2.1 块设备的注册过程</h4><p>注册一个块设备驱动，需要以下步骤：</p>\n<blockquote>\n<p>创建一个块设备 </p>\n<p>分配一个申请队列</p>\n<p>分配一个gendisk结构体</p>\n<p>设置gendisk结构体成员</p>\n<p>注册gendisk结构体</p>\n</blockquote>\n<pre class=\"mermaid\">graph TB\n    A(\"注册设备(register_blkdev)(可选)\")-->B(\"分配磁盘(alloc_disk)\")\n    B--有I/O调度-->C(\"不使用请求队列(blk_init_queue)\")-->E\n    B--无I/O调度-->D(\"使用请求队列(blk_alloc_queue)\")-->E\n    E(\"设置磁盘属性(gendisk)\")-->F(\"激活磁盘(add_disk)\")</pre>\n\n\n<ol>\n<li><p>通过register_blkdev()函数注册设备，是个可选操作；</p>\n</li>\n<li><p>使用alloc_disk()函数分配通用磁盘gendisk结构体；</p>\n</li>\n<li><p>根据是否需要I/O调度，分两种情况，一种是使用请求队列进行数据传输，一种是不使用请求队列进行数据传输；</p>\n</li>\n<li><p>初始化gendisk结构体的数据成员，包括：major、fops、queue等；</p>\n</li>\n<li><p>使用add_disk()函数激活磁盘设备，调用该函数之前要做好所有的准备工作；</p>\n</li>\n</ol>\n<p>分配一个gendisk结构体</p>\n<p>设置一个队列，将访问请求放到队列里</p>\n<p>设置gendisk结构体的属性，如：名称、容量、操作集等</p>\n<p>添加gendisk结构体</p>\n<p>另外分配一块内存空间，当做块设备，在request函数中使用memcpy访问，模仿块设备读写</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(sbull_blkdev_init);</span><br><span class=\"line\">module_exit(sbull_blkdev_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>块设备驱动程序的初始化方法在sbull_blkdev_init()函数中；</p>\n<h5 id=\"1）注册块设备\"><a href=\"#1）注册块设备\" class=\"headerlink\" title=\"1）注册块设备\"></a>1）注册块设备</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">major = register_blkdev(major, <span class=\"string\">\"sbull_blkdev\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>为块设备驱动分配一个未使用的主设备号，并在/proc/devies中添加一个入口；</p>\n<h5 id=\"2）注册请求队列\"><a href=\"#2）注册请求队列\" class=\"headerlink\" title=\"2）注册请求队列\"></a>2）注册请求队列</h5><p>注册请求队列的操作，将一个请求的操作方法与该设备相关联，通过blk_init_queue()函数实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">sbull_blkdev_request</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">DEFINE_SPINLOCK</span><span class=\"params\">(sbull_blkdev_lock)</span></span>;</span><br><span class=\"line\">sbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &amp;sbull_blkdev_lock);</span><br></pre></td></tr></table></figure>\n\n<p>blk_init_queue()函数返回请求队列request_queue，将sbull_blkdev_request()函数指针方式关联到该设备；</p>\n<p>第一个参数是函数指针，用来指定请求队列的处理函数；</p>\n<p>第二个参数是自旋锁，用来保护request_queue队列不被同时访问；</p>\n<h5 id=\"3）设置读写块大小\"><a href=\"#3）设置读写块大小\" class=\"headerlink\" title=\"3）设置读写块大小\"></a>3）设置读写块大小</h5><p>硬件执行磁盘是以扇区为单位的，而文件系统是以块为单位处理数据；通常，扇区大小为512字节，块大小为4096字节；需要将硬件支持的扇区大小和驱动程序在一次请求中能接收的最大扇区数通知块层；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_sect_size = <span class=\"number\">512</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_size = <span class=\"number\">16</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"comment\">// blk_queue_hardsect_size(blkdev_queue, my_blkdev_sect_size);</span></span><br><span class=\"line\">blk_queue_logical_block_size(sbull_blkdev_queue, sbull_blkdev_sect_size);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4）创建磁盘\"><a href=\"#4）创建磁盘\" class=\"headerlink\" title=\"4）创建磁盘\"></a>4）创建磁盘</h5><p>使用alloc_disk()函数分配一个与设备对应的磁盘gendisk结构体，并初始化其成员；需要初始化的成员有：block_device_operations、存储容量（单位是扇区）、请求队列、主设备号、磁盘名称等；设置存储容量通过set_capacity()函数来完成；</p>\n<p>调用add_disk()函数将磁盘添加到块I/O层；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sbull_blkdev_disk = alloc_disk(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(sbull_blkdev_disk-&gt;disk_name, <span class=\"string\">\"sbull_blkdev_disk\"</span>);</span><br><span class=\"line\">sbull_blkdev_disk-&gt;fops = &amp;sbull_blkdev_fops;</span><br><span class=\"line\">sbull_blkdev_disk-&gt;<span class=\"built_in\">queue</span> = sbull_blkdev_queue;</span><br><span class=\"line\">sbull_blkdev_disk-&gt;major = major;</span><br><span class=\"line\">sbull_blkdev_disk-&gt;first_minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">set_capacity(sbull_blkdev_disk, sbull_blkdev_size);</span><br><span class=\"line\"></span><br><span class=\"line\">add_disk(sbull_blkdev_disk);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>到这里，设备/dev/sbull_blkdev_disk就可以使用了，如果设备支持多个磁盘分区，会显示为/dev/sbull_blkdev_diskX，X是分区号；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># ls /dev/sbull_blkdev_disk -l</span></span><br><span class=\"line\">brw-rw----    <span class=\"number\">1</span> root     root      <span class=\"number\">253</span>,   <span class=\"number\">0</span> Oct <span class=\"number\">21</span> <span class=\"number\">08</span>:<span class=\"number\">18</span> /dev/sbull_blkdev_disk</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"5）块设备初始化实例\"><a href=\"#5）块设备初始化实例\" class=\"headerlink\" title=\"5）块设备初始化实例\"></a>5）块设备初始化实例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device_operations</span> <span class=\"title\">sbull_blkdev_fops</span> = &#123;</span></span><br><span class=\"line\">    .owner = THIS_MODULE,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = sbull_blkdev_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = sbull_blkdev_release,</span><br><span class=\"line\">    .ioctl = sbull_blkdev_ioctl,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>请求处理函数，具体实现内容，后边补充；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sbull_blkdev_request</span><span class=\"params\">(struct request_queue *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s: %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">sbull_blkdev_queue</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> *<span class=\"title\">sbull_blkdev_disk</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">DEFINE_SPINLOCK</span><span class=\"params\">(sbull_blkdev_lock)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_size = <span class=\"number\">256</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_sect_size = <span class=\"number\">512</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sbull_blkdev_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    major = register_blkdev(major, <span class=\"string\">\"mcy_blk\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (major &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, register_blkdev failed, major: %d\\n\"</span>, __func__, major);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> register_blkdev_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, major: %d\\n\"</span>, __func__, major);</span><br><span class=\"line\"></span><br><span class=\"line\">    sbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &amp;sbull_blkdev_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sbull_blkdev_queue) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, blk_init_queue failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> init_queue_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sbull_blkdev_disk = alloc_disk(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sbull_blkdev_disk) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, alloc_disk failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> alloc_disk_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(sbull_blkdev_disk-&gt;disk_name, <span class=\"string\">\"sbull_blkdev_disk\"</span>);</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;fops = &amp;sbull_blkdev_fops;</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;<span class=\"built_in\">queue</span> = sbull_blkdev_queue;</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;major = major;</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;first_minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set_capacity(sbull_blkdev_disk, sbull_blkdev_size * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    add_disk(sbull_blkdev_disk);</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, sbull_blkdev_disk add success!\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">alloc_disk_err:</span><br><span class=\"line\">    blk_cleanup_queue(sbull_blkdev_queue);</span><br><span class=\"line\">init_queue_err:</span><br><span class=\"line\">    unregister_blkdev(major, <span class=\"string\">\"sbull_blkdev\"</span>);</span><br><span class=\"line\">register_blkdev_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -EBUSY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-块设备的卸载过程\"><a href=\"#2-2-块设备的卸载过程\" class=\"headerlink\" title=\"2.2 块设备的卸载过程\"></a>2.2 块设备的卸载过程</h4><pre class=\"mermaid\">graph TB\n    A(\"删除gendisk(del_gendisk)\")-->\n    B(\"删除gendisk的引用(put_disk)\")-->\n    C(\"清除请求队列(blk_cleanup_queue)\")-->\n    D(\"注销块设备(unregister_blkdev)\")</pre>\n\n\n<ol>\n<li><p>使用del_gendisk()函数删除gendisk设备（磁盘）；</p>\n</li>\n<li><p>使用put_disk()函数删除gendisk设备的引用；</p>\n</li>\n<li><p>使用blk_cleanup_queue()函数清除请求队列，释放请求队列占用的资源；</p>\n</li>\n<li><p>使用unregister_blkdev()函数注销设备，并释放对设备的引用，可选操作，与register_blkdev()函数配合使用；</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sbull_blkdev_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    del_gendisk(sbull_blkdev_disk);</span><br><span class=\"line\">    put_disk(sbull_blkdev_disk);</span><br><span class=\"line\">    blk_cleanup_queue(sbull_blkdev_queue);</span><br><span class=\"line\">    unregister_blkdev(major, <span class=\"string\">\"sbull_blkdev\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(sbull_blkdev_init);</span><br><span class=\"line\">module_exit(sbull_blkdev_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">\"GPL\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"2-3-封装块设备信息\"><a href=\"#2-3-封装块设备信息\" class=\"headerlink\" title=\"2.3 封装块设备信息\"></a>2.3 封装块设备信息</h4><p>为了在一些函数中能够访问块设备驱动的一些信息（比如：请求队列，硬盘分区，硬盘尺寸等）参数，可以定义一个块设备驱动设备结构体，给每一个块设备定义一个信息描述，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sbull_dev</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> major;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"built_in\">size</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">queue</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> *<span class=\"title\">disk</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span> lock;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_list</span> <span class=\"title\">timer</span>;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">blkdev_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">blkdev_t</span> *blkdev = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p>同时，定义了一些必要的宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SBULL_BLKDEV_SIZE   (16 * 1024 * 1024)\t<span class=\"comment\">// 指定块设备硬盘的大小为16M</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SBULL_BLKDEV_SECTOR_SIZE    (512)\t<span class=\"comment\">// 设置块设备的sector为512字节</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SBULL_BLKDEV_MAX_PARTITIONS (16)\t<span class=\"comment\">// 设置块设备最大的分区数</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这样在块设备中只需要通过blkdev指针就可以获取到设备的所有需要的参数信息；而相应的初始化操作也需要相应地修改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">blkdev_t</span>), GFP_KERNEL);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!blkdev) &#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, blkdev kmalloc failed\\n\"</span>, __func__);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> blkdev_kmalloc_err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(blkdev, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">blkdev_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">spin_lock_init(&amp;blkdev-&gt;lock);</span><br><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span> = blk_alloc_queue(GFP_KERNEL);</span><br><span class=\"line\">blkdev-&gt;<span class=\"built_in\">size</span> = SBULL_BLKDEV_SIZE;</span><br><span class=\"line\">blkdev-&gt;data = sbull_blkdev_data;</span><br><span class=\"line\"></span><br><span class=\"line\">blkdev-&gt;disk = alloc_disk(SBULL_BLKDEV_MAX_PARTITIONS);</span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(blkdev-&gt;disk-&gt;disk_name, SBULL_BLKDEV_NAME);</span><br><span class=\"line\">blkdev-&gt;disk-&gt;fops = &amp;sbull_blkdev_fops;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;<span class=\"built_in\">queue</span> = blkdev-&gt;<span class=\"built_in\">queue</span>;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;major = major;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;first_minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">set_capacity(blkdev-&gt;disk, SBULL_BLKDEV_SIZE / SBULL_BLKDEV_SECTOR_SIZE);</span><br><span class=\"line\">add_disk(blkdev-&gt;disk);</span><br></pre></td></tr></table></figure>\n\n<p>这个块设备的结构体信息，可以通过gendisk结构体中的private_data指针保存，也可以通过request_queue结构体中的queuedata指针保存；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span>-&gt;queuedata = blkdev;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;private_data = blkdev;</span><br></pre></td></tr></table></figure>\n\n<p>在需要使用这些信息时可以通过queue-&gt;queuedata或disk-&gt;private_data指针快速获取到块设备信息；</p>\n<h3 id=\"3-队列请求\"><a href=\"#3-队列请求\" class=\"headerlink\" title=\"3. 队列请求\"></a>3. 队列请求</h3><p>这主要是由于该版本适用于2.6.29内核，从2.6.31内核开始，一些API发生变化（见linux/include/blkdev.h）；用到的几个API修改如下：</p>\n<table>\n<thead>\n<tr>\n<th>老版本内核接口</th>\n<th>新版本内核接口</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>request -&gt; sectors</td>\n<td>blk_rq_pos(request)</td>\n<td>获取请求的开始扇区</td>\n</tr>\n<tr>\n<td>request -&gt; nr_sectors</td>\n<td>blk_rq_nr_sectors(request)</td>\n<td>获取请求的扇区数</td>\n</tr>\n<tr>\n<td>elev_next_request(request)</td>\n<td>blk_fetch_request(request)</td>\n<td></td>\n</tr>\n<tr>\n<td>end_request(request, error)</td>\n<td>blk_end_request_all(request, error)</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>每个块设备，都有一个请求队列，当请求队列生成时，请求函数request()就与该队列绑定，这个操作根据有无有I/O调度，分两种方法实现；</p>\n<h4 id=\"3-1-blk-init-queue\"><a href=\"#3-1-blk-init-queue\" class=\"headerlink\" title=\"3.1 blk_init_queue\"></a>3.1 blk_init_queue</h4><p>第一种是有I/O调度类设备，通过blk_init_queue()函数完成；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request_queue *<span class=\"title\">blk_init_queue</span><span class=\"params\">(request_fn_proc *rfn, <span class=\"keyword\">spinlock_t</span> *lock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> blk_init_queue_node(rfn, lock, NUMA_NO_NODE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(blk_init_queue);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>blk_init_queue()函数的调用关系：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blk_init_queue</span><br><span class=\"line\">\tblk_init_queue_node</span><br><span class=\"line\">\t\tblk_alloc_queue_node</span><br><span class=\"line\">\t\t\tkmem_cache_alloc_node</span><br><span class=\"line\">\t\t\tida_simple_get</span><br><span class=\"line\">\t\t\tbioset_create</span><br><span class=\"line\">\t\t\tbdi_init</span><br><span class=\"line\">\t\t\tpercpu_ref_init</span><br><span class=\"line\">\t\t\tblkcg_init_queue</span><br><span class=\"line\">\t\tblk_init_allocated_queue</span><br><span class=\"line\">\t\t\tblk_alloc_flush_queue</span><br><span class=\"line\">\t\t\tblk_init_rl</span><br><span class=\"line\">\t\t\tblk_queue_make_request</span><br><span class=\"line\">\t\t\televator_init</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实现方法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span> = blk_init_queue(sbull_blkdev_request, &amp;blkdev-&gt;lock);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sbull_blkdev_request</span><span class=\"params\">(struct request_queue *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> *<span class=\"title\">req</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">blkdev_t</span> *dev = q-&gt;queuedata;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sect_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sect_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *<span class=\"built_in\">buffer</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    req = blk_fetch_request(q);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (req != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        sect_pos = blk_rq_pos(req);</span><br><span class=\"line\">        sect_count = blk_rq_cur_sectors(req);</span><br><span class=\"line\">        start = sect_pos &lt;&lt; <span class=\"number\">9</span>;</span><br><span class=\"line\">        len = blk_rq_cur_bytes(req);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start + len &gt; dev-&gt;<span class=\"built_in\">size</span>) &#123;</span><br><span class=\"line\">            printk(<span class=\"string\">\"%s, bad access, block: 0x%llx, count: 0x%lx\\n\"</span>, __func__, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)sect_pos, sect_count);</span><br><span class=\"line\">            err = -EIO;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">buffer</span> = bio_data(req-&gt;bio);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">buffer</span>) &#123;</span><br><span class=\"line\">            printk(<span class=\"string\">\"%s, bio_data buffer is null\\n\"</span>, __func__);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sbull_transfer(dev, sect_pos, sect_count, <span class=\"built_in\">buffer</span>, rq_data_dir(req) == WRITE);</span><br><span class=\"line\">done:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!__blk_end_request_cur(req, err)) &#123;</span><br><span class=\"line\">            req = blk_fetch_request(q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sbull_transfer</span><span class=\"params\">(<span class=\"keyword\">blkdev_t</span> *dev, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sector, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nsect, <span class=\"keyword\">char</span> *<span class=\"built_in\">buffer</span>, <span class=\"keyword\">int</span> <span class=\"built_in\">write</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> offset = sector * SBULL_BLKDEV_SECTOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nbytes = nsect * SBULL_BLKDEV_SECTOR_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset + nbytes &gt; dev-&gt;<span class=\"built_in\">size</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, over range, size: 0x%lx, offset: 0x%lx, nbytes: 0x%lx\"</span>, __func__, dev-&gt;<span class=\"built_in\">size</span>, offset, nbytes);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dev-&gt;data + offset, <span class=\"built_in\">buffer</span>, nbytes);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(<span class=\"built_in\">buffer</span>, dev-&gt;data + offset, nbytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h4 id=\"3-2-blk-alloc-queue\"><a href=\"#3-2-blk-alloc-queue\" class=\"headerlink\" title=\"3.2 blk_alloc_queue\"></a>3.2 blk_alloc_queue</h4><p>第二种是无I/O调度类设备，通过blk_alloc_queue()函数完成；</p>\n<p>实现方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span> = blk_alloc_queue(GFP_KERNEL);</span><br><span class=\"line\">blk_queue_make_request(blkdev-&gt;<span class=\"built_in\">queue</span>, sbull_blkdev_make_request);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">sbull_blkdev_make_request</span><span class=\"params\">(struct request_queue *q, struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">blkdev_t</span> *dev = q-&gt;queuedata;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> status = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = sbull_xfer_bio(dev, bio);</span><br><span class=\"line\">    bio_endio(bio);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sbull_xfer_bio</span><span class=\"params\">(<span class=\"keyword\">blkdev_t</span> *dev, struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bvec_iter</span> <span class=\"title\">iter</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio_vec</span> <span class=\"title\">bvec</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> sector = bio-&gt;bi_iter.bi_sector;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *<span class=\"built_in\">buffer</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    bio_for_each_segment(bvec, bio, iter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">buffer</span> = __bio_kmap_atomic(bio, iter);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">buffer</span>) &#123;</span><br><span class=\"line\">            printk(<span class=\"string\">\"%s, buffer is null\\n\"</span>, __func__);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sbull_transfer(dev, sector, bio_cur_bytes(bio)&gt;&gt;<span class=\"number\">9</span>, <span class=\"built_in\">buffer</span>, bio_data_dir(bio) == WRITE);</span><br><span class=\"line\">        sector += bio_cur_bytes(bio)&gt;&gt;<span class=\"number\">9</span>;</span><br><span class=\"line\">        __bio_kunmap_atomic(bio);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blk_queue_max_hw_sectors(blkdev-&gt;<span class=\"built_in\">queue</span>, <span class=\"number\">255</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>blk_queue_max_hw_sectors()函数，用来通知通用块层和I/O调度器，该请求队列的每个请求中能够包含的最大扇区数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blk_queue_logical_block_size(blkdev-&gt;<span class=\"built_in\">queue</span>, sbull_sect_size);</span><br></pre></td></tr></table></figure>\n\n\n<p>blk_queue_logical_block_size()函数，用于告知该请求队列的逻辑块大小；</p>\n<p>bio的一些接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/fs.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">bio_data_dir</span><span class=\"params\">(struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> op_is_write(bio_op(bio)) ? WRITE : READ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_BLOCK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">op_is_write</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> op)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> op == REQ_OP_READ ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>return：READ/WRITE</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bio.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BIO_MAX_PAGES       256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_prio(bio)           (bio)-&gt;bi_ioprio</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_set_prio(bio, prio)     ((bio)-&gt;bi_ioprio = prio)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_iovec(bio, iter)               \\</span></span><br><span class=\"line\">    bvec_iter_bvec((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_page(bio, iter)                \\</span></span><br><span class=\"line\">    bvec_iter_page((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_len(bio, iter)                 \\</span></span><br><span class=\"line\">    bvec_iter_len((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_offset(bio, iter)              \\</span></span><br><span class=\"line\">    bvec_iter_offset((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_page(bio)       bio_iter_page((bio), (bio)-&gt;bi_iter)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_offset(bio)     bio_iter_offset((bio), (bio)-&gt;bi_iter)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iovec(bio)      bio_iter_iovec((bio), (bio)-&gt;bi_iter)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_multiple_segments(bio)              \\</span></span><br><span class=\"line\">    ((bio)-&gt;bi_iter.bi_size != bio_iovec(bio).bv_len)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_sectors(bio)    ((bio)-&gt;bi_iter.bi_size &gt;&gt; 9)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_end_sector(bio) ((bio)-&gt;bi_iter.bi_sector + bio_sectors((bio)))</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bio.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">bio_cur_bytes</span><span class=\"params\">(struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bio_has_data(bio))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bio_iovec(bio).bv_len;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">/* dataless requests such as discard */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bio-&gt;bi_iter.bi_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数据缓冲区的内核虚拟地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> *<span class=\"title\">bio_data</span><span class=\"params\">(struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bio_has_data(bio))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> page_address(bio_page(bio)) + bio_offset(bio);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bio.h</span></span><br><span class=\"line\"><span class=\"comment\">// 获取给定bio的第i个缓冲区的虚拟地址</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __bio_kmap_atomic(bio, iter)                \\</span></span><br><span class=\"line\">    (kmap_atomic(bio_iter_iovec((bio), (iter)).bv_page) +   \\</span><br><span class=\"line\">        bio_iter_iovec((bio), (iter)).bv_offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放缓冲区的虚拟地址</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __bio_kunmap_atomic(addr)   kunmap_atomic(addr)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rq_data_dir(rq)     (op_is_write(req_op(rq)) ? WRITE : READ)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REQ_OP_SHIFT (8 * sizeof(u64) - REQ_OP_BITS)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> req_op(req)  ((req)-&gt;cmd_flags &gt;&gt; REQ_OP_SHIFT)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// include/linux/blk_types.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REQ_OP_BITS 3</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_pos()         : the current sector</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_bytes()       : bytes left in the entire request</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_cur_bytes()       : bytes left in the current segment</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_err_bytes()       : bytes left till the next error boundary</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_sectors()     : sectors left in the entire request</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_cur_sectors()     : sectors left in the current segment</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">sector_t</span> <span class=\"title\">blk_rq_pos</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rq-&gt;__sector;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rq-&gt;__data_len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_cur_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rq-&gt;bio ? bio_cur_bytes(rq-&gt;bio) : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_sectors</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> blk_rq_bytes(rq) &gt;&gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_cur_sectors</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> blk_rq_cur_bytes(rq) &gt;&gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_count_bios</span><span class=\"params\">(struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> nr_bios = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> *<span class=\"title\">bio</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    __rq_for_each_bio(bio, rq)</span><br><span class=\"line\">        nr_bios++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nr_bios;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3-3-两种队列请求的区别\"><a href=\"#3-3-两种队列请求的区别\" class=\"headerlink\" title=\"3.3 两种队列请求的区别\"></a>3.3 两种队列请求的区别</h4><h4 id=\"3-4-I-O调度器\"><a href=\"#3-4-I-O调度器\" class=\"headerlink\" title=\"3.4 I/O调度器\"></a>3.4 I/O调度器</h4><p>I/O调度器可以通过合并请求、重排块设备操作顺序等方式提高块设备访问的顺序；</p>\n<p>I/O调度器四种</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># cat /sys/block/sbull_disk/queue/scheduler</span></span><br><span class=\"line\">noop [cfq]</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>对于大多数基于物理磁盘的块设备驱动，使用适合的I/O调度器能提高性能；</p>\n<p>无I/O调度器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># cat /sys/block/sbull_disk/queue/scheduler</span></span><br><span class=\"line\">none</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h3 id=\"8-测试验证\"><a href=\"#8-测试验证\" class=\"headerlink\" title=\"8. 测试验证\"></a>8. 测试验证</h3><p>测试步骤：</p>\n<blockquote>\n<p>加载驱动：insmod ramblock.ko</p>\n<p>格式化：mkdosfs /dev/ramblock</p>\n<p>挂载：mount /dev/ramblock /mnt</p>\n<p>读写文件：cd /mnt，创建文件</p>\n<p>卸载：umount /mnt</p>\n<p>cat /dev/ramblock &gt; /mnt/ramblock.bin</p>\n<p>在PC上查看/mnt/ramblock.bin，sudo mount -o loop ramblock.bin /mnt</p>\n</blockquote>\n<h3 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9. 总结\"></a>9. 总结</h3><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.cnblogs.com/big-devil/p/8590007.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/big-devil/p/8590007.html</a></p>\n<p><a href=\"https://www.cnblogs.com/xiaojiang1025/p/6500557.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaojiang1025/p/6500557.html</a></p>\n<p><a href=\"#目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>未完成</p>\n<p>Linux块设备驱动</p>","more":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>字符设备</p>\n<p>字符设备是一种顺序的数据流设备，对字符设备的读写是以字节为单位进行的，这些字符连续地形成一个数据流，字符设备没有缓存区，对于字符设备的读写是实时的；</p>\n<p>块设备</p>\n<p>块设备是一种具有一定结构的随机存取设备，对块设备的读写是以块为单位进行的，块设备使用缓存区来存放数据，待条件满足后，将数据从缓存区一次性写入到设备，或者从设备一次性读取到缓存区；</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符设备</th>\n<th align=\"center\">块设备</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">顺序访问</td>\n<td align=\"center\">随机访问</td>\n</tr>\n<tr>\n<td align=\"center\">数据流设备</td>\n<td align=\"center\">存储设备</td>\n</tr>\n<tr>\n<td align=\"center\">以字节为单位</td>\n<td align=\"center\">以块为单位</td>\n</tr>\n<tr>\n<td align=\"center\">没有缓存区，实时读写</td>\n<td align=\"center\">有缓存区，非实时</td>\n</tr>\n<tr>\n<td align=\"center\">由应用层程序调用</td>\n<td align=\"center\">由文件系统程序调用</td>\n</tr>\n</tbody></table>\n<p>为了创建一个块设备驱动程序，实现一个基于内存的块设备驱动程序；</p>\n<h4 id=\"1-块设备结构\"><a href=\"#1-块设备结构\" class=\"headerlink\" title=\"1. 块设备结构\"></a>1. 块设备结构</h4><p><strong>段（Segments）</strong>：由若干个块组成；是Linux内存管理机制中一个内存页或内存页的一部分；</p>\n<p><strong>块（Blocks）</strong>：由Linux制定对内核或文件系统等数据处理的基本单位；通常通常为4096个字节，由1个或多个扇区组成；</p>\n<p><strong>扇区（Sectors）</strong>：块设备的基本单位，是一个固定的硬件单位，制定了设备最少能够传输的数据量；通常在512字节到32768字节之间，默认：512字节；</p>\n<p>块是连续扇区的序列，块长度总是扇区长度的整数倍；块的最大长度，受特定体系结构的内存页长度限制；</p>\n<p>块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备；</p>\n<p><img src=\"/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E7%9A%84%E5%9D%97IO.png\" alt=\"Linux的块IO\"></p>\n<h4 id=\"2-块设备驱动框架\"><a href=\"#2-块设备驱动框架\" class=\"headerlink\" title=\"2. 块设备驱动框架\"></a>2. 块设备驱动框架</h4><p><img src=\"/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"块设备驱动架构图\"></p>\n<h3 id=\"1-重要结构及操作\"><a href=\"#1-重要结构及操作\" class=\"headerlink\" title=\"1. 重要结构及操作\"></a>1. 重要结构及操作</h3><h4 id=\"1-注册块设备驱动程序\"><a href=\"#1-注册块设备驱动程序\" class=\"headerlink\" title=\"1. 注册块设备驱动程序\"></a>1. 注册块设备驱动程序</h4><p>向内核注册块设备驱动程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_blkdev</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> major, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>name：设备名字，是在/proc/devices中显示的名字</p>\n<p>major：设备的主设备号，如果major=0，则分配一个主设备号</p>\n</blockquote>\n<p>该函数的调用是可选的，完成的工作：</p>\n<blockquote>\n<ol>\n<li>如果需要的话分配一个动态的主设备号</li>\n<li>在/proc/devices中创建一个入口项</li>\n</ol>\n</blockquote>\n<p>注销块设备驱动程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unregister_blkdev</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> major, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>如下用例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_major = <span class=\"number\">0</span>;</span><br><span class=\"line\">sbull_major = register_blkdev(sbull_major, <span class=\"string\">\"sbull\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sbull_major &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\tprintk(KERN_WARNNING <span class=\"string\">\"sbull: unable to get major number\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -EBUSY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/fs.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>           bd_dev;  <span class=\"comment\">/* not a kdev_t - it's a search key */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_openers;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *      <span class=\"title\">bd_inode</span>;</span>   <span class=\"comment\">/* will die */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_block</span> *    <span class=\"title\">bd_super</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span>        <span class=\"title\">bd_mutex</span>;</span>   <span class=\"comment\">/* open/close mutex */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *          bd_claiming;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *          bd_holder;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_holders;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span>            bd_write_holder;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SYSFS</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">bd_holder_disks</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device</span> *   <span class=\"title\">bd_contains</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span>        bd_block_size;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hd_struct</span> *  <span class=\"title\">bd_part</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* number of times partitions within this device have been opened. */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span>        bd_part_count;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_invalidated;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> *    <span class=\"title\">bd_disk</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *  <span class=\"title\">bd_queue</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">bd_list</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private data.  You must have bd_claim'ed the block_device</span></span><br><span class=\"line\"><span class=\"comment\">     * to use this.  <span class=\"doctag\">NOTE:</span>  bd_claim allows an owner to claim</span></span><br><span class=\"line\"><span class=\"comment\">     * the same device multiple times, the owner must take special</span></span><br><span class=\"line\"><span class=\"comment\">     * care to not mess up bd_private for that case.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>       bd_private;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* The counter of freeze processes */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bd_fsfreeze_count;</span><br><span class=\"line\">    <span class=\"comment\">/* Mutex for freeze */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span>        <span class=\"title\">bd_fsfreeze_mutex</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h4 id=\"2-块设备操作\"><a href=\"#2-块设备操作\" class=\"headerlink\" title=\"2. 块设备操作\"></a>2. 块设备操作</h4><p>字符设备使用file_operations结构，来告诉系统字符设备驱动的操作接口；</p>\n<p>块设备使用block_device_operations结构，来告诉系统块设备驱动的操作接口；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device_operations</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">open</span>) (struct block_device *, <span class=\"keyword\">fmode_t</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">release</span>) (struct gendisk *, <span class=\"keyword\">fmode_t</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*rw_page)(struct block_device *, <span class=\"keyword\">sector_t</span>, struct page *, <span class=\"keyword\">bool</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*ioctl) (struct block_device *, <span class=\"keyword\">fmode_t</span>, <span class=\"keyword\">unsigned</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*compat_ioctl) (struct block_device *, <span class=\"keyword\">fmode_t</span>, <span class=\"keyword\">unsigned</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*media_changed) (struct gendisk *);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*getgeo)(struct block_device *, struct hd_geometry *);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>和字符设备驱动不同，块设备驱动的block_device_operations操作集中没有负责读和写数据的函数；在块设备驱动中，这些操作是由request函数处理的；</p>\n<h4 id=\"3-注册磁盘\"><a href=\"#3-注册磁盘\" class=\"headerlink\" title=\"3. 注册磁盘\"></a>3. 注册磁盘</h4><p>为了管理独立的磁盘，需要使用struct gendisk结构体，内核使用gendisk结构表示一个独立的磁盘设备，还可以表示分区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/genhd.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> major;          <span class=\"comment\">/* major number of driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first_minor;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minors;                     <span class=\"comment\">/* maximum number of minors, =1 for</span></span><br><span class=\"line\"><span class=\"comment\">                                         * disks that can't be partitioned. */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> disk_name[DISK_NAME_LEN];  <span class=\"comment\">/* name of major driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *(*devnode)(struct gendisk *gd, <span class=\"keyword\">umode_t</span> *mode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hd_struct</span> <span class=\"title\">part0</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device_operations</span> *<span class=\"title\">fops</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">queue</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>major：指定驱动程序的主设备号</p>\n<p>first_minor和minors：从设备号的可能范围</p>\n<p>disk_name：磁盘名称，在/proc/partitions 和 sysfs 中表示该磁盘</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> disk_name[DISK_NAME_LEN];</span><br></pre></td></tr></table></figure>\n\n\n<p>显示在/proc/partitions 和 sysfs 中</p>\n<p>对于每一个分区来说，都有一个hd_struct结构体，用于描述该分区</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/genhd.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hd_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> start_sect;</span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> nr_sects;</span><br><span class=\"line\">    <span class=\"keyword\">seqcount_t</span> nr_sects_seq;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">partition_meta_info</span> *<span class=\"title\">info</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>start_sect和nr_sects：定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区</p>\n<p>拥有了设备内存和请求队列，就可以分配、初始化及安装gendisk结构；在struct gendisk是动态分配的结构，需要内核进行初始化，驱动必须通过alloc_disk分配：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/genhd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">struct gendisk *<span class=\"title\">alloc_disk</span><span class=\"params\">(<span class=\"keyword\">int</span> minors)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>minors：是该磁盘使用的从设备号的数目；</p>\n</blockquote>\n<p>卸载磁盘</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del_gendisk</span><span class=\"params\">(struct gendisk *disk)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>gendisk是一个引用计数结构，get_disk和put_disk函数负责处理引用计数；调用del_gendisk后，该结构可能继续存在；</p>\n<p>为了使gendisk结构的磁盘设备生效，需要初始化结构，并将磁盘或分区信息添加到内核链表；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_disk</span><span class=\"params\">(struct gendisk *gd)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>调用add_disk后，磁盘设备将被激活，并随时会调用它提供的操作方法，因此在驱动程序完全被初始化并且能够响应对磁盘的请求前，不要调用add_disk；</p>\n<h4 id=\"4-请求队列\"><a href=\"#4-请求队列\" class=\"headerlink\" title=\"4. 请求队列\"></a>4. 请求队列</h4><p>块设备驱动程序的核心是请求函数，包含请求处理过程；</p>\n<p>有I/O调度类设备，使用blk_init_queue()函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request_queue *<span class=\"title\">blk_init_queue</span><span class=\"params\">(request_fn_proc *rfn, <span class=\"keyword\">spinlock_t</span> *lock)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>无I/O调度类设备，使用blk_alloc_queue()函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request_queue *<span class=\"title\">blk_alloc_queue</span><span class=\"params\">(<span class=\"keyword\">gfp_t</span> gfp_mask)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// block/blk-settings.c</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">blk_queue_make_request</span><span class=\"params\">(struct request_queue *q, make_request_fn *mfn)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>从请求队列中提取请求：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request *<span class=\"title\">blk_fetch_request</span><span class=\"params\">(struct request_queue *q)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在卸载函数中使用的清除请求队列：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">blk_cleanup_queue</span><span class=\"params\">(struct request_queue *q)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>块设备的读写请求放置在请求队列中，在struct gendisk中，通过struct request_queue *queue指针指向请求队列；请求队列用数据结构struct request_queue表示；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">queue_head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span>      *<span class=\"title\">last_merge</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">elevator_queue</span>   *<span class=\"title\">elevator</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    request_fn_proc     *request_fn;</span><br><span class=\"line\">    make_request_fn     *make_request_fn;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">void</span>            *queuedata;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">icq_list</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue_limits</span> <span class=\"title\">limits</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_flush_queue</span>  *<span class=\"title\">fq</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">requeue_list</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span>      requeue_lock;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">delayed_work</span> <span class=\"title\">requeue_work</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>queue_head：表头，用于构建一个IO请求的双链表；链表每个元素代表向块设备读取数据的一个请求；内核会重排该链表，以得到更好的IO性能；</p>\n<p>与每个块设备驱动程序相关的I/O请求队列用request_queue结构体描述，而每个request_queue队列中的请求用request结构体描述；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">queuelist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">q</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_mq_ctx</span> *<span class=\"title\">mq_ctx</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* the following two fields are internal, NEVER access directly */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> __data_len;    <span class=\"comment\">/* total data len */</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> __sector;      <span class=\"comment\">/* sector cursor */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> *<span class=\"title\">bio</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> *<span class=\"title\">biotail</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> *<span class=\"title\">next_rq</span>;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>request结构体关联了struct bio，struct bio结构体是块I/O操作在页级粒度的底层描述；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blk_types.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span>      *<span class=\"title\">bi_next</span>;</span>   <span class=\"comment\">/* request queue link */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device</span> *<span class=\"title\">bi_bdev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>         bi_error;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_flags;   <span class=\"comment\">/* status, command, etc */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_ioprio;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bvec_iter</span>    <span class=\"title\">bi_iter</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">atomic_t</span>        __bi_remaining;</span><br><span class=\"line\">    <span class=\"keyword\">bio_end_io_t</span>        *bi_end_io;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_vcnt;    <span class=\"comment\">/* how many bio_vec's */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> short      bi_max_vecs;    <span class=\"comment\">/* max bvl_vecs we can hold */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio_vec</span>      *<span class=\"title\">bi_io_vec</span>;</span> <span class=\"comment\">/* the actual vec list */</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>块数据通过bio_vec结构体数组在内部被表示成I/O向量；每个bio_vec数组元素由三元组组成（即，页、页偏移、长度），表示该块I/O的一个段；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bvec.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio_vec</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">bv_page</span>;</span>\t<span class=\"comment\">// 页指针</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>    bv_len;\t<span class=\"comment\">// 传输的字节数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>    bv_offset;\t<span class=\"comment\">// 偏移位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>struct bvec_iter结构体用来记录当前bvec被处理的情况，用于遍历bio；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bvec.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bvec_iter</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span>        bi_sector;  <span class=\"comment\">/* device address in 512 byte sectors */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tbi_size;    <span class=\"comment\">/* residual I/O count */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tbi_idx;     <span class=\"comment\">/* current index into bvl_vec */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>\tbi_bvec_done;   <span class=\"comment\">/* number of bytes completed in current bvec */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-数据结构间的关系\"><a href=\"#5-数据结构间的关系\" class=\"headerlink\" title=\"5. 数据结构间的关系\"></a>5. 数据结构间的关系</h4><table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>request_queue</td>\n<td>表示针对一个gendisk对象的所有请求的队列，是对应gendisk结构的一个成员；</td>\n</tr>\n<tr>\n<td>request</td>\n<td>表示经过I/O调度之后的针对gendisk的一个请求，是request_queue结构队列的一个节点，多个request构成了一个request_queue队列；</td>\n</tr>\n<tr>\n<td>bio</td>\n<td>表示应用程序对一个gendisk原始的访问请求；一个bio由多个bio_vec组成，多个bio经过I/O调度和合并形成一个request；</td>\n</tr>\n<tr>\n<td>bio_vec</td>\n<td>描述的应用层准备读写一个gendisk时需要使用的内存页（page）的一部分；多个bio_vec形成一个bio；</td>\n</tr>\n<tr>\n<td>bvec_iter</td>\n<td>描述一个bio_vec结构中的一个sector信息；</td>\n</tr>\n</tbody></table>\n<p>块设备数据结构间的关系如下所示：</p>\n<p><img src=\"/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%9D%97%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"块设备数据结构间的关系\"></p>\n<h3 id=\"2-块设备驱动的初始化\"><a href=\"#2-块设备驱动的初始化\" class=\"headerlink\" title=\"2. 块设备驱动的初始化\"></a>2. 块设备驱动的初始化</h3><h4 id=\"2-1-块设备的注册过程\"><a href=\"#2-1-块设备的注册过程\" class=\"headerlink\" title=\"2.1 块设备的注册过程\"></a>2.1 块设备的注册过程</h4><p>注册一个块设备驱动，需要以下步骤：</p>\n<blockquote>\n<p>创建一个块设备 </p>\n<p>分配一个申请队列</p>\n<p>分配一个gendisk结构体</p>\n<p>设置gendisk结构体成员</p>\n<p>注册gendisk结构体</p>\n</blockquote>\n<pre class=\"mermaid\">graph TB\n    A(\"注册设备(register_blkdev)(可选)\")-->B(\"分配磁盘(alloc_disk)\")\n    B--有I/O调度-->C(\"不使用请求队列(blk_init_queue)\")-->E\n    B--无I/O调度-->D(\"使用请求队列(blk_alloc_queue)\")-->E\n    E(\"设置磁盘属性(gendisk)\")-->F(\"激活磁盘(add_disk)\")</pre>\n\n\n<ol>\n<li><p>通过register_blkdev()函数注册设备，是个可选操作；</p>\n</li>\n<li><p>使用alloc_disk()函数分配通用磁盘gendisk结构体；</p>\n</li>\n<li><p>根据是否需要I/O调度，分两种情况，一种是使用请求队列进行数据传输，一种是不使用请求队列进行数据传输；</p>\n</li>\n<li><p>初始化gendisk结构体的数据成员，包括：major、fops、queue等；</p>\n</li>\n<li><p>使用add_disk()函数激活磁盘设备，调用该函数之前要做好所有的准备工作；</p>\n</li>\n</ol>\n<p>分配一个gendisk结构体</p>\n<p>设置一个队列，将访问请求放到队列里</p>\n<p>设置gendisk结构体的属性，如：名称、容量、操作集等</p>\n<p>添加gendisk结构体</p>\n<p>另外分配一块内存空间，当做块设备，在request函数中使用memcpy访问，模仿块设备读写</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(sbull_blkdev_init);</span><br><span class=\"line\">module_exit(sbull_blkdev_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>块设备驱动程序的初始化方法在sbull_blkdev_init()函数中；</p>\n<h5 id=\"1）注册块设备\"><a href=\"#1）注册块设备\" class=\"headerlink\" title=\"1）注册块设备\"></a>1）注册块设备</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">major = register_blkdev(major, <span class=\"string\">\"sbull_blkdev\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>为块设备驱动分配一个未使用的主设备号，并在/proc/devies中添加一个入口；</p>\n<h5 id=\"2）注册请求队列\"><a href=\"#2）注册请求队列\" class=\"headerlink\" title=\"2）注册请求队列\"></a>2）注册请求队列</h5><p>注册请求队列的操作，将一个请求的操作方法与该设备相关联，通过blk_init_queue()函数实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">sbull_blkdev_request</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">DEFINE_SPINLOCK</span><span class=\"params\">(sbull_blkdev_lock)</span></span>;</span><br><span class=\"line\">sbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &amp;sbull_blkdev_lock);</span><br></pre></td></tr></table></figure>\n\n<p>blk_init_queue()函数返回请求队列request_queue，将sbull_blkdev_request()函数指针方式关联到该设备；</p>\n<p>第一个参数是函数指针，用来指定请求队列的处理函数；</p>\n<p>第二个参数是自旋锁，用来保护request_queue队列不被同时访问；</p>\n<h5 id=\"3）设置读写块大小\"><a href=\"#3）设置读写块大小\" class=\"headerlink\" title=\"3）设置读写块大小\"></a>3）设置读写块大小</h5><p>硬件执行磁盘是以扇区为单位的，而文件系统是以块为单位处理数据；通常，扇区大小为512字节，块大小为4096字节；需要将硬件支持的扇区大小和驱动程序在一次请求中能接收的最大扇区数通知块层；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_sect_size = <span class=\"number\">512</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_size = <span class=\"number\">16</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"comment\">// blk_queue_hardsect_size(blkdev_queue, my_blkdev_sect_size);</span></span><br><span class=\"line\">blk_queue_logical_block_size(sbull_blkdev_queue, sbull_blkdev_sect_size);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4）创建磁盘\"><a href=\"#4）创建磁盘\" class=\"headerlink\" title=\"4）创建磁盘\"></a>4）创建磁盘</h5><p>使用alloc_disk()函数分配一个与设备对应的磁盘gendisk结构体，并初始化其成员；需要初始化的成员有：block_device_operations、存储容量（单位是扇区）、请求队列、主设备号、磁盘名称等；设置存储容量通过set_capacity()函数来完成；</p>\n<p>调用add_disk()函数将磁盘添加到块I/O层；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sbull_blkdev_disk = alloc_disk(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(sbull_blkdev_disk-&gt;disk_name, <span class=\"string\">\"sbull_blkdev_disk\"</span>);</span><br><span class=\"line\">sbull_blkdev_disk-&gt;fops = &amp;sbull_blkdev_fops;</span><br><span class=\"line\">sbull_blkdev_disk-&gt;<span class=\"built_in\">queue</span> = sbull_blkdev_queue;</span><br><span class=\"line\">sbull_blkdev_disk-&gt;major = major;</span><br><span class=\"line\">sbull_blkdev_disk-&gt;first_minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">set_capacity(sbull_blkdev_disk, sbull_blkdev_size);</span><br><span class=\"line\"></span><br><span class=\"line\">add_disk(sbull_blkdev_disk);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>到这里，设备/dev/sbull_blkdev_disk就可以使用了，如果设备支持多个磁盘分区，会显示为/dev/sbull_blkdev_diskX，X是分区号；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># ls /dev/sbull_blkdev_disk -l</span></span><br><span class=\"line\">brw-rw----    <span class=\"number\">1</span> root     root      <span class=\"number\">253</span>,   <span class=\"number\">0</span> Oct <span class=\"number\">21</span> <span class=\"number\">08</span>:<span class=\"number\">18</span> /dev/sbull_blkdev_disk</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"5）块设备初始化实例\"><a href=\"#5）块设备初始化实例\" class=\"headerlink\" title=\"5）块设备初始化实例\"></a>5）块设备初始化实例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">block_device_operations</span> <span class=\"title\">sbull_blkdev_fops</span> = &#123;</span></span><br><span class=\"line\">    .owner = THIS_MODULE,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = sbull_blkdev_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = sbull_blkdev_release,</span><br><span class=\"line\">    .ioctl = sbull_blkdev_ioctl,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>请求处理函数，具体实现内容，后边补充；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sbull_blkdev_request</span><span class=\"params\">(struct request_queue *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s: %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">sbull_blkdev_queue</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> *<span class=\"title\">sbull_blkdev_disk</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">DEFINE_SPINLOCK</span><span class=\"params\">(sbull_blkdev_lock)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_size = <span class=\"number\">256</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sbull_blkdev_sect_size = <span class=\"number\">512</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sbull_blkdev_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    major = register_blkdev(major, <span class=\"string\">\"mcy_blk\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (major &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, register_blkdev failed, major: %d\\n\"</span>, __func__, major);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> register_blkdev_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, major: %d\\n\"</span>, __func__, major);</span><br><span class=\"line\"></span><br><span class=\"line\">    sbull_blkdev_queue = blk_init_queue(sbull_blkdev_request, &amp;sbull_blkdev_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sbull_blkdev_queue) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, blk_init_queue failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> init_queue_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sbull_blkdev_disk = alloc_disk(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sbull_blkdev_disk) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, alloc_disk failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> alloc_disk_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(sbull_blkdev_disk-&gt;disk_name, <span class=\"string\">\"sbull_blkdev_disk\"</span>);</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;fops = &amp;sbull_blkdev_fops;</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;<span class=\"built_in\">queue</span> = sbull_blkdev_queue;</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;major = major;</span><br><span class=\"line\">    sbull_blkdev_disk-&gt;first_minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set_capacity(sbull_blkdev_disk, sbull_blkdev_size * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    add_disk(sbull_blkdev_disk);</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, sbull_blkdev_disk add success!\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">alloc_disk_err:</span><br><span class=\"line\">    blk_cleanup_queue(sbull_blkdev_queue);</span><br><span class=\"line\">init_queue_err:</span><br><span class=\"line\">    unregister_blkdev(major, <span class=\"string\">\"sbull_blkdev\"</span>);</span><br><span class=\"line\">register_blkdev_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -EBUSY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-块设备的卸载过程\"><a href=\"#2-2-块设备的卸载过程\" class=\"headerlink\" title=\"2.2 块设备的卸载过程\"></a>2.2 块设备的卸载过程</h4><pre class=\"mermaid\">graph TB\n    A(\"删除gendisk(del_gendisk)\")-->\n    B(\"删除gendisk的引用(put_disk)\")-->\n    C(\"清除请求队列(blk_cleanup_queue)\")-->\n    D(\"注销块设备(unregister_blkdev)\")</pre>\n\n\n<ol>\n<li><p>使用del_gendisk()函数删除gendisk设备（磁盘）；</p>\n</li>\n<li><p>使用put_disk()函数删除gendisk设备的引用；</p>\n</li>\n<li><p>使用blk_cleanup_queue()函数清除请求队列，释放请求队列占用的资源；</p>\n</li>\n<li><p>使用unregister_blkdev()函数注销设备，并释放对设备的引用，可选操作，与register_blkdev()函数配合使用；</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sbull_blkdev_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    del_gendisk(sbull_blkdev_disk);</span><br><span class=\"line\">    put_disk(sbull_blkdev_disk);</span><br><span class=\"line\">    blk_cleanup_queue(sbull_blkdev_queue);</span><br><span class=\"line\">    unregister_blkdev(major, <span class=\"string\">\"sbull_blkdev\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(sbull_blkdev_init);</span><br><span class=\"line\">module_exit(sbull_blkdev_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">\"GPL\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"2-3-封装块设备信息\"><a href=\"#2-3-封装块设备信息\" class=\"headerlink\" title=\"2.3 封装块设备信息\"></a>2.3 封装块设备信息</h4><p>为了在一些函数中能够访问块设备驱动的一些信息（比如：请求队列，硬盘分区，硬盘尺寸等）参数，可以定义一个块设备驱动设备结构体，给每一个块设备定义一个信息描述，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sbull_dev</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> major;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"built_in\">size</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_queue</span> *<span class=\"title\">queue</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gendisk</span> *<span class=\"title\">disk</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span> lock;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_list</span> <span class=\"title\">timer</span>;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">blkdev_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">blkdev_t</span> *blkdev = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p>同时，定义了一些必要的宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SBULL_BLKDEV_SIZE   (16 * 1024 * 1024)\t<span class=\"comment\">// 指定块设备硬盘的大小为16M</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SBULL_BLKDEV_SECTOR_SIZE    (512)\t<span class=\"comment\">// 设置块设备的sector为512字节</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SBULL_BLKDEV_MAX_PARTITIONS (16)\t<span class=\"comment\">// 设置块设备最大的分区数</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这样在块设备中只需要通过blkdev指针就可以获取到设备的所有需要的参数信息；而相应的初始化操作也需要相应地修改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">blkdev_t</span>), GFP_KERNEL);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!blkdev) &#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, blkdev kmalloc failed\\n\"</span>, __func__);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> blkdev_kmalloc_err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(blkdev, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">blkdev_t</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">spin_lock_init(&amp;blkdev-&gt;lock);</span><br><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span> = blk_alloc_queue(GFP_KERNEL);</span><br><span class=\"line\">blkdev-&gt;<span class=\"built_in\">size</span> = SBULL_BLKDEV_SIZE;</span><br><span class=\"line\">blkdev-&gt;data = sbull_blkdev_data;</span><br><span class=\"line\"></span><br><span class=\"line\">blkdev-&gt;disk = alloc_disk(SBULL_BLKDEV_MAX_PARTITIONS);</span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(blkdev-&gt;disk-&gt;disk_name, SBULL_BLKDEV_NAME);</span><br><span class=\"line\">blkdev-&gt;disk-&gt;fops = &amp;sbull_blkdev_fops;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;<span class=\"built_in\">queue</span> = blkdev-&gt;<span class=\"built_in\">queue</span>;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;major = major;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;first_minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">set_capacity(blkdev-&gt;disk, SBULL_BLKDEV_SIZE / SBULL_BLKDEV_SECTOR_SIZE);</span><br><span class=\"line\">add_disk(blkdev-&gt;disk);</span><br></pre></td></tr></table></figure>\n\n<p>这个块设备的结构体信息，可以通过gendisk结构体中的private_data指针保存，也可以通过request_queue结构体中的queuedata指针保存；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span>-&gt;queuedata = blkdev;</span><br><span class=\"line\">blkdev-&gt;disk-&gt;private_data = blkdev;</span><br></pre></td></tr></table></figure>\n\n<p>在需要使用这些信息时可以通过queue-&gt;queuedata或disk-&gt;private_data指针快速获取到块设备信息；</p>\n<h3 id=\"3-队列请求\"><a href=\"#3-队列请求\" class=\"headerlink\" title=\"3. 队列请求\"></a>3. 队列请求</h3><p>这主要是由于该版本适用于2.6.29内核，从2.6.31内核开始，一些API发生变化（见linux/include/blkdev.h）；用到的几个API修改如下：</p>\n<table>\n<thead>\n<tr>\n<th>老版本内核接口</th>\n<th>新版本内核接口</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>request -&gt; sectors</td>\n<td>blk_rq_pos(request)</td>\n<td>获取请求的开始扇区</td>\n</tr>\n<tr>\n<td>request -&gt; nr_sectors</td>\n<td>blk_rq_nr_sectors(request)</td>\n<td>获取请求的扇区数</td>\n</tr>\n<tr>\n<td>elev_next_request(request)</td>\n<td>blk_fetch_request(request)</td>\n<td></td>\n</tr>\n<tr>\n<td>end_request(request, error)</td>\n<td>blk_end_request_all(request, error)</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>每个块设备，都有一个请求队列，当请求队列生成时，请求函数request()就与该队列绑定，这个操作根据有无有I/O调度，分两种方法实现；</p>\n<h4 id=\"3-1-blk-init-queue\"><a href=\"#3-1-blk-init-queue\" class=\"headerlink\" title=\"3.1 blk_init_queue\"></a>3.1 blk_init_queue</h4><p>第一种是有I/O调度类设备，通过blk_init_queue()函数完成；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// block/blk-core.c</span></span><br><span class=\"line\"><span class=\"function\">struct request_queue *<span class=\"title\">blk_init_queue</span><span class=\"params\">(request_fn_proc *rfn, <span class=\"keyword\">spinlock_t</span> *lock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> blk_init_queue_node(rfn, lock, NUMA_NO_NODE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(blk_init_queue);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>blk_init_queue()函数的调用关系：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blk_init_queue</span><br><span class=\"line\">\tblk_init_queue_node</span><br><span class=\"line\">\t\tblk_alloc_queue_node</span><br><span class=\"line\">\t\t\tkmem_cache_alloc_node</span><br><span class=\"line\">\t\t\tida_simple_get</span><br><span class=\"line\">\t\t\tbioset_create</span><br><span class=\"line\">\t\t\tbdi_init</span><br><span class=\"line\">\t\t\tpercpu_ref_init</span><br><span class=\"line\">\t\t\tblkcg_init_queue</span><br><span class=\"line\">\t\tblk_init_allocated_queue</span><br><span class=\"line\">\t\t\tblk_alloc_flush_queue</span><br><span class=\"line\">\t\t\tblk_init_rl</span><br><span class=\"line\">\t\t\tblk_queue_make_request</span><br><span class=\"line\">\t\t\televator_init</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实现方法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span> = blk_init_queue(sbull_blkdev_request, &amp;blkdev-&gt;lock);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sbull_blkdev_request</span><span class=\"params\">(struct request_queue *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> *<span class=\"title\">req</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">blkdev_t</span> *dev = q-&gt;queuedata;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sect_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sect_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *<span class=\"built_in\">buffer</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    req = blk_fetch_request(q);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (req != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        sect_pos = blk_rq_pos(req);</span><br><span class=\"line\">        sect_count = blk_rq_cur_sectors(req);</span><br><span class=\"line\">        start = sect_pos &lt;&lt; <span class=\"number\">9</span>;</span><br><span class=\"line\">        len = blk_rq_cur_bytes(req);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start + len &gt; dev-&gt;<span class=\"built_in\">size</span>) &#123;</span><br><span class=\"line\">            printk(<span class=\"string\">\"%s, bad access, block: 0x%llx, count: 0x%lx\\n\"</span>, __func__, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)sect_pos, sect_count);</span><br><span class=\"line\">            err = -EIO;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">buffer</span> = bio_data(req-&gt;bio);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">buffer</span>) &#123;</span><br><span class=\"line\">            printk(<span class=\"string\">\"%s, bio_data buffer is null\\n\"</span>, __func__);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sbull_transfer(dev, sect_pos, sect_count, <span class=\"built_in\">buffer</span>, rq_data_dir(req) == WRITE);</span><br><span class=\"line\">done:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!__blk_end_request_cur(req, err)) &#123;</span><br><span class=\"line\">            req = blk_fetch_request(q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sbull_transfer</span><span class=\"params\">(<span class=\"keyword\">blkdev_t</span> *dev, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sector, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nsect, <span class=\"keyword\">char</span> *<span class=\"built_in\">buffer</span>, <span class=\"keyword\">int</span> <span class=\"built_in\">write</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> offset = sector * SBULL_BLKDEV_SECTOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nbytes = nsect * SBULL_BLKDEV_SECTOR_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset + nbytes &gt; dev-&gt;<span class=\"built_in\">size</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, over range, size: 0x%lx, offset: 0x%lx, nbytes: 0x%lx\"</span>, __func__, dev-&gt;<span class=\"built_in\">size</span>, offset, nbytes);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dev-&gt;data + offset, <span class=\"built_in\">buffer</span>, nbytes);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(<span class=\"built_in\">buffer</span>, dev-&gt;data + offset, nbytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h4 id=\"3-2-blk-alloc-queue\"><a href=\"#3-2-blk-alloc-queue\" class=\"headerlink\" title=\"3.2 blk_alloc_queue\"></a>3.2 blk_alloc_queue</h4><p>第二种是无I/O调度类设备，通过blk_alloc_queue()函数完成；</p>\n<p>实现方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blkdev-&gt;<span class=\"built_in\">queue</span> = blk_alloc_queue(GFP_KERNEL);</span><br><span class=\"line\">blk_queue_make_request(blkdev-&gt;<span class=\"built_in\">queue</span>, sbull_blkdev_make_request);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">sbull_blkdev_make_request</span><span class=\"params\">(struct request_queue *q, struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">blkdev_t</span> *dev = q-&gt;queuedata;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> status = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = sbull_xfer_bio(dev, bio);</span><br><span class=\"line\">    bio_endio(bio);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sbull_xfer_bio</span><span class=\"params\">(<span class=\"keyword\">blkdev_t</span> *dev, struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bvec_iter</span> <span class=\"title\">iter</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio_vec</span> <span class=\"title\">bvec</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">sector_t</span> sector = bio-&gt;bi_iter.bi_sector;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *<span class=\"built_in\">buffer</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    bio_for_each_segment(bvec, bio, iter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">buffer</span> = __bio_kmap_atomic(bio, iter);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">buffer</span>) &#123;</span><br><span class=\"line\">            printk(<span class=\"string\">\"%s, buffer is null\\n\"</span>, __func__);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sbull_transfer(dev, sector, bio_cur_bytes(bio)&gt;&gt;<span class=\"number\">9</span>, <span class=\"built_in\">buffer</span>, bio_data_dir(bio) == WRITE);</span><br><span class=\"line\">        sector += bio_cur_bytes(bio)&gt;&gt;<span class=\"number\">9</span>;</span><br><span class=\"line\">        __bio_kunmap_atomic(bio);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blk_queue_max_hw_sectors(blkdev-&gt;<span class=\"built_in\">queue</span>, <span class=\"number\">255</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>blk_queue_max_hw_sectors()函数，用来通知通用块层和I/O调度器，该请求队列的每个请求中能够包含的最大扇区数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blk_queue_logical_block_size(blkdev-&gt;<span class=\"built_in\">queue</span>, sbull_sect_size);</span><br></pre></td></tr></table></figure>\n\n\n<p>blk_queue_logical_block_size()函数，用于告知该请求队列的逻辑块大小；</p>\n<p>bio的一些接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/fs.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">bio_data_dir</span><span class=\"params\">(struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> op_is_write(bio_op(bio)) ? WRITE : READ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_BLOCK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">op_is_write</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> op)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> op == REQ_OP_READ ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>return：READ/WRITE</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bio.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BIO_MAX_PAGES       256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_prio(bio)           (bio)-&gt;bi_ioprio</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_set_prio(bio, prio)     ((bio)-&gt;bi_ioprio = prio)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_iovec(bio, iter)               \\</span></span><br><span class=\"line\">    bvec_iter_bvec((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_page(bio, iter)                \\</span></span><br><span class=\"line\">    bvec_iter_page((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_len(bio, iter)                 \\</span></span><br><span class=\"line\">    bvec_iter_len((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iter_offset(bio, iter)              \\</span></span><br><span class=\"line\">    bvec_iter_offset((bio)-&gt;bi_io_vec, (iter))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_page(bio)       bio_iter_page((bio), (bio)-&gt;bi_iter)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_offset(bio)     bio_iter_offset((bio), (bio)-&gt;bi_iter)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_iovec(bio)      bio_iter_iovec((bio), (bio)-&gt;bi_iter)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_multiple_segments(bio)              \\</span></span><br><span class=\"line\">    ((bio)-&gt;bi_iter.bi_size != bio_iovec(bio).bv_len)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_sectors(bio)    ((bio)-&gt;bi_iter.bi_size &gt;&gt; 9)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> bio_end_sector(bio) ((bio)-&gt;bi_iter.bi_sector + bio_sectors((bio)))</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bio.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">bio_cur_bytes</span><span class=\"params\">(struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bio_has_data(bio))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bio_iovec(bio).bv_len;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">/* dataless requests such as discard */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bio-&gt;bi_iter.bi_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数据缓冲区的内核虚拟地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> *<span class=\"title\">bio_data</span><span class=\"params\">(struct bio *bio)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bio_has_data(bio))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> page_address(bio_page(bio)) + bio_offset(bio);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/bio.h</span></span><br><span class=\"line\"><span class=\"comment\">// 获取给定bio的第i个缓冲区的虚拟地址</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __bio_kmap_atomic(bio, iter)                \\</span></span><br><span class=\"line\">    (kmap_atomic(bio_iter_iovec((bio), (iter)).bv_page) +   \\</span><br><span class=\"line\">        bio_iter_iovec((bio), (iter)).bv_offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放缓冲区的虚拟地址</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __bio_kunmap_atomic(addr)   kunmap_atomic(addr)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rq_data_dir(rq)     (op_is_write(req_op(rq)) ? WRITE : READ)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REQ_OP_SHIFT (8 * sizeof(u64) - REQ_OP_BITS)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> req_op(req)  ((req)-&gt;cmd_flags &gt;&gt; REQ_OP_SHIFT)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// include/linux/blk_types.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REQ_OP_BITS 3</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/blkdev.h</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_pos()         : the current sector</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_bytes()       : bytes left in the entire request</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_cur_bytes()       : bytes left in the current segment</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_err_bytes()       : bytes left till the next error boundary</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_sectors()     : sectors left in the entire request</span></span><br><span class=\"line\"><span class=\"comment\"> * blk_rq_cur_sectors()     : sectors left in the current segment</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">sector_t</span> <span class=\"title\">blk_rq_pos</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rq-&gt;__sector;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rq-&gt;__data_len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_cur_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rq-&gt;bio ? bio_cur_bytes(rq-&gt;bio) : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_sectors</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> blk_rq_bytes(rq) &gt;&gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_cur_sectors</span><span class=\"params\">(<span class=\"keyword\">const</span> struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> blk_rq_cur_bytes(rq) &gt;&gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">blk_rq_count_bios</span><span class=\"params\">(struct request *rq)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> nr_bios = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bio</span> *<span class=\"title\">bio</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    __rq_for_each_bio(bio, rq)</span><br><span class=\"line\">        nr_bios++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nr_bios;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3-3-两种队列请求的区别\"><a href=\"#3-3-两种队列请求的区别\" class=\"headerlink\" title=\"3.3 两种队列请求的区别\"></a>3.3 两种队列请求的区别</h4><h4 id=\"3-4-I-O调度器\"><a href=\"#3-4-I-O调度器\" class=\"headerlink\" title=\"3.4 I/O调度器\"></a>3.4 I/O调度器</h4><p>I/O调度器可以通过合并请求、重排块设备操作顺序等方式提高块设备访问的顺序；</p>\n<p>I/O调度器四种</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># cat /sys/block/sbull_disk/queue/scheduler</span></span><br><span class=\"line\">noop [cfq]</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>对于大多数基于物理磁盘的块设备驱动，使用适合的I/O调度器能提高性能；</p>\n<p>无I/O调度器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># cat /sys/block/sbull_disk/queue/scheduler</span></span><br><span class=\"line\">none</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h3 id=\"8-测试验证\"><a href=\"#8-测试验证\" class=\"headerlink\" title=\"8. 测试验证\"></a>8. 测试验证</h3><p>测试步骤：</p>\n<blockquote>\n<p>加载驱动：insmod ramblock.ko</p>\n<p>格式化：mkdosfs /dev/ramblock</p>\n<p>挂载：mount /dev/ramblock /mnt</p>\n<p>读写文件：cd /mnt，创建文件</p>\n<p>卸载：umount /mnt</p>\n<p>cat /dev/ramblock &gt; /mnt/ramblock.bin</p>\n<p>在PC上查看/mnt/ramblock.bin，sudo mount -o loop ramblock.bin /mnt</p>\n</blockquote>\n<h3 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9. 总结\"></a>9. 总结</h3><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.cnblogs.com/big-devil/p/8590007.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/big-devil/p/8590007.html</a></p>\n<p><a href=\"https://www.cnblogs.com/xiaojiang1025/p/6500557.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaojiang1025/p/6500557.html</a></p>\n<p><a href=\"#目录\">回到目录</a></p>"},{"title":"Linux设备驱动模型","date":"2020-05-10T13:31:28.000Z","_content":"\n\n\n\n\n未完成\n\nLinux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；\n\n<!--more-->\n\n\n\n\n#### 目录\n\n\n[TOC]\n\n\n#### 0. 简介\n\nLinux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；\n\n\nLinux设备驱动模型中的总线，既可以是实际物理总线的抽象（如：PCI总线、I2C总线、USB总线），也可以是虚拟总线，一个符合Linux设备驱动模型的设备和驱动都必须挂接在一根总线上，无论是实际存在的总线还是系统模拟的总线；\n\n\nLinux设备模型中，最底层每一个设备都用一个device结构的实例来表示；而驱动是使总线上的设备能够完成一些功能；系统中有很多种总线，如：PCI总线、I2C总线、USB总线、scsi总线等；\n\n\n```mermaid\ngraph LR\n\tdriver_init(driver_init)-->\n\tbuses_init(buses_init)\n```\n\n\nbuses_init()函数在sysfs文件系统的根目录下建立一个bus目录，即/sys/bus，是系统中后续注册总线的连接点；\n\n\n\n\nLinux设备模型中一组很重要的概念：总线、设备、驱动，即：bus、device、driver；分别对应数据结构struct bus_type，struct device，struct device_driver；\n\n| 名称 | 类型   | 对应的数据结构       | 代码文件              |\n| ---- | ------ | -------------------- | --------------------- |\n| 总线 | bus    | struct bus_type      | drivers/base/bus.c    |\n| 设备 | device | struct device        | drivers/base/core.c   |\n| 驱动 | driver | struct device_driver | drivers/base/driver.c |\n\n\n\n\n```mermaid\ngraph TB\n\tBus(bus)-->Device(device)\n\tBus-->Driver(device_driver)\n```\n\n\nLinux设备驱动模型中，总线、设备、驱动都有对于的属性信息；\n\n| 类型   | 属性数据结构     | 设置属性方法             |\n| ------ | ---------------- | ------------------------ |\n| bus    | bus_attribute    | BUS_ATTR()               |\n| device | device_attribute | DEVICE_ATTR()            |\n| driver | driver_attribute | 手动设置driver_attribute |\n\n\n\nLinux系统在启动时的初始化阶段，通过在driver_init()中调用buses_init()函数，完成所有总线的最初操作，创建出bus的祖先；\n\n\n```mermaid\ngraph TB\n\tdriver_init(driver_init)\n\t-->buses_init(buses_init)\n```\n\n\n```c\n// drivers/base/bus.c\nstatic struct kset *bus_kset;\nint __init buses_init(void)\n{\n    bus_kset = kset_create_and_add(\"bus\", &bus_uevent_ops, NULL);\n    system_kset = kset_create_and_add(\"system\", NULL, &devices_kset->kobj);\n\n    return 0;\n}\n```\n\n\nbuses_init()函数创建一个名为\"bus\"的kset，并将其加入到sysfs文件系统树中，在sysfs中的根目录创建bus，即/sys/bus目录；\n\n\n\n\n#### 1. 总线(bus)\n\n\n内核用struct bus_type结构体来描述总线信息；\n\n\n```c\n// include/linux/device.h\nstruct bus_type {\n    const char      *name;\t// 总线名称，在/sys/bus下出现\n    const char      *dev_name;\n    const struct attribute_group **bus_groups;\n    const struct attribute_group **dev_groups;\n    const struct attribute_group **drv_groups;\n\t......\n    int (*match)(struct device *dev, struct device_driver *drv);\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n\t......\n    struct subsys_private *p;\t// 用来管理bus中设备和驱动关系的结构体\n};\n```\n\n\n\n\n总线用struct subsys_private结构体来管理总线中设备和驱动的关系；\n\n\n```c\ndrivers/base/base.h\nstruct subsys_private {\n    struct kset subsys;\t\t// 表示bus所在的子系统\n    struct kset *devices_kset;\t\t// 表示bus上所有设备的集合\n    struct list_head interfaces;\n    struct mutex mutex;\n\n    struct kset *drivers_kset;\t\t// 表示bus上所有驱动的集合\n    struct klist klist_devices;\t\t// 表示bus上所有设备的链表\n    struct klist klist_drivers;\t\t// 表示bus上所有驱动的链表\n    struct blocking_notifier_head bus_notifier;\n    unsigned int drivers_autoprobe:1;\n    struct bus_type *bus;\n\n    struct kset glue_dirs;\n    struct class *class;\n};\n```\n\n\nstruct kset subsys：表示bus所在的子系统\n\n\nunsigned int drivers_autoprobe:1  表示向系统总线中注册设备或驱动时，是否进行设备和驱动的绑定操作；\n\n\nstruct kset *devices_kset和struct kset *drivers_kset分别表示bus上所有设备和驱动的集合；是在向系统注册当前新总线时动态生成的容纳该总线上所有驱动和设备的kset；\n\n\nstruct klist klist_devices和struct klist klist_drivers分别表示该总线上所有设备和驱动的链表；两个klist成员以链表的形式将该总线上所有的驱动与设备链接到一起；总线、设备、驱动的关系如下图所示：\n\n\n![总线设备驱动之间的关系](Linux设备驱动模型/总线设备驱动之间的关系.PNG)\n\n\n\n\n##### 1.1 总线的注册\n\n\n```c\n// drivers/base/bus.c\nint bus_register(struct bus_type *bus);\n```\n\n\nbus_register()函数用来注册一个bus总线子系统，可能会失败，必须检查返回值；注册成功后，可以在/sys/bus/目录下看到该总线；之后就可以向总线中添加设备了；\n\n\n```c\n// drivers/base/bus.c\nint bus_register(struct bus_type *bus)\n{\n    struct subsys_private *priv;\n\n    priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);\n    priv->bus = bus;\n    bus->p = priv;\n\n    BLOCKING_INIT_NOTIFIER_HEAD(&priv->bus_notifier);\n\n    retval = kobject_set_name(&priv->subsys.kobj, \"%s\", bus->name);\t// 为bus设定名字\n\n    priv->subsys.kobj.kset = bus_kset;\n    priv->subsys.kobj.ktype = &bus_ktype;\n    priv->drivers_autoprobe = 1;\n    retval = kset_register(&priv->subsys);\t// 在/sys/bus目录下为当前注册的bus生成目录\n\n    retval = bus_create_file(bus, &bus_attr_uevent);\t// 生成bus的属性文件\n    priv->devices_kset = kset_create_and_add(\"devices\", NULL,\n                         &priv->subsys.kobj);\t// 为bus生成容纳设备的kset容器\n    priv->drivers_kset = kset_create_and_add(\"drivers\", NULL,\n                         &priv->subsys.kobj);\t// // 为bus生成容纳驱动的kset容器\n\n    klist_init(&priv->klist_devices, klist_devices_get, klist_devices_put);\n    klist_init(&priv->klist_drivers, NULL, NULL);\t// 初始化bus上的设备和驱动链表\n\n    retval = add_probe_files(bus);\t// 为bus增加probe相关的属性文件\n    retval = bus_add_groups(bus, bus->bus_groups);\n\n    return 0;\n}\nEXPORT_SYMBOL_GPL(bus_register); \n```\n\n\nbus_register()函数，分配一个subsys_private结构体，通过kobject_set_name()函数为bus所在的内核对象设定名称，该名称在sysfs文件系统树中显示，再完成对subsys_private结构体成员参数的初始化操作，同时在创建了devices和drivers两个属性文件夹，/sys/bus/devices和/sys/bus/drivers；\n\n\nkset_register()函数将当前操作的bus所对应的kset加入到sysfs文件系统树中；\n\n\nbus_create_file()函数为bus创建一个属性文件；\n\n\nkset_create_and_add()函数生成一个kset对象，并将其加入到sysfs文件系统树中；parent参数为&priv->subsys.kobj，将在当前正在向系统注册的新bus目录下生成两个kset目录，对应新bus的devices和drivers，即/sys/bus/bus_name/devices和/sys/bus/bus_name/drivers；\n\n\n举例：通过bus_register()函数注册一个新的bus1总线，如下图所示：\n\n\n![bus_register函数注册bus1总线时的层次关系](Linux设备驱动模型/bus_register函数注册bus1总线时的层次关系.PNG)\n\n\n图中虚线部分，是将bus1总线通过bus_register()函数注册进系统时的层次结构：\n\n\n首先生成一个表示bus1的kset对象，并加入到sysfs文件系统中，该kset的parent内核对象为buses_init()函数中产生的bus_kset；\n\n\n其次，bus_register()函数，通过kset_create_and_add()函数，生成连接到bus1总线上的devices_kset和drivers_kset的集合，对应在sysfs系统中，会在/sys/bus/bus1目录下生成devices和drivers两个目录；\n\n\n最后，bus_register()函数，通过bus_create_file()函数，为bus1总线在/sys/bus/bus1目录下生成一些属性文件；\n\n\n属性文件实际上向用户空间提供了一些接口，用户程序可以通过这些属性文件获取或者设置属性内核对象的属性；\n\n\n\n\n##### 1.2 总线的注销\n\n\n```c\n// drivers/base/bus.c\nvoid bus_unregister(struct bus_type *bus);\n```\n\n\n\n\n```c\n// drivers/base/bus.c\nvoid bus_unregister(struct bus_type *bus)\n{\n    pr_debug(\"bus: '%s': unregistering\\n\", bus->name);\n    if (bus->dev_root)\n        device_unregister(bus->dev_root);\n    bus_remove_groups(bus, bus->bus_groups);\n    remove_probe_files(bus);\n    kset_unregister(bus->p->drivers_kset);\n    kset_unregister(bus->p->devices_kset);\n    bus_remove_file(bus, &bus_attr_uevent);\n    kset_unregister(&bus->p->subsys);\n}\nEXPORT_SYMBOL_GPL(bus_unregister);\n```\n\n\n\n\n\n\n##### 1.3 总线方法\n\n\n在struct bus_type结构体中定义了一些方法；\n\n\n```c\nint (*match)(struct device *dev, struct device_driver *drv);\n```\n\n\nmatch方法：当总线上添加新设备或新驱动程序时，会多次调用match方法，将device和device_driver进行匹配，如果匹配成功，说明指定的驱动程序能够处理指定的设备，match方法返回非零值；\n\n\n\n\n创建一个名为ldd的虚拟总线为例；\n\n\n\n\n```c\nstruct bus_type ldd_bus_type = {\n    .name = \"ldd\",\n    .match = ldd_match,\n};\n```\n\n\n\n\n```c\nret = bus_register(&ldd_bus_type);\nif (ret) {\n    printk(\"%s, bus_register failed\\n\", __func__);\n    return -1;\n}\n```\n\n\n\n\n\n\n```c\nbus_unregister(&ldd_bus_type);\n```\n\n\n\n\n\n\n\n\n在lddbus中添加一个简单的match方法，只是简单地比较设备和驱动程序的名字；在真实的总线驱动中，match方法可能会进行更加复杂的比较；\n\n\n```c\nint ldd_match(struct device *dev, struct device_driver *drv)\n{\n    return (strcmp(dev->kobj.name, drv->name) == 0);\n}\n```\n\n\n\n\n\n\n\n\n\n\n验证\n\n\n```c\n# lsmod\nldd_bus 16384 0 - Live 0xffff000000c90000 (O)\n```\n\n\n\n\n\n\n```c\n# ls /sys/bus/ldd/\ndevices            drivers_autoprobe  uevent\ndrivers            drivers_probe\n```\n\n\n\n\n\n\n\n\n##### 1.4 总线属性\n\n\n总线属性表示该总线的特有信息和配置，通过sysfs文件系统为总线生成属性文件，用户空间可以通过该属性文件接口，获取或者设置总线的属性；\n\n\n总线属性用struct bus_attribute结构体表示；\n\n\n```c\n// include/linux/device.h\nstruct bus_attribute {\n    struct attribute    attr;\n    ssize_t (*show)(struct bus_type *bus, char *buf);\n    ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);\n};\n```\n\n\nshow和store用来获取和设置总线的属性信息；\n\n\n```c\n// include/linux/sysfs.h\nstruct attribute {\n    const char      *name;\n    umode_t         mode;\n};\n```\n\n\n为总线定义属性可以使用BUS_ATTR()宏定义；\n\n\n```c\n// include/linux/device.h\n#define BUS_ATTR(_name, _mode, _show, _store)   \\\n    struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)\n```\n\n\n\n\n```c\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) {               \\\n    .attr = {.name = __stringify(_name),                \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \\\n    .show   = _show,                        \\\n    .store  = _store,                       \\\n}\n```\n\n\nBUS_ATTR()宏，定义一个以bus_attr_开头的总线属性，生成总线属性文件需要使用bus_create_file()函数来完成；\n\n\n```c\n// drivers/base/bus.c\nint bus_create_file(struct bus_type *bus, struct bus_attribute *attr)\n{\n    int error;\n\n    if (bus_get(bus)) {\n        error = sysfs_create_file(&bus->p->subsys.kobj, &attr->attr);\n        bus_put(bus);\n    } else\n        error = -EINVAL;\n    return error;\n}\nEXPORT_SYMBOL_GPL(bus_create_file);\n```\n\n\n\n\n\n\n\n\n\n\n```c\n// drivers/base/bus.c\nstatic BUS_ATTR(drivers_autoprobe, S_IWUSR | S_IRUGO,\n        show_drivers_autoprobe, store_drivers_autoprobe);\n\nstatic ssize_t show_drivers_autoprobe(struct bus_type *bus, char *buf)\n{\n    return sprintf(buf, \"%d\\n\", bus->p->drivers_autoprobe);\n}\n\nstatic ssize_t store_drivers_autoprobe(struct bus_type *bus,\n                       const char *buf, size_t count)\n{\n    if (buf[0] == '0')\n        bus->p->drivers_autoprobe = 0;\n    else\n        bus->p->drivers_autoprobe = 1;\n    return count;\n}\n```\n\n\n\n\n\n\n自己实现一个属性文件如下：\n\n\n```c\nssize_t ldd_show_bus_version(struct bus_type *bus, char *buf)\n{\n    return snprintf(buf, PAGE_SIZE, \"%s\\n\", VERSION);\n}\n\nBUS_ATTR(version, S_IRUGO, ldd_show_bus_version, NULL);\nret = bus_create_file(&ldd_bus_type, &bus_attr_version);\n```\n\n\n之后可以看到/sys/bus/ldd/version属性；\n\n\n\n\n#### 2. 设备(device)\n\n\n设备代表真实的具体的物理器件，\n\n\n总线实际上也是一个设备，因此也要以设备形式被单独注册；这个ldd总线是一个顶层总线，因此parent和bus成员是NULL，总线名字是ldd；\n\n\n\n\n```c\n// include/linux/device.h\nstruct device {\n    struct device       *parent;\n    struct device_private   *p;\n    struct kobject kobj;\n    const char      *init_name; /* initial name of the device */\n    const struct device_type *type;\n    struct bus_type *bus;       /* type of bus device is on */\n    struct device_driver *driver;   /* which driver has allocated this device */\n    void        *driver_data;   /* Driver data, set and get with\n                       dev_set/get_drvdata */\n    struct device_node  *of_node; /* associated device tree node */\n    void    (*release)(struct device *dev);\n    ......\n};\n```\n\n\n\n\n\n\n##### 2.1 设备注册\n\n\n```c\n// drivers/base/core.c\nint device_register(struct device *dev)\n{\n    device_initialize(dev);\t\t// 初始化device\n    return device_add(dev);\t\t// 将device添加到系统中\n}\nEXPORT_SYMBOL_GPL(device_register);\n```\n\n\ndevice_register()函数用来注册设备，可能会失败，必须检查返回值；注册成功后，可以在/sys/devices目录下看到该设备；以后添加到改总线上的任何设备都可以在/sys/devices/ldd目录下显示；\n\n\n创建一个名为ldd的设备为例；\n\n\n```c\nstruct device ldd_bus_dev = {\n    .init_name = \"ldd\",\n};\n```\n\n\n\n\n```c\nret = device_register(&ldd_bus_dev);\nif (ret) {\n    printk(\"%s, device_register failed\\n\", __func__);\n    return -1;\n}\n```\n\n\n\n\n##### 2.2 设备注销\n\n\n```c\n// drivers/base/core.c\nvoid device_unregister(struct device *dev)\n{\n    pr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\n    device_del(dev);\t// 从子系统中删除\n    put_device(dev);\t// 减少引用计数\n}\nEXPORT_SYMBOL_GPL(device_unregister);\n```\n\n\n用法：\n\n\n```c\ndevice_unregister(&ldd_bus_dev);\n```\n\n\n\n\n##### 2.3 设备属性\n\n\n\n\n```c\n// include/linux/device.h\nstruct device_attribute {\n    struct attribute    attr;\n    ssize_t (*show)(struct device *dev, struct device_attribute *attr,\n            char *buf);\n    ssize_t (*store)(struct device *dev, struct device_attribute *attr,\n             const char *buf, size_t count);\n};\n```\n\n\n\n\n```c\n// include/linux/device.h\n#define DEVICE_ATTR(_name, _mode, _show, _store) \\\n    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)\n```\n\n\n\n\n```c\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) {               \\\n    .attr = {.name = __stringify(_name),                \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \\\n    .show   = _show,                        \\\n    .store  = _store,                       \\\n}\n```\n\n\n\n\n\n\n```c\n// drivers/base/core.c\nint device_create_file(struct device *dev,\n                       const struct device_attribute *attr);\nvoid device_remove_file(struct device *dev,\n                        const struct device_attribute *attr);\n```\n\n\n\n\n\n\n##### 2.4 设备结构的封装\n\n\n在device结构体中已经包含了设备模型核心，用来模拟系统的信息；对于大多数系统来说，还需要包含一些系统其它的信息，因此需要对封装一个ldd_device，包含device结构体以及其它一些重要的信息；在ldd总线的每一个设备都需要使用ldd_device结构体来抽象；\n\n\n```c\nstruct ldd_device {\n    char *name;\n    struct ldd_driver *driver;\n    struct device dev;\n};\n\n#define to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))\n```\n\n\nldd_device结构体可以作为ldd总线上设备的一个抽象，包含一个device结构体，一个指向驱动程序的结构体指针；还可以根据需要添加信息，如：供应商信息、设备模型、设备配置、使用的资源等；\n\n\nto_ldd_device()宏定义，用来方便地用device结构体找到ldd_device结构体；\n\n\n\n\nldd总线下的设备注册功能可以使用以下封装的ldd_device_register()函数来实现；\n\n\n```c\nint ldd_device_register(struct ldd_device *ldddev)\n{\n    ldddev->dev.bus = &ldd_bus_type;\n    ldddev->dev.parent = &ldd_bus;\n    ldddev->dev.release = ldd_dev_release;\n    strncpy(ldddev->dev.kobj.name, ldddev->name, strlen(ldddev->name) + 1);\n\n    return device_register(&ldddev->dev);\n}\nEXPORT_SYMBOL(ldd_device_register);\n```\n\n\nldd_device_register()函数简单地初始化了ldd_device结构体中的device结构体成员，并向驱动程序核心注册该device结构体设备；\n\n\n\n\n##### 2.5 举例\n\n\n\n\n#### 3. 设备驱动(device_driver)\n\n\n\n\n设备驱动用device_driver结构体来表示：\n\n\n```c\n// include/linux/device.h\nstruct device_driver {\n    const char      *name;\t// 驱动程序的名字\n    struct bus_type     *bus;\n\n    const struct of_device_id   *of_match_table;\n    const struct acpi_device_id *acpi_match_table;\n\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n\t......\n    struct driver_private *p;\n};\n```\n\n\nname：驱动程序的名字，会显示在sysfs中\n\n\nbus：该驱动程序的总线类型\n\n\n\n\n##### 3.1 设备驱动注册\n\n\n\n\n```c\n// drivers/base/driver.c\nint driver_register(struct device_driver *drv);\n```\n\n\n\n\n##### 3.2 设备驱动注销\n\n\n```c\n// drivers/base/driver.c\nvoid driver_unregister(struct device_driver *drv);\n```\n\n\n\n\n\n\n##### 3.3 设备驱动属性\n\n\n\n\n```c\n// include/linux/device.h\nstruct driver_attribute {\n    struct attribute attr;\n    ssize_t (*show)(struct device_driver *driver, char *buf);\n    ssize_t (*store)(struct device_driver *driver, const char *buf,\n             size_t count);\n};\n\n#define DRIVER_ATTR(_name, _mode, _show, _store) \\\n    struct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store)\n\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) {               \\\n    .attr = {.name = __stringify(_name),                \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \\\n    .show   = _show,                        \\\n    .store  = _store,                       \\\n}\n```\n\n\n属性文件的创建和删除：\n\n\n```c\n// drivers/base/driver.c\nint driver_create_file(struct device_driver *drv,\n               const struct driver_attribute *attr);\nvoid driver_remove_file(struct device_driver *drv,\n            const struct driver_attribute *attr);\n```\n\n\n\n\n##### 3.4 驱动程序结构的封装\n\n\n对于大多数驱动程序来说，device_driver结构通常被包含在高层和总线相关的结构中，因此对于ldd子系统需要定义一个ldd_driver结构，包含device_driver结构体和一些需要的信息；在ldd总线的每一个驱动都需要使用ldd_driver结构体来抽象；\n\n\n```c\nstruct ldd_driver {\n    char *version;\n    struct module *module;\n    struct device_driver driver;\n    struct driver_attribute version_attr;\n};\n\n#define to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))\n```\n\n\nldd_driver结构体可以作为ldd总线上设备驱动的一个抽象，包含一个device_driver结构体；还可以根据需要添加一些别的信息；\n\n\nto_ldd_driver()宏定义，用来方便地用device_driver结构体找到ldd_driver结构体；\n\n\n\n\nldd总线下的设备驱动注册功能可以使用以下封装的ldd_driver_register()函数来实现；\n\n\n```c\nint ldd_driver_register(struct ldd_driver *driver)\n{\n    int ret = -1;\n\n    driver->driver.bus = &ldd_bus_type;\n    ret = driver_register(&driver->driver);\n    if (ret) {\n        printk(\"%s, driver_register failed\\n\", __func__);\n        return ret;\n    }\n    driver->version_attr.attr.name = \"version\";\n    driver->version_attr.attr.mode = S_IRUGO;\n    driver->version_attr.show = show_version;\n    driver->version_attr.store = NULL;\n\n    return driver_create_file(&driver->driver, &driver->version_attr);\n}\nEXPORT_SYMBOL(ldd_driver_register);\n```\n\n\nldd_driver_register()函数简单地初始化了ldd_driver结构体中的device_driver结构体成员，并向驱动程序核心注册该device_driver结构体设备驱动，同时还设置了驱动的版本号属性信息；因为驱动的版本号信息是在系统运行时建立的，所以必须手动设置driver_attribute结构体，而不能使用DRIVER_ATTR()宏；\n\n\n```c\nstatic ssize_t show_version(struct device_driver *driver, char *buf)\n{\n    struct ldd_driver *ldd_drv = to_ldd_driver(driver);\n\n    sprintf(buf, \"%s\\n\", ldd_drv->version);\n    return strlen(buf);\n}\n```\n\n\n\n\n##### 3.5 举例\n\n\n\n\n\n\n#### 4. 实例\n\n\n驱动工程师在驱动开发过程中，都是使用内核中已经封装好的总线，以及设备驱动模型接口，很少会需要添加一条总线，本节为了验证创建总线的过程，创建一条简单的总线ldd，用做测试；\n\n\n\n\n##### 4.1 注册总线 \n\n\n```c\nint ldd_bus_init(void)\n{\n    int ret = -1;\n\n    ret = bus_register(&ldd_bus_type);\n    if (ret) {\n        printk(\"%s, bus_register failed\\n\", __func__);\n        return -1;\n    }\n\n    ret = bus_create_file(&ldd_bus_type, &bus_attr_version);\n    if (ret) {\n        printk(\"%s, bus_create_file failed\\n\", __func__);\n        return -1;\n    }\n\n    ret = device_register(&ldd_bus_dev);\n    if (ret) {\n        printk(\"%s, device_register failed\\n\", __func__);\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid ldd_bus_exit(void)\n{\n    device_unregister(&ldd_bus_dev);\n    bus_remove_file(&ldd_bus_type, &bus_attr_version);\n    bus_unregister(&ldd_bus_type);\n}\n\nmodule_init(ldd_bus_init);\nmodule_exit(ldd_bus_exit);\nMODULE_LICENSE(\"GPL\");\n```\n\n\n\n\n\n\n```c\nssize_t ldd_show_bus_version(struct bus_type *bus, char *buf)\n{\n    return snprintf(buf, PAGE_SIZE, \"%s\\n\", VERSION);\n}\n\nBUS_ATTR(version, S_IRUGO, ldd_show_bus_version, NULL);\n\nstruct device ldd_bus_dev = {\n    .init_name = \"ldd\",\n};\n\nint ldd_match(struct device *dev, struct device_driver *drv)\n{\n    return (strcmp(dev->kobj.name, drv->name) == 0);\n}\n\nstruct bus_type ldd_bus_type = {\n    .name = \"ldd\",\n    .match = ldd_match,\n};\nEXPORT_SYMBOL(ldd_bus_type);\n```\n\n\n\n\n##### 4.2 封装设备接口\n\n\n\n\n```c\n//===================================\n\nvoid ldd_bus_release(struct device *dev)\n{\n    printk(\"%s, %d\\n\", __func__, __LINE__);\n}\n\nstruct device ldd_bus = {\n    .init_name = \"ldd\",\n    .release = ldd_bus_release,\n};\n\nstruct ldd_device {\n    char *name;\n    struct ldd_driver *driver;\n    struct device dev;\n};\n\n#define to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))\n\nvoid ldd_dev_release(struct device *dev)\n{\n    printk(\"%s, %d\\n\", __func__, __LINE__);\n}\n\nint ldd_device_register(struct ldd_device *ldddev)\n{\n    ldddev->dev.bus = &ldd_bus_type;\n    ldddev->dev.parent = &ldd_bus;\n    ldddev->dev.release = ldd_dev_release;\n    strncpy(ldddev->dev.kobj.name, ldddev->name, strlen(ldddev->name) + 1);\n\n    return device_register(&ldddev->dev);\n}\nEXPORT_SYMBOL(ldd_device_register);\n\n//===================================\n```\n\n\n\n\n##### 4.3 封装驱动接口\n\n\n```c\nstruct ldd_driver {\n    char *version;\n    struct module *module;\n    struct device_driver driver;\n    struct driver_attribute version_attr;\n};\n\n#define to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))\n\nstatic ssize_t show_version(struct device_driver *driver, char *buf)\n{\n    struct ldd_driver *ldd_drv = to_ldd_driver(driver);\n\n    sprintf(buf, \"%s\\n\", ldd_drv->version);\n    return strlen(buf);\n}\n\nint ldd_driver_register(struct ldd_driver *driver)\n{\n    int ret = -1;\n\n    driver->driver.bus = &ldd_bus_type;\n    ret = driver_register(&driver->driver);\n    if (ret) {\n        printk(\"%s, driver_register failed\\n\", __func__);\n        return ret;\n    }\n    driver->version_attr.attr.name = \"version\";\n    //driver->version_attr.attr.owner = driver->module;\n    driver->version_attr.attr.mode = S_IRUGO;\n    driver->version_attr.show = show_version;\n    driver->version_attr.store = NULL;\n\n    return driver_create_file(&driver->driver, &driver->version_attr);\n}\nEXPORT_SYMBOL(ldd_driver_register);\n```\n\n\n\n\n\n\n##### 4.4 添加设备和驱动\n\n\n\n\n##### 4.5 测试\n\n\n\n\n#### 5. 总结\n\n\n\n\n\n\n#### 6. 参考资料\n\n\n《Linux设备驱动程序》\n\n\n《深入Linux设备驱动程序内核机制》\n\n\n\n\n\n[回到目录](!目录)\n\n\n\n","source":"_posts/Linux设备驱动模型.md","raw":"---\ntitle: Linux设备驱动模型\ndate: 2020-05-10 21:31:28\ntags: Driver\n---\n\n\n\n\n\n未完成\n\nLinux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；\n\n<!--more-->\n\n\n\n\n#### 目录\n\n\n[TOC]\n\n\n#### 0. 简介\n\nLinux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；\n\n\nLinux设备驱动模型中的总线，既可以是实际物理总线的抽象（如：PCI总线、I2C总线、USB总线），也可以是虚拟总线，一个符合Linux设备驱动模型的设备和驱动都必须挂接在一根总线上，无论是实际存在的总线还是系统模拟的总线；\n\n\nLinux设备模型中，最底层每一个设备都用一个device结构的实例来表示；而驱动是使总线上的设备能够完成一些功能；系统中有很多种总线，如：PCI总线、I2C总线、USB总线、scsi总线等；\n\n\n```mermaid\ngraph LR\n\tdriver_init(driver_init)-->\n\tbuses_init(buses_init)\n```\n\n\nbuses_init()函数在sysfs文件系统的根目录下建立一个bus目录，即/sys/bus，是系统中后续注册总线的连接点；\n\n\n\n\nLinux设备模型中一组很重要的概念：总线、设备、驱动，即：bus、device、driver；分别对应数据结构struct bus_type，struct device，struct device_driver；\n\n| 名称 | 类型   | 对应的数据结构       | 代码文件              |\n| ---- | ------ | -------------------- | --------------------- |\n| 总线 | bus    | struct bus_type      | drivers/base/bus.c    |\n| 设备 | device | struct device        | drivers/base/core.c   |\n| 驱动 | driver | struct device_driver | drivers/base/driver.c |\n\n\n\n\n```mermaid\ngraph TB\n\tBus(bus)-->Device(device)\n\tBus-->Driver(device_driver)\n```\n\n\nLinux设备驱动模型中，总线、设备、驱动都有对于的属性信息；\n\n| 类型   | 属性数据结构     | 设置属性方法             |\n| ------ | ---------------- | ------------------------ |\n| bus    | bus_attribute    | BUS_ATTR()               |\n| device | device_attribute | DEVICE_ATTR()            |\n| driver | driver_attribute | 手动设置driver_attribute |\n\n\n\nLinux系统在启动时的初始化阶段，通过在driver_init()中调用buses_init()函数，完成所有总线的最初操作，创建出bus的祖先；\n\n\n```mermaid\ngraph TB\n\tdriver_init(driver_init)\n\t-->buses_init(buses_init)\n```\n\n\n```c\n// drivers/base/bus.c\nstatic struct kset *bus_kset;\nint __init buses_init(void)\n{\n    bus_kset = kset_create_and_add(\"bus\", &bus_uevent_ops, NULL);\n    system_kset = kset_create_and_add(\"system\", NULL, &devices_kset->kobj);\n\n    return 0;\n}\n```\n\n\nbuses_init()函数创建一个名为\"bus\"的kset，并将其加入到sysfs文件系统树中，在sysfs中的根目录创建bus，即/sys/bus目录；\n\n\n\n\n#### 1. 总线(bus)\n\n\n内核用struct bus_type结构体来描述总线信息；\n\n\n```c\n// include/linux/device.h\nstruct bus_type {\n    const char      *name;\t// 总线名称，在/sys/bus下出现\n    const char      *dev_name;\n    const struct attribute_group **bus_groups;\n    const struct attribute_group **dev_groups;\n    const struct attribute_group **drv_groups;\n\t......\n    int (*match)(struct device *dev, struct device_driver *drv);\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n\t......\n    struct subsys_private *p;\t// 用来管理bus中设备和驱动关系的结构体\n};\n```\n\n\n\n\n总线用struct subsys_private结构体来管理总线中设备和驱动的关系；\n\n\n```c\ndrivers/base/base.h\nstruct subsys_private {\n    struct kset subsys;\t\t// 表示bus所在的子系统\n    struct kset *devices_kset;\t\t// 表示bus上所有设备的集合\n    struct list_head interfaces;\n    struct mutex mutex;\n\n    struct kset *drivers_kset;\t\t// 表示bus上所有驱动的集合\n    struct klist klist_devices;\t\t// 表示bus上所有设备的链表\n    struct klist klist_drivers;\t\t// 表示bus上所有驱动的链表\n    struct blocking_notifier_head bus_notifier;\n    unsigned int drivers_autoprobe:1;\n    struct bus_type *bus;\n\n    struct kset glue_dirs;\n    struct class *class;\n};\n```\n\n\nstruct kset subsys：表示bus所在的子系统\n\n\nunsigned int drivers_autoprobe:1  表示向系统总线中注册设备或驱动时，是否进行设备和驱动的绑定操作；\n\n\nstruct kset *devices_kset和struct kset *drivers_kset分别表示bus上所有设备和驱动的集合；是在向系统注册当前新总线时动态生成的容纳该总线上所有驱动和设备的kset；\n\n\nstruct klist klist_devices和struct klist klist_drivers分别表示该总线上所有设备和驱动的链表；两个klist成员以链表的形式将该总线上所有的驱动与设备链接到一起；总线、设备、驱动的关系如下图所示：\n\n\n![总线设备驱动之间的关系](Linux设备驱动模型/总线设备驱动之间的关系.PNG)\n\n\n\n\n##### 1.1 总线的注册\n\n\n```c\n// drivers/base/bus.c\nint bus_register(struct bus_type *bus);\n```\n\n\nbus_register()函数用来注册一个bus总线子系统，可能会失败，必须检查返回值；注册成功后，可以在/sys/bus/目录下看到该总线；之后就可以向总线中添加设备了；\n\n\n```c\n// drivers/base/bus.c\nint bus_register(struct bus_type *bus)\n{\n    struct subsys_private *priv;\n\n    priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);\n    priv->bus = bus;\n    bus->p = priv;\n\n    BLOCKING_INIT_NOTIFIER_HEAD(&priv->bus_notifier);\n\n    retval = kobject_set_name(&priv->subsys.kobj, \"%s\", bus->name);\t// 为bus设定名字\n\n    priv->subsys.kobj.kset = bus_kset;\n    priv->subsys.kobj.ktype = &bus_ktype;\n    priv->drivers_autoprobe = 1;\n    retval = kset_register(&priv->subsys);\t// 在/sys/bus目录下为当前注册的bus生成目录\n\n    retval = bus_create_file(bus, &bus_attr_uevent);\t// 生成bus的属性文件\n    priv->devices_kset = kset_create_and_add(\"devices\", NULL,\n                         &priv->subsys.kobj);\t// 为bus生成容纳设备的kset容器\n    priv->drivers_kset = kset_create_and_add(\"drivers\", NULL,\n                         &priv->subsys.kobj);\t// // 为bus生成容纳驱动的kset容器\n\n    klist_init(&priv->klist_devices, klist_devices_get, klist_devices_put);\n    klist_init(&priv->klist_drivers, NULL, NULL);\t// 初始化bus上的设备和驱动链表\n\n    retval = add_probe_files(bus);\t// 为bus增加probe相关的属性文件\n    retval = bus_add_groups(bus, bus->bus_groups);\n\n    return 0;\n}\nEXPORT_SYMBOL_GPL(bus_register); \n```\n\n\nbus_register()函数，分配一个subsys_private结构体，通过kobject_set_name()函数为bus所在的内核对象设定名称，该名称在sysfs文件系统树中显示，再完成对subsys_private结构体成员参数的初始化操作，同时在创建了devices和drivers两个属性文件夹，/sys/bus/devices和/sys/bus/drivers；\n\n\nkset_register()函数将当前操作的bus所对应的kset加入到sysfs文件系统树中；\n\n\nbus_create_file()函数为bus创建一个属性文件；\n\n\nkset_create_and_add()函数生成一个kset对象，并将其加入到sysfs文件系统树中；parent参数为&priv->subsys.kobj，将在当前正在向系统注册的新bus目录下生成两个kset目录，对应新bus的devices和drivers，即/sys/bus/bus_name/devices和/sys/bus/bus_name/drivers；\n\n\n举例：通过bus_register()函数注册一个新的bus1总线，如下图所示：\n\n\n![bus_register函数注册bus1总线时的层次关系](Linux设备驱动模型/bus_register函数注册bus1总线时的层次关系.PNG)\n\n\n图中虚线部分，是将bus1总线通过bus_register()函数注册进系统时的层次结构：\n\n\n首先生成一个表示bus1的kset对象，并加入到sysfs文件系统中，该kset的parent内核对象为buses_init()函数中产生的bus_kset；\n\n\n其次，bus_register()函数，通过kset_create_and_add()函数，生成连接到bus1总线上的devices_kset和drivers_kset的集合，对应在sysfs系统中，会在/sys/bus/bus1目录下生成devices和drivers两个目录；\n\n\n最后，bus_register()函数，通过bus_create_file()函数，为bus1总线在/sys/bus/bus1目录下生成一些属性文件；\n\n\n属性文件实际上向用户空间提供了一些接口，用户程序可以通过这些属性文件获取或者设置属性内核对象的属性；\n\n\n\n\n##### 1.2 总线的注销\n\n\n```c\n// drivers/base/bus.c\nvoid bus_unregister(struct bus_type *bus);\n```\n\n\n\n\n```c\n// drivers/base/bus.c\nvoid bus_unregister(struct bus_type *bus)\n{\n    pr_debug(\"bus: '%s': unregistering\\n\", bus->name);\n    if (bus->dev_root)\n        device_unregister(bus->dev_root);\n    bus_remove_groups(bus, bus->bus_groups);\n    remove_probe_files(bus);\n    kset_unregister(bus->p->drivers_kset);\n    kset_unregister(bus->p->devices_kset);\n    bus_remove_file(bus, &bus_attr_uevent);\n    kset_unregister(&bus->p->subsys);\n}\nEXPORT_SYMBOL_GPL(bus_unregister);\n```\n\n\n\n\n\n\n##### 1.3 总线方法\n\n\n在struct bus_type结构体中定义了一些方法；\n\n\n```c\nint (*match)(struct device *dev, struct device_driver *drv);\n```\n\n\nmatch方法：当总线上添加新设备或新驱动程序时，会多次调用match方法，将device和device_driver进行匹配，如果匹配成功，说明指定的驱动程序能够处理指定的设备，match方法返回非零值；\n\n\n\n\n创建一个名为ldd的虚拟总线为例；\n\n\n\n\n```c\nstruct bus_type ldd_bus_type = {\n    .name = \"ldd\",\n    .match = ldd_match,\n};\n```\n\n\n\n\n```c\nret = bus_register(&ldd_bus_type);\nif (ret) {\n    printk(\"%s, bus_register failed\\n\", __func__);\n    return -1;\n}\n```\n\n\n\n\n\n\n```c\nbus_unregister(&ldd_bus_type);\n```\n\n\n\n\n\n\n\n\n在lddbus中添加一个简单的match方法，只是简单地比较设备和驱动程序的名字；在真实的总线驱动中，match方法可能会进行更加复杂的比较；\n\n\n```c\nint ldd_match(struct device *dev, struct device_driver *drv)\n{\n    return (strcmp(dev->kobj.name, drv->name) == 0);\n}\n```\n\n\n\n\n\n\n\n\n\n\n验证\n\n\n```c\n# lsmod\nldd_bus 16384 0 - Live 0xffff000000c90000 (O)\n```\n\n\n\n\n\n\n```c\n# ls /sys/bus/ldd/\ndevices            drivers_autoprobe  uevent\ndrivers            drivers_probe\n```\n\n\n\n\n\n\n\n\n##### 1.4 总线属性\n\n\n总线属性表示该总线的特有信息和配置，通过sysfs文件系统为总线生成属性文件，用户空间可以通过该属性文件接口，获取或者设置总线的属性；\n\n\n总线属性用struct bus_attribute结构体表示；\n\n\n```c\n// include/linux/device.h\nstruct bus_attribute {\n    struct attribute    attr;\n    ssize_t (*show)(struct bus_type *bus, char *buf);\n    ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);\n};\n```\n\n\nshow和store用来获取和设置总线的属性信息；\n\n\n```c\n// include/linux/sysfs.h\nstruct attribute {\n    const char      *name;\n    umode_t         mode;\n};\n```\n\n\n为总线定义属性可以使用BUS_ATTR()宏定义；\n\n\n```c\n// include/linux/device.h\n#define BUS_ATTR(_name, _mode, _show, _store)   \\\n    struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)\n```\n\n\n\n\n```c\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) {               \\\n    .attr = {.name = __stringify(_name),                \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \\\n    .show   = _show,                        \\\n    .store  = _store,                       \\\n}\n```\n\n\nBUS_ATTR()宏，定义一个以bus_attr_开头的总线属性，生成总线属性文件需要使用bus_create_file()函数来完成；\n\n\n```c\n// drivers/base/bus.c\nint bus_create_file(struct bus_type *bus, struct bus_attribute *attr)\n{\n    int error;\n\n    if (bus_get(bus)) {\n        error = sysfs_create_file(&bus->p->subsys.kobj, &attr->attr);\n        bus_put(bus);\n    } else\n        error = -EINVAL;\n    return error;\n}\nEXPORT_SYMBOL_GPL(bus_create_file);\n```\n\n\n\n\n\n\n\n\n\n\n```c\n// drivers/base/bus.c\nstatic BUS_ATTR(drivers_autoprobe, S_IWUSR | S_IRUGO,\n        show_drivers_autoprobe, store_drivers_autoprobe);\n\nstatic ssize_t show_drivers_autoprobe(struct bus_type *bus, char *buf)\n{\n    return sprintf(buf, \"%d\\n\", bus->p->drivers_autoprobe);\n}\n\nstatic ssize_t store_drivers_autoprobe(struct bus_type *bus,\n                       const char *buf, size_t count)\n{\n    if (buf[0] == '0')\n        bus->p->drivers_autoprobe = 0;\n    else\n        bus->p->drivers_autoprobe = 1;\n    return count;\n}\n```\n\n\n\n\n\n\n自己实现一个属性文件如下：\n\n\n```c\nssize_t ldd_show_bus_version(struct bus_type *bus, char *buf)\n{\n    return snprintf(buf, PAGE_SIZE, \"%s\\n\", VERSION);\n}\n\nBUS_ATTR(version, S_IRUGO, ldd_show_bus_version, NULL);\nret = bus_create_file(&ldd_bus_type, &bus_attr_version);\n```\n\n\n之后可以看到/sys/bus/ldd/version属性；\n\n\n\n\n#### 2. 设备(device)\n\n\n设备代表真实的具体的物理器件，\n\n\n总线实际上也是一个设备，因此也要以设备形式被单独注册；这个ldd总线是一个顶层总线，因此parent和bus成员是NULL，总线名字是ldd；\n\n\n\n\n```c\n// include/linux/device.h\nstruct device {\n    struct device       *parent;\n    struct device_private   *p;\n    struct kobject kobj;\n    const char      *init_name; /* initial name of the device */\n    const struct device_type *type;\n    struct bus_type *bus;       /* type of bus device is on */\n    struct device_driver *driver;   /* which driver has allocated this device */\n    void        *driver_data;   /* Driver data, set and get with\n                       dev_set/get_drvdata */\n    struct device_node  *of_node; /* associated device tree node */\n    void    (*release)(struct device *dev);\n    ......\n};\n```\n\n\n\n\n\n\n##### 2.1 设备注册\n\n\n```c\n// drivers/base/core.c\nint device_register(struct device *dev)\n{\n    device_initialize(dev);\t\t// 初始化device\n    return device_add(dev);\t\t// 将device添加到系统中\n}\nEXPORT_SYMBOL_GPL(device_register);\n```\n\n\ndevice_register()函数用来注册设备，可能会失败，必须检查返回值；注册成功后，可以在/sys/devices目录下看到该设备；以后添加到改总线上的任何设备都可以在/sys/devices/ldd目录下显示；\n\n\n创建一个名为ldd的设备为例；\n\n\n```c\nstruct device ldd_bus_dev = {\n    .init_name = \"ldd\",\n};\n```\n\n\n\n\n```c\nret = device_register(&ldd_bus_dev);\nif (ret) {\n    printk(\"%s, device_register failed\\n\", __func__);\n    return -1;\n}\n```\n\n\n\n\n##### 2.2 设备注销\n\n\n```c\n// drivers/base/core.c\nvoid device_unregister(struct device *dev)\n{\n    pr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\n    device_del(dev);\t// 从子系统中删除\n    put_device(dev);\t// 减少引用计数\n}\nEXPORT_SYMBOL_GPL(device_unregister);\n```\n\n\n用法：\n\n\n```c\ndevice_unregister(&ldd_bus_dev);\n```\n\n\n\n\n##### 2.3 设备属性\n\n\n\n\n```c\n// include/linux/device.h\nstruct device_attribute {\n    struct attribute    attr;\n    ssize_t (*show)(struct device *dev, struct device_attribute *attr,\n            char *buf);\n    ssize_t (*store)(struct device *dev, struct device_attribute *attr,\n             const char *buf, size_t count);\n};\n```\n\n\n\n\n```c\n// include/linux/device.h\n#define DEVICE_ATTR(_name, _mode, _show, _store) \\\n    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)\n```\n\n\n\n\n```c\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) {               \\\n    .attr = {.name = __stringify(_name),                \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \\\n    .show   = _show,                        \\\n    .store  = _store,                       \\\n}\n```\n\n\n\n\n\n\n```c\n// drivers/base/core.c\nint device_create_file(struct device *dev,\n                       const struct device_attribute *attr);\nvoid device_remove_file(struct device *dev,\n                        const struct device_attribute *attr);\n```\n\n\n\n\n\n\n##### 2.4 设备结构的封装\n\n\n在device结构体中已经包含了设备模型核心，用来模拟系统的信息；对于大多数系统来说，还需要包含一些系统其它的信息，因此需要对封装一个ldd_device，包含device结构体以及其它一些重要的信息；在ldd总线的每一个设备都需要使用ldd_device结构体来抽象；\n\n\n```c\nstruct ldd_device {\n    char *name;\n    struct ldd_driver *driver;\n    struct device dev;\n};\n\n#define to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))\n```\n\n\nldd_device结构体可以作为ldd总线上设备的一个抽象，包含一个device结构体，一个指向驱动程序的结构体指针；还可以根据需要添加信息，如：供应商信息、设备模型、设备配置、使用的资源等；\n\n\nto_ldd_device()宏定义，用来方便地用device结构体找到ldd_device结构体；\n\n\n\n\nldd总线下的设备注册功能可以使用以下封装的ldd_device_register()函数来实现；\n\n\n```c\nint ldd_device_register(struct ldd_device *ldddev)\n{\n    ldddev->dev.bus = &ldd_bus_type;\n    ldddev->dev.parent = &ldd_bus;\n    ldddev->dev.release = ldd_dev_release;\n    strncpy(ldddev->dev.kobj.name, ldddev->name, strlen(ldddev->name) + 1);\n\n    return device_register(&ldddev->dev);\n}\nEXPORT_SYMBOL(ldd_device_register);\n```\n\n\nldd_device_register()函数简单地初始化了ldd_device结构体中的device结构体成员，并向驱动程序核心注册该device结构体设备；\n\n\n\n\n##### 2.5 举例\n\n\n\n\n#### 3. 设备驱动(device_driver)\n\n\n\n\n设备驱动用device_driver结构体来表示：\n\n\n```c\n// include/linux/device.h\nstruct device_driver {\n    const char      *name;\t// 驱动程序的名字\n    struct bus_type     *bus;\n\n    const struct of_device_id   *of_match_table;\n    const struct acpi_device_id *acpi_match_table;\n\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n\t......\n    struct driver_private *p;\n};\n```\n\n\nname：驱动程序的名字，会显示在sysfs中\n\n\nbus：该驱动程序的总线类型\n\n\n\n\n##### 3.1 设备驱动注册\n\n\n\n\n```c\n// drivers/base/driver.c\nint driver_register(struct device_driver *drv);\n```\n\n\n\n\n##### 3.2 设备驱动注销\n\n\n```c\n// drivers/base/driver.c\nvoid driver_unregister(struct device_driver *drv);\n```\n\n\n\n\n\n\n##### 3.3 设备驱动属性\n\n\n\n\n```c\n// include/linux/device.h\nstruct driver_attribute {\n    struct attribute attr;\n    ssize_t (*show)(struct device_driver *driver, char *buf);\n    ssize_t (*store)(struct device_driver *driver, const char *buf,\n             size_t count);\n};\n\n#define DRIVER_ATTR(_name, _mode, _show, _store) \\\n    struct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store)\n\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) {               \\\n    .attr = {.name = __stringify(_name),                \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \\\n    .show   = _show,                        \\\n    .store  = _store,                       \\\n}\n```\n\n\n属性文件的创建和删除：\n\n\n```c\n// drivers/base/driver.c\nint driver_create_file(struct device_driver *drv,\n               const struct driver_attribute *attr);\nvoid driver_remove_file(struct device_driver *drv,\n            const struct driver_attribute *attr);\n```\n\n\n\n\n##### 3.4 驱动程序结构的封装\n\n\n对于大多数驱动程序来说，device_driver结构通常被包含在高层和总线相关的结构中，因此对于ldd子系统需要定义一个ldd_driver结构，包含device_driver结构体和一些需要的信息；在ldd总线的每一个驱动都需要使用ldd_driver结构体来抽象；\n\n\n```c\nstruct ldd_driver {\n    char *version;\n    struct module *module;\n    struct device_driver driver;\n    struct driver_attribute version_attr;\n};\n\n#define to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))\n```\n\n\nldd_driver结构体可以作为ldd总线上设备驱动的一个抽象，包含一个device_driver结构体；还可以根据需要添加一些别的信息；\n\n\nto_ldd_driver()宏定义，用来方便地用device_driver结构体找到ldd_driver结构体；\n\n\n\n\nldd总线下的设备驱动注册功能可以使用以下封装的ldd_driver_register()函数来实现；\n\n\n```c\nint ldd_driver_register(struct ldd_driver *driver)\n{\n    int ret = -1;\n\n    driver->driver.bus = &ldd_bus_type;\n    ret = driver_register(&driver->driver);\n    if (ret) {\n        printk(\"%s, driver_register failed\\n\", __func__);\n        return ret;\n    }\n    driver->version_attr.attr.name = \"version\";\n    driver->version_attr.attr.mode = S_IRUGO;\n    driver->version_attr.show = show_version;\n    driver->version_attr.store = NULL;\n\n    return driver_create_file(&driver->driver, &driver->version_attr);\n}\nEXPORT_SYMBOL(ldd_driver_register);\n```\n\n\nldd_driver_register()函数简单地初始化了ldd_driver结构体中的device_driver结构体成员，并向驱动程序核心注册该device_driver结构体设备驱动，同时还设置了驱动的版本号属性信息；因为驱动的版本号信息是在系统运行时建立的，所以必须手动设置driver_attribute结构体，而不能使用DRIVER_ATTR()宏；\n\n\n```c\nstatic ssize_t show_version(struct device_driver *driver, char *buf)\n{\n    struct ldd_driver *ldd_drv = to_ldd_driver(driver);\n\n    sprintf(buf, \"%s\\n\", ldd_drv->version);\n    return strlen(buf);\n}\n```\n\n\n\n\n##### 3.5 举例\n\n\n\n\n\n\n#### 4. 实例\n\n\n驱动工程师在驱动开发过程中，都是使用内核中已经封装好的总线，以及设备驱动模型接口，很少会需要添加一条总线，本节为了验证创建总线的过程，创建一条简单的总线ldd，用做测试；\n\n\n\n\n##### 4.1 注册总线 \n\n\n```c\nint ldd_bus_init(void)\n{\n    int ret = -1;\n\n    ret = bus_register(&ldd_bus_type);\n    if (ret) {\n        printk(\"%s, bus_register failed\\n\", __func__);\n        return -1;\n    }\n\n    ret = bus_create_file(&ldd_bus_type, &bus_attr_version);\n    if (ret) {\n        printk(\"%s, bus_create_file failed\\n\", __func__);\n        return -1;\n    }\n\n    ret = device_register(&ldd_bus_dev);\n    if (ret) {\n        printk(\"%s, device_register failed\\n\", __func__);\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid ldd_bus_exit(void)\n{\n    device_unregister(&ldd_bus_dev);\n    bus_remove_file(&ldd_bus_type, &bus_attr_version);\n    bus_unregister(&ldd_bus_type);\n}\n\nmodule_init(ldd_bus_init);\nmodule_exit(ldd_bus_exit);\nMODULE_LICENSE(\"GPL\");\n```\n\n\n\n\n\n\n```c\nssize_t ldd_show_bus_version(struct bus_type *bus, char *buf)\n{\n    return snprintf(buf, PAGE_SIZE, \"%s\\n\", VERSION);\n}\n\nBUS_ATTR(version, S_IRUGO, ldd_show_bus_version, NULL);\n\nstruct device ldd_bus_dev = {\n    .init_name = \"ldd\",\n};\n\nint ldd_match(struct device *dev, struct device_driver *drv)\n{\n    return (strcmp(dev->kobj.name, drv->name) == 0);\n}\n\nstruct bus_type ldd_bus_type = {\n    .name = \"ldd\",\n    .match = ldd_match,\n};\nEXPORT_SYMBOL(ldd_bus_type);\n```\n\n\n\n\n##### 4.2 封装设备接口\n\n\n\n\n```c\n//===================================\n\nvoid ldd_bus_release(struct device *dev)\n{\n    printk(\"%s, %d\\n\", __func__, __LINE__);\n}\n\nstruct device ldd_bus = {\n    .init_name = \"ldd\",\n    .release = ldd_bus_release,\n};\n\nstruct ldd_device {\n    char *name;\n    struct ldd_driver *driver;\n    struct device dev;\n};\n\n#define to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))\n\nvoid ldd_dev_release(struct device *dev)\n{\n    printk(\"%s, %d\\n\", __func__, __LINE__);\n}\n\nint ldd_device_register(struct ldd_device *ldddev)\n{\n    ldddev->dev.bus = &ldd_bus_type;\n    ldddev->dev.parent = &ldd_bus;\n    ldddev->dev.release = ldd_dev_release;\n    strncpy(ldddev->dev.kobj.name, ldddev->name, strlen(ldddev->name) + 1);\n\n    return device_register(&ldddev->dev);\n}\nEXPORT_SYMBOL(ldd_device_register);\n\n//===================================\n```\n\n\n\n\n##### 4.3 封装驱动接口\n\n\n```c\nstruct ldd_driver {\n    char *version;\n    struct module *module;\n    struct device_driver driver;\n    struct driver_attribute version_attr;\n};\n\n#define to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))\n\nstatic ssize_t show_version(struct device_driver *driver, char *buf)\n{\n    struct ldd_driver *ldd_drv = to_ldd_driver(driver);\n\n    sprintf(buf, \"%s\\n\", ldd_drv->version);\n    return strlen(buf);\n}\n\nint ldd_driver_register(struct ldd_driver *driver)\n{\n    int ret = -1;\n\n    driver->driver.bus = &ldd_bus_type;\n    ret = driver_register(&driver->driver);\n    if (ret) {\n        printk(\"%s, driver_register failed\\n\", __func__);\n        return ret;\n    }\n    driver->version_attr.attr.name = \"version\";\n    //driver->version_attr.attr.owner = driver->module;\n    driver->version_attr.attr.mode = S_IRUGO;\n    driver->version_attr.show = show_version;\n    driver->version_attr.store = NULL;\n\n    return driver_create_file(&driver->driver, &driver->version_attr);\n}\nEXPORT_SYMBOL(ldd_driver_register);\n```\n\n\n\n\n\n\n##### 4.4 添加设备和驱动\n\n\n\n\n##### 4.5 测试\n\n\n\n\n#### 5. 总结\n\n\n\n\n\n\n#### 6. 参考资料\n\n\n《Linux设备驱动程序》\n\n\n《深入Linux设备驱动程序内核机制》\n\n\n\n\n\n[回到目录](!目录)\n\n\n\n","slug":"Linux设备驱动模型","published":1,"updated":"2020-05-16T14:10:44.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv0000cdqg17mvg93ay","content":"<p>未完成</p>\n<p>Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；</p>\n<a id=\"more\"></a>\n\n\n\n\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><p>[TOC]</p>\n<h4 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h4><p>Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；</p>\n<p>Linux设备驱动模型中的总线，既可以是实际物理总线的抽象（如：PCI总线、I2C总线、USB总线），也可以是虚拟总线，一个符合Linux设备驱动模型的设备和驱动都必须挂接在一根总线上，无论是实际存在的总线还是系统模拟的总线；</p>\n<p>Linux设备模型中，最底层每一个设备都用一个device结构的实例来表示；而驱动是使总线上的设备能够完成一些功能；系统中有很多种总线，如：PCI总线、I2C总线、USB总线、scsi总线等；</p>\n<pre class=\"mermaid\">graph LR\n    driver_init(driver_init)-->\n    buses_init(buses_init)</pre>\n\n\n<p>buses_init()函数在sysfs文件系统的根目录下建立一个bus目录，即/sys/bus，是系统中后续注册总线的连接点；</p>\n<p>Linux设备模型中一组很重要的概念：总线、设备、驱动，即：bus、device、driver；分别对应数据结构struct bus_type，struct device，struct device_driver；</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型</th>\n<th>对应的数据结构</th>\n<th>代码文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>总线</td>\n<td>bus</td>\n<td>struct bus_type</td>\n<td>drivers/base/bus.c</td>\n</tr>\n<tr>\n<td>设备</td>\n<td>device</td>\n<td>struct device</td>\n<td>drivers/base/core.c</td>\n</tr>\n<tr>\n<td>驱动</td>\n<td>driver</td>\n<td>struct device_driver</td>\n<td>drivers/base/driver.c</td>\n</tr>\n</tbody></table>\n<pre class=\"mermaid\">graph TB\n    Bus(bus)-->Device(device)\n    Bus-->Driver(device_driver)</pre>\n\n\n<p>Linux设备驱动模型中，总线、设备、驱动都有对于的属性信息；</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>属性数据结构</th>\n<th>设置属性方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bus</td>\n<td>bus_attribute</td>\n<td>BUS_ATTR()</td>\n</tr>\n<tr>\n<td>device</td>\n<td>device_attribute</td>\n<td>DEVICE_ATTR()</td>\n</tr>\n<tr>\n<td>driver</td>\n<td>driver_attribute</td>\n<td>手动设置driver_attribute</td>\n</tr>\n</tbody></table>\n<p>Linux系统在启动时的初始化阶段，通过在driver_init()中调用buses_init()函数，完成所有总线的最初操作，创建出bus的祖先；</p>\n<pre class=\"mermaid\">graph TB\n    driver_init(driver_init)\n    -->buses_init(buses_init)</pre>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> *<span class=\"title\">bus_kset</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __init <span class=\"title\">buses_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    bus_kset = kset_create_and_add(<span class=\"string\">\"bus\"</span>, &amp;bus_uevent_ops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    system_kset = kset_create_and_add(<span class=\"string\">\"system\"</span>, <span class=\"literal\">NULL</span>, &amp;devices_kset-&gt;kobj);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>buses_init()函数创建一个名为”bus”的kset，并将其加入到sysfs文件系统树中，在sysfs中的根目录创建bus，即/sys/bus目录；</p>\n<h4 id=\"1-总线-bus\"><a href=\"#1-总线-bus\" class=\"headerlink\" title=\"1. 总线(bus)\"></a>1. 总线(bus)</h4><p>内核用struct bus_type结构体来描述总线信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;\t<span class=\"comment\">// 总线名称，在/sys/bus下出现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *dev_name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute_group</span> **<span class=\"title\">bus_groups</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute_group</span> **<span class=\"title\">dev_groups</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute_group</span> **<span class=\"title\">drv_groups</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct device *dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> *<span class=\"title\">p</span>;</span>\t<span class=\"comment\">// 用来管理bus中设备和驱动关系的结构体</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>总线用struct subsys_private结构体来管理总线中设备和驱动的关系；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drivers/base/base.h</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> <span class=\"title\">subsys</span>;</span>\t\t<span class=\"comment\">// 表示bus所在的子系统</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> *<span class=\"title\">devices_kset</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有设备的集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">interfaces</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> <span class=\"title\">mutex</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> *<span class=\"title\">drivers_kset</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有驱动的集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">klist</span> <span class=\"title\">klist_devices</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有设备的链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">klist</span> <span class=\"title\">klist_drivers</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有驱动的链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blocking_notifier_head</span> <span class=\"title\">bus_notifier</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> drivers_autoprobe:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> *<span class=\"title\">bus</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> <span class=\"title\">glue_dirs</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class</span> *<span class=\"title\">class</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>struct kset subsys：表示bus所在的子系统</p>\n<p>unsigned int drivers_autoprobe:1  表示向系统总线中注册设备或驱动时，是否进行设备和驱动的绑定操作；</p>\n<p>struct kset *devices_kset和struct kset *drivers_kset分别表示bus上所有设备和驱动的集合；是在向系统注册当前新总线时动态生成的容纳该总线上所有驱动和设备的kset；</p>\n<p>struct klist klist_devices和struct klist klist_drivers分别表示该总线上所有设备和驱动的链表；两个klist成员以链表的形式将该总线上所有的驱动与设备链接到一起；总线、设备、驱动的关系如下图所示：</p>\n<p><img src=\"/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.PNG\" alt=\"总线设备驱动之间的关系\"></p>\n<h5 id=\"1-1-总线的注册\"><a href=\"#1-1-总线的注册\" class=\"headerlink\" title=\"1.1 总线的注册\"></a>1.1 总线的注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bus_register</span><span class=\"params\">(struct bus_type *bus)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>bus_register()函数用来注册一个bus总线子系统，可能会失败，必须检查返回值；注册成功后，可以在/sys/bus/目录下看到该总线；之后就可以向总线中添加设备了；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bus_register</span><span class=\"params\">(struct bus_type *bus)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> *<span class=\"title\">priv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priv = kzalloc(<span class=\"keyword\">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class=\"line\">    priv-&gt;bus = bus;</span><br><span class=\"line\">    bus-&gt;p = priv;</span><br><span class=\"line\"></span><br><span class=\"line\">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class=\"string\">\"%s\"</span>, bus-&gt;name);\t<span class=\"comment\">// 为bus设定名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class=\"line\">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class=\"line\">    priv-&gt;drivers_autoprobe = <span class=\"number\">1</span>;</span><br><span class=\"line\">    retval = kset_register(&amp;priv-&gt;subsys);\t<span class=\"comment\">// 在/sys/bus目录下为当前注册的bus生成目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">    retval = bus_create_file(bus, &amp;bus_attr_uevent);\t<span class=\"comment\">// 生成bus的属性文件</span></span><br><span class=\"line\">    priv-&gt;devices_kset = kset_create_and_add(<span class=\"string\">\"devices\"</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         &amp;priv-&gt;subsys.kobj);\t<span class=\"comment\">// 为bus生成容纳设备的kset容器</span></span><br><span class=\"line\">    priv-&gt;drivers_kset = kset_create_and_add(<span class=\"string\">\"drivers\"</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         &amp;priv-&gt;subsys.kobj);\t<span class=\"comment\">// // 为bus生成容纳驱动的kset容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class=\"line\">    klist_init(&amp;priv-&gt;klist_drivers, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">// 初始化bus上的设备和驱动链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    retval = add_probe_files(bus);\t<span class=\"comment\">// 为bus增加probe相关的属性文件</span></span><br><span class=\"line\">    retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>bus_register()函数，分配一个subsys_private结构体，通过kobject_set_name()函数为bus所在的内核对象设定名称，该名称在sysfs文件系统树中显示，再完成对subsys_private结构体成员参数的初始化操作，同时在创建了devices和drivers两个属性文件夹，/sys/bus/devices和/sys/bus/drivers；</p>\n<p>kset_register()函数将当前操作的bus所对应的kset加入到sysfs文件系统树中；</p>\n<p>bus_create_file()函数为bus创建一个属性文件；</p>\n<p>kset_create_and_add()函数生成一个kset对象，并将其加入到sysfs文件系统树中；parent参数为&amp;priv-&gt;subsys.kobj，将在当前正在向系统注册的新bus目录下生成两个kset目录，对应新bus的devices和drivers，即/sys/bus/bus_name/devices和/sys/bus/bus_name/drivers；</p>\n<p>举例：通过bus_register()函数注册一个新的bus1总线，如下图所示：</p>\n<p><img src=\"/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/bus_register%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8Cbus1%E6%80%BB%E7%BA%BF%E6%97%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.PNG\" alt=\"bus_register函数注册bus1总线时的层次关系\"></p>\n<p>图中虚线部分，是将bus1总线通过bus_register()函数注册进系统时的层次结构：</p>\n<p>首先生成一个表示bus1的kset对象，并加入到sysfs文件系统中，该kset的parent内核对象为buses_init()函数中产生的bus_kset；</p>\n<p>其次，bus_register()函数，通过kset_create_and_add()函数，生成连接到bus1总线上的devices_kset和drivers_kset的集合，对应在sysfs系统中，会在/sys/bus/bus1目录下生成devices和drivers两个目录；</p>\n<p>最后，bus_register()函数，通过bus_create_file()函数，为bus1总线在/sys/bus/bus1目录下生成一些属性文件；</p>\n<p>属性文件实际上向用户空间提供了一些接口，用户程序可以通过这些属性文件获取或者设置属性内核对象的属性；</p>\n<h5 id=\"1-2-总线的注销\"><a href=\"#1-2-总线的注销\" class=\"headerlink\" title=\"1.2 总线的注销\"></a>1.2 总线的注销</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bus_unregister</span><span class=\"params\">(struct bus_type *bus)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bus_unregister</span><span class=\"params\">(struct bus_type *bus)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"bus: '%s': unregistering\\n\"</span>, bus-&gt;name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bus-&gt;dev_root)</span><br><span class=\"line\">        device_unregister(bus-&gt;dev_root);</span><br><span class=\"line\">    bus_remove_groups(bus, bus-&gt;bus_groups);</span><br><span class=\"line\">    remove_probe_files(bus);</span><br><span class=\"line\">    kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class=\"line\">    kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class=\"line\">    bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class=\"line\">    kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_unregister);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"1-3-总线方法\"><a href=\"#1-3-总线方法\" class=\"headerlink\" title=\"1.3 总线方法\"></a>1.3 总线方法</h5><p>在struct bus_type结构体中定义了一些方法；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br></pre></td></tr></table></figure>\n\n\n<p>match方法：当总线上添加新设备或新驱动程序时，会多次调用match方法，将device和device_driver进行匹配，如果匹配成功，说明指定的驱动程序能够处理指定的设备，match方法返回非零值；</p>\n<p>创建一个名为ldd的虚拟总线为例；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">ldd_bus_type</span> = &#123;</span></span><br><span class=\"line\">    .name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">    .match = ldd_match,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret = bus_register(&amp;ldd_bus_type);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, bus_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bus_unregister(&amp;ldd_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<p>在lddbus中添加一个简单的match方法，只是简单地比较设备和驱动程序的名字；在真实的总线驱动中，match方法可能会进行更加复杂的比较；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(dev-&gt;kobj.name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<p>验证</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># lsmod</span></span><br><span class=\"line\">ldd_bus <span class=\"number\">16384</span> <span class=\"number\">0</span> - Live <span class=\"number\">0xffff000000c90000</span> (O)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># ls /sys/bus/ldd/</span></span><br><span class=\"line\">devices            drivers_autoprobe  uevent</span><br><span class=\"line\">drivers            drivers_probe</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h5 id=\"1-4-总线属性\"><a href=\"#1-4-总线属性\" class=\"headerlink\" title=\"1.4 总线属性\"></a>1.4 总线属性</h5><p>总线属性表示该总线的特有信息和配置，通过sysfs文件系统为总线生成属性文件，用户空间可以通过该属性文件接口，获取或者设置总线的属性；</p>\n<p>总线属性用struct bus_attribute结构体表示；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span>    <span class=\"title\">attr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*show)(struct bus_type *bus, <span class=\"keyword\">char</span> *buf);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*store)(struct bus_type *bus, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>show和store用来获取和设置总线的属性信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/sysfs.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;</span><br><span class=\"line\">    <span class=\"keyword\">umode_t</span>         mode;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>为总线定义属性可以使用BUS_ATTR()宏定义；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUS_ATTR(_name, _mode, _show, _store)   \\</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_attribute</span> <span class=\"title\">bus_attr_</span>##_<span class=\"title\">name</span> = __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/sysfs.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __ATTR(_name, _mode, _show, _store) &#123;               \\</span></span><br><span class=\"line\">    .attr = &#123;.name = __stringify(_name),                \\</span><br><span class=\"line\">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \\</span><br><span class=\"line\">    .show   = _show,                        \\</span><br><span class=\"line\">    .store  = _store,                       \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>BUS_ATTR()宏，定义一个以bus_attr_开头的总线属性，生成总线属性文件需要使用bus_create_file()函数来完成；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bus_create_file</span><span class=\"params\">(struct bus_type *bus, struct bus_attribute *attr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bus_get(bus)) &#123;</span><br><span class=\"line\">        error = sysfs_create_file(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr);</span><br><span class=\"line\">        bus_put(bus);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        error = -EINVAL;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_create_file);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">BUS_ATTR</span><span class=\"params\">(drivers_autoprobe, S_IWUSR | S_IRUGO,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        show_drivers_autoprobe, store_drivers_autoprobe)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">show_drivers_autoprobe</span><span class=\"params\">(struct bus_type *bus, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">\"%d\\n\"</span>, bus-&gt;p-&gt;drivers_autoprobe);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">store_drivers_autoprobe</span><span class=\"params\">(struct bus_type *bus,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf[<span class=\"number\">0</span>] == <span class=\"string\">'0'</span>)</span><br><span class=\"line\">        bus-&gt;p-&gt;drivers_autoprobe = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        bus-&gt;p-&gt;drivers_autoprobe = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>自己实现一个属性文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">ldd_show_bus_version</span><span class=\"params\">(struct bus_type *bus, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">snprintf</span>(buf, PAGE_SIZE, <span class=\"string\">\"%s\\n\"</span>, VERSION);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BUS_ATTR(version, S_IRUGO, ldd_show_bus_version, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">ret = bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br></pre></td></tr></table></figure>\n\n\n<p>之后可以看到/sys/bus/ldd/version属性；</p>\n<h4 id=\"2-设备-device\"><a href=\"#2-设备-device\" class=\"headerlink\" title=\"2. 设备(device)\"></a>2. 设备(device)</h4><p>设备代表真实的具体的物理器件，</p>\n<p>总线实际上也是一个设备，因此也要以设备形式被单独注册；这个ldd总线是一个顶层总线，因此parent和bus成员是NULL，总线名字是ldd；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span>       *<span class=\"title\">parent</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_private</span>   *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kobject</span> <span class=\"title\">kobj</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *init_name; <span class=\"comment\">/* initial name of the device */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_type</span> *<span class=\"title\">type</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> *<span class=\"title\">bus</span>;</span>       <span class=\"comment\">/* type of bus device is on */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> *<span class=\"title\">driver</span>;</span>   <span class=\"comment\">/* which driver has allocated this device */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *driver_data;   <span class=\"comment\">/* Driver data, set and get with</span></span><br><span class=\"line\"><span class=\"comment\">                       dev_set/get_drvdata */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_node</span>  *<span class=\"title\">of_node</span>;</span> <span class=\"comment\">/* associated device tree node */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*<span class=\"built_in\">release</span>)(struct device *dev);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"2-1-设备注册\"><a href=\"#2-1-设备注册\" class=\"headerlink\" title=\"2.1 设备注册\"></a>2.1 设备注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">device_register</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_initialize(dev);\t\t<span class=\"comment\">// 初始化device</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> device_add(dev);\t\t<span class=\"comment\">// 将device添加到系统中</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>device_register()函数用来注册设备，可能会失败，必须检查返回值；注册成功后，可以在/sys/devices目录下看到该设备；以后添加到改总线上的任何设备都可以在/sys/devices/ldd目录下显示；</p>\n<p>创建一个名为ldd的设备为例；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">ldd_bus_dev</span> = &#123;</span></span><br><span class=\"line\">    .init_name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret = device_register(&amp;ldd_bus_dev);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, device_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-2-设备注销\"><a href=\"#2-2-设备注销\" class=\"headerlink\" title=\"2.2 设备注销\"></a>2.2 设备注销</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">device_unregister</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"device: '%s': %s\\n\"</span>, dev_name(dev), __func__);</span><br><span class=\"line\">    device_del(dev);\t<span class=\"comment\">// 从子系统中删除</span></span><br><span class=\"line\">    put_device(dev);\t<span class=\"comment\">// 减少引用计数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_unregister);</span><br></pre></td></tr></table></figure>\n\n\n<p>用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">device_unregister(&amp;ldd_bus_dev);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-3-设备属性\"><a href=\"#2-3-设备属性\" class=\"headerlink\" title=\"2.3 设备属性\"></a>2.3 设备属性</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span>    <span class=\"title\">attr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class=\"line\">            <span class=\"keyword\">char</span> *buf);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class=\"line\">             <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \\</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_attribute</span> <span class=\"title\">dev_attr_</span>##_<span class=\"title\">name</span> = __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/sysfs.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __ATTR(_name, _mode, _show, _store) &#123;               \\</span></span><br><span class=\"line\">    .attr = &#123;.name = __stringify(_name),                \\</span><br><span class=\"line\">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \\</span><br><span class=\"line\">    .show   = _show,                        \\</span><br><span class=\"line\">    .store  = _store,                       \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">device_create_file</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">const</span> struct device_attribute *attr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">device_remove_file</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">const</span> struct device_attribute *attr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"2-4-设备结构的封装\"><a href=\"#2-4-设备结构的封装\" class=\"headerlink\" title=\"2.4 设备结构的封装\"></a>2.4 设备结构的封装</h5><p>在device结构体中已经包含了设备模型核心，用来模拟系统的信息；对于大多数系统来说，还需要包含一些系统其它的信息，因此需要对封装一个ldd_device，包含device结构体以及其它一些重要的信息；在ldd总线的每一个设备都需要使用ldd_device结构体来抽象；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))</span></span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_device结构体可以作为ldd总线上设备的一个抽象，包含一个device结构体，一个指向驱动程序的结构体指针；还可以根据需要添加信息，如：供应商信息、设备模型、设备配置、使用的资源等；</p>\n<p>to_ldd_device()宏定义，用来方便地用device结构体找到ldd_device结构体；</p>\n<p>ldd总线下的设备注册功能可以使用以下封装的ldd_device_register()函数来实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_device_register</span><span class=\"params\">(struct ldd_device *ldddev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ldddev-&gt;dev.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ldddev-&gt;dev.parent = &amp;ldd_bus;</span><br><span class=\"line\">    ldddev-&gt;dev.<span class=\"built_in\">release</span> = ldd_dev_release;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>(ldddev-&gt;dev.kobj.name, ldddev-&gt;name, <span class=\"built_in\">strlen</span>(ldddev-&gt;name) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> device_register(&amp;ldddev-&gt;dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_device_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_device_register()函数简单地初始化了ldd_device结构体中的device结构体成员，并向驱动程序核心注册该device结构体设备；</p>\n<h5 id=\"2-5-举例\"><a href=\"#2-5-举例\" class=\"headerlink\" title=\"2.5 举例\"></a>2.5 举例</h5><h4 id=\"3-设备驱动-device-driver\"><a href=\"#3-设备驱动-device-driver\" class=\"headerlink\" title=\"3. 设备驱动(device_driver)\"></a>3. 设备驱动(device_driver)</h4><p>设备驱动用device_driver结构体来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;\t<span class=\"comment\">// 驱动程序的名字</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span>     *<span class=\"title\">bus</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span>   *<span class=\"title\">of_match_table</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">acpi_device_id</span> *<span class=\"title\">acpi_match_table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe) (struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>) (struct device *dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_private</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>name：驱动程序的名字，会显示在sysfs中</p>\n<p>bus：该驱动程序的总线类型</p>\n<h5 id=\"3-1-设备驱动注册\"><a href=\"#3-1-设备驱动注册\" class=\"headerlink\" title=\"3.1 设备驱动注册\"></a>3.1 设备驱动注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/driver.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">driver_register</span><span class=\"params\">(struct device_driver *drv)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-2-设备驱动注销\"><a href=\"#3-2-设备驱动注销\" class=\"headerlink\" title=\"3.2 设备驱动注销\"></a>3.2 设备驱动注销</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/driver.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">driver_unregister</span><span class=\"params\">(struct device_driver *drv)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"3-3-设备驱动属性\"><a href=\"#3-3-设备驱动属性\" class=\"headerlink\" title=\"3.3 设备驱动属性\"></a>3.3 设备驱动属性</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span> <span class=\"title\">attr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*show)(struct device_driver *driver, <span class=\"keyword\">char</span> *buf);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*store)(struct device_driver *driver, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf,</span><br><span class=\"line\">             <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DRIVER_ATTR(_name, _mode, _show, _store) \\</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> <span class=\"title\">driver_attr_</span>##_<span class=\"title\">name</span> = __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>)</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">// <span class=\"title\">include</span>/<span class=\"title\">linux</span>/<span class=\"title\">sysfs</span>.<span class=\"title\">h</span></span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">define</span> __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>) &#123;</span>               \\</span><br><span class=\"line\">    .attr = &#123;.name = __stringify(_name),                \\</span><br><span class=\"line\">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \\</span><br><span class=\"line\">    .show   = _show,                        \\</span><br><span class=\"line\">    .store  = _store,                       \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>属性文件的创建和删除：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/driver.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">driver_create_file</span><span class=\"params\">(struct device_driver *drv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">const</span> struct driver_attribute *attr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">driver_remove_file</span><span class=\"params\">(struct device_driver *drv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">const</span> struct driver_attribute *attr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-4-驱动程序结构的封装\"><a href=\"#3-4-驱动程序结构的封装\" class=\"headerlink\" title=\"3.4 驱动程序结构的封装\"></a>3.4 驱动程序结构的封装</h5><p>对于大多数驱动程序来说，device_driver结构通常被包含在高层和总线相关的结构中，因此对于ldd子系统需要定义一个ldd_driver结构，包含device_driver结构体和一些需要的信息；在ldd总线的每一个驱动都需要使用ldd_driver结构体来抽象；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *version;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">module</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> <span class=\"title\">version_attr</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))</span></span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_driver结构体可以作为ldd总线上设备驱动的一个抽象，包含一个device_driver结构体；还可以根据需要添加一些别的信息；</p>\n<p>to_ldd_driver()宏定义，用来方便地用device_driver结构体找到ldd_driver结构体；</p>\n<p>ldd总线下的设备驱动注册功能可以使用以下封装的ldd_driver_register()函数来实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_driver_register</span><span class=\"params\">(struct ldd_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    driver-&gt;driver.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ret = driver_register(&amp;driver-&gt;driver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, driver_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    driver-&gt;version_attr.attr.name = <span class=\"string\">\"version\"</span>;</span><br><span class=\"line\">    driver-&gt;version_attr.attr.mode = S_IRUGO;</span><br><span class=\"line\">    driver-&gt;version_attr.show = show_version;</span><br><span class=\"line\">    driver-&gt;version_attr.store = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_driver_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_driver_register()函数简单地初始化了ldd_driver结构体中的device_driver结构体成员，并向驱动程序核心注册该device_driver结构体设备驱动，同时还设置了驱动的版本号属性信息；因为驱动的版本号信息是在系统运行时建立的，所以必须手动设置driver_attribute结构体，而不能使用DRIVER_ATTR()宏；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">show_version</span><span class=\"params\">(struct device_driver *driver, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">ldd_drv</span> = <span class=\"title\">to_ldd_driver</span>(<span class=\"title\">driver</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">\"%s\\n\"</span>, ldd_drv-&gt;version);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strlen</span>(buf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-5-举例\"><a href=\"#3-5-举例\" class=\"headerlink\" title=\"3.5 举例\"></a>3.5 举例</h5><h4 id=\"4-实例\"><a href=\"#4-实例\" class=\"headerlink\" title=\"4. 实例\"></a>4. 实例</h4><p>驱动工程师在驱动开发过程中，都是使用内核中已经封装好的总线，以及设备驱动模型接口，很少会需要添加一条总线，本节为了验证创建总线的过程，创建一条简单的总线ldd，用做测试；</p>\n<h5 id=\"4-1-注册总线\"><a href=\"#4-1-注册总线\" class=\"headerlink\" title=\"4.1 注册总线\"></a>4.1 注册总线</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_bus_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = bus_register(&amp;ldd_bus_type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, bus_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, bus_create_file failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = device_register(&amp;ldd_bus_dev);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, device_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ldd_bus_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_unregister(&amp;ldd_bus_dev);</span><br><span class=\"line\">    bus_remove_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br><span class=\"line\">    bus_unregister(&amp;ldd_bus_type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(ldd_bus_init);</span><br><span class=\"line\">module_exit(ldd_bus_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">\"GPL\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">ldd_show_bus_version</span><span class=\"params\">(struct bus_type *bus, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">snprintf</span>(buf, PAGE_SIZE, <span class=\"string\">\"%s\\n\"</span>, VERSION);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BUS_ATTR(version, S_IRUGO, ldd_show_bus_version, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">ldd_bus_dev</span> = &#123;</span></span><br><span class=\"line\">    .init_name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(dev-&gt;kobj.name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">ldd_bus_type</span> = &#123;</span></span><br><span class=\"line\">    .name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">    .match = ldd_match,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4-2-封装设备接口\"><a href=\"#4-2-封装设备接口\" class=\"headerlink\" title=\"4.2 封装设备接口\"></a>4.2 封装设备接口</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//===================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ldd_bus_release</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">ldd_bus</span> = &#123;</span></span><br><span class=\"line\">    .init_name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = ldd_bus_release,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ldd_dev_release</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_device_register</span><span class=\"params\">(struct ldd_device *ldddev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ldddev-&gt;dev.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ldddev-&gt;dev.parent = &amp;ldd_bus;</span><br><span class=\"line\">    ldddev-&gt;dev.<span class=\"built_in\">release</span> = ldd_dev_release;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>(ldddev-&gt;dev.kobj.name, ldddev-&gt;name, <span class=\"built_in\">strlen</span>(ldddev-&gt;name) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> device_register(&amp;ldddev-&gt;dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_device_register);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//===================================</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4-3-封装驱动接口\"><a href=\"#4-3-封装驱动接口\" class=\"headerlink\" title=\"4.3 封装驱动接口\"></a>4.3 封装驱动接口</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *version;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">module</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> <span class=\"title\">version_attr</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">show_version</span><span class=\"params\">(struct device_driver *driver, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">ldd_drv</span> = <span class=\"title\">to_ldd_driver</span>(<span class=\"title\">driver</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">\"%s\\n\"</span>, ldd_drv-&gt;version);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strlen</span>(buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_driver_register</span><span class=\"params\">(struct ldd_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    driver-&gt;driver.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ret = driver_register(&amp;driver-&gt;driver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, driver_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    driver-&gt;version_attr.attr.name = <span class=\"string\">\"version\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">//driver-&gt;version_attr.attr.owner = driver-&gt;module;</span></span><br><span class=\"line\">    driver-&gt;version_attr.attr.mode = S_IRUGO;</span><br><span class=\"line\">    driver-&gt;version_attr.show = show_version;</span><br><span class=\"line\">    driver-&gt;version_attr.store = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_driver_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"4-4-添加设备和驱动\"><a href=\"#4-4-添加设备和驱动\" class=\"headerlink\" title=\"4.4 添加设备和驱动\"></a>4.4 添加设备和驱动</h5><h5 id=\"4-5-测试\"><a href=\"#4-5-测试\" class=\"headerlink\" title=\"4.5 测试\"></a>4.5 测试</h5><h4 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h4><h4 id=\"6-参考资料\"><a href=\"#6-参考资料\" class=\"headerlink\" title=\"6. 参考资料\"></a>6. 参考资料</h4><p>《Linux设备驱动程序》</p>\n<p>《深入Linux设备驱动程序内核机制》</p>\n<p><a href=\"!目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>未完成</p>\n<p>Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；</p>","more":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><p>[TOC]</p>\n<h4 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h4><p>Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；</p>\n<p>Linux设备驱动模型中的总线，既可以是实际物理总线的抽象（如：PCI总线、I2C总线、USB总线），也可以是虚拟总线，一个符合Linux设备驱动模型的设备和驱动都必须挂接在一根总线上，无论是实际存在的总线还是系统模拟的总线；</p>\n<p>Linux设备模型中，最底层每一个设备都用一个device结构的实例来表示；而驱动是使总线上的设备能够完成一些功能；系统中有很多种总线，如：PCI总线、I2C总线、USB总线、scsi总线等；</p>\n<pre class=\"mermaid\">graph LR\n    driver_init(driver_init)-->\n    buses_init(buses_init)</pre>\n\n\n<p>buses_init()函数在sysfs文件系统的根目录下建立一个bus目录，即/sys/bus，是系统中后续注册总线的连接点；</p>\n<p>Linux设备模型中一组很重要的概念：总线、设备、驱动，即：bus、device、driver；分别对应数据结构struct bus_type，struct device，struct device_driver；</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型</th>\n<th>对应的数据结构</th>\n<th>代码文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>总线</td>\n<td>bus</td>\n<td>struct bus_type</td>\n<td>drivers/base/bus.c</td>\n</tr>\n<tr>\n<td>设备</td>\n<td>device</td>\n<td>struct device</td>\n<td>drivers/base/core.c</td>\n</tr>\n<tr>\n<td>驱动</td>\n<td>driver</td>\n<td>struct device_driver</td>\n<td>drivers/base/driver.c</td>\n</tr>\n</tbody></table>\n<pre class=\"mermaid\">graph TB\n    Bus(bus)-->Device(device)\n    Bus-->Driver(device_driver)</pre>\n\n\n<p>Linux设备驱动模型中，总线、设备、驱动都有对于的属性信息；</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>属性数据结构</th>\n<th>设置属性方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bus</td>\n<td>bus_attribute</td>\n<td>BUS_ATTR()</td>\n</tr>\n<tr>\n<td>device</td>\n<td>device_attribute</td>\n<td>DEVICE_ATTR()</td>\n</tr>\n<tr>\n<td>driver</td>\n<td>driver_attribute</td>\n<td>手动设置driver_attribute</td>\n</tr>\n</tbody></table>\n<p>Linux系统在启动时的初始化阶段，通过在driver_init()中调用buses_init()函数，完成所有总线的最初操作，创建出bus的祖先；</p>\n<pre class=\"mermaid\">graph TB\n    driver_init(driver_init)\n    -->buses_init(buses_init)</pre>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> *<span class=\"title\">bus_kset</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __init <span class=\"title\">buses_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    bus_kset = kset_create_and_add(<span class=\"string\">\"bus\"</span>, &amp;bus_uevent_ops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    system_kset = kset_create_and_add(<span class=\"string\">\"system\"</span>, <span class=\"literal\">NULL</span>, &amp;devices_kset-&gt;kobj);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>buses_init()函数创建一个名为”bus”的kset，并将其加入到sysfs文件系统树中，在sysfs中的根目录创建bus，即/sys/bus目录；</p>\n<h4 id=\"1-总线-bus\"><a href=\"#1-总线-bus\" class=\"headerlink\" title=\"1. 总线(bus)\"></a>1. 总线(bus)</h4><p>内核用struct bus_type结构体来描述总线信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;\t<span class=\"comment\">// 总线名称，在/sys/bus下出现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *dev_name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute_group</span> **<span class=\"title\">bus_groups</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute_group</span> **<span class=\"title\">dev_groups</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute_group</span> **<span class=\"title\">drv_groups</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct device *dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> *<span class=\"title\">p</span>;</span>\t<span class=\"comment\">// 用来管理bus中设备和驱动关系的结构体</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>总线用struct subsys_private结构体来管理总线中设备和驱动的关系；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drivers/base/base.h</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> <span class=\"title\">subsys</span>;</span>\t\t<span class=\"comment\">// 表示bus所在的子系统</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> *<span class=\"title\">devices_kset</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有设备的集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">interfaces</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> <span class=\"title\">mutex</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> *<span class=\"title\">drivers_kset</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有驱动的集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">klist</span> <span class=\"title\">klist_devices</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有设备的链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">klist</span> <span class=\"title\">klist_drivers</span>;</span>\t\t<span class=\"comment\">// 表示bus上所有驱动的链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blocking_notifier_head</span> <span class=\"title\">bus_notifier</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> drivers_autoprobe:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> *<span class=\"title\">bus</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kset</span> <span class=\"title\">glue_dirs</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class</span> *<span class=\"title\">class</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>struct kset subsys：表示bus所在的子系统</p>\n<p>unsigned int drivers_autoprobe:1  表示向系统总线中注册设备或驱动时，是否进行设备和驱动的绑定操作；</p>\n<p>struct kset *devices_kset和struct kset *drivers_kset分别表示bus上所有设备和驱动的集合；是在向系统注册当前新总线时动态生成的容纳该总线上所有驱动和设备的kset；</p>\n<p>struct klist klist_devices和struct klist klist_drivers分别表示该总线上所有设备和驱动的链表；两个klist成员以链表的形式将该总线上所有的驱动与设备链接到一起；总线、设备、驱动的关系如下图所示：</p>\n<p><img src=\"/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.PNG\" alt=\"总线设备驱动之间的关系\"></p>\n<h5 id=\"1-1-总线的注册\"><a href=\"#1-1-总线的注册\" class=\"headerlink\" title=\"1.1 总线的注册\"></a>1.1 总线的注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bus_register</span><span class=\"params\">(struct bus_type *bus)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>bus_register()函数用来注册一个bus总线子系统，可能会失败，必须检查返回值；注册成功后，可以在/sys/bus/目录下看到该总线；之后就可以向总线中添加设备了；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bus_register</span><span class=\"params\">(struct bus_type *bus)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> *<span class=\"title\">priv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priv = kzalloc(<span class=\"keyword\">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class=\"line\">    priv-&gt;bus = bus;</span><br><span class=\"line\">    bus-&gt;p = priv;</span><br><span class=\"line\"></span><br><span class=\"line\">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class=\"string\">\"%s\"</span>, bus-&gt;name);\t<span class=\"comment\">// 为bus设定名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class=\"line\">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class=\"line\">    priv-&gt;drivers_autoprobe = <span class=\"number\">1</span>;</span><br><span class=\"line\">    retval = kset_register(&amp;priv-&gt;subsys);\t<span class=\"comment\">// 在/sys/bus目录下为当前注册的bus生成目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">    retval = bus_create_file(bus, &amp;bus_attr_uevent);\t<span class=\"comment\">// 生成bus的属性文件</span></span><br><span class=\"line\">    priv-&gt;devices_kset = kset_create_and_add(<span class=\"string\">\"devices\"</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         &amp;priv-&gt;subsys.kobj);\t<span class=\"comment\">// 为bus生成容纳设备的kset容器</span></span><br><span class=\"line\">    priv-&gt;drivers_kset = kset_create_and_add(<span class=\"string\">\"drivers\"</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         &amp;priv-&gt;subsys.kobj);\t<span class=\"comment\">// // 为bus生成容纳驱动的kset容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class=\"line\">    klist_init(&amp;priv-&gt;klist_drivers, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">// 初始化bus上的设备和驱动链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    retval = add_probe_files(bus);\t<span class=\"comment\">// 为bus增加probe相关的属性文件</span></span><br><span class=\"line\">    retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>bus_register()函数，分配一个subsys_private结构体，通过kobject_set_name()函数为bus所在的内核对象设定名称，该名称在sysfs文件系统树中显示，再完成对subsys_private结构体成员参数的初始化操作，同时在创建了devices和drivers两个属性文件夹，/sys/bus/devices和/sys/bus/drivers；</p>\n<p>kset_register()函数将当前操作的bus所对应的kset加入到sysfs文件系统树中；</p>\n<p>bus_create_file()函数为bus创建一个属性文件；</p>\n<p>kset_create_and_add()函数生成一个kset对象，并将其加入到sysfs文件系统树中；parent参数为&amp;priv-&gt;subsys.kobj，将在当前正在向系统注册的新bus目录下生成两个kset目录，对应新bus的devices和drivers，即/sys/bus/bus_name/devices和/sys/bus/bus_name/drivers；</p>\n<p>举例：通过bus_register()函数注册一个新的bus1总线，如下图所示：</p>\n<p><img src=\"/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/bus_register%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8Cbus1%E6%80%BB%E7%BA%BF%E6%97%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.PNG\" alt=\"bus_register函数注册bus1总线时的层次关系\"></p>\n<p>图中虚线部分，是将bus1总线通过bus_register()函数注册进系统时的层次结构：</p>\n<p>首先生成一个表示bus1的kset对象，并加入到sysfs文件系统中，该kset的parent内核对象为buses_init()函数中产生的bus_kset；</p>\n<p>其次，bus_register()函数，通过kset_create_and_add()函数，生成连接到bus1总线上的devices_kset和drivers_kset的集合，对应在sysfs系统中，会在/sys/bus/bus1目录下生成devices和drivers两个目录；</p>\n<p>最后，bus_register()函数，通过bus_create_file()函数，为bus1总线在/sys/bus/bus1目录下生成一些属性文件；</p>\n<p>属性文件实际上向用户空间提供了一些接口，用户程序可以通过这些属性文件获取或者设置属性内核对象的属性；</p>\n<h5 id=\"1-2-总线的注销\"><a href=\"#1-2-总线的注销\" class=\"headerlink\" title=\"1.2 总线的注销\"></a>1.2 总线的注销</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bus_unregister</span><span class=\"params\">(struct bus_type *bus)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bus_unregister</span><span class=\"params\">(struct bus_type *bus)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"bus: '%s': unregistering\\n\"</span>, bus-&gt;name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bus-&gt;dev_root)</span><br><span class=\"line\">        device_unregister(bus-&gt;dev_root);</span><br><span class=\"line\">    bus_remove_groups(bus, bus-&gt;bus_groups);</span><br><span class=\"line\">    remove_probe_files(bus);</span><br><span class=\"line\">    kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class=\"line\">    kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class=\"line\">    bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class=\"line\">    kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_unregister);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"1-3-总线方法\"><a href=\"#1-3-总线方法\" class=\"headerlink\" title=\"1.3 总线方法\"></a>1.3 总线方法</h5><p>在struct bus_type结构体中定义了一些方法；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br></pre></td></tr></table></figure>\n\n\n<p>match方法：当总线上添加新设备或新驱动程序时，会多次调用match方法，将device和device_driver进行匹配，如果匹配成功，说明指定的驱动程序能够处理指定的设备，match方法返回非零值；</p>\n<p>创建一个名为ldd的虚拟总线为例；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">ldd_bus_type</span> = &#123;</span></span><br><span class=\"line\">    .name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">    .match = ldd_match,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret = bus_register(&amp;ldd_bus_type);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, bus_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bus_unregister(&amp;ldd_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<p>在lddbus中添加一个简单的match方法，只是简单地比较设备和驱动程序的名字；在真实的总线驱动中，match方法可能会进行更加复杂的比较；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(dev-&gt;kobj.name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<p>验证</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># lsmod</span></span><br><span class=\"line\">ldd_bus <span class=\"number\">16384</span> <span class=\"number\">0</span> - Live <span class=\"number\">0xffff000000c90000</span> (O)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># ls /sys/bus/ldd/</span></span><br><span class=\"line\">devices            drivers_autoprobe  uevent</span><br><span class=\"line\">drivers            drivers_probe</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h5 id=\"1-4-总线属性\"><a href=\"#1-4-总线属性\" class=\"headerlink\" title=\"1.4 总线属性\"></a>1.4 总线属性</h5><p>总线属性表示该总线的特有信息和配置，通过sysfs文件系统为总线生成属性文件，用户空间可以通过该属性文件接口，获取或者设置总线的属性；</p>\n<p>总线属性用struct bus_attribute结构体表示；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span>    <span class=\"title\">attr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*show)(struct bus_type *bus, <span class=\"keyword\">char</span> *buf);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*store)(struct bus_type *bus, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>show和store用来获取和设置总线的属性信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/sysfs.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;</span><br><span class=\"line\">    <span class=\"keyword\">umode_t</span>         mode;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>为总线定义属性可以使用BUS_ATTR()宏定义；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUS_ATTR(_name, _mode, _show, _store)   \\</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_attribute</span> <span class=\"title\">bus_attr_</span>##_<span class=\"title\">name</span> = __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/sysfs.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __ATTR(_name, _mode, _show, _store) &#123;               \\</span></span><br><span class=\"line\">    .attr = &#123;.name = __stringify(_name),                \\</span><br><span class=\"line\">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \\</span><br><span class=\"line\">    .show   = _show,                        \\</span><br><span class=\"line\">    .store  = _store,                       \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>BUS_ATTR()宏，定义一个以bus_attr_开头的总线属性，生成总线属性文件需要使用bus_create_file()函数来完成；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bus_create_file</span><span class=\"params\">(struct bus_type *bus, struct bus_attribute *attr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bus_get(bus)) &#123;</span><br><span class=\"line\">        error = sysfs_create_file(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr);</span><br><span class=\"line\">        bus_put(bus);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        error = -EINVAL;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_create_file);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/bus.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">BUS_ATTR</span><span class=\"params\">(drivers_autoprobe, S_IWUSR | S_IRUGO,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        show_drivers_autoprobe, store_drivers_autoprobe)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">show_drivers_autoprobe</span><span class=\"params\">(struct bus_type *bus, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">\"%d\\n\"</span>, bus-&gt;p-&gt;drivers_autoprobe);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">store_drivers_autoprobe</span><span class=\"params\">(struct bus_type *bus,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf[<span class=\"number\">0</span>] == <span class=\"string\">'0'</span>)</span><br><span class=\"line\">        bus-&gt;p-&gt;drivers_autoprobe = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        bus-&gt;p-&gt;drivers_autoprobe = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>自己实现一个属性文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">ldd_show_bus_version</span><span class=\"params\">(struct bus_type *bus, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">snprintf</span>(buf, PAGE_SIZE, <span class=\"string\">\"%s\\n\"</span>, VERSION);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BUS_ATTR(version, S_IRUGO, ldd_show_bus_version, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">ret = bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br></pre></td></tr></table></figure>\n\n\n<p>之后可以看到/sys/bus/ldd/version属性；</p>\n<h4 id=\"2-设备-device\"><a href=\"#2-设备-device\" class=\"headerlink\" title=\"2. 设备(device)\"></a>2. 设备(device)</h4><p>设备代表真实的具体的物理器件，</p>\n<p>总线实际上也是一个设备，因此也要以设备形式被单独注册；这个ldd总线是一个顶层总线，因此parent和bus成员是NULL，总线名字是ldd；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span>       *<span class=\"title\">parent</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_private</span>   *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kobject</span> <span class=\"title\">kobj</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *init_name; <span class=\"comment\">/* initial name of the device */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_type</span> *<span class=\"title\">type</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> *<span class=\"title\">bus</span>;</span>       <span class=\"comment\">/* type of bus device is on */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> *<span class=\"title\">driver</span>;</span>   <span class=\"comment\">/* which driver has allocated this device */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *driver_data;   <span class=\"comment\">/* Driver data, set and get with</span></span><br><span class=\"line\"><span class=\"comment\">                       dev_set/get_drvdata */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_node</span>  *<span class=\"title\">of_node</span>;</span> <span class=\"comment\">/* associated device tree node */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*<span class=\"built_in\">release</span>)(struct device *dev);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"2-1-设备注册\"><a href=\"#2-1-设备注册\" class=\"headerlink\" title=\"2.1 设备注册\"></a>2.1 设备注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">device_register</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_initialize(dev);\t\t<span class=\"comment\">// 初始化device</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> device_add(dev);\t\t<span class=\"comment\">// 将device添加到系统中</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>device_register()函数用来注册设备，可能会失败，必须检查返回值；注册成功后，可以在/sys/devices目录下看到该设备；以后添加到改总线上的任何设备都可以在/sys/devices/ldd目录下显示；</p>\n<p>创建一个名为ldd的设备为例；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">ldd_bus_dev</span> = &#123;</span></span><br><span class=\"line\">    .init_name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret = device_register(&amp;ldd_bus_dev);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, device_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-2-设备注销\"><a href=\"#2-2-设备注销\" class=\"headerlink\" title=\"2.2 设备注销\"></a>2.2 设备注销</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">device_unregister</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pr_debug(<span class=\"string\">\"device: '%s': %s\\n\"</span>, dev_name(dev), __func__);</span><br><span class=\"line\">    device_del(dev);\t<span class=\"comment\">// 从子系统中删除</span></span><br><span class=\"line\">    put_device(dev);\t<span class=\"comment\">// 减少引用计数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_unregister);</span><br></pre></td></tr></table></figure>\n\n\n<p>用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">device_unregister(&amp;ldd_bus_dev);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-3-设备属性\"><a href=\"#2-3-设备属性\" class=\"headerlink\" title=\"2.3 设备属性\"></a>2.3 设备属性</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span>    <span class=\"title\">attr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class=\"line\">            <span class=\"keyword\">char</span> *buf);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class=\"line\">             <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \\</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_attribute</span> <span class=\"title\">dev_attr_</span>##_<span class=\"title\">name</span> = __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/sysfs.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __ATTR(_name, _mode, _show, _store) &#123;               \\</span></span><br><span class=\"line\">    .attr = &#123;.name = __stringify(_name),                \\</span><br><span class=\"line\">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \\</span><br><span class=\"line\">    .show   = _show,                        \\</span><br><span class=\"line\">    .store  = _store,                       \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">device_create_file</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">const</span> struct device_attribute *attr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">device_remove_file</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">const</span> struct device_attribute *attr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"2-4-设备结构的封装\"><a href=\"#2-4-设备结构的封装\" class=\"headerlink\" title=\"2.4 设备结构的封装\"></a>2.4 设备结构的封装</h5><p>在device结构体中已经包含了设备模型核心，用来模拟系统的信息；对于大多数系统来说，还需要包含一些系统其它的信息，因此需要对封装一个ldd_device，包含device结构体以及其它一些重要的信息；在ldd总线的每一个设备都需要使用ldd_device结构体来抽象；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))</span></span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_device结构体可以作为ldd总线上设备的一个抽象，包含一个device结构体，一个指向驱动程序的结构体指针；还可以根据需要添加信息，如：供应商信息、设备模型、设备配置、使用的资源等；</p>\n<p>to_ldd_device()宏定义，用来方便地用device结构体找到ldd_device结构体；</p>\n<p>ldd总线下的设备注册功能可以使用以下封装的ldd_device_register()函数来实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_device_register</span><span class=\"params\">(struct ldd_device *ldddev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ldddev-&gt;dev.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ldddev-&gt;dev.parent = &amp;ldd_bus;</span><br><span class=\"line\">    ldddev-&gt;dev.<span class=\"built_in\">release</span> = ldd_dev_release;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>(ldddev-&gt;dev.kobj.name, ldddev-&gt;name, <span class=\"built_in\">strlen</span>(ldddev-&gt;name) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> device_register(&amp;ldddev-&gt;dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_device_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_device_register()函数简单地初始化了ldd_device结构体中的device结构体成员，并向驱动程序核心注册该device结构体设备；</p>\n<h5 id=\"2-5-举例\"><a href=\"#2-5-举例\" class=\"headerlink\" title=\"2.5 举例\"></a>2.5 举例</h5><h4 id=\"3-设备驱动-device-driver\"><a href=\"#3-设备驱动-device-driver\" class=\"headerlink\" title=\"3. 设备驱动(device_driver)\"></a>3. 设备驱动(device_driver)</h4><p>设备驱动用device_driver结构体来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;\t<span class=\"comment\">// 驱动程序的名字</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span>     *<span class=\"title\">bus</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span>   *<span class=\"title\">of_match_table</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">acpi_device_id</span> *<span class=\"title\">acpi_match_table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe) (struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>) (struct device *dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_private</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>name：驱动程序的名字，会显示在sysfs中</p>\n<p>bus：该驱动程序的总线类型</p>\n<h5 id=\"3-1-设备驱动注册\"><a href=\"#3-1-设备驱动注册\" class=\"headerlink\" title=\"3.1 设备驱动注册\"></a>3.1 设备驱动注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/driver.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">driver_register</span><span class=\"params\">(struct device_driver *drv)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-2-设备驱动注销\"><a href=\"#3-2-设备驱动注销\" class=\"headerlink\" title=\"3.2 设备驱动注销\"></a>3.2 设备驱动注销</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/driver.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">driver_unregister</span><span class=\"params\">(struct device_driver *drv)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"3-3-设备驱动属性\"><a href=\"#3-3-设备驱动属性\" class=\"headerlink\" title=\"3.3 设备驱动属性\"></a>3.3 设备驱动属性</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">attribute</span> <span class=\"title\">attr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*show)(struct device_driver *driver, <span class=\"keyword\">char</span> *buf);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*store)(struct device_driver *driver, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf,</span><br><span class=\"line\">             <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DRIVER_ATTR(_name, _mode, _show, _store) \\</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> <span class=\"title\">driver_attr_</span>##_<span class=\"title\">name</span> = __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>)</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">// <span class=\"title\">include</span>/<span class=\"title\">linux</span>/<span class=\"title\">sysfs</span>.<span class=\"title\">h</span></span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">define</span> __<span class=\"title\">ATTR</span>(_<span class=\"title\">name</span>, _<span class=\"title\">mode</span>, _<span class=\"title\">show</span>, _<span class=\"title\">store</span>) &#123;</span>               \\</span><br><span class=\"line\">    .attr = &#123;.name = __stringify(_name),                \\</span><br><span class=\"line\">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \\</span><br><span class=\"line\">    .show   = _show,                        \\</span><br><span class=\"line\">    .store  = _store,                       \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>属性文件的创建和删除：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/driver.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">driver_create_file</span><span class=\"params\">(struct device_driver *drv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">const</span> struct driver_attribute *attr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">driver_remove_file</span><span class=\"params\">(struct device_driver *drv,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">const</span> struct driver_attribute *attr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-4-驱动程序结构的封装\"><a href=\"#3-4-驱动程序结构的封装\" class=\"headerlink\" title=\"3.4 驱动程序结构的封装\"></a>3.4 驱动程序结构的封装</h5><p>对于大多数驱动程序来说，device_driver结构通常被包含在高层和总线相关的结构中，因此对于ldd子系统需要定义一个ldd_driver结构，包含device_driver结构体和一些需要的信息；在ldd总线的每一个驱动都需要使用ldd_driver结构体来抽象；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *version;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">module</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> <span class=\"title\">version_attr</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))</span></span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_driver结构体可以作为ldd总线上设备驱动的一个抽象，包含一个device_driver结构体；还可以根据需要添加一些别的信息；</p>\n<p>to_ldd_driver()宏定义，用来方便地用device_driver结构体找到ldd_driver结构体；</p>\n<p>ldd总线下的设备驱动注册功能可以使用以下封装的ldd_driver_register()函数来实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_driver_register</span><span class=\"params\">(struct ldd_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    driver-&gt;driver.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ret = driver_register(&amp;driver-&gt;driver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, driver_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    driver-&gt;version_attr.attr.name = <span class=\"string\">\"version\"</span>;</span><br><span class=\"line\">    driver-&gt;version_attr.attr.mode = S_IRUGO;</span><br><span class=\"line\">    driver-&gt;version_attr.show = show_version;</span><br><span class=\"line\">    driver-&gt;version_attr.store = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_driver_register);</span><br></pre></td></tr></table></figure>\n\n\n<p>ldd_driver_register()函数简单地初始化了ldd_driver结构体中的device_driver结构体成员，并向驱动程序核心注册该device_driver结构体设备驱动，同时还设置了驱动的版本号属性信息；因为驱动的版本号信息是在系统运行时建立的，所以必须手动设置driver_attribute结构体，而不能使用DRIVER_ATTR()宏；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">show_version</span><span class=\"params\">(struct device_driver *driver, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">ldd_drv</span> = <span class=\"title\">to_ldd_driver</span>(<span class=\"title\">driver</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">\"%s\\n\"</span>, ldd_drv-&gt;version);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strlen</span>(buf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"3-5-举例\"><a href=\"#3-5-举例\" class=\"headerlink\" title=\"3.5 举例\"></a>3.5 举例</h5><h4 id=\"4-实例\"><a href=\"#4-实例\" class=\"headerlink\" title=\"4. 实例\"></a>4. 实例</h4><p>驱动工程师在驱动开发过程中，都是使用内核中已经封装好的总线，以及设备驱动模型接口，很少会需要添加一条总线，本节为了验证创建总线的过程，创建一条简单的总线ldd，用做测试；</p>\n<h5 id=\"4-1-注册总线\"><a href=\"#4-1-注册总线\" class=\"headerlink\" title=\"4.1 注册总线\"></a>4.1 注册总线</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_bus_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = bus_register(&amp;ldd_bus_type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, bus_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, bus_create_file failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = device_register(&amp;ldd_bus_dev);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, device_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ldd_bus_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_unregister(&amp;ldd_bus_dev);</span><br><span class=\"line\">    bus_remove_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br><span class=\"line\">    bus_unregister(&amp;ldd_bus_type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(ldd_bus_init);</span><br><span class=\"line\">module_exit(ldd_bus_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">\"GPL\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">ldd_show_bus_version</span><span class=\"params\">(struct bus_type *bus, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">snprintf</span>(buf, PAGE_SIZE, <span class=\"string\">\"%s\\n\"</span>, VERSION);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BUS_ATTR(version, S_IRUGO, ldd_show_bus_version, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">ldd_bus_dev</span> = &#123;</span></span><br><span class=\"line\">    .init_name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(dev-&gt;kobj.name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">ldd_bus_type</span> = &#123;</span></span><br><span class=\"line\">    .name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">    .match = ldd_match,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4-2-封装设备接口\"><a href=\"#4-2-封装设备接口\" class=\"headerlink\" title=\"4.2 封装设备接口\"></a>4.2 封装设备接口</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//===================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ldd_bus_release</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">ldd_bus</span> = &#123;</span></span><br><span class=\"line\">    .init_name = <span class=\"string\">\"ldd\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = ldd_bus_release,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ldd_dev_release</span><span class=\"params\">(struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_device_register</span><span class=\"params\">(struct ldd_device *ldddev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ldddev-&gt;dev.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ldddev-&gt;dev.parent = &amp;ldd_bus;</span><br><span class=\"line\">    ldddev-&gt;dev.<span class=\"built_in\">release</span> = ldd_dev_release;</span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>(ldddev-&gt;dev.kobj.name, ldddev-&gt;name, <span class=\"built_in\">strlen</span>(ldddev-&gt;name) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> device_register(&amp;ldddev-&gt;dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_device_register);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//===================================</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"4-3-封装驱动接口\"><a href=\"#4-3-封装驱动接口\" class=\"headerlink\" title=\"4.3 封装驱动接口\"></a>4.3 封装驱动接口</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *version;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">module</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">driver_attribute</span> <span class=\"title\">version_attr</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">show_version</span><span class=\"params\">(struct device_driver *driver, <span class=\"keyword\">char</span> *buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ldd_driver</span> *<span class=\"title\">ldd_drv</span> = <span class=\"title\">to_ldd_driver</span>(<span class=\"title\">driver</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">\"%s\\n\"</span>, ldd_drv-&gt;version);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strlen</span>(buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ldd_driver_register</span><span class=\"params\">(struct ldd_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    driver-&gt;driver.bus = &amp;ldd_bus_type;</span><br><span class=\"line\">    ret = driver_register(&amp;driver-&gt;driver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, driver_register failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    driver-&gt;version_attr.attr.name = <span class=\"string\">\"version\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">//driver-&gt;version_attr.attr.owner = driver-&gt;module;</span></span><br><span class=\"line\">    driver-&gt;version_attr.attr.mode = S_IRUGO;</span><br><span class=\"line\">    driver-&gt;version_attr.show = show_version;</span><br><span class=\"line\">    driver-&gt;version_attr.store = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(ldd_driver_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"4-4-添加设备和驱动\"><a href=\"#4-4-添加设备和驱动\" class=\"headerlink\" title=\"4.4 添加设备和驱动\"></a>4.4 添加设备和驱动</h5><h5 id=\"4-5-测试\"><a href=\"#4-5-测试\" class=\"headerlink\" title=\"4.5 测试\"></a>4.5 测试</h5><h4 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h4><h4 id=\"6-参考资料\"><a href=\"#6-参考资料\" class=\"headerlink\" title=\"6. 参考资料\"></a>6. 参考资料</h4><p>《Linux设备驱动程序》</p>\n<p>《深入Linux设备驱动程序内核机制》</p>\n<p><a href=\"!目录\">回到目录</a></p>"},{"title":"Qemu搭建ARM vexpress开发环境(一)","date":"2019-08-11T13:37:50.000Z","_content":"\n标签： Qemu\n\n---\n\n嵌入式软件开发依赖于嵌入式硬件设备，比如：开发板、外部模块设备等，但是如果只是想学习、研究Linux内核，想学习Linux内核的架构，工作模式，需要修改一些代码，重新编译并烧写到开发板中进行验证，这样未必有些复杂，并且为此专门购买各种开发版，浪费资金，开会演示效果还需要携带一大串的板子和电线，不胜其烦。然而Qemu的使用可以避免频繁在开发板上烧写版本，如果进行的调试工作与外设无关，仅仅是内核方面的调试，Qemu模拟ARM开发环境完全可以完美地胜任。\n\n<!--more-->\n\n\n\n下面简单介绍下我的Qemu开发环境搭建过程\n\n\n\n## 1. 环境\n\n由于在开发过程中也需要Windows系统下的一些工具，双系统环境切换操作系统时必须重启，于是放弃了以前搭建的双系统环境，而采用在PC的Windows10系统下通过VirtualBox虚拟机安装Xubuntu系统进行开发，避免了双系统开发中需要不断重启切换PC系统的问题。Xubuntu系统和Ubuntu系统大同小异，只是桌面封装更加简洁。\n\n\n\n### 1.1 所使用环境\n\n> Ubuntu-18.04.1\n\n或：\n\n> PC系统：Windows10\n> 虚拟机：VirtualBox-5.18\n> 虚拟机系统：Xubuntu\n> 模拟的开发板：vexpress\n\n\n\n### 1.2 搭建环境时使用的工具\n\nqemu-4.2.0\nlinux-4.14.172(Linux Kernel)\nu-boot-2017.05\nbusybox-1.31.1\narm-linux-gnueabi-gcc (Linaro 7.5.0-3)\n\n\n\n为了将Qemu搭建开发环境资料统一放到一起，创建～/qemu目录，所有相关文件全部放置在一起；\n\n\n\n## 2. 安装交叉编译工具\n```shell\n# sudo apt install gcc-arm-linux-gnueabi\n```\n\n查看安装是否成功：\n\n```shell\n# arm-linux-gnueabi-gcc -v\nUsing built-in specs.\nCOLLECT_GCC=arm-linux-gnueabi-gcc\nCOLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/arm-linux-gnueabi/7/lto-wrapper\nTarget: arm-linux-gnueabi\nConfigured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-multiarch --enable-multilib --disable-sjlj-exceptions --with-arch=armv5t --with-float=soft --disable-werror --enable-multilib --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabi --program-prefix=arm-linux-gnueabi- --includedir=/usr/arm-linux-gnueabi/include\nThread model: posix\ngcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) \n```\n\n\n\n## 3. 安装Qemu工具\n\n有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要第二种方法，通过Git工具下载源码，切换到最新分支再去编译安装了；但是一般情况下通过git下载代码速度极慢，我们可以使用第三种方法，找到要下载的qemu版本，使用迅雷下载；具体操作如下所述：\n\n\n\n### 3.1 快速安装Qemu\n```shell\n# sudo apt install qemu\n```\n\n这种情况下安装的qemu版本可能不是最新版本；如果想要安装最新版本的qemu，还得使用下边介绍的使用源代码编译安装的方法；\n\n\n\n### 3.2 下载Qemu源码编译安装\n\n\n\n#### 3.2.1 下载Qemu源码\n\n1. 从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支：\n\n```shell\n# git clone git://git.qemu-project.org/qemu.git\n# cd qemu\n# git checkout -b stable-*** remotes/origin/stable-***\n```\n2. 在windows系统下使用迅雷下载\n\n   登陆download.qemu.org网站，选择需要的版本，点击下载，或者右键后选使用迅雷下载，速度会更快：\n\n   在这里选择qemu-4.2.0.tar.xz使用；\n\n\n\n#### 3.2.2 安装\n\n在配置qemu之前，需要安装一些依赖的库或者软件包：\n\n```shell\n# sudo apt-get install zlib1g-dev \n# sudo apt-get install libglib2.0-0\n# sudo apt-get install libglib2.0-dev\n# sudo apt-get install libtool\n# sudo apt-get install libsdl1.2-dev\n# sudo apt-get install autoconf\n```\n\n解压源代码：\n\n```shell\n# tar -xvf qemu-4.2.0.tar.xz\n```\n\n为了防止编译后文件比较乱，选择创建build目录作为编译中间目标路径：\n\n```shell\n# cd qemu-4.2.0/\n# mkdir build\n# cd build/\n```\n\n\n\n配置、编译并安装Qemu：\n\n```shell\n# ../configure --target-list=arm-softmmu --audio-drv-list=\n# make\n# make install\n```\n\n\n\n#### 3.2.3 在编译过程中可能出现的问题\n\n```shell\n# ../configure --target-list=arm-softmmu --audio-drv-list=\nERROR: pkg-config binary 'pkg-config' not found\n```\n\n缺少库文件，按照上一步中的步骤安装库文件；\n\n\n\n```shell\n# ../configure --target-list=arm-softmmu --audio-drv-list=\nERROR: pixman >= 0.21.8 not present.\n       Please install the pixman devel package.\n```\n\n可以通过apt-cache查询缺少的依赖库：\n\n```shell\n# apt-cache search pixman\nlibpixman-1-0 - pixel-manipulation library for X and cairo\nlibpixman-1-dev - pixel-manipulation library for X and cairo (development files)\n```\n\n安装缺少的依赖库：\n\n```shell\n# sudo apt-get install libpixman-1-0\n# sudo apt-get install libpixman-1-dev\n```\n\n\n\n### 3.3 查看Qemu版本\n\n```shell\n# qemu-system-arm --version\nQEMU emulator version 4.2.0\nCopyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers\n```\n\n\n\n### 3.4 查看Qemu支持的开发板\n\nQemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表：\n```shell\n# qemu-system-arm -M help\n......\nvexpress-a15         ARM Versatile Express for Cortex-A15\nvexpress-a9          ARM Versatile Express for Cortex-A9\n......\n```\n\n\n\n### 3.5 运行Qemu\n\n该操作目前还不能运行，因为还没有编译内核，如果手边有编译好的别的版本的zImage文件，可以通过下面命令尝试运行看下效果。\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel ./zImage -dtb ./vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\n    -M          指定开发板\n    -m          指定内存大小\n    -kernel     指定内核文件\n    -dtb        指定dtb文件\n    -nographic  指定不需要图形界面\n    -append     指定扩展显示界面，串口或者LCD\n```\n\n实例参考：\n\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\n-M vexpress-a9\t模拟vexpress-a9板，可以使用-M ?参数来查询qemu支持的所有单板\n-m 512M\t单板物理内存512M\n-kernel\t~/qemu/zImage\t指定内和镜像及路径\n-dtb ~/qemu/vexpress-v2p-ca9.dtb\t指定单板的设备树文件\n-nographic\t不使用图形界面，使用串口\n-append \"console=ttyAMA0\"\t指定内核启动参数，串口设备使用ttyAMA0\n```\n\n\n\n## 4. 配置并编译Linux内核\n\n\n\n### 4.1 下载Linux内核\n\n通过众所周知的内核下载网站www.kernel.org下载需要的内核版本，这里我下载的是相对来说最新的长期支持的内核版本linux-4.4.157。\n\n\n\n### 4.2 解压Linux内核\n\n```shell\n# tar -xvf linux-4.4.157.tar.xz\n```\n\n\n\n### 4.3 编译Linux内核\n\n\n\n#### 4.3.1 配置\n\n```shell\n# make vexpress_defconfig ARCH=arm O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n  HOSTCC  scripts/basic/fixdep\n  GEN     ./Makefile\n  HOSTCC  scripts/kconfig/conf.o\n  SHIPPED scripts/kconfig/zconf.tab.c\n  SHIPPED scripts/kconfig/zconf.lex.c\n  HOSTCC  scripts/kconfig/zconf.tab.o\n  HOSTLD  scripts/kconfig/conf\n#\n# configuration written to .config\n#\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\n```\n\n\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig -j4 O=./object\n```\n\n\n\n#### 4.3.2 编译\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object\n```\n\n或者在Makefile中配置默认值，指定ARCH和CROSS_COMPILE，免得每次编译都需要带参数；\n\n```shell\n# make vexpress_defconfig\n# make zImage -j4\n# make modules -j4    // 编译驱动模块\n# make dtbs\t\t// 编译设备树\n```\n得到编译文件：\n```shell\narch/arm/boot/zImage\narch/arm/boot/dts/vexpress-v2p-ca9.dtb\n```\n\n分别将编译生成的zImage和vexpress-v2p-ca9.dtb文件放到~/qemu目录；\n\n```shell\n# cp arch/arm/boot/zImage ~/qemu\n# cp arch/arm/boot/dts/vexpress-v2p-ca9.dtb ~/qemu\n```\n\n\n\n### 4.4 Qemu启动命令\n\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel kernel/linux-4.4.157/arch/arm/boot/zImage -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\n```\nQemu的启动命令需要带好几个参数，完成启动命令比较长，每次都输入很可能会出现错误，为了使用方便，可以将该命令放到shell脚本中执行：\n```shell\n# cat boot.sh\n#! /bin/sh\nqemu-system-arm \\\n        -M vexpress-a9  \\\n        -m 512M \\\n        -kernel kernel/linux-4.4.157/arch/arm/boot/zImage   \\   \n        -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb    \\   \n        -nographic  \\\n        -append \"console=ttyAMA0\"\n```\n\n启动日志\n内核成功启动，内核的启动打印信息非常多。启动最后出错是因为没有挂载根文件系统。\n\n```\n$ qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\nBooting Linux on physical CPU 0x0\nLinux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020\nCPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr=10c5387d\nCPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache\nOF: fdt: Machine model: V2P-CA9\nMemory policy: Data cache writeback\nCPU: All CPU(s) started in SVC mode.\npercpu: Embedded 15 pages/cpu s32396 r8192 d20852 u61440\nBuilt 1 zonelists, mobility grouping on.  Total pages: 130048\nKernel command line: console=ttyAMA0\nlog_buf_len individual max cpu contribution: 4096 bytes\nlog_buf_len total cpu_extra contributions: 12288 bytes\nlog_buf_len min size: 16384 bytes\nlog_buf_len: 32768 bytes\nearly log buf free: 15044(91%)\nPID hash table entries: 2048 (order: 1, 8192 bytes)\nDentry cache hash table entries: 65536 (order: 6, 262144 bytes)\nInode-cache hash table entries: 32768 (order: 5, 131072 bytes)\nMemory: 509580K/524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14708K reserved, 0K cma-reserved)\nVirtual kernel memory layout:\n    vector  : 0xffff0000 - 0xffff1000   (   4 kB)\n    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)\n    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)\n    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)\n    modules : 0x7f000000 - 0x80000000   (  16 MB)\n      .text : 0x80008000 - 0x80700000   (7136 kB)\n      .init : 0x80900000 - 0x80a00000   (1024 kB)\n      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)\n       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)\nSLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1\nHierarchical RCU implementation.\n\tRCU event tracing is enabled.\n\tRCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.\nRCU: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4\n......\ninput: ImExPS/2 Generic Explorer Mouse as /devices/platform/smb@4000000/smb@4000000:motherboard/smb@4000000:motherboard:iofpga@7,00000000/10007000.kmi/serio1/input/input2\nVFS: Cannot open root device \"(null)\" or unknown-block(0,0): error -6\nPlease append a correct \"root=\" boot option; here are the available partitions:\n1f00          131072 mtdblock0 \n (driver?)\n1f01           32768 mtdblock1 \n (driver?)\nKernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.14.172 #1\nHardware name: ARM-Versatile Express\n[<8010f180>] (unwind_backtrace) from [<8010b444>] (show_stack+0x10/0x14)\n[<8010b444>] (show_stack) from [<806616cc>] (dump_stack+0x94/0xa8)\n[<806616cc>] (dump_stack) from [<8011d67c>] (panic+0xdc/0x248)\n[<8011d67c>] (panic) from [<8090129c>] (mount_block_root+0x1d4/0x2a8)\n[<8090129c>] (mount_block_root) from [<80901490>] (mount_root+0x120/0x128)\n[<80901490>] (mount_root) from [<809015e8>] (prepare_namespace+0x150/0x198)\n[<809015e8>] (prepare_namespace) from [<80900ea0>] (kernel_init_freeable+0x244/0x254)\n[<80900ea0>] (kernel_init_freeable) from [<80674538>] (kernel_init+0x8/0x114)\n[<80674538>] (kernel_init) from [<801076a8>] (ret_from_fork+0x14/0x2c)\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n```\n\n最后的Kernel panic是因为没有挂载根文件系统，下一布制作一个简易文件系统。\n\n\n\n## 5. 制作简易根文件系统\n\n使用busybox制作简易的根文件系统\n\n\n\n### 5.1 下载busybox工具\n\n从https://busybox.net/downloads/下载最新的busybox。\n\n同样，建议在windows系统下使用迅雷下载，先找到合适的busybox版本，再用右键，选择用迅雷下载，这样速度会很快；\n\n\n\n### 5.2 解压busybox\n\n```shell\n# tar -xvf busybox-1.31.1.tar.bz2\n```\n\n\n\n### 5.3 配置并编译busybox\n\n\n\n#### 5.3.1 配置\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig\n```\n\n\n\n编译选择使用glibc动态库，因为静态库可能会出现一些未知的问题\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig\nSettings  --->\n    Build Options  --->\n        [ ] Build static binary (no shared libs)\n```\n\n\n\n默认的安装目录是./_install，如果需要指定安装目录，可以在下边修改：\n\n```shell\nSettings  --->\nInstallation Options (\"make install\" behavior)\n(./_install) Destination path for 'make install'\n```\n\n\n\n#### 5.3.2 编译\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-\n```\n\n\n\n#### 5.3.3 安装\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install\n```\n\n提示下边信息，表示安装成功：\n\n```shell\n--------------------------------------------------\nYou will probably need to make your busybox binary\nsetuid root to ensure all configured applets will\nwork properly.\n--------------------------------------------------\n```\n\n安装完成之后，生成的目标文件默认在./_install目录，这个目标文件目录就是下边要制作根文件系统需要用到的工具：\n\n```shell\n$ ls _install/\nbin  linuxrc  sbin  usr\n```\n\n\n\n或者直接使用CONFIG_PREFIX指定安装目录：\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- CONFIG_PREFIX=/.../rootfs/ install\n```\n\n\n\n#### 5.3.4 提前设置好编译默认值\n\n编译安装过程中，一直输入ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-比较麻烦，可以在Makefile中设置好默认值；\n\n修改Makefile:\n\n```shell\n# vim Makefile\nARCH = arm\nCROSS_COMPILE = arm-linux-gnueabi-\n```\n之后的编译、安装命令就简单了：\n```shell\n# make\n# make install\n```\n\n\n\n### 5.4 生成简易根文件系统\n\n制作一个简易的根文件系统，该文件系统包含的功能极其简陋，仅为了验证Qemu启动Linux内核后挂载跟文件系统的过程。以后会根据具体需要进一步完善该文件系统。\n\n\n\n#### 1) 编译并安装busybox\n\n将busybox编译生成的_install目录下的文件全部拷贝到根文件系统目标rootfs/目录：\n```shell\n# mkdir rootfs\n# cp /.../busybox-1.29.3/_install/* rootfs/ -rfd\n```\n也可以在指定busybox的安装目录直接安装：\n```shell\n# make CONFIG_PREFIX=/.../rootfs/ install\n```\n\n\n\n#### 2) 添加glibc库\n\n在根文件系统中添加加载器和动态库：\n```shell\n# mkdir rootfs/lib\n# cp /usr/arm-linux-gnueabi/lib/* rootfs/lib/ -rfp\n```\n\n\n\n#### 3) 静态创建设备文件\n\n```shell\n# mkdir rootfs/dev\n# cd rootfs/dev\n# mknod -m 666 tty1 c 4 1\n# mknod -m 666 tty2 c 4 2\n# mknod -m 666 tty3 c 4 3\n# mknod -m 666 tty4 c 4 4\n# mknod -m 666 console c 5 1\n# mknod -m 666 null c 1 3\n```\n至此，简易版根文件系统就制作完成，该根文件系统只含有最基本的功能，一些其他功能在以后的操作中会进行添加，如有兴趣可以继续参考下一篇文章《》《》。\n\n\n\n### 5.5 制作SD卡文件系统镜像\n\n\n\n#### 1) 生成一个空的SD卡镜像：\n\n```shell\n# dd if=/dev/zero of=rootfs.ext3 bs=1M count=32\n32+0 records in\n32+0 records out\n33554432 bytes (34 MB, 32 MiB) copied, 0.0236764 s, 1.4 GB/s\n```\n\n\n\n#### 2) 将SD卡格式化为exts文件系统：\n\n```shell\n# mkfs.ext3 rootfs.ext3\nmke2fs 1.42.13 (17-May-2015)\nDiscarding device blocks: done                            \nCreating filesystem with 32768 1k blocks and 8192 inodes\nFilesystem UUID: 51ab1063-a137-48e5-a6f4-4552dad3b898\nSuperblock backups stored on blocks:\n    8193, 24577\n\nAllocating group tables: done                            \nWriting inode tables: done                            \nCreating journal (4096 blocks): done\nWriting superblocks and filesystem accounting information: done\n```\n\n\n\n#### 3) 将rootfs烧写到SD卡：\n\n```shell\n# sudo mount -t ext3 rootfs.ext3 /mnt -o loop\n# sudo cp -rf rootfs/* /mnt/\n# sudo umount /mnt\n```\n\n\n\n在开发过程中，如果需要修改SD卡中的内容，可以将SD卡的镜像rootfs.ext3挂载到/mnt目录下，直接操作/mnt来修改；\n\n```shell\n# sudo mount -t ext3 rootfs.ext3 /mnt -o loop\n```\n\n\n\n```shell\n# cp rootfs.ext3 ~/qemu\n```\n\n\n\n## 6. 验证\n\n\n\n### 1) Qemu启动命令：\n\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append \"root=/dev/mmcblk0 rw console=ttyAMA0\" -sd rootfs.ext3\n```\n\n\n\n### 2) 启动脚本：\n\n```shell\n# boot.sh\n#! /bin/sh\nqemu-system-arm \\\n        -M vexpress-a9  \\\n        -m 512M \\\n        -kernel ~/qemu/zImage   \\   \n        -dtb ~/qemu/vexpress-v2p-ca9.dtb    \\   \n        -nographic  \\\n        -append \"root=/dev/mmcblk0 rw console=ttyAMA0\"    \\\n        -sd rootfs.ext3\n```\n\n以上为在串口终端启动系统，按照以下的启动命令可以使用LCD屏作为输出启动系统。\n\n\n\n### 3) 图形化启动内核：\n\n```shell\nqemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -append \"root=/dev/mmcblk0 rw console=tty0\" -sd rootfs.ext3\n```\n\n\n\n### 4) 启动验证：\n\n```\nrequest_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...\nrequest_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now\nStarting init: /sbin/init exists but couldn't execute it (error -8)\nrequest_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...\nrequest_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now\nStarting init: /bin/sh exists but couldn't execute it (error -8)\nKernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.14.172 #1\nHardware name: ARM-Versatile Express\n[<8010f180>] (unwind_backtrace) from [<8010b444>] (show_stack+0x10/0x14)\n[<8010b444>] (show_stack) from [<806616cc>] (dump_stack+0x94/0xa8)\n[<806616cc>] (dump_stack) from [<8011d67c>] (panic+0xdc/0x248)\n[<8011d67c>] (panic) from [<80674634>] (kernel_init+0x104/0x114)\n[<80674634>] (kernel_init) from [<801076a8>] (ret_from_fork+0x14/0x2c)\n---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\nQEMU: Terminated\n```\n\n如上问题是由于编译生成的busybox工具，是x86环境下使用的：\n\n```shell\n# file bin/busybox \nbin/busybox: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=7fe433943e201f5337be6116a883d54fc1a4a349, stripped\n```\n\n是因为在安装busybox的时候，使用了make install，应该使用\n\n```shell\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install\n```\n\n编译工具生成arm平台使用的busybox工具：\n\n```shell\n# file rootfs/bin/busybox\nrootfs/bin/busybox: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=cbcd33b8d6c946cb19408a5e8e714de554c87f52, stripped\n```\n\n再次验证：\n\n```\nrtc-pl031 10017000.rtc: setting system clock to 2018-09-24 13:22:14 UTC (1537795334)\nALSA device list:\n  #0: ARM AC'97 Interface PL041 rev0 at 0x10004000, irq 33\ninput: ImExPS/2 Generic Explorer Mouse as /devices/platform/smb/smb:motherboard/smb:motherboard:iofpga@7,00000000/10007000.kmi/serio1/input/input2\nEXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem\nEXT4-fs (mmcblk0): recovery complete\nEXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)\nVFS: Mounted root (ext3 filesystem) on device 179:0.\nFreeing unused kernel memory: 284K\nrandom: nonblocking pool is initialized\ncan't run '/etc/init.d/rcS': No such file or directory\n\nPlease press Enter to activate this console.\n/ #\n/ #\n/ # uname -a\nLinux (none) 4.4.157 #1 SMP Sun Sep 23 21:11:22 CST 2018 armv7l GNU/Linux\n```\n\n至此，Qemu启动Linux内核并挂载跟文件系统已经启动成功，通过串口终端可以正常和系统进行简单功能的交互。\n打印中提示的不能运行/etc/init.d/rcS问题，只需要添加/etc/init.d/rcS文件即可，文件内容可以是提示语句。\n\n```shell\n# cat /etc/init.d/rcS\nHello Qemu Linux!\n```\n\n注意，要在创建/etc/init.d/rcS文件时，记着修改该文件的可执行权限，否则启动过程中会报错：\n\n```\nFreeing unused kernel memory: 1024K\nrandom: crng init done\ncan't run '/etc/init.d/rcS': Permission denied\n\nPlease press Enter to activate this console. \n```\n\n\n\n## 7. 退出Qemu环境\n\nQemu环境搭建好之后，在出错时需要关闭并重新启动Qemu，不用的时候需要关闭Qemu。\n\n\n\n### 1）手动退出Qemu\n\n```\nCtrl + A; X\n```\n\n操作之后，终端上会打印：\n\n```\nQEMU: Terminated\n```\n\n\n\n### 2）强制退出Qemu\n\n有时候会发现无法通过shutdown等工具关闭，因为Qemu也是一个进程，可以通过杀掉Qemu进程的方法关闭Qemu模拟环境。\n\n```shell\n# ps -a\n# kill xxx\n```\n\n如下可以采用脚本运行：\n\n```shell\n# cat kill_qemu.sh \n#! /bin/sh\nps -a | grep qemu-system-arm | awk '{print $1}' | xargs sudo kill -9\n```\n\n本文讲述了Qemu环境启动Linux内核，并挂载SD卡中的根文件系统的一些操作步骤。如果需要在Qemu环境下以ARM开发板的正常启动流程来加载Linux内核并挂载根文件系统，可以参考下一篇文章《[Qemu搭建ARM vexpress开发环境(二)----通过u-boot启动Linux内核](https://www.jianshu.com/p/8619a6739040\n)》。","source":"_posts/Qemu搭建ARM-vexpress开发环境(一).md","raw":"---\ntitle: Qemu搭建ARM vexpress开发环境(一)\ndate: 2019-08-11 21:37:50\ntags: Qemu\n---\n\n标签： Qemu\n\n---\n\n嵌入式软件开发依赖于嵌入式硬件设备，比如：开发板、外部模块设备等，但是如果只是想学习、研究Linux内核，想学习Linux内核的架构，工作模式，需要修改一些代码，重新编译并烧写到开发板中进行验证，这样未必有些复杂，并且为此专门购买各种开发版，浪费资金，开会演示效果还需要携带一大串的板子和电线，不胜其烦。然而Qemu的使用可以避免频繁在开发板上烧写版本，如果进行的调试工作与外设无关，仅仅是内核方面的调试，Qemu模拟ARM开发环境完全可以完美地胜任。\n\n<!--more-->\n\n\n\n下面简单介绍下我的Qemu开发环境搭建过程\n\n\n\n## 1. 环境\n\n由于在开发过程中也需要Windows系统下的一些工具，双系统环境切换操作系统时必须重启，于是放弃了以前搭建的双系统环境，而采用在PC的Windows10系统下通过VirtualBox虚拟机安装Xubuntu系统进行开发，避免了双系统开发中需要不断重启切换PC系统的问题。Xubuntu系统和Ubuntu系统大同小异，只是桌面封装更加简洁。\n\n\n\n### 1.1 所使用环境\n\n> Ubuntu-18.04.1\n\n或：\n\n> PC系统：Windows10\n> 虚拟机：VirtualBox-5.18\n> 虚拟机系统：Xubuntu\n> 模拟的开发板：vexpress\n\n\n\n### 1.2 搭建环境时使用的工具\n\nqemu-4.2.0\nlinux-4.14.172(Linux Kernel)\nu-boot-2017.05\nbusybox-1.31.1\narm-linux-gnueabi-gcc (Linaro 7.5.0-3)\n\n\n\n为了将Qemu搭建开发环境资料统一放到一起，创建～/qemu目录，所有相关文件全部放置在一起；\n\n\n\n## 2. 安装交叉编译工具\n```shell\n# sudo apt install gcc-arm-linux-gnueabi\n```\n\n查看安装是否成功：\n\n```shell\n# arm-linux-gnueabi-gcc -v\nUsing built-in specs.\nCOLLECT_GCC=arm-linux-gnueabi-gcc\nCOLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/arm-linux-gnueabi/7/lto-wrapper\nTarget: arm-linux-gnueabi\nConfigured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-multiarch --enable-multilib --disable-sjlj-exceptions --with-arch=armv5t --with-float=soft --disable-werror --enable-multilib --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabi --program-prefix=arm-linux-gnueabi- --includedir=/usr/arm-linux-gnueabi/include\nThread model: posix\ngcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) \n```\n\n\n\n## 3. 安装Qemu工具\n\n有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要第二种方法，通过Git工具下载源码，切换到最新分支再去编译安装了；但是一般情况下通过git下载代码速度极慢，我们可以使用第三种方法，找到要下载的qemu版本，使用迅雷下载；具体操作如下所述：\n\n\n\n### 3.1 快速安装Qemu\n```shell\n# sudo apt install qemu\n```\n\n这种情况下安装的qemu版本可能不是最新版本；如果想要安装最新版本的qemu，还得使用下边介绍的使用源代码编译安装的方法；\n\n\n\n### 3.2 下载Qemu源码编译安装\n\n\n\n#### 3.2.1 下载Qemu源码\n\n1. 从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支：\n\n```shell\n# git clone git://git.qemu-project.org/qemu.git\n# cd qemu\n# git checkout -b stable-*** remotes/origin/stable-***\n```\n2. 在windows系统下使用迅雷下载\n\n   登陆download.qemu.org网站，选择需要的版本，点击下载，或者右键后选使用迅雷下载，速度会更快：\n\n   在这里选择qemu-4.2.0.tar.xz使用；\n\n\n\n#### 3.2.2 安装\n\n在配置qemu之前，需要安装一些依赖的库或者软件包：\n\n```shell\n# sudo apt-get install zlib1g-dev \n# sudo apt-get install libglib2.0-0\n# sudo apt-get install libglib2.0-dev\n# sudo apt-get install libtool\n# sudo apt-get install libsdl1.2-dev\n# sudo apt-get install autoconf\n```\n\n解压源代码：\n\n```shell\n# tar -xvf qemu-4.2.0.tar.xz\n```\n\n为了防止编译后文件比较乱，选择创建build目录作为编译中间目标路径：\n\n```shell\n# cd qemu-4.2.0/\n# mkdir build\n# cd build/\n```\n\n\n\n配置、编译并安装Qemu：\n\n```shell\n# ../configure --target-list=arm-softmmu --audio-drv-list=\n# make\n# make install\n```\n\n\n\n#### 3.2.3 在编译过程中可能出现的问题\n\n```shell\n# ../configure --target-list=arm-softmmu --audio-drv-list=\nERROR: pkg-config binary 'pkg-config' not found\n```\n\n缺少库文件，按照上一步中的步骤安装库文件；\n\n\n\n```shell\n# ../configure --target-list=arm-softmmu --audio-drv-list=\nERROR: pixman >= 0.21.8 not present.\n       Please install the pixman devel package.\n```\n\n可以通过apt-cache查询缺少的依赖库：\n\n```shell\n# apt-cache search pixman\nlibpixman-1-0 - pixel-manipulation library for X and cairo\nlibpixman-1-dev - pixel-manipulation library for X and cairo (development files)\n```\n\n安装缺少的依赖库：\n\n```shell\n# sudo apt-get install libpixman-1-0\n# sudo apt-get install libpixman-1-dev\n```\n\n\n\n### 3.3 查看Qemu版本\n\n```shell\n# qemu-system-arm --version\nQEMU emulator version 4.2.0\nCopyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers\n```\n\n\n\n### 3.4 查看Qemu支持的开发板\n\nQemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表：\n```shell\n# qemu-system-arm -M help\n......\nvexpress-a15         ARM Versatile Express for Cortex-A15\nvexpress-a9          ARM Versatile Express for Cortex-A9\n......\n```\n\n\n\n### 3.5 运行Qemu\n\n该操作目前还不能运行，因为还没有编译内核，如果手边有编译好的别的版本的zImage文件，可以通过下面命令尝试运行看下效果。\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel ./zImage -dtb ./vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\n    -M          指定开发板\n    -m          指定内存大小\n    -kernel     指定内核文件\n    -dtb        指定dtb文件\n    -nographic  指定不需要图形界面\n    -append     指定扩展显示界面，串口或者LCD\n```\n\n实例参考：\n\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\n-M vexpress-a9\t模拟vexpress-a9板，可以使用-M ?参数来查询qemu支持的所有单板\n-m 512M\t单板物理内存512M\n-kernel\t~/qemu/zImage\t指定内和镜像及路径\n-dtb ~/qemu/vexpress-v2p-ca9.dtb\t指定单板的设备树文件\n-nographic\t不使用图形界面，使用串口\n-append \"console=ttyAMA0\"\t指定内核启动参数，串口设备使用ttyAMA0\n```\n\n\n\n## 4. 配置并编译Linux内核\n\n\n\n### 4.1 下载Linux内核\n\n通过众所周知的内核下载网站www.kernel.org下载需要的内核版本，这里我下载的是相对来说最新的长期支持的内核版本linux-4.4.157。\n\n\n\n### 4.2 解压Linux内核\n\n```shell\n# tar -xvf linux-4.4.157.tar.xz\n```\n\n\n\n### 4.3 编译Linux内核\n\n\n\n#### 4.3.1 配置\n\n```shell\n# make vexpress_defconfig ARCH=arm O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n  HOSTCC  scripts/basic/fixdep\n  GEN     ./Makefile\n  HOSTCC  scripts/kconfig/conf.o\n  SHIPPED scripts/kconfig/zconf.tab.c\n  SHIPPED scripts/kconfig/zconf.lex.c\n  HOSTCC  scripts/kconfig/zconf.tab.o\n  HOSTLD  scripts/kconfig/conf\n#\n# configuration written to .config\n#\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\n```\n\n\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig -j4 O=./object\n```\n\n\n\n#### 4.3.2 编译\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object\n```\n\n或者在Makefile中配置默认值，指定ARCH和CROSS_COMPILE，免得每次编译都需要带参数；\n\n```shell\n# make vexpress_defconfig\n# make zImage -j4\n# make modules -j4    // 编译驱动模块\n# make dtbs\t\t// 编译设备树\n```\n得到编译文件：\n```shell\narch/arm/boot/zImage\narch/arm/boot/dts/vexpress-v2p-ca9.dtb\n```\n\n分别将编译生成的zImage和vexpress-v2p-ca9.dtb文件放到~/qemu目录；\n\n```shell\n# cp arch/arm/boot/zImage ~/qemu\n# cp arch/arm/boot/dts/vexpress-v2p-ca9.dtb ~/qemu\n```\n\n\n\n### 4.4 Qemu启动命令\n\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel kernel/linux-4.4.157/arch/arm/boot/zImage -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\n```\nQemu的启动命令需要带好几个参数，完成启动命令比较长，每次都输入很可能会出现错误，为了使用方便，可以将该命令放到shell脚本中执行：\n```shell\n# cat boot.sh\n#! /bin/sh\nqemu-system-arm \\\n        -M vexpress-a9  \\\n        -m 512M \\\n        -kernel kernel/linux-4.4.157/arch/arm/boot/zImage   \\   \n        -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb    \\   \n        -nographic  \\\n        -append \"console=ttyAMA0\"\n```\n\n启动日志\n内核成功启动，内核的启动打印信息非常多。启动最后出错是因为没有挂载根文件系统。\n\n```\n$ qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append \"console=ttyAMA0\"\nBooting Linux on physical CPU 0x0\nLinux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020\nCPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr=10c5387d\nCPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache\nOF: fdt: Machine model: V2P-CA9\nMemory policy: Data cache writeback\nCPU: All CPU(s) started in SVC mode.\npercpu: Embedded 15 pages/cpu s32396 r8192 d20852 u61440\nBuilt 1 zonelists, mobility grouping on.  Total pages: 130048\nKernel command line: console=ttyAMA0\nlog_buf_len individual max cpu contribution: 4096 bytes\nlog_buf_len total cpu_extra contributions: 12288 bytes\nlog_buf_len min size: 16384 bytes\nlog_buf_len: 32768 bytes\nearly log buf free: 15044(91%)\nPID hash table entries: 2048 (order: 1, 8192 bytes)\nDentry cache hash table entries: 65536 (order: 6, 262144 bytes)\nInode-cache hash table entries: 32768 (order: 5, 131072 bytes)\nMemory: 509580K/524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14708K reserved, 0K cma-reserved)\nVirtual kernel memory layout:\n    vector  : 0xffff0000 - 0xffff1000   (   4 kB)\n    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)\n    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)\n    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)\n    modules : 0x7f000000 - 0x80000000   (  16 MB)\n      .text : 0x80008000 - 0x80700000   (7136 kB)\n      .init : 0x80900000 - 0x80a00000   (1024 kB)\n      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)\n       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)\nSLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1\nHierarchical RCU implementation.\n\tRCU event tracing is enabled.\n\tRCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.\nRCU: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4\n......\ninput: ImExPS/2 Generic Explorer Mouse as /devices/platform/smb@4000000/smb@4000000:motherboard/smb@4000000:motherboard:iofpga@7,00000000/10007000.kmi/serio1/input/input2\nVFS: Cannot open root device \"(null)\" or unknown-block(0,0): error -6\nPlease append a correct \"root=\" boot option; here are the available partitions:\n1f00          131072 mtdblock0 \n (driver?)\n1f01           32768 mtdblock1 \n (driver?)\nKernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.14.172 #1\nHardware name: ARM-Versatile Express\n[<8010f180>] (unwind_backtrace) from [<8010b444>] (show_stack+0x10/0x14)\n[<8010b444>] (show_stack) from [<806616cc>] (dump_stack+0x94/0xa8)\n[<806616cc>] (dump_stack) from [<8011d67c>] (panic+0xdc/0x248)\n[<8011d67c>] (panic) from [<8090129c>] (mount_block_root+0x1d4/0x2a8)\n[<8090129c>] (mount_block_root) from [<80901490>] (mount_root+0x120/0x128)\n[<80901490>] (mount_root) from [<809015e8>] (prepare_namespace+0x150/0x198)\n[<809015e8>] (prepare_namespace) from [<80900ea0>] (kernel_init_freeable+0x244/0x254)\n[<80900ea0>] (kernel_init_freeable) from [<80674538>] (kernel_init+0x8/0x114)\n[<80674538>] (kernel_init) from [<801076a8>] (ret_from_fork+0x14/0x2c)\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n```\n\n最后的Kernel panic是因为没有挂载根文件系统，下一布制作一个简易文件系统。\n\n\n\n## 5. 制作简易根文件系统\n\n使用busybox制作简易的根文件系统\n\n\n\n### 5.1 下载busybox工具\n\n从https://busybox.net/downloads/下载最新的busybox。\n\n同样，建议在windows系统下使用迅雷下载，先找到合适的busybox版本，再用右键，选择用迅雷下载，这样速度会很快；\n\n\n\n### 5.2 解压busybox\n\n```shell\n# tar -xvf busybox-1.31.1.tar.bz2\n```\n\n\n\n### 5.3 配置并编译busybox\n\n\n\n#### 5.3.1 配置\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig\n```\n\n\n\n编译选择使用glibc动态库，因为静态库可能会出现一些未知的问题\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig\nSettings  --->\n    Build Options  --->\n        [ ] Build static binary (no shared libs)\n```\n\n\n\n默认的安装目录是./_install，如果需要指定安装目录，可以在下边修改：\n\n```shell\nSettings  --->\nInstallation Options (\"make install\" behavior)\n(./_install) Destination path for 'make install'\n```\n\n\n\n#### 5.3.2 编译\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-\n```\n\n\n\n#### 5.3.3 安装\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install\n```\n\n提示下边信息，表示安装成功：\n\n```shell\n--------------------------------------------------\nYou will probably need to make your busybox binary\nsetuid root to ensure all configured applets will\nwork properly.\n--------------------------------------------------\n```\n\n安装完成之后，生成的目标文件默认在./_install目录，这个目标文件目录就是下边要制作根文件系统需要用到的工具：\n\n```shell\n$ ls _install/\nbin  linuxrc  sbin  usr\n```\n\n\n\n或者直接使用CONFIG_PREFIX指定安装目录：\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- CONFIG_PREFIX=/.../rootfs/ install\n```\n\n\n\n#### 5.3.4 提前设置好编译默认值\n\n编译安装过程中，一直输入ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-比较麻烦，可以在Makefile中设置好默认值；\n\n修改Makefile:\n\n```shell\n# vim Makefile\nARCH = arm\nCROSS_COMPILE = arm-linux-gnueabi-\n```\n之后的编译、安装命令就简单了：\n```shell\n# make\n# make install\n```\n\n\n\n### 5.4 生成简易根文件系统\n\n制作一个简易的根文件系统，该文件系统包含的功能极其简陋，仅为了验证Qemu启动Linux内核后挂载跟文件系统的过程。以后会根据具体需要进一步完善该文件系统。\n\n\n\n#### 1) 编译并安装busybox\n\n将busybox编译生成的_install目录下的文件全部拷贝到根文件系统目标rootfs/目录：\n```shell\n# mkdir rootfs\n# cp /.../busybox-1.29.3/_install/* rootfs/ -rfd\n```\n也可以在指定busybox的安装目录直接安装：\n```shell\n# make CONFIG_PREFIX=/.../rootfs/ install\n```\n\n\n\n#### 2) 添加glibc库\n\n在根文件系统中添加加载器和动态库：\n```shell\n# mkdir rootfs/lib\n# cp /usr/arm-linux-gnueabi/lib/* rootfs/lib/ -rfp\n```\n\n\n\n#### 3) 静态创建设备文件\n\n```shell\n# mkdir rootfs/dev\n# cd rootfs/dev\n# mknod -m 666 tty1 c 4 1\n# mknod -m 666 tty2 c 4 2\n# mknod -m 666 tty3 c 4 3\n# mknod -m 666 tty4 c 4 4\n# mknod -m 666 console c 5 1\n# mknod -m 666 null c 1 3\n```\n至此，简易版根文件系统就制作完成，该根文件系统只含有最基本的功能，一些其他功能在以后的操作中会进行添加，如有兴趣可以继续参考下一篇文章《》《》。\n\n\n\n### 5.5 制作SD卡文件系统镜像\n\n\n\n#### 1) 生成一个空的SD卡镜像：\n\n```shell\n# dd if=/dev/zero of=rootfs.ext3 bs=1M count=32\n32+0 records in\n32+0 records out\n33554432 bytes (34 MB, 32 MiB) copied, 0.0236764 s, 1.4 GB/s\n```\n\n\n\n#### 2) 将SD卡格式化为exts文件系统：\n\n```shell\n# mkfs.ext3 rootfs.ext3\nmke2fs 1.42.13 (17-May-2015)\nDiscarding device blocks: done                            \nCreating filesystem with 32768 1k blocks and 8192 inodes\nFilesystem UUID: 51ab1063-a137-48e5-a6f4-4552dad3b898\nSuperblock backups stored on blocks:\n    8193, 24577\n\nAllocating group tables: done                            \nWriting inode tables: done                            \nCreating journal (4096 blocks): done\nWriting superblocks and filesystem accounting information: done\n```\n\n\n\n#### 3) 将rootfs烧写到SD卡：\n\n```shell\n# sudo mount -t ext3 rootfs.ext3 /mnt -o loop\n# sudo cp -rf rootfs/* /mnt/\n# sudo umount /mnt\n```\n\n\n\n在开发过程中，如果需要修改SD卡中的内容，可以将SD卡的镜像rootfs.ext3挂载到/mnt目录下，直接操作/mnt来修改；\n\n```shell\n# sudo mount -t ext3 rootfs.ext3 /mnt -o loop\n```\n\n\n\n```shell\n# cp rootfs.ext3 ~/qemu\n```\n\n\n\n## 6. 验证\n\n\n\n### 1) Qemu启动命令：\n\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append \"root=/dev/mmcblk0 rw console=ttyAMA0\" -sd rootfs.ext3\n```\n\n\n\n### 2) 启动脚本：\n\n```shell\n# boot.sh\n#! /bin/sh\nqemu-system-arm \\\n        -M vexpress-a9  \\\n        -m 512M \\\n        -kernel ~/qemu/zImage   \\   \n        -dtb ~/qemu/vexpress-v2p-ca9.dtb    \\   \n        -nographic  \\\n        -append \"root=/dev/mmcblk0 rw console=ttyAMA0\"    \\\n        -sd rootfs.ext3\n```\n\n以上为在串口终端启动系统，按照以下的启动命令可以使用LCD屏作为输出启动系统。\n\n\n\n### 3) 图形化启动内核：\n\n```shell\nqemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -append \"root=/dev/mmcblk0 rw console=tty0\" -sd rootfs.ext3\n```\n\n\n\n### 4) 启动验证：\n\n```\nrequest_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...\nrequest_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now\nStarting init: /sbin/init exists but couldn't execute it (error -8)\nrequest_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...\nrequest_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now\nStarting init: /bin/sh exists but couldn't execute it (error -8)\nKernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.14.172 #1\nHardware name: ARM-Versatile Express\n[<8010f180>] (unwind_backtrace) from [<8010b444>] (show_stack+0x10/0x14)\n[<8010b444>] (show_stack) from [<806616cc>] (dump_stack+0x94/0xa8)\n[<806616cc>] (dump_stack) from [<8011d67c>] (panic+0xdc/0x248)\n[<8011d67c>] (panic) from [<80674634>] (kernel_init+0x104/0x114)\n[<80674634>] (kernel_init) from [<801076a8>] (ret_from_fork+0x14/0x2c)\n---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\nQEMU: Terminated\n```\n\n如上问题是由于编译生成的busybox工具，是x86环境下使用的：\n\n```shell\n# file bin/busybox \nbin/busybox: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=7fe433943e201f5337be6116a883d54fc1a4a349, stripped\n```\n\n是因为在安装busybox的时候，使用了make install，应该使用\n\n```shell\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install\n```\n\n编译工具生成arm平台使用的busybox工具：\n\n```shell\n# file rootfs/bin/busybox\nrootfs/bin/busybox: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=cbcd33b8d6c946cb19408a5e8e714de554c87f52, stripped\n```\n\n再次验证：\n\n```\nrtc-pl031 10017000.rtc: setting system clock to 2018-09-24 13:22:14 UTC (1537795334)\nALSA device list:\n  #0: ARM AC'97 Interface PL041 rev0 at 0x10004000, irq 33\ninput: ImExPS/2 Generic Explorer Mouse as /devices/platform/smb/smb:motherboard/smb:motherboard:iofpga@7,00000000/10007000.kmi/serio1/input/input2\nEXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem\nEXT4-fs (mmcblk0): recovery complete\nEXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)\nVFS: Mounted root (ext3 filesystem) on device 179:0.\nFreeing unused kernel memory: 284K\nrandom: nonblocking pool is initialized\ncan't run '/etc/init.d/rcS': No such file or directory\n\nPlease press Enter to activate this console.\n/ #\n/ #\n/ # uname -a\nLinux (none) 4.4.157 #1 SMP Sun Sep 23 21:11:22 CST 2018 armv7l GNU/Linux\n```\n\n至此，Qemu启动Linux内核并挂载跟文件系统已经启动成功，通过串口终端可以正常和系统进行简单功能的交互。\n打印中提示的不能运行/etc/init.d/rcS问题，只需要添加/etc/init.d/rcS文件即可，文件内容可以是提示语句。\n\n```shell\n# cat /etc/init.d/rcS\nHello Qemu Linux!\n```\n\n注意，要在创建/etc/init.d/rcS文件时，记着修改该文件的可执行权限，否则启动过程中会报错：\n\n```\nFreeing unused kernel memory: 1024K\nrandom: crng init done\ncan't run '/etc/init.d/rcS': Permission denied\n\nPlease press Enter to activate this console. \n```\n\n\n\n## 7. 退出Qemu环境\n\nQemu环境搭建好之后，在出错时需要关闭并重新启动Qemu，不用的时候需要关闭Qemu。\n\n\n\n### 1）手动退出Qemu\n\n```\nCtrl + A; X\n```\n\n操作之后，终端上会打印：\n\n```\nQEMU: Terminated\n```\n\n\n\n### 2）强制退出Qemu\n\n有时候会发现无法通过shutdown等工具关闭，因为Qemu也是一个进程，可以通过杀掉Qemu进程的方法关闭Qemu模拟环境。\n\n```shell\n# ps -a\n# kill xxx\n```\n\n如下可以采用脚本运行：\n\n```shell\n# cat kill_qemu.sh \n#! /bin/sh\nps -a | grep qemu-system-arm | awk '{print $1}' | xargs sudo kill -9\n```\n\n本文讲述了Qemu环境启动Linux内核，并挂载SD卡中的根文件系统的一些操作步骤。如果需要在Qemu环境下以ARM开发板的正常启动流程来加载Linux内核并挂载根文件系统，可以参考下一篇文章《[Qemu搭建ARM vexpress开发环境(二)----通过u-boot启动Linux内核](https://www.jianshu.com/p/8619a6739040\n)》。","slug":"Qemu搭建ARM-vexpress开发环境(一)","published":1,"updated":"2020-05-07T13:53:23.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv1000ddqg17qp5eh1n","content":"<p>标签： Qemu</p>\n<hr>\n<p>嵌入式软件开发依赖于嵌入式硬件设备，比如：开发板、外部模块设备等，但是如果只是想学习、研究Linux内核，想学习Linux内核的架构，工作模式，需要修改一些代码，重新编译并烧写到开发板中进行验证，这样未必有些复杂，并且为此专门购买各种开发版，浪费资金，开会演示效果还需要携带一大串的板子和电线，不胜其烦。然而Qemu的使用可以避免频繁在开发板上烧写版本，如果进行的调试工作与外设无关，仅仅是内核方面的调试，Qemu模拟ARM开发环境完全可以完美地胜任。</p>\n<a id=\"more\"></a>\n\n\n\n<p>下面简单介绍下我的Qemu开发环境搭建过程</p>\n<h2 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h2><p>由于在开发过程中也需要Windows系统下的一些工具，双系统环境切换操作系统时必须重启，于是放弃了以前搭建的双系统环境，而采用在PC的Windows10系统下通过VirtualBox虚拟机安装Xubuntu系统进行开发，避免了双系统开发中需要不断重启切换PC系统的问题。Xubuntu系统和Ubuntu系统大同小异，只是桌面封装更加简洁。</p>\n<h3 id=\"1-1-所使用环境\"><a href=\"#1-1-所使用环境\" class=\"headerlink\" title=\"1.1 所使用环境\"></a>1.1 所使用环境</h3><blockquote>\n<p>Ubuntu-18.04.1</p>\n</blockquote>\n<p>或：</p>\n<blockquote>\n<p>PC系统：Windows10<br>虚拟机：VirtualBox-5.18<br>虚拟机系统：Xubuntu<br>模拟的开发板：vexpress</p>\n</blockquote>\n<h3 id=\"1-2-搭建环境时使用的工具\"><a href=\"#1-2-搭建环境时使用的工具\" class=\"headerlink\" title=\"1.2 搭建环境时使用的工具\"></a>1.2 搭建环境时使用的工具</h3><p>qemu-4.2.0<br>linux-4.14.172(Linux Kernel)<br>u-boot-2017.05<br>busybox-1.31.1<br>arm-linux-gnueabi-gcc (Linaro 7.5.0-3)</p>\n<p>为了将Qemu搭建开发环境资料统一放到一起，创建～/qemu目录，所有相关文件全部放置在一起；</p>\n<h2 id=\"2-安装交叉编译工具\"><a href=\"#2-安装交叉编译工具\" class=\"headerlink\" title=\"2. 安装交叉编译工具\"></a>2. 安装交叉编译工具</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install gcc-arm-linux-gnueabi</span></span><br></pre></td></tr></table></figure>\n\n<p>查看安装是否成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> arm-linux-gnueabi-gcc -v</span></span><br><span class=\"line\">Using built-in specs.</span><br><span class=\"line\">COLLECT_GCC=arm-linux-gnueabi-gcc</span><br><span class=\"line\">COLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/arm-linux-gnueabi/7/lto-wrapper</span><br><span class=\"line\">Target: arm-linux-gnueabi</span><br><span class=\"line\">Configured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-multiarch --enable-multilib --disable-sjlj-exceptions --with-arch=armv5t --with-float=soft --disable-werror --enable-multilib --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabi --program-prefix=arm-linux-gnueabi- --includedir=/usr/arm-linux-gnueabi/include</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-安装Qemu工具\"><a href=\"#3-安装Qemu工具\" class=\"headerlink\" title=\"3. 安装Qemu工具\"></a>3. 安装Qemu工具</h2><p>有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要第二种方法，通过Git工具下载源码，切换到最新分支再去编译安装了；但是一般情况下通过git下载代码速度极慢，我们可以使用第三种方法，找到要下载的qemu版本，使用迅雷下载；具体操作如下所述：</p>\n<h3 id=\"3-1-快速安装Qemu\"><a href=\"#3-1-快速安装Qemu\" class=\"headerlink\" title=\"3.1 快速安装Qemu\"></a>3.1 快速安装Qemu</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install qemu</span></span><br></pre></td></tr></table></figure>\n\n<p>这种情况下安装的qemu版本可能不是最新版本；如果想要安装最新版本的qemu，还得使用下边介绍的使用源代码编译安装的方法；</p>\n<h3 id=\"3-2-下载Qemu源码编译安装\"><a href=\"#3-2-下载Qemu源码编译安装\" class=\"headerlink\" title=\"3.2 下载Qemu源码编译安装\"></a>3.2 下载Qemu源码编译安装</h3><h4 id=\"3-2-1-下载Qemu源码\"><a href=\"#3-2-1-下载Qemu源码\" class=\"headerlink\" title=\"3.2.1 下载Qemu源码\"></a>3.2.1 下载Qemu源码</h4><ol>\n<li>从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git://git.qemu-project.org/qemu.git</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> qemu</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git checkout -b stable-*** remotes/origin/stable-***</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>在windows系统下使用迅雷下载</p>\n<p>登陆download.qemu.org网站，选择需要的版本，点击下载，或者右键后选使用迅雷下载，速度会更快：</p>\n<p>在这里选择qemu-4.2.0.tar.xz使用；</p>\n</li>\n</ol>\n<h4 id=\"3-2-2-安装\"><a href=\"#3-2-2-安装\" class=\"headerlink\" title=\"3.2.2 安装\"></a>3.2.2 安装</h4><p>在配置qemu之前，需要安装一些依赖的库或者软件包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install zlib1g-dev </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libglib2.0-0</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libglib2.0-dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libtool</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libsdl1.2-dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install autoconf</span></span><br></pre></td></tr></table></figure>\n\n<p>解压源代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf qemu-4.2.0.tar.xz</span></span><br></pre></td></tr></table></figure>\n\n<p>为了防止编译后文件比较乱，选择创建build目录作为编译中间目标路径：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> qemu-4.2.0/</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir build</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> build/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>配置、编译并安装Qemu：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ../configure --target-list=arm-softmmu --audio-drv-list=</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-3-在编译过程中可能出现的问题\"><a href=\"#3-2-3-在编译过程中可能出现的问题\" class=\"headerlink\" title=\"3.2.3 在编译过程中可能出现的问题\"></a>3.2.3 在编译过程中可能出现的问题</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ../configure --target-list=arm-softmmu --audio-drv-list=</span></span><br><span class=\"line\">ERROR: pkg-config binary 'pkg-config' not found</span><br></pre></td></tr></table></figure>\n\n<p>缺少库文件，按照上一步中的步骤安装库文件；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ../configure --target-list=arm-softmmu --audio-drv-list=</span></span><br><span class=\"line\">ERROR: pixman &gt;= 0.21.8 not present.</span><br><span class=\"line\">       Please install the pixman devel package.</span><br></pre></td></tr></table></figure>\n\n<p>可以通过apt-cache查询缺少的依赖库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> apt-cache search pixman</span></span><br><span class=\"line\">libpixman-1-0 - pixel-manipulation library for X and cairo</span><br><span class=\"line\">libpixman-1-dev - pixel-manipulation library for X and cairo (development files)</span><br></pre></td></tr></table></figure>\n\n<p>安装缺少的依赖库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libpixman-1-0</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libpixman-1-dev</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-3-查看Qemu版本\"><a href=\"#3-3-查看Qemu版本\" class=\"headerlink\" title=\"3.3 查看Qemu版本\"></a>3.3 查看Qemu版本</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm --version</span></span><br><span class=\"line\">QEMU emulator version 4.2.0</span><br><span class=\"line\">Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-4-查看Qemu支持的开发板\"><a href=\"#3-4-查看Qemu支持的开发板\" class=\"headerlink\" title=\"3.4 查看Qemu支持的开发板\"></a>3.4 查看Qemu支持的开发板</h3><p>Qemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M <span class=\"built_in\">help</span></span></span><br><span class=\"line\">......</span><br><span class=\"line\">vexpress-a15         ARM Versatile Express for Cortex-A15</span><br><span class=\"line\">vexpress-a9          ARM Versatile Express for Cortex-A9</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-5-运行Qemu\"><a href=\"#3-5-运行Qemu\" class=\"headerlink\" title=\"3.5 运行Qemu\"></a>3.5 运行Qemu</h3><p>该操作目前还不能运行，因为还没有编译内核，如果手边有编译好的别的版本的zImage文件，可以通过下面命令尝试运行看下效果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel ./zImage -dtb ./vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"console=ttyAMA0\"</span></span></span><br><span class=\"line\">    -M          指定开发板</span><br><span class=\"line\">    -m          指定内存大小</span><br><span class=\"line\">    -kernel     指定内核文件</span><br><span class=\"line\">    -dtb        指定dtb文件</span><br><span class=\"line\">    -nographic  指定不需要图形界面</span><br><span class=\"line\">    -append     指定扩展显示界面，串口或者LCD</span><br></pre></td></tr></table></figure>\n\n<p>实例参考：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"console=ttyAMA0\"</span></span></span><br><span class=\"line\">-M vexpress-a9\t模拟vexpress-a9板，可以使用-M ?参数来查询qemu支持的所有单板</span><br><span class=\"line\">-m 512M\t单板物理内存512M</span><br><span class=\"line\">-kernel\t~/qemu/zImage\t指定内和镜像及路径</span><br><span class=\"line\">-dtb ~/qemu/vexpress-v2p-ca9.dtb\t指定单板的设备树文件</span><br><span class=\"line\">-nographic\t不使用图形界面，使用串口</span><br><span class=\"line\">-append \"console=ttyAMA0\"\t指定内核启动参数，串口设备使用ttyAMA0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-配置并编译Linux内核\"><a href=\"#4-配置并编译Linux内核\" class=\"headerlink\" title=\"4. 配置并编译Linux内核\"></a>4. 配置并编译Linux内核</h2><h3 id=\"4-1-下载Linux内核\"><a href=\"#4-1-下载Linux内核\" class=\"headerlink\" title=\"4.1 下载Linux内核\"></a>4.1 下载Linux内核</h3><p>通过众所周知的内核下载网站<a href=\"http://www.kernel.org下载需要的内核版本，这里我下载的是相对来说最新的长期支持的内核版本linux-4.4.157。\" target=\"_blank\" rel=\"noopener\">www.kernel.org下载需要的内核版本，这里我下载的是相对来说最新的长期支持的内核版本linux-4.4.157。</a></p>\n<h3 id=\"4-2-解压Linux内核\"><a href=\"#4-2-解压Linux内核\" class=\"headerlink\" title=\"4.2 解压Linux内核\"></a>4.2 解压Linux内核</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf linux-4.4.157.tar.xz</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-3-编译Linux内核\"><a href=\"#4-3-编译Linux内核\" class=\"headerlink\" title=\"4.3 编译Linux内核\"></a>4.3 编译Linux内核</h3><h4 id=\"4-3-1-配置\"><a href=\"#4-3-1-配置\" class=\"headerlink\" title=\"4.3.1 配置\"></a>4.3.1 配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_defconfig ARCH=arm O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">  HOSTCC  scripts/basic/fixdep</span><br><span class=\"line\">  GEN     ./Makefile</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/conf.o</span><br><span class=\"line\">  SHIPPED scripts/kconfig/zconf.tab.c</span><br><span class=\"line\">  SHIPPED scripts/kconfig/zconf.lex.c</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class=\"line\">  HOSTLD  scripts/kconfig/conf</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> configuration written to .config</span></span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig -j4 O=./object</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-3-2-编译\"><a href=\"#4-3-2-编译\" class=\"headerlink\" title=\"4.3.2 编译\"></a>4.3.2 编译</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object</span></span><br></pre></td></tr></table></figure>\n\n<p>或者在Makefile中配置默认值，指定ARCH和CROSS_COMPILE，免得每次编译都需要带参数；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_defconfig</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make zImage -j4</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make modules -j4    // 编译驱动模块</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make dtbs\t\t// 编译设备树</span></span><br></pre></td></tr></table></figure>\n<p>得到编译文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch/arm/boot/zImage</span><br><span class=\"line\">arch/arm/boot/dts/vexpress-v2p-ca9.dtb</span><br></pre></td></tr></table></figure>\n\n<p>分别将编译生成的zImage和vexpress-v2p-ca9.dtb文件放到~/qemu目录；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp arch/arm/boot/zImage ~/qemu</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp arch/arm/boot/dts/vexpress-v2p-ca9.dtb ~/qemu</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-4-Qemu启动命令\"><a href=\"#4-4-Qemu启动命令\" class=\"headerlink\" title=\"4.4 Qemu启动命令\"></a>4.4 Qemu启动命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel kernel/linux-4.4.157/arch/arm/boot/zImage -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"console=ttyAMA0\"</span></span></span><br></pre></td></tr></table></figure>\n<p>Qemu的启动命令需要带好几个参数，完成启动命令比较长，每次都输入很可能会出现错误，为了使用方便，可以将该命令放到shell脚本中执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat boot.sh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/sh</span></span><br><span class=\"line\">qemu-system-arm \\</span><br><span class=\"line\">        -M vexpress-a9  \\</span><br><span class=\"line\">        -m 512M \\</span><br><span class=\"line\">        -kernel kernel/linux-4.4.157/arch/arm/boot/zImage   \\   </span><br><span class=\"line\">        -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb    \\   </span><br><span class=\"line\">        -nographic  \\</span><br><span class=\"line\">        -append \"console=ttyAMA0\"</span><br></pre></td></tr></table></figure>\n\n<p>启动日志<br>内核成功启动，内核的启动打印信息非常多。启动最后出错是因为没有挂载根文件系统。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ qemu-system-arm -M vexpress-a9 -m 512M -kernel ~&#x2F;qemu&#x2F;zImage -dtb ~&#x2F;qemu&#x2F;vexpress-v2p-ca9.dtb -nographic -append &quot;console&#x3D;ttyAMA0&quot;</span><br><span class=\"line\">Booting Linux on physical CPU 0x0</span><br><span class=\"line\">Linux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020</span><br><span class=\"line\">CPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr&#x3D;10c5387d</span><br><span class=\"line\">CPU: PIPT &#x2F; VIPT nonaliasing data cache, VIPT nonaliasing instruction cache</span><br><span class=\"line\">OF: fdt: Machine model: V2P-CA9</span><br><span class=\"line\">Memory policy: Data cache writeback</span><br><span class=\"line\">CPU: All CPU(s) started in SVC mode.</span><br><span class=\"line\">percpu: Embedded 15 pages&#x2F;cpu s32396 r8192 d20852 u61440</span><br><span class=\"line\">Built 1 zonelists, mobility grouping on.  Total pages: 130048</span><br><span class=\"line\">Kernel command line: console&#x3D;ttyAMA0</span><br><span class=\"line\">log_buf_len individual max cpu contribution: 4096 bytes</span><br><span class=\"line\">log_buf_len total cpu_extra contributions: 12288 bytes</span><br><span class=\"line\">log_buf_len min size: 16384 bytes</span><br><span class=\"line\">log_buf_len: 32768 bytes</span><br><span class=\"line\">early log buf free: 15044(91%)</span><br><span class=\"line\">PID hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class=\"line\">Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)</span><br><span class=\"line\">Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)</span><br><span class=\"line\">Memory: 509580K&#x2F;524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14708K reserved, 0K cma-reserved)</span><br><span class=\"line\">Virtual kernel memory layout:</span><br><span class=\"line\">    vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class=\"line\">    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class=\"line\">    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)</span><br><span class=\"line\">    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)</span><br><span class=\"line\">    modules : 0x7f000000 - 0x80000000   (  16 MB)</span><br><span class=\"line\">      .text : 0x80008000 - 0x80700000   (7136 kB)</span><br><span class=\"line\">      .init : 0x80900000 - 0x80a00000   (1024 kB)</span><br><span class=\"line\">      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)</span><br><span class=\"line\">       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)</span><br><span class=\"line\">SLUB: HWalign&#x3D;64, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;4, Nodes&#x3D;1</span><br><span class=\"line\">Hierarchical RCU implementation.</span><br><span class=\"line\">\tRCU event tracing is enabled.</span><br><span class=\"line\">\tRCU restricting CPUs from NR_CPUS&#x3D;8 to nr_cpu_ids&#x3D;4.</span><br><span class=\"line\">RCU: Adjusting geometry for rcu_fanout_leaf&#x3D;16, nr_cpu_ids&#x3D;4</span><br><span class=\"line\">......</span><br><span class=\"line\">input: ImExPS&#x2F;2 Generic Explorer Mouse as &#x2F;devices&#x2F;platform&#x2F;smb@4000000&#x2F;smb@4000000:motherboard&#x2F;smb@4000000:motherboard:iofpga@7,00000000&#x2F;10007000.kmi&#x2F;serio1&#x2F;input&#x2F;input2</span><br><span class=\"line\">VFS: Cannot open root device &quot;(null)&quot; or unknown-block(0,0): error -6</span><br><span class=\"line\">Please append a correct &quot;root&#x3D;&quot; boot option; here are the available partitions:</span><br><span class=\"line\">1f00          131072 mtdblock0 </span><br><span class=\"line\"> (driver?)</span><br><span class=\"line\">1f01           32768 mtdblock1 </span><br><span class=\"line\"> (driver?)</span><br><span class=\"line\">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br><span class=\"line\">CPU: 0 PID: 1 Comm: swapper&#x2F;0 Not tainted 4.14.172 #1</span><br><span class=\"line\">Hardware name: ARM-Versatile Express</span><br><span class=\"line\">[&lt;8010f180&gt;] (unwind_backtrace) from [&lt;8010b444&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class=\"line\">[&lt;8010b444&gt;] (show_stack) from [&lt;806616cc&gt;] (dump_stack+0x94&#x2F;0xa8)</span><br><span class=\"line\">[&lt;806616cc&gt;] (dump_stack) from [&lt;8011d67c&gt;] (panic+0xdc&#x2F;0x248)</span><br><span class=\"line\">[&lt;8011d67c&gt;] (panic) from [&lt;8090129c&gt;] (mount_block_root+0x1d4&#x2F;0x2a8)</span><br><span class=\"line\">[&lt;8090129c&gt;] (mount_block_root) from [&lt;80901490&gt;] (mount_root+0x120&#x2F;0x128)</span><br><span class=\"line\">[&lt;80901490&gt;] (mount_root) from [&lt;809015e8&gt;] (prepare_namespace+0x150&#x2F;0x198)</span><br><span class=\"line\">[&lt;809015e8&gt;] (prepare_namespace) from [&lt;80900ea0&gt;] (kernel_init_freeable+0x244&#x2F;0x254)</span><br><span class=\"line\">[&lt;80900ea0&gt;] (kernel_init_freeable) from [&lt;80674538&gt;] (kernel_init+0x8&#x2F;0x114)</span><br><span class=\"line\">[&lt;80674538&gt;] (kernel_init) from [&lt;801076a8&gt;] (ret_from_fork+0x14&#x2F;0x2c)</span><br><span class=\"line\">---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>\n\n<p>最后的Kernel panic是因为没有挂载根文件系统，下一布制作一个简易文件系统。</p>\n<h2 id=\"5-制作简易根文件系统\"><a href=\"#5-制作简易根文件系统\" class=\"headerlink\" title=\"5. 制作简易根文件系统\"></a>5. 制作简易根文件系统</h2><p>使用busybox制作简易的根文件系统</p>\n<h3 id=\"5-1-下载busybox工具\"><a href=\"#5-1-下载busybox工具\" class=\"headerlink\" title=\"5.1 下载busybox工具\"></a>5.1 下载busybox工具</h3><p>从<a href=\"https://busybox.net/downloads/下载最新的busybox。\" target=\"_blank\" rel=\"noopener\">https://busybox.net/downloads/下载最新的busybox。</a></p>\n<p>同样，建议在windows系统下使用迅雷下载，先找到合适的busybox版本，再用右键，选择用迅雷下载，这样速度会很快；</p>\n<h3 id=\"5-2-解压busybox\"><a href=\"#5-2-解压busybox\" class=\"headerlink\" title=\"5.2 解压busybox\"></a>5.2 解压busybox</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf busybox-1.31.1.tar.bz2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3-配置并编译busybox\"><a href=\"#5-3-配置并编译busybox\" class=\"headerlink\" title=\"5.3 配置并编译busybox\"></a>5.3 配置并编译busybox</h3><h4 id=\"5-3-1-配置\"><a href=\"#5-3-1-配置\" class=\"headerlink\" title=\"5.3.1 配置\"></a>5.3.1 配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>编译选择使用glibc动态库，因为静态库可能会出现一些未知的问题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span></span><br><span class=\"line\">Settings  ---&gt;</span><br><span class=\"line\">    Build Options  ---&gt;</span><br><span class=\"line\">        [ ] Build static binary (no shared libs)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认的安装目录是./_install，如果需要指定安装目录，可以在下边修改：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Settings  ---&gt;</span><br><span class=\"line\">Installation Options (\"make install\" behavior)</span><br><span class=\"line\">(./_install) Destination path for 'make install'</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-2-编译\"><a href=\"#5-3-2-编译\" class=\"headerlink\" title=\"5.3.2 编译\"></a>5.3.2 编译</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-3-安装\"><a href=\"#5-3-3-安装\" class=\"headerlink\" title=\"5.3.3 安装\"></a>5.3.3 安装</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install</span></span><br></pre></td></tr></table></figure>\n\n<p>提示下边信息，表示安装成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------------------------</span><br><span class=\"line\">You will probably need to make your busybox binary</span><br><span class=\"line\">setuid root to ensure all configured applets will</span><br><span class=\"line\">work properly.</span><br><span class=\"line\">--------------------------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>安装完成之后，生成的目标文件默认在./_install目录，这个目标文件目录就是下边要制作根文件系统需要用到的工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls _install/</span></span><br><span class=\"line\">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure>\n\n\n\n<p>或者直接使用CONFIG_PREFIX指定安装目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- CONFIG_PREFIX=/.../rootfs/ install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-4-提前设置好编译默认值\"><a href=\"#5-3-4-提前设置好编译默认值\" class=\"headerlink\" title=\"5.3.4 提前设置好编译默认值\"></a>5.3.4 提前设置好编译默认值</h4><p>编译安装过程中，一直输入ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-比较麻烦，可以在Makefile中设置好默认值；</p>\n<p>修改Makefile:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim Makefile</span></span><br><span class=\"line\">ARCH = arm</span><br><span class=\"line\">CROSS_COMPILE = arm-linux-gnueabi-</span><br></pre></td></tr></table></figure>\n<p>之后的编译、安装命令就简单了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-4-生成简易根文件系统\"><a href=\"#5-4-生成简易根文件系统\" class=\"headerlink\" title=\"5.4 生成简易根文件系统\"></a>5.4 生成简易根文件系统</h3><p>制作一个简易的根文件系统，该文件系统包含的功能极其简陋，仅为了验证Qemu启动Linux内核后挂载跟文件系统的过程。以后会根据具体需要进一步完善该文件系统。</p>\n<h4 id=\"1-编译并安装busybox\"><a href=\"#1-编译并安装busybox\" class=\"headerlink\" title=\"1) 编译并安装busybox\"></a>1) 编译并安装busybox</h4><p>将busybox编译生成的_install目录下的文件全部拷贝到根文件系统目标rootfs/目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir rootfs</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp /.../busybox-1.29.3/_install/* rootfs/ -rfd</span></span><br></pre></td></tr></table></figure>\n<p>也可以在指定busybox的安装目录直接安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make CONFIG_PREFIX=/.../rootfs/ install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-添加glibc库\"><a href=\"#2-添加glibc库\" class=\"headerlink\" title=\"2) 添加glibc库\"></a>2) 添加glibc库</h4><p>在根文件系统中添加加载器和动态库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir rootfs/lib</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp /usr/arm-linux-gnueabi/lib/* rootfs/lib/ -rfp</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-静态创建设备文件\"><a href=\"#3-静态创建设备文件\" class=\"headerlink\" title=\"3) 静态创建设备文件\"></a>3) 静态创建设备文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir rootfs/dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> rootfs/dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty1 c 4 1</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty2 c 4 2</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty3 c 4 3</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty4 c 4 4</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 console c 5 1</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 null c 1 3</span></span><br></pre></td></tr></table></figure>\n<p>至此，简易版根文件系统就制作完成，该根文件系统只含有最基本的功能，一些其他功能在以后的操作中会进行添加，如有兴趣可以继续参考下一篇文章《》《》。</p>\n<h3 id=\"5-5-制作SD卡文件系统镜像\"><a href=\"#5-5-制作SD卡文件系统镜像\" class=\"headerlink\" title=\"5.5 制作SD卡文件系统镜像\"></a>5.5 制作SD卡文件系统镜像</h3><h4 id=\"1-生成一个空的SD卡镜像：\"><a href=\"#1-生成一个空的SD卡镜像：\" class=\"headerlink\" title=\"1) 生成一个空的SD卡镜像：\"></a>1) 生成一个空的SD卡镜像：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dd <span class=\"keyword\">if</span>=/dev/zero of=rootfs.ext3 bs=1M count=32</span></span><br><span class=\"line\">32+0 records in</span><br><span class=\"line\">32+0 records out</span><br><span class=\"line\">33554432 bytes (34 MB, 32 MiB) copied, 0.0236764 s, 1.4 GB/s</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-将SD卡格式化为exts文件系统：\"><a href=\"#2-将SD卡格式化为exts文件系统：\" class=\"headerlink\" title=\"2) 将SD卡格式化为exts文件系统：\"></a>2) 将SD卡格式化为exts文件系统：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkfs.ext3 rootfs.ext3</span></span><br><span class=\"line\">mke2fs 1.42.13 (17-May-2015)</span><br><span class=\"line\">Discarding device blocks: done                            </span><br><span class=\"line\">Creating filesystem with 32768 1k blocks and 8192 inodes</span><br><span class=\"line\">Filesystem UUID: 51ab1063-a137-48e5-a6f4-4552dad3b898</span><br><span class=\"line\">Superblock backups stored on blocks:</span><br><span class=\"line\">    8193, 24577</span><br><span class=\"line\"></span><br><span class=\"line\">Allocating group tables: done                            </span><br><span class=\"line\">Writing inode tables: done                            </span><br><span class=\"line\">Creating journal (4096 blocks): done</span><br><span class=\"line\">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-将rootfs烧写到SD卡：\"><a href=\"#3-将rootfs烧写到SD卡：\" class=\"headerlink\" title=\"3) 将rootfs烧写到SD卡：\"></a>3) 将rootfs烧写到SD卡：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo mount -t ext3 rootfs.ext3 /mnt -o loop</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo cp -rf rootfs/* /mnt/</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo umount /mnt</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在开发过程中，如果需要修改SD卡中的内容，可以将SD卡的镜像rootfs.ext3挂载到/mnt目录下，直接操作/mnt来修改；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo mount -t ext3 rootfs.ext3 /mnt -o loop</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp rootfs.ext3 ~/qemu</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-验证\"><a href=\"#6-验证\" class=\"headerlink\" title=\"6. 验证\"></a>6. 验证</h2><h3 id=\"1-Qemu启动命令：\"><a href=\"#1-Qemu启动命令：\" class=\"headerlink\" title=\"1) Qemu启动命令：\"></a>1) Qemu启动命令：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"root=/dev/mmcblk0 rw console=ttyAMA0\"</span> -sd rootfs.ext3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-启动脚本：\"><a href=\"#2-启动脚本：\" class=\"headerlink\" title=\"2) 启动脚本：\"></a>2) 启动脚本：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> boot.sh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/sh</span></span><br><span class=\"line\">qemu-system-arm \\</span><br><span class=\"line\">        -M vexpress-a9  \\</span><br><span class=\"line\">        -m 512M \\</span><br><span class=\"line\">        -kernel ~/qemu/zImage   \\   </span><br><span class=\"line\">        -dtb ~/qemu/vexpress-v2p-ca9.dtb    \\   </span><br><span class=\"line\">        -nographic  \\</span><br><span class=\"line\">        -append \"root=/dev/mmcblk0 rw console=ttyAMA0\"    \\</span><br><span class=\"line\">        -sd rootfs.ext3</span><br></pre></td></tr></table></figure>\n\n<p>以上为在串口终端启动系统，按照以下的启动命令可以使用LCD屏作为输出启动系统。</p>\n<h3 id=\"3-图形化启动内核：\"><a href=\"#3-图形化启动内核：\" class=\"headerlink\" title=\"3) 图形化启动内核：\"></a>3) 图形化启动内核：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -append \"root=/dev/mmcblk0 rw console=tty0\" -sd rootfs.ext3</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-启动验证：\"><a href=\"#4-启动验证：\" class=\"headerlink\" title=\"4) 启动验证：\"></a>4) 启动验证：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...</span><br><span class=\"line\">request_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now</span><br><span class=\"line\">Starting init: &#x2F;sbin&#x2F;init exists but couldn&#39;t execute it (error -8)</span><br><span class=\"line\">request_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...</span><br><span class=\"line\">request_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now</span><br><span class=\"line\">Starting init: &#x2F;bin&#x2F;sh exists but couldn&#39;t execute it (error -8)</span><br><span class=\"line\">Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class=\"line\">CPU: 0 PID: 1 Comm: swapper&#x2F;0 Not tainted 4.14.172 #1</span><br><span class=\"line\">Hardware name: ARM-Versatile Express</span><br><span class=\"line\">[&lt;8010f180&gt;] (unwind_backtrace) from [&lt;8010b444&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class=\"line\">[&lt;8010b444&gt;] (show_stack) from [&lt;806616cc&gt;] (dump_stack+0x94&#x2F;0xa8)</span><br><span class=\"line\">[&lt;806616cc&gt;] (dump_stack) from [&lt;8011d67c&gt;] (panic+0xdc&#x2F;0x248)</span><br><span class=\"line\">[&lt;8011d67c&gt;] (panic) from [&lt;80674634&gt;] (kernel_init+0x104&#x2F;0x114)</span><br><span class=\"line\">[&lt;80674634&gt;] (kernel_init) from [&lt;801076a8&gt;] (ret_from_fork+0x14&#x2F;0x2c)</span><br><span class=\"line\">---[ end Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class=\"line\">QEMU: Terminated</span><br></pre></td></tr></table></figure>\n\n<p>如上问题是由于编译生成的busybox工具，是x86环境下使用的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> file bin/busybox </span></span><br><span class=\"line\">bin/busybox: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=7fe433943e201f5337be6116a883d54fc1a4a349, stripped</span><br></pre></td></tr></table></figure>\n\n<p>是因为在安装busybox的时候，使用了make install，应该使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install</span><br></pre></td></tr></table></figure>\n\n<p>编译工具生成arm平台使用的busybox工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> file rootfs/bin/busybox</span></span><br><span class=\"line\">rootfs/bin/busybox: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=cbcd33b8d6c946cb19408a5e8e714de554c87f52, stripped</span><br></pre></td></tr></table></figure>\n\n<p>再次验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtc-pl031 10017000.rtc: setting system clock to 2018-09-24 13:22:14 UTC (1537795334)</span><br><span class=\"line\">ALSA device list:</span><br><span class=\"line\">  #0: ARM AC&#39;97 Interface PL041 rev0 at 0x10004000, irq 33</span><br><span class=\"line\">input: ImExPS&#x2F;2 Generic Explorer Mouse as &#x2F;devices&#x2F;platform&#x2F;smb&#x2F;smb:motherboard&#x2F;smb:motherboard:iofpga@7,00000000&#x2F;10007000.kmi&#x2F;serio1&#x2F;input&#x2F;input2</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem</span><br><span class=\"line\">EXT4-fs (mmcblk0): recovery complete</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class=\"line\">VFS: Mounted root (ext3 filesystem) on device 179:0.</span><br><span class=\"line\">Freeing unused kernel memory: 284K</span><br><span class=\"line\">random: nonblocking pool is initialized</span><br><span class=\"line\">can&#39;t run &#39;&#x2F;etc&#x2F;init.d&#x2F;rcS&#39;: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">Please press Enter to activate this console.</span><br><span class=\"line\">&#x2F; #</span><br><span class=\"line\">&#x2F; #</span><br><span class=\"line\">&#x2F; # uname -a</span><br><span class=\"line\">Linux (none) 4.4.157 #1 SMP Sun Sep 23 21:11:22 CST 2018 armv7l GNU&#x2F;Linux</span><br></pre></td></tr></table></figure>\n\n<p>至此，Qemu启动Linux内核并挂载跟文件系统已经启动成功，通过串口终端可以正常和系统进行简单功能的交互。<br>打印中提示的不能运行/etc/init.d/rcS问题，只需要添加/etc/init.d/rcS文件即可，文件内容可以是提示语句。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/init.d/rcS</span></span><br><span class=\"line\">Hello Qemu Linux!</span><br></pre></td></tr></table></figure>\n\n<p>注意，要在创建/etc/init.d/rcS文件时，记着修改该文件的可执行权限，否则启动过程中会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Freeing unused kernel memory: 1024K</span><br><span class=\"line\">random: crng init done</span><br><span class=\"line\">can&#39;t run &#39;&#x2F;etc&#x2F;init.d&#x2F;rcS&#39;: Permission denied</span><br><span class=\"line\"></span><br><span class=\"line\">Please press Enter to activate this console.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"7-退出Qemu环境\"><a href=\"#7-退出Qemu环境\" class=\"headerlink\" title=\"7. 退出Qemu环境\"></a>7. 退出Qemu环境</h2><p>Qemu环境搭建好之后，在出错时需要关闭并重新启动Qemu，不用的时候需要关闭Qemu。</p>\n<h3 id=\"1）手动退出Qemu\"><a href=\"#1）手动退出Qemu\" class=\"headerlink\" title=\"1）手动退出Qemu\"></a>1）手动退出Qemu</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl + A; X</span><br></pre></td></tr></table></figure>\n\n<p>操作之后，终端上会打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QEMU: Terminated</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2）强制退出Qemu\"><a href=\"#2）强制退出Qemu\" class=\"headerlink\" title=\"2）强制退出Qemu\"></a>2）强制退出Qemu</h3><p>有时候会发现无法通过shutdown等工具关闭，因为Qemu也是一个进程，可以通过杀掉Qemu进程的方法关闭Qemu模拟环境。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ps -a</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">kill</span> xxx</span></span><br></pre></td></tr></table></figure>\n\n<p>如下可以采用脚本运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat kill_qemu.sh </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/sh</span></span><br><span class=\"line\">ps -a | grep qemu-system-arm | awk '&#123;print $1&#125;' | xargs sudo kill -9</span><br></pre></td></tr></table></figure>\n\n<p>本文讲述了Qemu环境启动Linux内核，并挂载SD卡中的根文件系统的一些操作步骤。如果需要在Qemu环境下以ARM开发板的正常启动流程来加载Linux内核并挂载根文件系统，可以参考下一篇文章《<a href=\"https://www.jianshu.com/p/8619a6739040\" target=\"_blank\" rel=\"noopener\">Qemu搭建ARM vexpress开发环境(二)—-通过u-boot启动Linux内核</a>》。</p>\n","site":{"data":{}},"excerpt":"<p>标签： Qemu</p>\n<hr>\n<p>嵌入式软件开发依赖于嵌入式硬件设备，比如：开发板、外部模块设备等，但是如果只是想学习、研究Linux内核，想学习Linux内核的架构，工作模式，需要修改一些代码，重新编译并烧写到开发板中进行验证，这样未必有些复杂，并且为此专门购买各种开发版，浪费资金，开会演示效果还需要携带一大串的板子和电线，不胜其烦。然而Qemu的使用可以避免频繁在开发板上烧写版本，如果进行的调试工作与外设无关，仅仅是内核方面的调试，Qemu模拟ARM开发环境完全可以完美地胜任。</p>","more":"<p>下面简单介绍下我的Qemu开发环境搭建过程</p>\n<h2 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h2><p>由于在开发过程中也需要Windows系统下的一些工具，双系统环境切换操作系统时必须重启，于是放弃了以前搭建的双系统环境，而采用在PC的Windows10系统下通过VirtualBox虚拟机安装Xubuntu系统进行开发，避免了双系统开发中需要不断重启切换PC系统的问题。Xubuntu系统和Ubuntu系统大同小异，只是桌面封装更加简洁。</p>\n<h3 id=\"1-1-所使用环境\"><a href=\"#1-1-所使用环境\" class=\"headerlink\" title=\"1.1 所使用环境\"></a>1.1 所使用环境</h3><blockquote>\n<p>Ubuntu-18.04.1</p>\n</blockquote>\n<p>或：</p>\n<blockquote>\n<p>PC系统：Windows10<br>虚拟机：VirtualBox-5.18<br>虚拟机系统：Xubuntu<br>模拟的开发板：vexpress</p>\n</blockquote>\n<h3 id=\"1-2-搭建环境时使用的工具\"><a href=\"#1-2-搭建环境时使用的工具\" class=\"headerlink\" title=\"1.2 搭建环境时使用的工具\"></a>1.2 搭建环境时使用的工具</h3><p>qemu-4.2.0<br>linux-4.14.172(Linux Kernel)<br>u-boot-2017.05<br>busybox-1.31.1<br>arm-linux-gnueabi-gcc (Linaro 7.5.0-3)</p>\n<p>为了将Qemu搭建开发环境资料统一放到一起，创建～/qemu目录，所有相关文件全部放置在一起；</p>\n<h2 id=\"2-安装交叉编译工具\"><a href=\"#2-安装交叉编译工具\" class=\"headerlink\" title=\"2. 安装交叉编译工具\"></a>2. 安装交叉编译工具</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install gcc-arm-linux-gnueabi</span></span><br></pre></td></tr></table></figure>\n\n<p>查看安装是否成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> arm-linux-gnueabi-gcc -v</span></span><br><span class=\"line\">Using built-in specs.</span><br><span class=\"line\">COLLECT_GCC=arm-linux-gnueabi-gcc</span><br><span class=\"line\">COLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/arm-linux-gnueabi/7/lto-wrapper</span><br><span class=\"line\">Target: arm-linux-gnueabi</span><br><span class=\"line\">Configured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-multiarch --enable-multilib --disable-sjlj-exceptions --with-arch=armv5t --with-float=soft --disable-werror --enable-multilib --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabi --program-prefix=arm-linux-gnueabi- --includedir=/usr/arm-linux-gnueabi/include</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-安装Qemu工具\"><a href=\"#3-安装Qemu工具\" class=\"headerlink\" title=\"3. 安装Qemu工具\"></a>3. 安装Qemu工具</h2><p>有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要第二种方法，通过Git工具下载源码，切换到最新分支再去编译安装了；但是一般情况下通过git下载代码速度极慢，我们可以使用第三种方法，找到要下载的qemu版本，使用迅雷下载；具体操作如下所述：</p>\n<h3 id=\"3-1-快速安装Qemu\"><a href=\"#3-1-快速安装Qemu\" class=\"headerlink\" title=\"3.1 快速安装Qemu\"></a>3.1 快速安装Qemu</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install qemu</span></span><br></pre></td></tr></table></figure>\n\n<p>这种情况下安装的qemu版本可能不是最新版本；如果想要安装最新版本的qemu，还得使用下边介绍的使用源代码编译安装的方法；</p>\n<h3 id=\"3-2-下载Qemu源码编译安装\"><a href=\"#3-2-下载Qemu源码编译安装\" class=\"headerlink\" title=\"3.2 下载Qemu源码编译安装\"></a>3.2 下载Qemu源码编译安装</h3><h4 id=\"3-2-1-下载Qemu源码\"><a href=\"#3-2-1-下载Qemu源码\" class=\"headerlink\" title=\"3.2.1 下载Qemu源码\"></a>3.2.1 下载Qemu源码</h4><ol>\n<li>从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git://git.qemu-project.org/qemu.git</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> qemu</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git checkout -b stable-*** remotes/origin/stable-***</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>在windows系统下使用迅雷下载</p>\n<p>登陆download.qemu.org网站，选择需要的版本，点击下载，或者右键后选使用迅雷下载，速度会更快：</p>\n<p>在这里选择qemu-4.2.0.tar.xz使用；</p>\n</li>\n</ol>\n<h4 id=\"3-2-2-安装\"><a href=\"#3-2-2-安装\" class=\"headerlink\" title=\"3.2.2 安装\"></a>3.2.2 安装</h4><p>在配置qemu之前，需要安装一些依赖的库或者软件包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install zlib1g-dev </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libglib2.0-0</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libglib2.0-dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libtool</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libsdl1.2-dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install autoconf</span></span><br></pre></td></tr></table></figure>\n\n<p>解压源代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf qemu-4.2.0.tar.xz</span></span><br></pre></td></tr></table></figure>\n\n<p>为了防止编译后文件比较乱，选择创建build目录作为编译中间目标路径：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> qemu-4.2.0/</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir build</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> build/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>配置、编译并安装Qemu：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ../configure --target-list=arm-softmmu --audio-drv-list=</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-3-在编译过程中可能出现的问题\"><a href=\"#3-2-3-在编译过程中可能出现的问题\" class=\"headerlink\" title=\"3.2.3 在编译过程中可能出现的问题\"></a>3.2.3 在编译过程中可能出现的问题</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ../configure --target-list=arm-softmmu --audio-drv-list=</span></span><br><span class=\"line\">ERROR: pkg-config binary 'pkg-config' not found</span><br></pre></td></tr></table></figure>\n\n<p>缺少库文件，按照上一步中的步骤安装库文件；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ../configure --target-list=arm-softmmu --audio-drv-list=</span></span><br><span class=\"line\">ERROR: pixman &gt;= 0.21.8 not present.</span><br><span class=\"line\">       Please install the pixman devel package.</span><br></pre></td></tr></table></figure>\n\n<p>可以通过apt-cache查询缺少的依赖库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> apt-cache search pixman</span></span><br><span class=\"line\">libpixman-1-0 - pixel-manipulation library for X and cairo</span><br><span class=\"line\">libpixman-1-dev - pixel-manipulation library for X and cairo (development files)</span><br></pre></td></tr></table></figure>\n\n<p>安装缺少的依赖库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libpixman-1-0</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install libpixman-1-dev</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-3-查看Qemu版本\"><a href=\"#3-3-查看Qemu版本\" class=\"headerlink\" title=\"3.3 查看Qemu版本\"></a>3.3 查看Qemu版本</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm --version</span></span><br><span class=\"line\">QEMU emulator version 4.2.0</span><br><span class=\"line\">Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-4-查看Qemu支持的开发板\"><a href=\"#3-4-查看Qemu支持的开发板\" class=\"headerlink\" title=\"3.4 查看Qemu支持的开发板\"></a>3.4 查看Qemu支持的开发板</h3><p>Qemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M <span class=\"built_in\">help</span></span></span><br><span class=\"line\">......</span><br><span class=\"line\">vexpress-a15         ARM Versatile Express for Cortex-A15</span><br><span class=\"line\">vexpress-a9          ARM Versatile Express for Cortex-A9</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-5-运行Qemu\"><a href=\"#3-5-运行Qemu\" class=\"headerlink\" title=\"3.5 运行Qemu\"></a>3.5 运行Qemu</h3><p>该操作目前还不能运行，因为还没有编译内核，如果手边有编译好的别的版本的zImage文件，可以通过下面命令尝试运行看下效果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel ./zImage -dtb ./vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"console=ttyAMA0\"</span></span></span><br><span class=\"line\">    -M          指定开发板</span><br><span class=\"line\">    -m          指定内存大小</span><br><span class=\"line\">    -kernel     指定内核文件</span><br><span class=\"line\">    -dtb        指定dtb文件</span><br><span class=\"line\">    -nographic  指定不需要图形界面</span><br><span class=\"line\">    -append     指定扩展显示界面，串口或者LCD</span><br></pre></td></tr></table></figure>\n\n<p>实例参考：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"console=ttyAMA0\"</span></span></span><br><span class=\"line\">-M vexpress-a9\t模拟vexpress-a9板，可以使用-M ?参数来查询qemu支持的所有单板</span><br><span class=\"line\">-m 512M\t单板物理内存512M</span><br><span class=\"line\">-kernel\t~/qemu/zImage\t指定内和镜像及路径</span><br><span class=\"line\">-dtb ~/qemu/vexpress-v2p-ca9.dtb\t指定单板的设备树文件</span><br><span class=\"line\">-nographic\t不使用图形界面，使用串口</span><br><span class=\"line\">-append \"console=ttyAMA0\"\t指定内核启动参数，串口设备使用ttyAMA0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-配置并编译Linux内核\"><a href=\"#4-配置并编译Linux内核\" class=\"headerlink\" title=\"4. 配置并编译Linux内核\"></a>4. 配置并编译Linux内核</h2><h3 id=\"4-1-下载Linux内核\"><a href=\"#4-1-下载Linux内核\" class=\"headerlink\" title=\"4.1 下载Linux内核\"></a>4.1 下载Linux内核</h3><p>通过众所周知的内核下载网站<a href=\"http://www.kernel.org下载需要的内核版本，这里我下载的是相对来说最新的长期支持的内核版本linux-4.4.157。\" target=\"_blank\" rel=\"noopener\">www.kernel.org下载需要的内核版本，这里我下载的是相对来说最新的长期支持的内核版本linux-4.4.157。</a></p>\n<h3 id=\"4-2-解压Linux内核\"><a href=\"#4-2-解压Linux内核\" class=\"headerlink\" title=\"4.2 解压Linux内核\"></a>4.2 解压Linux内核</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf linux-4.4.157.tar.xz</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-3-编译Linux内核\"><a href=\"#4-3-编译Linux内核\" class=\"headerlink\" title=\"4.3 编译Linux内核\"></a>4.3 编译Linux内核</h3><h4 id=\"4-3-1-配置\"><a href=\"#4-3-1-配置\" class=\"headerlink\" title=\"4.3.1 配置\"></a>4.3.1 配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_defconfig ARCH=arm O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">  HOSTCC  scripts/basic/fixdep</span><br><span class=\"line\">  GEN     ./Makefile</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/conf.o</span><br><span class=\"line\">  SHIPPED scripts/kconfig/zconf.tab.c</span><br><span class=\"line\">  SHIPPED scripts/kconfig/zconf.lex.c</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class=\"line\">  HOSTLD  scripts/kconfig/conf</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> configuration written to .config</span></span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig -j4 O=./object</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-3-2-编译\"><a href=\"#4-3-2-编译\" class=\"headerlink\" title=\"4.3.2 编译\"></a>4.3.2 编译</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object</span></span><br></pre></td></tr></table></figure>\n\n<p>或者在Makefile中配置默认值，指定ARCH和CROSS_COMPILE，免得每次编译都需要带参数；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_defconfig</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make zImage -j4</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make modules -j4    // 编译驱动模块</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make dtbs\t\t// 编译设备树</span></span><br></pre></td></tr></table></figure>\n<p>得到编译文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch/arm/boot/zImage</span><br><span class=\"line\">arch/arm/boot/dts/vexpress-v2p-ca9.dtb</span><br></pre></td></tr></table></figure>\n\n<p>分别将编译生成的zImage和vexpress-v2p-ca9.dtb文件放到~/qemu目录；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp arch/arm/boot/zImage ~/qemu</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp arch/arm/boot/dts/vexpress-v2p-ca9.dtb ~/qemu</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-4-Qemu启动命令\"><a href=\"#4-4-Qemu启动命令\" class=\"headerlink\" title=\"4.4 Qemu启动命令\"></a>4.4 Qemu启动命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel kernel/linux-4.4.157/arch/arm/boot/zImage -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"console=ttyAMA0\"</span></span></span><br></pre></td></tr></table></figure>\n<p>Qemu的启动命令需要带好几个参数，完成启动命令比较长，每次都输入很可能会出现错误，为了使用方便，可以将该命令放到shell脚本中执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat boot.sh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/sh</span></span><br><span class=\"line\">qemu-system-arm \\</span><br><span class=\"line\">        -M vexpress-a9  \\</span><br><span class=\"line\">        -m 512M \\</span><br><span class=\"line\">        -kernel kernel/linux-4.4.157/arch/arm/boot/zImage   \\   </span><br><span class=\"line\">        -dtb kernel/linux-4.4.157/arch/arm/boot/dts/vexpress-v2p-ca9.dtb    \\   </span><br><span class=\"line\">        -nographic  \\</span><br><span class=\"line\">        -append \"console=ttyAMA0\"</span><br></pre></td></tr></table></figure>\n\n<p>启动日志<br>内核成功启动，内核的启动打印信息非常多。启动最后出错是因为没有挂载根文件系统。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ qemu-system-arm -M vexpress-a9 -m 512M -kernel ~&#x2F;qemu&#x2F;zImage -dtb ~&#x2F;qemu&#x2F;vexpress-v2p-ca9.dtb -nographic -append &quot;console&#x3D;ttyAMA0&quot;</span><br><span class=\"line\">Booting Linux on physical CPU 0x0</span><br><span class=\"line\">Linux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020</span><br><span class=\"line\">CPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr&#x3D;10c5387d</span><br><span class=\"line\">CPU: PIPT &#x2F; VIPT nonaliasing data cache, VIPT nonaliasing instruction cache</span><br><span class=\"line\">OF: fdt: Machine model: V2P-CA9</span><br><span class=\"line\">Memory policy: Data cache writeback</span><br><span class=\"line\">CPU: All CPU(s) started in SVC mode.</span><br><span class=\"line\">percpu: Embedded 15 pages&#x2F;cpu s32396 r8192 d20852 u61440</span><br><span class=\"line\">Built 1 zonelists, mobility grouping on.  Total pages: 130048</span><br><span class=\"line\">Kernel command line: console&#x3D;ttyAMA0</span><br><span class=\"line\">log_buf_len individual max cpu contribution: 4096 bytes</span><br><span class=\"line\">log_buf_len total cpu_extra contributions: 12288 bytes</span><br><span class=\"line\">log_buf_len min size: 16384 bytes</span><br><span class=\"line\">log_buf_len: 32768 bytes</span><br><span class=\"line\">early log buf free: 15044(91%)</span><br><span class=\"line\">PID hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class=\"line\">Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)</span><br><span class=\"line\">Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)</span><br><span class=\"line\">Memory: 509580K&#x2F;524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14708K reserved, 0K cma-reserved)</span><br><span class=\"line\">Virtual kernel memory layout:</span><br><span class=\"line\">    vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class=\"line\">    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class=\"line\">    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)</span><br><span class=\"line\">    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)</span><br><span class=\"line\">    modules : 0x7f000000 - 0x80000000   (  16 MB)</span><br><span class=\"line\">      .text : 0x80008000 - 0x80700000   (7136 kB)</span><br><span class=\"line\">      .init : 0x80900000 - 0x80a00000   (1024 kB)</span><br><span class=\"line\">      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)</span><br><span class=\"line\">       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)</span><br><span class=\"line\">SLUB: HWalign&#x3D;64, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;4, Nodes&#x3D;1</span><br><span class=\"line\">Hierarchical RCU implementation.</span><br><span class=\"line\">\tRCU event tracing is enabled.</span><br><span class=\"line\">\tRCU restricting CPUs from NR_CPUS&#x3D;8 to nr_cpu_ids&#x3D;4.</span><br><span class=\"line\">RCU: Adjusting geometry for rcu_fanout_leaf&#x3D;16, nr_cpu_ids&#x3D;4</span><br><span class=\"line\">......</span><br><span class=\"line\">input: ImExPS&#x2F;2 Generic Explorer Mouse as &#x2F;devices&#x2F;platform&#x2F;smb@4000000&#x2F;smb@4000000:motherboard&#x2F;smb@4000000:motherboard:iofpga@7,00000000&#x2F;10007000.kmi&#x2F;serio1&#x2F;input&#x2F;input2</span><br><span class=\"line\">VFS: Cannot open root device &quot;(null)&quot; or unknown-block(0,0): error -6</span><br><span class=\"line\">Please append a correct &quot;root&#x3D;&quot; boot option; here are the available partitions:</span><br><span class=\"line\">1f00          131072 mtdblock0 </span><br><span class=\"line\"> (driver?)</span><br><span class=\"line\">1f01           32768 mtdblock1 </span><br><span class=\"line\"> (driver?)</span><br><span class=\"line\">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br><span class=\"line\">CPU: 0 PID: 1 Comm: swapper&#x2F;0 Not tainted 4.14.172 #1</span><br><span class=\"line\">Hardware name: ARM-Versatile Express</span><br><span class=\"line\">[&lt;8010f180&gt;] (unwind_backtrace) from [&lt;8010b444&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class=\"line\">[&lt;8010b444&gt;] (show_stack) from [&lt;806616cc&gt;] (dump_stack+0x94&#x2F;0xa8)</span><br><span class=\"line\">[&lt;806616cc&gt;] (dump_stack) from [&lt;8011d67c&gt;] (panic+0xdc&#x2F;0x248)</span><br><span class=\"line\">[&lt;8011d67c&gt;] (panic) from [&lt;8090129c&gt;] (mount_block_root+0x1d4&#x2F;0x2a8)</span><br><span class=\"line\">[&lt;8090129c&gt;] (mount_block_root) from [&lt;80901490&gt;] (mount_root+0x120&#x2F;0x128)</span><br><span class=\"line\">[&lt;80901490&gt;] (mount_root) from [&lt;809015e8&gt;] (prepare_namespace+0x150&#x2F;0x198)</span><br><span class=\"line\">[&lt;809015e8&gt;] (prepare_namespace) from [&lt;80900ea0&gt;] (kernel_init_freeable+0x244&#x2F;0x254)</span><br><span class=\"line\">[&lt;80900ea0&gt;] (kernel_init_freeable) from [&lt;80674538&gt;] (kernel_init+0x8&#x2F;0x114)</span><br><span class=\"line\">[&lt;80674538&gt;] (kernel_init) from [&lt;801076a8&gt;] (ret_from_fork+0x14&#x2F;0x2c)</span><br><span class=\"line\">---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>\n\n<p>最后的Kernel panic是因为没有挂载根文件系统，下一布制作一个简易文件系统。</p>\n<h2 id=\"5-制作简易根文件系统\"><a href=\"#5-制作简易根文件系统\" class=\"headerlink\" title=\"5. 制作简易根文件系统\"></a>5. 制作简易根文件系统</h2><p>使用busybox制作简易的根文件系统</p>\n<h3 id=\"5-1-下载busybox工具\"><a href=\"#5-1-下载busybox工具\" class=\"headerlink\" title=\"5.1 下载busybox工具\"></a>5.1 下载busybox工具</h3><p>从<a href=\"https://busybox.net/downloads/下载最新的busybox。\" target=\"_blank\" rel=\"noopener\">https://busybox.net/downloads/下载最新的busybox。</a></p>\n<p>同样，建议在windows系统下使用迅雷下载，先找到合适的busybox版本，再用右键，选择用迅雷下载，这样速度会很快；</p>\n<h3 id=\"5-2-解压busybox\"><a href=\"#5-2-解压busybox\" class=\"headerlink\" title=\"5.2 解压busybox\"></a>5.2 解压busybox</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf busybox-1.31.1.tar.bz2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3-配置并编译busybox\"><a href=\"#5-3-配置并编译busybox\" class=\"headerlink\" title=\"5.3 配置并编译busybox\"></a>5.3 配置并编译busybox</h3><h4 id=\"5-3-1-配置\"><a href=\"#5-3-1-配置\" class=\"headerlink\" title=\"5.3.1 配置\"></a>5.3.1 配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>编译选择使用glibc动态库，因为静态库可能会出现一些未知的问题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span></span><br><span class=\"line\">Settings  ---&gt;</span><br><span class=\"line\">    Build Options  ---&gt;</span><br><span class=\"line\">        [ ] Build static binary (no shared libs)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认的安装目录是./_install，如果需要指定安装目录，可以在下边修改：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Settings  ---&gt;</span><br><span class=\"line\">Installation Options (\"make install\" behavior)</span><br><span class=\"line\">(./_install) Destination path for 'make install'</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-2-编译\"><a href=\"#5-3-2-编译\" class=\"headerlink\" title=\"5.3.2 编译\"></a>5.3.2 编译</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-3-安装\"><a href=\"#5-3-3-安装\" class=\"headerlink\" title=\"5.3.3 安装\"></a>5.3.3 安装</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install</span></span><br></pre></td></tr></table></figure>\n\n<p>提示下边信息，表示安装成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------------------------</span><br><span class=\"line\">You will probably need to make your busybox binary</span><br><span class=\"line\">setuid root to ensure all configured applets will</span><br><span class=\"line\">work properly.</span><br><span class=\"line\">--------------------------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>安装完成之后，生成的目标文件默认在./_install目录，这个目标文件目录就是下边要制作根文件系统需要用到的工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls _install/</span></span><br><span class=\"line\">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure>\n\n\n\n<p>或者直接使用CONFIG_PREFIX指定安装目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- CONFIG_PREFIX=/.../rootfs/ install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-4-提前设置好编译默认值\"><a href=\"#5-3-4-提前设置好编译默认值\" class=\"headerlink\" title=\"5.3.4 提前设置好编译默认值\"></a>5.3.4 提前设置好编译默认值</h4><p>编译安装过程中，一直输入ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-比较麻烦，可以在Makefile中设置好默认值；</p>\n<p>修改Makefile:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim Makefile</span></span><br><span class=\"line\">ARCH = arm</span><br><span class=\"line\">CROSS_COMPILE = arm-linux-gnueabi-</span><br></pre></td></tr></table></figure>\n<p>之后的编译、安装命令就简单了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-4-生成简易根文件系统\"><a href=\"#5-4-生成简易根文件系统\" class=\"headerlink\" title=\"5.4 生成简易根文件系统\"></a>5.4 生成简易根文件系统</h3><p>制作一个简易的根文件系统，该文件系统包含的功能极其简陋，仅为了验证Qemu启动Linux内核后挂载跟文件系统的过程。以后会根据具体需要进一步完善该文件系统。</p>\n<h4 id=\"1-编译并安装busybox\"><a href=\"#1-编译并安装busybox\" class=\"headerlink\" title=\"1) 编译并安装busybox\"></a>1) 编译并安装busybox</h4><p>将busybox编译生成的_install目录下的文件全部拷贝到根文件系统目标rootfs/目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir rootfs</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp /.../busybox-1.29.3/_install/* rootfs/ -rfd</span></span><br></pre></td></tr></table></figure>\n<p>也可以在指定busybox的安装目录直接安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make CONFIG_PREFIX=/.../rootfs/ install</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-添加glibc库\"><a href=\"#2-添加glibc库\" class=\"headerlink\" title=\"2) 添加glibc库\"></a>2) 添加glibc库</h4><p>在根文件系统中添加加载器和动态库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir rootfs/lib</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp /usr/arm-linux-gnueabi/lib/* rootfs/lib/ -rfp</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-静态创建设备文件\"><a href=\"#3-静态创建设备文件\" class=\"headerlink\" title=\"3) 静态创建设备文件\"></a>3) 静态创建设备文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir rootfs/dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> rootfs/dev</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty1 c 4 1</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty2 c 4 2</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty3 c 4 3</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 tty4 c 4 4</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 console c 5 1</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mknod -m 666 null c 1 3</span></span><br></pre></td></tr></table></figure>\n<p>至此，简易版根文件系统就制作完成，该根文件系统只含有最基本的功能，一些其他功能在以后的操作中会进行添加，如有兴趣可以继续参考下一篇文章《》《》。</p>\n<h3 id=\"5-5-制作SD卡文件系统镜像\"><a href=\"#5-5-制作SD卡文件系统镜像\" class=\"headerlink\" title=\"5.5 制作SD卡文件系统镜像\"></a>5.5 制作SD卡文件系统镜像</h3><h4 id=\"1-生成一个空的SD卡镜像：\"><a href=\"#1-生成一个空的SD卡镜像：\" class=\"headerlink\" title=\"1) 生成一个空的SD卡镜像：\"></a>1) 生成一个空的SD卡镜像：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dd <span class=\"keyword\">if</span>=/dev/zero of=rootfs.ext3 bs=1M count=32</span></span><br><span class=\"line\">32+0 records in</span><br><span class=\"line\">32+0 records out</span><br><span class=\"line\">33554432 bytes (34 MB, 32 MiB) copied, 0.0236764 s, 1.4 GB/s</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-将SD卡格式化为exts文件系统：\"><a href=\"#2-将SD卡格式化为exts文件系统：\" class=\"headerlink\" title=\"2) 将SD卡格式化为exts文件系统：\"></a>2) 将SD卡格式化为exts文件系统：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkfs.ext3 rootfs.ext3</span></span><br><span class=\"line\">mke2fs 1.42.13 (17-May-2015)</span><br><span class=\"line\">Discarding device blocks: done                            </span><br><span class=\"line\">Creating filesystem with 32768 1k blocks and 8192 inodes</span><br><span class=\"line\">Filesystem UUID: 51ab1063-a137-48e5-a6f4-4552dad3b898</span><br><span class=\"line\">Superblock backups stored on blocks:</span><br><span class=\"line\">    8193, 24577</span><br><span class=\"line\"></span><br><span class=\"line\">Allocating group tables: done                            </span><br><span class=\"line\">Writing inode tables: done                            </span><br><span class=\"line\">Creating journal (4096 blocks): done</span><br><span class=\"line\">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-将rootfs烧写到SD卡：\"><a href=\"#3-将rootfs烧写到SD卡：\" class=\"headerlink\" title=\"3) 将rootfs烧写到SD卡：\"></a>3) 将rootfs烧写到SD卡：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo mount -t ext3 rootfs.ext3 /mnt -o loop</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo cp -rf rootfs/* /mnt/</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo umount /mnt</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在开发过程中，如果需要修改SD卡中的内容，可以将SD卡的镜像rootfs.ext3挂载到/mnt目录下，直接操作/mnt来修改；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo mount -t ext3 rootfs.ext3 /mnt -o loop</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp rootfs.ext3 ~/qemu</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-验证\"><a href=\"#6-验证\" class=\"headerlink\" title=\"6. 验证\"></a>6. 验证</h2><h3 id=\"1-Qemu启动命令：\"><a href=\"#1-Qemu启动命令：\" class=\"headerlink\" title=\"1) Qemu启动命令：\"></a>1) Qemu启动命令：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -nographic -append <span class=\"string\">\"root=/dev/mmcblk0 rw console=ttyAMA0\"</span> -sd rootfs.ext3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-启动脚本：\"><a href=\"#2-启动脚本：\" class=\"headerlink\" title=\"2) 启动脚本：\"></a>2) 启动脚本：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> boot.sh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/sh</span></span><br><span class=\"line\">qemu-system-arm \\</span><br><span class=\"line\">        -M vexpress-a9  \\</span><br><span class=\"line\">        -m 512M \\</span><br><span class=\"line\">        -kernel ~/qemu/zImage   \\   </span><br><span class=\"line\">        -dtb ~/qemu/vexpress-v2p-ca9.dtb    \\   </span><br><span class=\"line\">        -nographic  \\</span><br><span class=\"line\">        -append \"root=/dev/mmcblk0 rw console=ttyAMA0\"    \\</span><br><span class=\"line\">        -sd rootfs.ext3</span><br></pre></td></tr></table></figure>\n\n<p>以上为在串口终端启动系统，按照以下的启动命令可以使用LCD屏作为输出启动系统。</p>\n<h3 id=\"3-图形化启动内核：\"><a href=\"#3-图形化启动内核：\" class=\"headerlink\" title=\"3) 图形化启动内核：\"></a>3) 图形化启动内核：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-arm -M vexpress-a9 -m 512M -kernel ~/qemu/zImage -dtb ~/qemu/vexpress-v2p-ca9.dtb -append \"root=/dev/mmcblk0 rw console=tty0\" -sd rootfs.ext3</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-启动验证：\"><a href=\"#4-启动验证：\" class=\"headerlink\" title=\"4) 启动验证：\"></a>4) 启动验证：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...</span><br><span class=\"line\">request_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now</span><br><span class=\"line\">Starting init: &#x2F;sbin&#x2F;init exists but couldn&#39;t execute it (error -8)</span><br><span class=\"line\">request_module: kmod_concurrent_max (0) close to 0 (max_modprobes: 50), for module binfmt-464c, throttling...</span><br><span class=\"line\">request_module: modprobe binfmt-464c cannot be processed, kmod busy with 50 threads for more than 5 seconds now</span><br><span class=\"line\">Starting init: &#x2F;bin&#x2F;sh exists but couldn&#39;t execute it (error -8)</span><br><span class=\"line\">Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class=\"line\">CPU: 0 PID: 1 Comm: swapper&#x2F;0 Not tainted 4.14.172 #1</span><br><span class=\"line\">Hardware name: ARM-Versatile Express</span><br><span class=\"line\">[&lt;8010f180&gt;] (unwind_backtrace) from [&lt;8010b444&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class=\"line\">[&lt;8010b444&gt;] (show_stack) from [&lt;806616cc&gt;] (dump_stack+0x94&#x2F;0xa8)</span><br><span class=\"line\">[&lt;806616cc&gt;] (dump_stack) from [&lt;8011d67c&gt;] (panic+0xdc&#x2F;0x248)</span><br><span class=\"line\">[&lt;8011d67c&gt;] (panic) from [&lt;80674634&gt;] (kernel_init+0x104&#x2F;0x114)</span><br><span class=\"line\">[&lt;80674634&gt;] (kernel_init) from [&lt;801076a8&gt;] (ret_from_fork+0x14&#x2F;0x2c)</span><br><span class=\"line\">---[ end Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class=\"line\">QEMU: Terminated</span><br></pre></td></tr></table></figure>\n\n<p>如上问题是由于编译生成的busybox工具，是x86环境下使用的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> file bin/busybox </span></span><br><span class=\"line\">bin/busybox: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=7fe433943e201f5337be6116a883d54fc1a4a349, stripped</span><br></pre></td></tr></table></figure>\n\n<p>是因为在安装busybox的时候，使用了make install，应该使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install</span><br></pre></td></tr></table></figure>\n\n<p>编译工具生成arm平台使用的busybox工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> file rootfs/bin/busybox</span></span><br><span class=\"line\">rootfs/bin/busybox: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=cbcd33b8d6c946cb19408a5e8e714de554c87f52, stripped</span><br></pre></td></tr></table></figure>\n\n<p>再次验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtc-pl031 10017000.rtc: setting system clock to 2018-09-24 13:22:14 UTC (1537795334)</span><br><span class=\"line\">ALSA device list:</span><br><span class=\"line\">  #0: ARM AC&#39;97 Interface PL041 rev0 at 0x10004000, irq 33</span><br><span class=\"line\">input: ImExPS&#x2F;2 Generic Explorer Mouse as &#x2F;devices&#x2F;platform&#x2F;smb&#x2F;smb:motherboard&#x2F;smb:motherboard:iofpga@7,00000000&#x2F;10007000.kmi&#x2F;serio1&#x2F;input&#x2F;input2</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem</span><br><span class=\"line\">EXT4-fs (mmcblk0): recovery complete</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class=\"line\">VFS: Mounted root (ext3 filesystem) on device 179:0.</span><br><span class=\"line\">Freeing unused kernel memory: 284K</span><br><span class=\"line\">random: nonblocking pool is initialized</span><br><span class=\"line\">can&#39;t run &#39;&#x2F;etc&#x2F;init.d&#x2F;rcS&#39;: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">Please press Enter to activate this console.</span><br><span class=\"line\">&#x2F; #</span><br><span class=\"line\">&#x2F; #</span><br><span class=\"line\">&#x2F; # uname -a</span><br><span class=\"line\">Linux (none) 4.4.157 #1 SMP Sun Sep 23 21:11:22 CST 2018 armv7l GNU&#x2F;Linux</span><br></pre></td></tr></table></figure>\n\n<p>至此，Qemu启动Linux内核并挂载跟文件系统已经启动成功，通过串口终端可以正常和系统进行简单功能的交互。<br>打印中提示的不能运行/etc/init.d/rcS问题，只需要添加/etc/init.d/rcS文件即可，文件内容可以是提示语句。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/init.d/rcS</span></span><br><span class=\"line\">Hello Qemu Linux!</span><br></pre></td></tr></table></figure>\n\n<p>注意，要在创建/etc/init.d/rcS文件时，记着修改该文件的可执行权限，否则启动过程中会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Freeing unused kernel memory: 1024K</span><br><span class=\"line\">random: crng init done</span><br><span class=\"line\">can&#39;t run &#39;&#x2F;etc&#x2F;init.d&#x2F;rcS&#39;: Permission denied</span><br><span class=\"line\"></span><br><span class=\"line\">Please press Enter to activate this console.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"7-退出Qemu环境\"><a href=\"#7-退出Qemu环境\" class=\"headerlink\" title=\"7. 退出Qemu环境\"></a>7. 退出Qemu环境</h2><p>Qemu环境搭建好之后，在出错时需要关闭并重新启动Qemu，不用的时候需要关闭Qemu。</p>\n<h3 id=\"1）手动退出Qemu\"><a href=\"#1）手动退出Qemu\" class=\"headerlink\" title=\"1）手动退出Qemu\"></a>1）手动退出Qemu</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl + A; X</span><br></pre></td></tr></table></figure>\n\n<p>操作之后，终端上会打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QEMU: Terminated</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2）强制退出Qemu\"><a href=\"#2）强制退出Qemu\" class=\"headerlink\" title=\"2）强制退出Qemu\"></a>2）强制退出Qemu</h3><p>有时候会发现无法通过shutdown等工具关闭，因为Qemu也是一个进程，可以通过杀掉Qemu进程的方法关闭Qemu模拟环境。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ps -a</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">kill</span> xxx</span></span><br></pre></td></tr></table></figure>\n\n<p>如下可以采用脚本运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat kill_qemu.sh </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/sh</span></span><br><span class=\"line\">ps -a | grep qemu-system-arm | awk '&#123;print $1&#125;' | xargs sudo kill -9</span><br></pre></td></tr></table></figure>\n\n<p>本文讲述了Qemu环境启动Linux内核，并挂载SD卡中的根文件系统的一些操作步骤。如果需要在Qemu环境下以ARM开发板的正常启动流程来加载Linux内核并挂载根文件系统，可以参考下一篇文章《<a href=\"https://www.jianshu.com/p/8619a6739040\" target=\"_blank\" rel=\"noopener\">Qemu搭建ARM vexpress开发环境(二)—-通过u-boot启动Linux内核</a>》。</p>"},{"title":"platform总线设备驱动模型","date":"2020-05-17T02:28:23.000Z","_content":"\n\n\n\n\nLinux设备模型提取了设备操作的共有属性，进行抽象，并将这部分抽象的共有属性在内核中实现，而为需要添加设备和驱动的操作提供了统一的接口，简化了驱动开发过程，只需要熟悉这些统一的接口就可以进行驱动开发；\n\n\n\n\n<!--more-->\n\n\n\n#### 目录\n\n[TOC]\n\n\n#### 1. platform总线\n\n\n内核中有个用的比较多的驱动模型，platform平台总线模型，是一条虚拟的总线；在platform总线中，设备用platform_device表示，驱动用platform_driver表示；platform由内核统一管理，在驱动中使用资源，安全性和可移植性高；在硬件部分修改时，只需要修改硬件部分的设备platform_device代码，即可完成硬件适配；\n\n\n\n\n\n\n\n\n\n\n总线、设备、驱动模型\n\n\n\n\n```mermaid\ngraph TB\n\tBus(Bus)-->Dev(Dev)\n\tBus-->Drv(Drv)\n\tDev-->platform_device(platform_device)\n\tDrv-->platform_driver(platform_driver)\n```\n\n\nDev：指定硬件资源\n\n\nDrv：\n\n1）分配、设置、注册file_operations\n\n2）根据Dev的硬件资源操作硬件\n\n\n\n\nDrv：\n\n\n\tprobe，分配、设置、注册file_operations\n\n\n\n\n![平台总线设备驱动模型框架](../../../mshrimp_blog/platform总线设备驱动模型/平台总线设备驱动模型框架.png)\n\n\n\n\n#### 2. 重要的结构体\n\n\nstruct bus_type\n\n\nstruct platform_device\n\n\nstruct platform_driver\n\n\n\n\nplatform_match函数用来比对Dev和Drv是否匹配，如果匹配成功，则调用Drv里的probe函数；\n\n\n\n\n##### bus_type\n\n\n\n\n```c\n// include/linux/device.h\nstruct bus_type {\n    const char      *name;\t// 总线名称\n    const char      *dev_name;\n\t......\n    int (*match)(struct device *dev, struct device_driver *drv);\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n\t......\n};\n```\n\n\n\n\n\n\n##### platform_device\n\n\n\n\n```c\n// include/linux/platform_device.h\nstruct platform_device {\n    const char  *name;\t// 设备名称，要和platform_driver的name匹配\n    int     id;\t\t// 插入总线下相同name的设备编号，一个驱动支持多个设备\n    bool        id_auto;\n    struct device   dev;\n    u32     num_resources;\n    struct resource *resource;\t// 设备资源，设备硬件信息\n\n    const struct platform_device_id *id_entry;\n    char *driver_override; /* Driver name to force a match */\n\n    /* MFD cell pointer */\n    struct mfd_cell *mfd_cell;\n\n    /* arch specific additions */\n    struct pdev_archdata    archdata;\n};\n```\n\n\n\n\n##### platform_driver\n\n\n\n\n```c\n// include/linux/platform_device.h\nstruct platform_driver {\n    int (*probe)(struct platform_device *);\n    int (*remove)(struct platform_device *);\n    void (*shutdown)(struct platform_device *);\n    int (*suspend)(struct platform_device *, pm_message_t state);\n    int (*resume)(struct platform_device *);\n    struct device_driver driver;\n    const struct platform_device_id *id_table;\n    bool prevent_deferred_probe;\n};\n```\n\n\n\n\n\n\n```c\n// include/linux/mod_devicetable.h\nstruct platform_device_id {\n    char name[PLATFORM_NAME_SIZE];\n    kernel_ulong_t driver_data;\n};\n```\n\n\n\n\nid_table是一个数组，可以支持一个或多个设备名；数组的最后一个成员应该为空；\n\n\n\n\n\n\n#### 3. platform初始化\n\n\nplatform的初始化操作在内核启动时完成，不需要驱动开发者修改；\n\n\n```mermaid\ngraph LR\n\tdo_basic_setup(do_basic_setup)-->\n\tdriver_init(driver_init)-->\n\tplatform_bus_init(platform_bus_init)\n```\n\n\n```c\n// drivers/base/platform.c\nint __init platform_bus_init(void)\n{\n    int error;\n\n    early_platform_cleanup();\n\n    error = device_register(&platform_bus);\n    if (error)\n        return error;\n    error = bus_register(&platform_bus_type);\n    if (error)\n        device_unregister(&platform_bus);\n    of_platform_register_reconfig_notifier();\n    return error;\n}\n```\n\n\n\n\nbus_register()\n\n\n可在sysfs下看到/sys/bus/platform；\n\n\n\n\n```c\n// drivers/base/platform.c\nstruct device platform_bus = {\n    .init_name  = \"platform\",\n};\nEXPORT_SYMBOL_GPL(platform_bus);\n```\n\n\n\n\n\n\n```c\n// drivers/base/platform.c\nstruct bus_type platform_bus_type = {\n    .name       = \"platform\",\n    .dev_groups = platform_dev_groups,\n    .match      = platform_match,\n    .uevent     = platform_uevent,\n    .pm     = &platform_dev_pm_ops,\n};\nEXPORT_SYMBOL_GPL(platform_bus_type);\n```\n\n\n\n\n#### 4. platform注册\n\n\n##### 4.1 platform_device注册\n\n\n\n\n```c\n// drivers/base/platform.c\nint platform_device_register(struct platform_device *pdev)\n{\n    device_initialize(&pdev->dev);\n    arch_setup_pdev_archdata(pdev);\n    return platform_device_add(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_register);\n```\n\n\n\n\n```c\n// drivers/base/platform.c\nvoid platform_device_unregister(struct platform_device *pdev)\n{\n    platform_device_del(pdev);\n    platform_device_put(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_unregister);\n```\n\n\n\n\n\n\n##### 4.2 platform_driver注册\n\n\n\n\n```c\n// include/linux/platform_device.h\n#define platform_driver_register(drv) \\\n    __platform_driver_register(drv, THIS_MODULE)\n```\n\n\n\n\n```c\n// drivers/base/platform.c\nint __platform_driver_register(struct platform_driver *drv,\n                struct module *owner)\n{\n    drv->driver.owner = owner;\n    drv->driver.bus = &platform_bus_type;\n    drv->driver.probe = platform_drv_probe;\n    drv->driver.remove = platform_drv_remove;\n    drv->driver.shutdown = platform_drv_shutdown;\n\n    return driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__platform_driver_register);\n```\n\n\n\n\n```c\n// drivers/base/platform.c\nvoid platform_driver_unregister(struct platform_driver *drv)\n{\n    driver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(platform_driver_unregister);\n```\n\n\n\n\n或者直接使用一个宏代替：\n\n\n```c\n// include/linux/platform_device.h\n#define module_platform_driver(__platform_driver) \\\n    module_driver(__platform_driver, platform_driver_register, \\\n            platform_driver_unregister)\n```\n\n\n\n\n```c\n// include/linux/device.h\n#define module_driver(__driver, __register, __unregister, ...) \\\nstatic int __init __driver##_init(void) \\\n{ \\\n    return __register(&(__driver) , ##__VA_ARGS__); \\\n} \\\nmodule_init(__driver##_init); \\\nstatic void __exit __driver##_exit(void) \\\n{ \\\n    __unregister(&(__driver) , ##__VA_ARGS__); \\\n} \\\nmodule_exit(__driver##_exit);\n```\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tbus_add_driver(bus_add_driver)-->\n\tdriver_attach(driver_attach)--bus_for_each_dev-->\n\t__driver_attach(__driver_attach)-->\n\tdriver_match_device(driver_match_device)-->\n\tbus_match(drv->bus->match)\n\t__driver_attach-->driver_probe_device(driver_probe_device)-->\n\treally_probe(really_probe)-->\n\tdev_bus_probe(dev->bus->probe)\n\treally_probe-->drv_probe(drv->probe)\n```\n\n\n\n\n\n\n\n\n#### 5. match匹配\n\n\ndriver_match_device()函数中的drv->bus->match，就是指向platform_bus_type的match函数指针，即platform_match()函数，用来完成Dev和Drv的匹配；通过Dev中的name和Drv中的id_table->name进行匹配，匹配成功后就会调用Drv中的probe函数；\n\n\n```c\nint (*match)(struct device *dev, struct device_driver *drv);\n```\n\n\nplatform_bus_type的match函数指针，被初始化指向platform_match()函数；\n\n\n```c\n// drivers/base/platform.c\nstruct bus_type platform_bus_type = {\n\t......\n    .match      = platform_match,\n\t......\n};\n```\n\n\n当一个新设备或新驱动添加到总线时，match方法被调用，用于判断指定的驱动程序是否能够处理指定的设备；\n\n\n\n\n```c\n// drivers/base/platform.c\nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n    struct platform_device *pdev = to_platform_device(dev);\n    struct platform_driver *pdrv = to_platform_driver(drv);\n\n    /* When driver_override is set, only bind to the matching driver */\n    if (pdev->driver_override)\n        return !strcmp(pdev->driver_override, drv->name);\n\n    /* Attempt an OF style match first */\n    if (of_driver_match_device(dev, drv))\t// 使用设备树匹配，of表示Open Firmware\n        return 1;\n\n    /* Then try ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then try to match against the id table */\n    if (pdrv->id_table)\n        return platform_match_id(pdrv->id_table, pdev) != NULL;\n\n    /* fall-back to driver name match */\n    return (strcmp(pdev->name, drv->name) == 0);\n}\n```\n\n\n如果platform_driver中存在id_table，就通过platform_match_id()函数来比较id_table进行匹配；\n\n\n```c\n// drivers/base/platform.c\nstatic const struct platform_device_id *platform_match_id(\n            const struct platform_device_id *id,\n            struct platform_device *pdev)\n{\n    while (id->name[0]) {\n        if (strcmp(pdev->name, id->name) == 0) {\n            pdev->id_entry = id;\n            return id;\n        }\n        id++;\n    }\n    return NULL;\n}\n```\n\n\n\n\n如果platform_driver中有id_table，用platform_device中的const char  *name和platform_driver中的id_table->name比较；\n\n\n```c\nstrcmp(pdev->name, id->name);\n```\n\n\n如果platform_driver中没有id_table，用platform_device中的const char  *name和platform_driver中的struct device_driver driver中的name比较；\n\n\n```c\nstrcmp(pdev->name, drv->name);\n```\n\n\n优先比较id_table->name\n\n\n其次比较struct device_driver driver中的name；\n\n\n如果比较的两个name相同，match就匹配成功，就会调用driver中的probe函数；\n\n\n\n\n#### 6. probe\n\n\ndriver_probe_device()函数通过really_probe()函数，调用drv->bus->probe，就是指向platform_bus_type的probe函数指针，即platform_probe()函数，\n\n\n\n\n```mermaid\ngraph TB\n\tdriver_probe_device(driver_probe_device)-->\n\treally_probe(really_probe)-->\n\tdev_bus_probe(dev->bus->probe)-->\n\tplatform_drv_probe(platform_drv_probe)-->\n\tdrv_probe(drv->probe)\n\treally_probe-->drv_probe2(drv->probe)\n```\n\n\n\n\n\n\n#### 7. platform资源\n\n\n\n\n```c\n// include/linux/ioport.h\nstruct resource {\n    resource_size_t start;\t// 设备在CPU总线的线性起始物理地址\n    resource_size_t end;\t// 设备在CPU总线的线性结尾物理地址\n    const char *name;\t// 设备的名称\n    unsigned long flags;\t// 设备的标志位\n    unsigned long desc;\n    struct resource *parent, *sibling, *child;\n};\n```\n\n\n\n\n获取资源\n\n\n```c\nstruct resource *platform_get_resource(struct platform_device *dev,\n                       unsigned int type, unsigned int num);\n```\n\n\n\n\n\n\n资源类型\n\n\n```c\n// include/linux/ioport.h\n#define IORESOURCE_TYPE_BITS    0x00001f00  /* Resource type */\n#define IORESOURCE_IO       0x00000100  /* PCI/ISA I/O ports */\n#define IORESOURCE_MEM      0x00000200\n#define IORESOURCE_REG      0x00000300  /* Register offsets */\n#define IORESOURCE_IRQ      0x00000400\n#define IORESOURCE_DMA      0x00000800\n#define IORESOURCE_BUS      0x00001000\n```\n\n\n\n\n\n\n用法\n\n\n```c\nstruct platform_device *dev;\nstruct resource *res;\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n```\n\n\n\n\n\n\n\n\n#### 8. 实例\n\n\n\n\n\n\n\n\n```c\nplatform_device_register();\nplatform_device_unregister();\n```\n\n\n\n\n\n\n```c\nplatform_driver_register();\nplatform_driver_unregister();\n```\n\n\n\n\n\n\n```c\nstruct resource *res;\nres = platform_get_resource();\n```\n\n\n\n\n\n\n### 使用设备树\n\n\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tBus(Bus)-->Dts(DTS中构造节点)\n\tBus-->Drv(Drv)\n```\n\n\nDev：在DTS中构造设备节点，指定硬件资源\n\n\nDrv：\n\n1）分配、设置、注册file_operations\n\n2）根据Dev的硬件资源操作硬件\n\n\n\n\nDrv：\n\n\n\tprobe，分配、设置、注册file_operations\n\n\n\n\ndts-->dtb-->\n\n\n内核解析dtb文件，得到device_node结构体，生成platform_device结构体，其中包含硬件资源，硬件资源来源于DTS文件；\n\n\n\n\n设备树中节点的compatible，用来\n\n\nreg是寄存器，和内存基本一样\n\n\n\n\n```c\nstruct resource *res;\nres = platform_get_resource\nif (res) {\n    led_pin = ;\n} else {\n    of_property_read_s32(platform_device->dev.of_node, \"pin\", &ledpin);\n}\n```\n\n\n\n\n\n\n\n\n```c\n// drivers/base/platform.c\nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n    struct platform_device *pdev = to_platform_device(dev);\n    struct platform_driver *pdrv = to_platform_driver(drv);\n\n    /* When driver_override is set, only bind to the matching driver */\n    if (pdev->driver_override)\n        return !strcmp(pdev->driver_override, drv->name);\n\n    /* Attempt an OF style match first */\n    if (of_driver_match_device(dev, drv))\t// 使用设备树匹配\n        return 1;\n\n    /* Then try ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then try to match against the id table */\n    if (pdrv->id_table)\n        return platform_match_id(pdrv->id_table, pdev) != NULL;\n\n    /* fall-back to driver name match */\n    return (strcmp(pdev->name, drv->name) == 0);\n}\n```\n\n\n\n\n```c\nstatic inline int of_driver_match_device(struct device *dev,\n                     const struct device_driver *drv)\n{\n    return of_match_device(drv->of_match_table, dev) != NULL;\n}\n```\n\n\n\n\n\n\n```c\nstruct device_driver {\n    const char      *name;\n    struct bus_type     *bus;\n\t......\n\tconst struct of_device_id   *of_match_table;\n};\n```\n\n\n\n\n\n\n```c\n// include/linux/mod_devicetable.h\nstruct of_device_id {\n    char    name[32];\n    char    type[32];\n    char    compatible[128];\n    const void *data;\n};\n```\n\n\n\n\n\n\n\n\n\n\n```c\n// drivers/of/device.c\nconst struct of_device_id *of_match_device(const struct of_device_id *matches,\n                       const struct device *dev)\n{\n    if ((!matches) || (!dev->of_node))\n        return NULL;\n    return of_match_node(matches, dev->of_node);\n}\nEXPORT_SYMBOL(of_match_device);\n```\n\n\n\n\n```c\n// drivers/of/base.c\nconst struct of_device_id *of_match_node(const struct of_device_id *matches,\n                     const struct device_node *node)\n{\n    const struct of_device_id *match;\n    unsigned long flags;\n\n    raw_spin_lock_irqsave(&devtree_lock, flags);\n    match = __of_match_node(matches, node);\n    raw_spin_unlock_irqrestore(&devtree_lock, flags);\n    return match;\n}\nEXPORT_SYMBOL(of_match_node);\n```\n\n\n\n\n```c\n// drivers/of/base.c\nconst struct of_device_id *__of_match_node(const struct of_device_id *matches,\n                       const struct device_node *node)\n{\n    const struct of_device_id *best_match = NULL;\n    int score, best_score = 0;\n\n    if (!matches)\n        return NULL;\n\n    for (; matches->name[0] || matches->type[0] || matches->compatible[0]; matches++) {\n        score = __of_device_is_compatible(node, matches->compatible,\n                          matches->type, matches->name);\n        if (score > best_score) {\n            best_match = matches;\n            best_score = score;\n        }\n    }\n\n    return best_match;\n}\n```\n\n\n\n\n\n\n设备树和驱动的匹配过程如下：\n\n\n```mermaid\ngraph TB\n\tof_driver_match_device(of_driver_match_device)-->\n\tof_match_device(of_match_device)-->\n\tof_match_node(of_match_node)-->\n\t__of_match_node(__of_match_node)-->\n\t__of_device_is_compatible(__of_device_is_compatible)\n\t__of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n\t__of_device_is_compatible--type-->of_compat_cmp\n\t__of_device_is_compatible--name-->of_compat_cmp\n\tof_compat_cmp-->\n\tstrcasecmp(strcasecmp)\n```\n\n\n\n\n\n__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；\n\n\n匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；\n\n\n\n\n\n\n\n\nplatform_device\n\n\n\tstruct device dev;\n\n\n\t\tof_node\n\n\n对于dts生成的platform_device，dev中含有of_node；\n\n\nof_node中含有的属性，取决于设备树；比如：compatible、reg、pin属性；\n\n\ncompatible属性和of_match_table中的compatible进行比对；\n\n\n\n\n优先比较：compatible，\n\n\n\n\n\n\n\n\n#### 参考资料\n\n\n\n\nhttps://www.jianshu.com/p/6325f723509b\n\n\n\n\n\n\n\n[回到目录](目录)","source":"_posts/platform总线设备驱动模型.md","raw":"---\ntitle: platform总线设备驱动模型\ndate: 2020-05-17 10:28:23\ntags: Driver\n---\n\n\n\n\n\nLinux设备模型提取了设备操作的共有属性，进行抽象，并将这部分抽象的共有属性在内核中实现，而为需要添加设备和驱动的操作提供了统一的接口，简化了驱动开发过程，只需要熟悉这些统一的接口就可以进行驱动开发；\n\n\n\n\n<!--more-->\n\n\n\n#### 目录\n\n[TOC]\n\n\n#### 1. platform总线\n\n\n内核中有个用的比较多的驱动模型，platform平台总线模型，是一条虚拟的总线；在platform总线中，设备用platform_device表示，驱动用platform_driver表示；platform由内核统一管理，在驱动中使用资源，安全性和可移植性高；在硬件部分修改时，只需要修改硬件部分的设备platform_device代码，即可完成硬件适配；\n\n\n\n\n\n\n\n\n\n\n总线、设备、驱动模型\n\n\n\n\n```mermaid\ngraph TB\n\tBus(Bus)-->Dev(Dev)\n\tBus-->Drv(Drv)\n\tDev-->platform_device(platform_device)\n\tDrv-->platform_driver(platform_driver)\n```\n\n\nDev：指定硬件资源\n\n\nDrv：\n\n1）分配、设置、注册file_operations\n\n2）根据Dev的硬件资源操作硬件\n\n\n\n\nDrv：\n\n\n\tprobe，分配、设置、注册file_operations\n\n\n\n\n![平台总线设备驱动模型框架](../../../mshrimp_blog/platform总线设备驱动模型/平台总线设备驱动模型框架.png)\n\n\n\n\n#### 2. 重要的结构体\n\n\nstruct bus_type\n\n\nstruct platform_device\n\n\nstruct platform_driver\n\n\n\n\nplatform_match函数用来比对Dev和Drv是否匹配，如果匹配成功，则调用Drv里的probe函数；\n\n\n\n\n##### bus_type\n\n\n\n\n```c\n// include/linux/device.h\nstruct bus_type {\n    const char      *name;\t// 总线名称\n    const char      *dev_name;\n\t......\n    int (*match)(struct device *dev, struct device_driver *drv);\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n\t......\n};\n```\n\n\n\n\n\n\n##### platform_device\n\n\n\n\n```c\n// include/linux/platform_device.h\nstruct platform_device {\n    const char  *name;\t// 设备名称，要和platform_driver的name匹配\n    int     id;\t\t// 插入总线下相同name的设备编号，一个驱动支持多个设备\n    bool        id_auto;\n    struct device   dev;\n    u32     num_resources;\n    struct resource *resource;\t// 设备资源，设备硬件信息\n\n    const struct platform_device_id *id_entry;\n    char *driver_override; /* Driver name to force a match */\n\n    /* MFD cell pointer */\n    struct mfd_cell *mfd_cell;\n\n    /* arch specific additions */\n    struct pdev_archdata    archdata;\n};\n```\n\n\n\n\n##### platform_driver\n\n\n\n\n```c\n// include/linux/platform_device.h\nstruct platform_driver {\n    int (*probe)(struct platform_device *);\n    int (*remove)(struct platform_device *);\n    void (*shutdown)(struct platform_device *);\n    int (*suspend)(struct platform_device *, pm_message_t state);\n    int (*resume)(struct platform_device *);\n    struct device_driver driver;\n    const struct platform_device_id *id_table;\n    bool prevent_deferred_probe;\n};\n```\n\n\n\n\n\n\n```c\n// include/linux/mod_devicetable.h\nstruct platform_device_id {\n    char name[PLATFORM_NAME_SIZE];\n    kernel_ulong_t driver_data;\n};\n```\n\n\n\n\nid_table是一个数组，可以支持一个或多个设备名；数组的最后一个成员应该为空；\n\n\n\n\n\n\n#### 3. platform初始化\n\n\nplatform的初始化操作在内核启动时完成，不需要驱动开发者修改；\n\n\n```mermaid\ngraph LR\n\tdo_basic_setup(do_basic_setup)-->\n\tdriver_init(driver_init)-->\n\tplatform_bus_init(platform_bus_init)\n```\n\n\n```c\n// drivers/base/platform.c\nint __init platform_bus_init(void)\n{\n    int error;\n\n    early_platform_cleanup();\n\n    error = device_register(&platform_bus);\n    if (error)\n        return error;\n    error = bus_register(&platform_bus_type);\n    if (error)\n        device_unregister(&platform_bus);\n    of_platform_register_reconfig_notifier();\n    return error;\n}\n```\n\n\n\n\nbus_register()\n\n\n可在sysfs下看到/sys/bus/platform；\n\n\n\n\n```c\n// drivers/base/platform.c\nstruct device platform_bus = {\n    .init_name  = \"platform\",\n};\nEXPORT_SYMBOL_GPL(platform_bus);\n```\n\n\n\n\n\n\n```c\n// drivers/base/platform.c\nstruct bus_type platform_bus_type = {\n    .name       = \"platform\",\n    .dev_groups = platform_dev_groups,\n    .match      = platform_match,\n    .uevent     = platform_uevent,\n    .pm     = &platform_dev_pm_ops,\n};\nEXPORT_SYMBOL_GPL(platform_bus_type);\n```\n\n\n\n\n#### 4. platform注册\n\n\n##### 4.1 platform_device注册\n\n\n\n\n```c\n// drivers/base/platform.c\nint platform_device_register(struct platform_device *pdev)\n{\n    device_initialize(&pdev->dev);\n    arch_setup_pdev_archdata(pdev);\n    return platform_device_add(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_register);\n```\n\n\n\n\n```c\n// drivers/base/platform.c\nvoid platform_device_unregister(struct platform_device *pdev)\n{\n    platform_device_del(pdev);\n    platform_device_put(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_unregister);\n```\n\n\n\n\n\n\n##### 4.2 platform_driver注册\n\n\n\n\n```c\n// include/linux/platform_device.h\n#define platform_driver_register(drv) \\\n    __platform_driver_register(drv, THIS_MODULE)\n```\n\n\n\n\n```c\n// drivers/base/platform.c\nint __platform_driver_register(struct platform_driver *drv,\n                struct module *owner)\n{\n    drv->driver.owner = owner;\n    drv->driver.bus = &platform_bus_type;\n    drv->driver.probe = platform_drv_probe;\n    drv->driver.remove = platform_drv_remove;\n    drv->driver.shutdown = platform_drv_shutdown;\n\n    return driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__platform_driver_register);\n```\n\n\n\n\n```c\n// drivers/base/platform.c\nvoid platform_driver_unregister(struct platform_driver *drv)\n{\n    driver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(platform_driver_unregister);\n```\n\n\n\n\n或者直接使用一个宏代替：\n\n\n```c\n// include/linux/platform_device.h\n#define module_platform_driver(__platform_driver) \\\n    module_driver(__platform_driver, platform_driver_register, \\\n            platform_driver_unregister)\n```\n\n\n\n\n```c\n// include/linux/device.h\n#define module_driver(__driver, __register, __unregister, ...) \\\nstatic int __init __driver##_init(void) \\\n{ \\\n    return __register(&(__driver) , ##__VA_ARGS__); \\\n} \\\nmodule_init(__driver##_init); \\\nstatic void __exit __driver##_exit(void) \\\n{ \\\n    __unregister(&(__driver) , ##__VA_ARGS__); \\\n} \\\nmodule_exit(__driver##_exit);\n```\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tbus_add_driver(bus_add_driver)-->\n\tdriver_attach(driver_attach)--bus_for_each_dev-->\n\t__driver_attach(__driver_attach)-->\n\tdriver_match_device(driver_match_device)-->\n\tbus_match(drv->bus->match)\n\t__driver_attach-->driver_probe_device(driver_probe_device)-->\n\treally_probe(really_probe)-->\n\tdev_bus_probe(dev->bus->probe)\n\treally_probe-->drv_probe(drv->probe)\n```\n\n\n\n\n\n\n\n\n#### 5. match匹配\n\n\ndriver_match_device()函数中的drv->bus->match，就是指向platform_bus_type的match函数指针，即platform_match()函数，用来完成Dev和Drv的匹配；通过Dev中的name和Drv中的id_table->name进行匹配，匹配成功后就会调用Drv中的probe函数；\n\n\n```c\nint (*match)(struct device *dev, struct device_driver *drv);\n```\n\n\nplatform_bus_type的match函数指针，被初始化指向platform_match()函数；\n\n\n```c\n// drivers/base/platform.c\nstruct bus_type platform_bus_type = {\n\t......\n    .match      = platform_match,\n\t......\n};\n```\n\n\n当一个新设备或新驱动添加到总线时，match方法被调用，用于判断指定的驱动程序是否能够处理指定的设备；\n\n\n\n\n```c\n// drivers/base/platform.c\nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n    struct platform_device *pdev = to_platform_device(dev);\n    struct platform_driver *pdrv = to_platform_driver(drv);\n\n    /* When driver_override is set, only bind to the matching driver */\n    if (pdev->driver_override)\n        return !strcmp(pdev->driver_override, drv->name);\n\n    /* Attempt an OF style match first */\n    if (of_driver_match_device(dev, drv))\t// 使用设备树匹配，of表示Open Firmware\n        return 1;\n\n    /* Then try ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then try to match against the id table */\n    if (pdrv->id_table)\n        return platform_match_id(pdrv->id_table, pdev) != NULL;\n\n    /* fall-back to driver name match */\n    return (strcmp(pdev->name, drv->name) == 0);\n}\n```\n\n\n如果platform_driver中存在id_table，就通过platform_match_id()函数来比较id_table进行匹配；\n\n\n```c\n// drivers/base/platform.c\nstatic const struct platform_device_id *platform_match_id(\n            const struct platform_device_id *id,\n            struct platform_device *pdev)\n{\n    while (id->name[0]) {\n        if (strcmp(pdev->name, id->name) == 0) {\n            pdev->id_entry = id;\n            return id;\n        }\n        id++;\n    }\n    return NULL;\n}\n```\n\n\n\n\n如果platform_driver中有id_table，用platform_device中的const char  *name和platform_driver中的id_table->name比较；\n\n\n```c\nstrcmp(pdev->name, id->name);\n```\n\n\n如果platform_driver中没有id_table，用platform_device中的const char  *name和platform_driver中的struct device_driver driver中的name比较；\n\n\n```c\nstrcmp(pdev->name, drv->name);\n```\n\n\n优先比较id_table->name\n\n\n其次比较struct device_driver driver中的name；\n\n\n如果比较的两个name相同，match就匹配成功，就会调用driver中的probe函数；\n\n\n\n\n#### 6. probe\n\n\ndriver_probe_device()函数通过really_probe()函数，调用drv->bus->probe，就是指向platform_bus_type的probe函数指针，即platform_probe()函数，\n\n\n\n\n```mermaid\ngraph TB\n\tdriver_probe_device(driver_probe_device)-->\n\treally_probe(really_probe)-->\n\tdev_bus_probe(dev->bus->probe)-->\n\tplatform_drv_probe(platform_drv_probe)-->\n\tdrv_probe(drv->probe)\n\treally_probe-->drv_probe2(drv->probe)\n```\n\n\n\n\n\n\n#### 7. platform资源\n\n\n\n\n```c\n// include/linux/ioport.h\nstruct resource {\n    resource_size_t start;\t// 设备在CPU总线的线性起始物理地址\n    resource_size_t end;\t// 设备在CPU总线的线性结尾物理地址\n    const char *name;\t// 设备的名称\n    unsigned long flags;\t// 设备的标志位\n    unsigned long desc;\n    struct resource *parent, *sibling, *child;\n};\n```\n\n\n\n\n获取资源\n\n\n```c\nstruct resource *platform_get_resource(struct platform_device *dev,\n                       unsigned int type, unsigned int num);\n```\n\n\n\n\n\n\n资源类型\n\n\n```c\n// include/linux/ioport.h\n#define IORESOURCE_TYPE_BITS    0x00001f00  /* Resource type */\n#define IORESOURCE_IO       0x00000100  /* PCI/ISA I/O ports */\n#define IORESOURCE_MEM      0x00000200\n#define IORESOURCE_REG      0x00000300  /* Register offsets */\n#define IORESOURCE_IRQ      0x00000400\n#define IORESOURCE_DMA      0x00000800\n#define IORESOURCE_BUS      0x00001000\n```\n\n\n\n\n\n\n用法\n\n\n```c\nstruct platform_device *dev;\nstruct resource *res;\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n```\n\n\n\n\n\n\n\n\n#### 8. 实例\n\n\n\n\n\n\n\n\n```c\nplatform_device_register();\nplatform_device_unregister();\n```\n\n\n\n\n\n\n```c\nplatform_driver_register();\nplatform_driver_unregister();\n```\n\n\n\n\n\n\n```c\nstruct resource *res;\nres = platform_get_resource();\n```\n\n\n\n\n\n\n### 使用设备树\n\n\n\n\n\n\n\n\n```mermaid\ngraph TB\n\tBus(Bus)-->Dts(DTS中构造节点)\n\tBus-->Drv(Drv)\n```\n\n\nDev：在DTS中构造设备节点，指定硬件资源\n\n\nDrv：\n\n1）分配、设置、注册file_operations\n\n2）根据Dev的硬件资源操作硬件\n\n\n\n\nDrv：\n\n\n\tprobe，分配、设置、注册file_operations\n\n\n\n\ndts-->dtb-->\n\n\n内核解析dtb文件，得到device_node结构体，生成platform_device结构体，其中包含硬件资源，硬件资源来源于DTS文件；\n\n\n\n\n设备树中节点的compatible，用来\n\n\nreg是寄存器，和内存基本一样\n\n\n\n\n```c\nstruct resource *res;\nres = platform_get_resource\nif (res) {\n    led_pin = ;\n} else {\n    of_property_read_s32(platform_device->dev.of_node, \"pin\", &ledpin);\n}\n```\n\n\n\n\n\n\n\n\n```c\n// drivers/base/platform.c\nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n    struct platform_device *pdev = to_platform_device(dev);\n    struct platform_driver *pdrv = to_platform_driver(drv);\n\n    /* When driver_override is set, only bind to the matching driver */\n    if (pdev->driver_override)\n        return !strcmp(pdev->driver_override, drv->name);\n\n    /* Attempt an OF style match first */\n    if (of_driver_match_device(dev, drv))\t// 使用设备树匹配\n        return 1;\n\n    /* Then try ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then try to match against the id table */\n    if (pdrv->id_table)\n        return platform_match_id(pdrv->id_table, pdev) != NULL;\n\n    /* fall-back to driver name match */\n    return (strcmp(pdev->name, drv->name) == 0);\n}\n```\n\n\n\n\n```c\nstatic inline int of_driver_match_device(struct device *dev,\n                     const struct device_driver *drv)\n{\n    return of_match_device(drv->of_match_table, dev) != NULL;\n}\n```\n\n\n\n\n\n\n```c\nstruct device_driver {\n    const char      *name;\n    struct bus_type     *bus;\n\t......\n\tconst struct of_device_id   *of_match_table;\n};\n```\n\n\n\n\n\n\n```c\n// include/linux/mod_devicetable.h\nstruct of_device_id {\n    char    name[32];\n    char    type[32];\n    char    compatible[128];\n    const void *data;\n};\n```\n\n\n\n\n\n\n\n\n\n\n```c\n// drivers/of/device.c\nconst struct of_device_id *of_match_device(const struct of_device_id *matches,\n                       const struct device *dev)\n{\n    if ((!matches) || (!dev->of_node))\n        return NULL;\n    return of_match_node(matches, dev->of_node);\n}\nEXPORT_SYMBOL(of_match_device);\n```\n\n\n\n\n```c\n// drivers/of/base.c\nconst struct of_device_id *of_match_node(const struct of_device_id *matches,\n                     const struct device_node *node)\n{\n    const struct of_device_id *match;\n    unsigned long flags;\n\n    raw_spin_lock_irqsave(&devtree_lock, flags);\n    match = __of_match_node(matches, node);\n    raw_spin_unlock_irqrestore(&devtree_lock, flags);\n    return match;\n}\nEXPORT_SYMBOL(of_match_node);\n```\n\n\n\n\n```c\n// drivers/of/base.c\nconst struct of_device_id *__of_match_node(const struct of_device_id *matches,\n                       const struct device_node *node)\n{\n    const struct of_device_id *best_match = NULL;\n    int score, best_score = 0;\n\n    if (!matches)\n        return NULL;\n\n    for (; matches->name[0] || matches->type[0] || matches->compatible[0]; matches++) {\n        score = __of_device_is_compatible(node, matches->compatible,\n                          matches->type, matches->name);\n        if (score > best_score) {\n            best_match = matches;\n            best_score = score;\n        }\n    }\n\n    return best_match;\n}\n```\n\n\n\n\n\n\n设备树和驱动的匹配过程如下：\n\n\n```mermaid\ngraph TB\n\tof_driver_match_device(of_driver_match_device)-->\n\tof_match_device(of_match_device)-->\n\tof_match_node(of_match_node)-->\n\t__of_match_node(__of_match_node)-->\n\t__of_device_is_compatible(__of_device_is_compatible)\n\t__of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n\t__of_device_is_compatible--type-->of_compat_cmp\n\t__of_device_is_compatible--name-->of_compat_cmp\n\tof_compat_cmp-->\n\tstrcasecmp(strcasecmp)\n```\n\n\n\n\n\n__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；\n\n\n匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；\n\n\n\n\n\n\n\n\nplatform_device\n\n\n\tstruct device dev;\n\n\n\t\tof_node\n\n\n对于dts生成的platform_device，dev中含有of_node；\n\n\nof_node中含有的属性，取决于设备树；比如：compatible、reg、pin属性；\n\n\ncompatible属性和of_match_table中的compatible进行比对；\n\n\n\n\n优先比较：compatible，\n\n\n\n\n\n\n\n\n#### 参考资料\n\n\n\n\nhttps://www.jianshu.com/p/6325f723509b\n\n\n\n\n\n\n\n[回到目录](目录)","slug":"platform总线设备驱动模型","published":1,"updated":"2020-05-17T02:40:10.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv2000fdqg1gbargmpl","content":"<p>Linux设备模型提取了设备操作的共有属性，进行抽象，并将这部分抽象的共有属性在内核中实现，而为需要添加设备和驱动的操作提供了统一的接口，简化了驱动开发过程，只需要熟悉这些统一的接口就可以进行驱动开发；</p>\n<a id=\"more\"></a>\n\n\n\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><p>[TOC]</p>\n<h4 id=\"1-platform总线\"><a href=\"#1-platform总线\" class=\"headerlink\" title=\"1. platform总线\"></a>1. platform总线</h4><p>内核中有个用的比较多的驱动模型，platform平台总线模型，是一条虚拟的总线；在platform总线中，设备用platform_device表示，驱动用platform_driver表示；platform由内核统一管理，在驱动中使用资源，安全性和可移植性高；在硬件部分修改时，只需要修改硬件部分的设备platform_device代码，即可完成硬件适配；</p>\n<p>总线、设备、驱动模型</p>\n<pre class=\"mermaid\">graph TB\n    Bus(Bus)-->Dev(Dev)\n    Bus-->Drv(Drv)\n    Dev-->platform_device(platform_device)\n    Drv-->platform_driver(platform_driver)</pre>\n\n\n<p>Dev：指定硬件资源</p>\n<p>Drv：</p>\n<p>1）分配、设置、注册file_operations</p>\n<p>2）根据Dev的硬件资源操作硬件</p>\n<p>Drv：</p>\n<pre><code>probe，分配、设置、注册file_operations</code></pre><p><img src=\"/2020/05/17/platform%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/../../mshrimp_blog/platform%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6.png\" alt=\"平台总线设备驱动模型框架\"></p>\n<h4 id=\"2-重要的结构体\"><a href=\"#2-重要的结构体\" class=\"headerlink\" title=\"2. 重要的结构体\"></a>2. 重要的结构体</h4><p>struct bus_type</p>\n<p>struct platform_device</p>\n<p>struct platform_driver</p>\n<p>platform_match函数用来比对Dev和Drv是否匹配，如果匹配成功，则调用Drv里的probe函数；</p>\n<h5 id=\"bus-type\"><a href=\"#bus-type\" class=\"headerlink\" title=\"bus_type\"></a>bus_type</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;\t<span class=\"comment\">// 总线名称</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *dev_name;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct device *dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"platform-device\"><a href=\"#platform-device\" class=\"headerlink\" title=\"platform_device\"></a>platform_device</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *name;\t<span class=\"comment\">// 设备名称，要和platform_driver的name匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     id;\t\t<span class=\"comment\">// 插入总线下相同name的设备编号，一个驱动支持多个设备</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span>        id_auto;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span>   <span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    u32     num_resources;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">resource</span>;</span>\t<span class=\"comment\">// 设备资源，设备硬件信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device_id</span> *<span class=\"title\">id_entry</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *driver_override; <span class=\"comment\">/* Driver name to force a match */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* MFD cell pointer */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mfd_cell</span> *<span class=\"title\">mfd_cell</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* arch specific additions */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pdev_archdata</span>    <span class=\"title\">archdata</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"platform-driver\"><a href=\"#platform-driver\" class=\"headerlink\" title=\"platform_driver\"></a>platform_driver</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*suspend)(struct platform_device *, <span class=\"keyword\">pm_message_t</span> state);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*resume)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device_id</span> *<span class=\"title\">id_table</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> prevent_deferred_probe;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/mod_devicetable.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device_id</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[PLATFORM_NAME_SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">kernel_ulong_t</span> driver_data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>id_table是一个数组，可以支持一个或多个设备名；数组的最后一个成员应该为空；</p>\n<h4 id=\"3-platform初始化\"><a href=\"#3-platform初始化\" class=\"headerlink\" title=\"3. platform初始化\"></a>3. platform初始化</h4><p>platform的初始化操作在内核启动时完成，不需要驱动开发者修改；</p>\n<pre class=\"mermaid\">graph LR\n    do_basic_setup(do_basic_setup)-->\n    driver_init(driver_init)-->\n    platform_bus_init(platform_bus_init)</pre>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __init <span class=\"title\">platform_bus_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">    early_platform_cleanup();</span><br><span class=\"line\"></span><br><span class=\"line\">    error = device_register(&amp;platform_bus);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">    error = bus_register(&amp;platform_bus_type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">        device_unregister(&amp;platform_bus);</span><br><span class=\"line\">    of_platform_register_reconfig_notifier();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>bus_register()</p>\n<p>可在sysfs下看到/sys/bus/platform；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">platform_bus</span> = &#123;</span></span><br><span class=\"line\">    .init_name  = <span class=\"string\">\"platform\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_bus);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">platform_bus_type</span> = &#123;</span></span><br><span class=\"line\">    .name       = <span class=\"string\">\"platform\"</span>,</span><br><span class=\"line\">    .dev_groups = platform_dev_groups,</span><br><span class=\"line\">    .match      = platform_match,</span><br><span class=\"line\">    .uevent     = platform_uevent,</span><br><span class=\"line\">    .pm     = &amp;platform_dev_pm_ops,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"4-platform注册\"><a href=\"#4-platform注册\" class=\"headerlink\" title=\"4. platform注册\"></a>4. platform注册</h4><h5 id=\"4-1-platform-device注册\"><a href=\"#4-1-platform-device注册\" class=\"headerlink\" title=\"4.1 platform_device注册\"></a>4.1 platform_device注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">platform_device_register</span><span class=\"params\">(struct platform_device *pdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_initialize(&amp;pdev-&gt;dev);</span><br><span class=\"line\">    arch_setup_pdev_archdata(pdev);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> platform_device_add(pdev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_device_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">platform_device_unregister</span><span class=\"params\">(struct platform_device *pdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    platform_device_del(pdev);</span><br><span class=\"line\">    platform_device_put(pdev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_device_unregister);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"4-2-platform-driver注册\"><a href=\"#4-2-platform-driver注册\" class=\"headerlink\" title=\"4.2 platform_driver注册\"></a>4.2 platform_driver注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> platform_driver_register(drv) \\</span></span><br><span class=\"line\">    __platform_driver_register(drv, THIS_MODULE)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> __platform_driver_register(struct platform_driver *drv,</span><br><span class=\"line\">                struct <span class=\"keyword\">module</span> *owner)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    drv-&gt;driver.owner = owner;</span><br><span class=\"line\">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class=\"line\">    drv-&gt;driver.probe = platform_drv_probe;</span><br><span class=\"line\">    drv-&gt;driver.<span class=\"built_in\">remove</span> = platform_drv_remove;</span><br><span class=\"line\">    drv-&gt;driver.<span class=\"built_in\">shutdown</span> = platform_drv_shutdown;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(__platform_driver_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">platform_driver_unregister</span><span class=\"params\">(struct platform_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    driver_unregister(&amp;drv-&gt;driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_driver_unregister);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>或者直接使用一个宏代替：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> module_platform_driver(__platform_driver) \\</span></span><br><span class=\"line\">    module_driver(__platform_driver, platform_driver_register, \\</span><br><span class=\"line\">            platform_driver_unregister)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> module_driver(__driver, __register, __unregister, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init __driver##_init(<span class=\"keyword\">void</span>) \\</span><br><span class=\"line\">&#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \\</span><br><span class=\"line\">&#125; \\</span><br><span class=\"line\">module_init(__driver##_init); \\</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit __driver##_exit(<span class=\"keyword\">void</span>) \\</span><br><span class=\"line\">&#123; \\</span><br><span class=\"line\">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \\</span><br><span class=\"line\">&#125; \\</span><br><span class=\"line\">module_exit(__driver##_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    bus_add_driver(bus_add_driver)-->\n    driver_attach(driver_attach)--bus_for_each_dev-->\n    __driver_attach(__driver_attach)-->\n    driver_match_device(driver_match_device)-->\n    bus_match(drv->bus->match)\n    __driver_attach-->driver_probe_device(driver_probe_device)-->\n    really_probe(really_probe)-->\n    dev_bus_probe(dev->bus->probe)\n    really_probe-->drv_probe(drv->probe)</pre>\n\n\n\n\n\n\n\n\n<h4 id=\"5-match匹配\"><a href=\"#5-match匹配\" class=\"headerlink\" title=\"5. match匹配\"></a>5. match匹配</h4><p>driver_match_device()函数中的drv-&gt;bus-&gt;match，就是指向platform_bus_type的match函数指针，即platform_match()函数，用来完成Dev和Drv的匹配；通过Dev中的name和Drv中的id_table-&gt;name进行匹配，匹配成功后就会调用Drv中的probe函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br></pre></td></tr></table></figure>\n\n\n<p>platform_bus_type的match函数指针，被初始化指向platform_match()函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">platform_bus_type</span> = &#123;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    .match      = platform_match,</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>当一个新设备或新驱动添加到总线时，match方法被调用，用于判断指定的驱动程序是否能够处理指定的设备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">platform_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> *<span class=\"title\">pdev</span> = <span class=\"title\">to_platform_device</span>(<span class=\"title\">dev</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> *<span class=\"title\">pdrv</span> = <span class=\"title\">to_platform_driver</span>(<span class=\"title\">drv</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdev-&gt;driver_override)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !<span class=\"built_in\">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Attempt an OF style match first */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (of_driver_match_device(dev, drv))\t<span class=\"comment\">// 使用设备树匹配，of表示Open Firmware</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try ACPI style match */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try to match against the id table */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdrv-&gt;id_table)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* fall-back to driver name match */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>如果platform_driver中存在id_table，就通过platform_match_id()函数来比较id_table进行匹配；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> struct platform_device_id *<span class=\"title\">platform_match_id</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">const</span> struct platform_device_id *id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            struct platform_device *pdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (id-&gt;name[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(pdev-&gt;name, id-&gt;name) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            pdev-&gt;id_entry = id;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        id++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>如果platform_driver中有id_table，用platform_device中的const char  *name和platform_driver中的id_table-&gt;name比较；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcmp</span>(pdev-&gt;name, id-&gt;name);</span><br></pre></td></tr></table></figure>\n\n\n<p>如果platform_driver中没有id_table，用platform_device中的const char  *name和platform_driver中的struct device_driver driver中的name比较；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcmp</span>(pdev-&gt;name, drv-&gt;name);</span><br></pre></td></tr></table></figure>\n\n\n<p>优先比较id_table-&gt;name</p>\n<p>其次比较struct device_driver driver中的name；</p>\n<p>如果比较的两个name相同，match就匹配成功，就会调用driver中的probe函数；</p>\n<h4 id=\"6-probe\"><a href=\"#6-probe\" class=\"headerlink\" title=\"6. probe\"></a>6. probe</h4><p>driver_probe_device()函数通过really_probe()函数，调用drv-&gt;bus-&gt;probe，就是指向platform_bus_type的probe函数指针，即platform_probe()函数，</p>\n<pre class=\"mermaid\">graph TB\n    driver_probe_device(driver_probe_device)-->\n    really_probe(really_probe)-->\n    dev_bus_probe(dev->bus->probe)-->\n    platform_drv_probe(platform_drv_probe)-->\n    drv_probe(drv->probe)\n    really_probe-->drv_probe2(drv->probe)</pre>\n\n\n\n\n\n\n<h4 id=\"7-platform资源\"><a href=\"#7-platform资源\" class=\"headerlink\" title=\"7. platform资源\"></a>7. platform资源</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/ioport.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">resource_size_t</span> start;\t<span class=\"comment\">// 设备在CPU总线的线性起始物理地址</span></span><br><span class=\"line\">    <span class=\"keyword\">resource_size_t</span> <span class=\"built_in\">end</span>;\t<span class=\"comment\">// 设备在CPU总线的线性结尾物理地址</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;\t<span class=\"comment\">// 设备的名称</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;\t<span class=\"comment\">// 设备的标志位</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> desc;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">parent</span>, *<span class=\"title\">sibling</span>, *<span class=\"title\">child</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>获取资源</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct resource *<span class=\"title\">platform_get_resource</span><span class=\"params\">(struct platform_device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>资源类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/ioport.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_TYPE_BITS    0x00001f00  <span class=\"comment\">/* Resource type */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_IO       0x00000100  <span class=\"comment\">/* PCI/ISA I/O ports */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_MEM      0x00000200</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_REG      0x00000300  <span class=\"comment\">/* Register offsets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_IRQ      0x00000400</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_DMA      0x00000800</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_BUS      0x00001000</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>用法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">res</span>;</span></span><br><span class=\"line\">res = platform_get_resource(dev, IORESOURCE_MEM, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h4 id=\"8-实例\"><a href=\"#8-实例\" class=\"headerlink\" title=\"8. 实例\"></a>8. 实例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform_device_register();</span><br><span class=\"line\">platform_device_unregister();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform_driver_register();</span><br><span class=\"line\">platform_driver_unregister();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">res</span>;</span></span><br><span class=\"line\">res = platform_get_resource();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h3 id=\"使用设备树\"><a href=\"#使用设备树\" class=\"headerlink\" title=\"使用设备树\"></a>使用设备树</h3><pre class=\"mermaid\">graph TB\n    Bus(Bus)-->Dts(DTS中构造节点)\n    Bus-->Drv(Drv)</pre>\n\n\n<p>Dev：在DTS中构造设备节点，指定硬件资源</p>\n<p>Drv：</p>\n<p>1）分配、设置、注册file_operations</p>\n<p>2）根据Dev的硬件资源操作硬件</p>\n<p>Drv：</p>\n<pre><code>probe，分配、设置、注册file_operations</code></pre><p>dts–&gt;dtb–&gt;</p>\n<p>内核解析dtb文件，得到device_node结构体，生成platform_device结构体，其中包含硬件资源，硬件资源来源于DTS文件；</p>\n<p>设备树中节点的compatible，用来</p>\n<p>reg是寄存器，和内存基本一样</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">res</span>;</span></span><br><span class=\"line\">res = platform_get_resource</span><br><span class=\"line\"><span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">    led_pin = ;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    of_property_read_s32(platform_device-&gt;dev.of_node, <span class=\"string\">\"pin\"</span>, &amp;ledpin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">platform_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> *<span class=\"title\">pdev</span> = <span class=\"title\">to_platform_device</span>(<span class=\"title\">dev</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> *<span class=\"title\">pdrv</span> = <span class=\"title\">to_platform_driver</span>(<span class=\"title\">drv</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdev-&gt;driver_override)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !<span class=\"built_in\">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Attempt an OF style match first */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (of_driver_match_device(dev, drv))\t<span class=\"comment\">// 使用设备树匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try ACPI style match */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try to match against the id table */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdrv-&gt;id_table)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* fall-back to driver name match */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">of_driver_match_device</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">const</span> struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> of_match_device(drv-&gt;of_match_table, dev) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span>     *<span class=\"title\">bus</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span>   *<span class=\"title\">of_match_table</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/mod_devicetable.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>    name[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    type[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    compatible[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/device.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> struct of_device_id *<span class=\"title\">of_match_device</span><span class=\"params\">(<span class=\"keyword\">const</span> struct of_device_id *matches,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">const</span> struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((!matches) || (!dev-&gt;of_node))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> of_match_node(matches, dev-&gt;of_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(of_match_device);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/base.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> struct of_device_id *<span class=\"title\">of_match_node</span><span class=\"params\">(<span class=\"keyword\">const</span> struct of_device_id *matches,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">const</span> struct device_node *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> *<span class=\"title\">match</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">    raw_spin_lock_irqsave(&amp;devtree_lock, flags);</span><br><span class=\"line\">    match = __of_match_node(matches, node);</span><br><span class=\"line\">    raw_spin_unlock_irqrestore(&amp;devtree_lock, flags);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(of_match_node);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/base.c</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> *__<span class=\"title\">of_match_node</span>(<span class=\"title\">const</span> <span class=\"title\">struct</span> <span class=\"title\">of_device_id</span> *<span class=\"title\">matches</span>,</span></span><br><span class=\"line\"><span class=\"class\">                       <span class=\"title\">const</span> <span class=\"title\">struct</span> <span class=\"title\">device_node</span> *<span class=\"title\">node</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> *<span class=\"title\">best_match</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> score, best_score = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!matches)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; matches-&gt;name[<span class=\"number\">0</span>] || matches-&gt;type[<span class=\"number\">0</span>] || matches-&gt;compatible[<span class=\"number\">0</span>]; matches++) &#123;</span><br><span class=\"line\">        score = __of_device_is_compatible(node, matches-&gt;compatible,</span><br><span class=\"line\">                          matches-&gt;type, matches-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (score &gt; best_score) &#123;</span><br><span class=\"line\">            best_match = matches;</span><br><span class=\"line\">            best_score = score;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> best_match;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>设备树和驱动的匹配过程如下：</p>\n<pre class=\"mermaid\">graph TB\n    of_driver_match_device(of_driver_match_device)-->\n    of_match_device(of_match_device)-->\n    of_match_node(of_match_node)-->\n    __of_match_node(__of_match_node)-->\n    __of_device_is_compatible(__of_device_is_compatible)\n    __of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n    __of_device_is_compatible--type-->of_compat_cmp\n    __of_device_is_compatible--name-->of_compat_cmp\n    of_compat_cmp-->\n    strcasecmp(strcasecmp)</pre>\n\n\n\n\n\n<p>__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；</p>\n<p>匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；</p>\n<p>platform_device</p>\n<pre><code>struct device dev;\n\n\n    of_node</code></pre><p>对于dts生成的platform_device，dev中含有of_node；</p>\n<p>of_node中含有的属性，取决于设备树；比如：compatible、reg、pin属性；</p>\n<p>compatible属性和of_match_table中的compatible进行比对；</p>\n<p>优先比较：compatible，</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://www.jianshu.com/p/6325f723509b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6325f723509b</a></p>\n<p><a href=\"目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>Linux设备模型提取了设备操作的共有属性，进行抽象，并将这部分抽象的共有属性在内核中实现，而为需要添加设备和驱动的操作提供了统一的接口，简化了驱动开发过程，只需要熟悉这些统一的接口就可以进行驱动开发；</p>","more":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><p>[TOC]</p>\n<h4 id=\"1-platform总线\"><a href=\"#1-platform总线\" class=\"headerlink\" title=\"1. platform总线\"></a>1. platform总线</h4><p>内核中有个用的比较多的驱动模型，platform平台总线模型，是一条虚拟的总线；在platform总线中，设备用platform_device表示，驱动用platform_driver表示；platform由内核统一管理，在驱动中使用资源，安全性和可移植性高；在硬件部分修改时，只需要修改硬件部分的设备platform_device代码，即可完成硬件适配；</p>\n<p>总线、设备、驱动模型</p>\n<pre class=\"mermaid\">graph TB\n    Bus(Bus)-->Dev(Dev)\n    Bus-->Drv(Drv)\n    Dev-->platform_device(platform_device)\n    Drv-->platform_driver(platform_driver)</pre>\n\n\n<p>Dev：指定硬件资源</p>\n<p>Drv：</p>\n<p>1）分配、设置、注册file_operations</p>\n<p>2）根据Dev的硬件资源操作硬件</p>\n<p>Drv：</p>\n<pre><code>probe，分配、设置、注册file_operations</code></pre><p><img src=\"/2020/05/17/platform%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/../../mshrimp_blog/platform%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6.png\" alt=\"平台总线设备驱动模型框架\"></p>\n<h4 id=\"2-重要的结构体\"><a href=\"#2-重要的结构体\" class=\"headerlink\" title=\"2. 重要的结构体\"></a>2. 重要的结构体</h4><p>struct bus_type</p>\n<p>struct platform_device</p>\n<p>struct platform_driver</p>\n<p>platform_match函数用来比对Dev和Drv是否匹配，如果匹配成功，则调用Drv里的probe函数；</p>\n<h5 id=\"bus-type\"><a href=\"#bus-type\" class=\"headerlink\" title=\"bus_type\"></a>bus_type</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;\t<span class=\"comment\">// 总线名称</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *dev_name;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>)(struct device *dev);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct device *dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"platform-device\"><a href=\"#platform-device\" class=\"headerlink\" title=\"platform_device\"></a>platform_device</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *name;\t<span class=\"comment\">// 设备名称，要和platform_driver的name匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     id;\t\t<span class=\"comment\">// 插入总线下相同name的设备编号，一个驱动支持多个设备</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span>        id_auto;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span>   <span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    u32     num_resources;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">resource</span>;</span>\t<span class=\"comment\">// 设备资源，设备硬件信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device_id</span> *<span class=\"title\">id_entry</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *driver_override; <span class=\"comment\">/* Driver name to force a match */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* MFD cell pointer */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mfd_cell</span> *<span class=\"title\">mfd_cell</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* arch specific additions */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pdev_archdata</span>    <span class=\"title\">archdata</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"platform-driver\"><a href=\"#platform-driver\" class=\"headerlink\" title=\"platform_driver\"></a>platform_driver</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*probe)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">remove</span>)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*suspend)(struct platform_device *, <span class=\"keyword\">pm_message_t</span> state);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*resume)(struct platform_device *);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device_id</span> *<span class=\"title\">id_table</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> prevent_deferred_probe;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/mod_devicetable.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device_id</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[PLATFORM_NAME_SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">kernel_ulong_t</span> driver_data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>id_table是一个数组，可以支持一个或多个设备名；数组的最后一个成员应该为空；</p>\n<h4 id=\"3-platform初始化\"><a href=\"#3-platform初始化\" class=\"headerlink\" title=\"3. platform初始化\"></a>3. platform初始化</h4><p>platform的初始化操作在内核启动时完成，不需要驱动开发者修改；</p>\n<pre class=\"mermaid\">graph LR\n    do_basic_setup(do_basic_setup)-->\n    driver_init(driver_init)-->\n    platform_bus_init(platform_bus_init)</pre>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __init <span class=\"title\">platform_bus_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">    early_platform_cleanup();</span><br><span class=\"line\"></span><br><span class=\"line\">    error = device_register(&amp;platform_bus);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">    error = bus_register(&amp;platform_bus_type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">        device_unregister(&amp;platform_bus);</span><br><span class=\"line\">    of_platform_register_reconfig_notifier();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>bus_register()</p>\n<p>可在sysfs下看到/sys/bus/platform；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">platform_bus</span> = &#123;</span></span><br><span class=\"line\">    .init_name  = <span class=\"string\">\"platform\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_bus);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">platform_bus_type</span> = &#123;</span></span><br><span class=\"line\">    .name       = <span class=\"string\">\"platform\"</span>,</span><br><span class=\"line\">    .dev_groups = platform_dev_groups,</span><br><span class=\"line\">    .match      = platform_match,</span><br><span class=\"line\">    .uevent     = platform_uevent,</span><br><span class=\"line\">    .pm     = &amp;platform_dev_pm_ops,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"4-platform注册\"><a href=\"#4-platform注册\" class=\"headerlink\" title=\"4. platform注册\"></a>4. platform注册</h4><h5 id=\"4-1-platform-device注册\"><a href=\"#4-1-platform-device注册\" class=\"headerlink\" title=\"4.1 platform_device注册\"></a>4.1 platform_device注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">platform_device_register</span><span class=\"params\">(struct platform_device *pdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_initialize(&amp;pdev-&gt;dev);</span><br><span class=\"line\">    arch_setup_pdev_archdata(pdev);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> platform_device_add(pdev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_device_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">platform_device_unregister</span><span class=\"params\">(struct platform_device *pdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    platform_device_del(pdev);</span><br><span class=\"line\">    platform_device_put(pdev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_device_unregister);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h5 id=\"4-2-platform-driver注册\"><a href=\"#4-2-platform-driver注册\" class=\"headerlink\" title=\"4.2 platform_driver注册\"></a>4.2 platform_driver注册</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> platform_driver_register(drv) \\</span></span><br><span class=\"line\">    __platform_driver_register(drv, THIS_MODULE)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> __platform_driver_register(struct platform_driver *drv,</span><br><span class=\"line\">                struct <span class=\"keyword\">module</span> *owner)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    drv-&gt;driver.owner = owner;</span><br><span class=\"line\">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class=\"line\">    drv-&gt;driver.probe = platform_drv_probe;</span><br><span class=\"line\">    drv-&gt;driver.<span class=\"built_in\">remove</span> = platform_drv_remove;</span><br><span class=\"line\">    drv-&gt;driver.<span class=\"built_in\">shutdown</span> = platform_drv_shutdown;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(__platform_driver_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">platform_driver_unregister</span><span class=\"params\">(struct platform_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    driver_unregister(&amp;drv-&gt;driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(platform_driver_unregister);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>或者直接使用一个宏代替：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/platform_device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> module_platform_driver(__platform_driver) \\</span></span><br><span class=\"line\">    module_driver(__platform_driver, platform_driver_register, \\</span><br><span class=\"line\">            platform_driver_unregister)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/device.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> module_driver(__driver, __register, __unregister, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init __driver##_init(<span class=\"keyword\">void</span>) \\</span><br><span class=\"line\">&#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \\</span><br><span class=\"line\">&#125; \\</span><br><span class=\"line\">module_init(__driver##_init); \\</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit __driver##_exit(<span class=\"keyword\">void</span>) \\</span><br><span class=\"line\">&#123; \\</span><br><span class=\"line\">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \\</span><br><span class=\"line\">&#125; \\</span><br><span class=\"line\">module_exit(__driver##_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    bus_add_driver(bus_add_driver)-->\n    driver_attach(driver_attach)--bus_for_each_dev-->\n    __driver_attach(__driver_attach)-->\n    driver_match_device(driver_match_device)-->\n    bus_match(drv->bus->match)\n    __driver_attach-->driver_probe_device(driver_probe_device)-->\n    really_probe(really_probe)-->\n    dev_bus_probe(dev->bus->probe)\n    really_probe-->drv_probe(drv->probe)</pre>\n\n\n\n\n\n\n\n\n<h4 id=\"5-match匹配\"><a href=\"#5-match匹配\" class=\"headerlink\" title=\"5. match匹配\"></a>5. match匹配</h4><p>driver_match_device()函数中的drv-&gt;bus-&gt;match，就是指向platform_bus_type的match函数指针，即platform_match()函数，用来完成Dev和Drv的匹配；通过Dev中的name和Drv中的id_table-&gt;name进行匹配，匹配成功后就会调用Drv中的probe函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br></pre></td></tr></table></figure>\n\n\n<p>platform_bus_type的match函数指针，被初始化指向platform_match()函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> <span class=\"title\">platform_bus_type</span> = &#123;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    .match      = platform_match,</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>当一个新设备或新驱动添加到总线时，match方法被调用，用于判断指定的驱动程序是否能够处理指定的设备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">platform_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> *<span class=\"title\">pdev</span> = <span class=\"title\">to_platform_device</span>(<span class=\"title\">dev</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> *<span class=\"title\">pdrv</span> = <span class=\"title\">to_platform_driver</span>(<span class=\"title\">drv</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdev-&gt;driver_override)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !<span class=\"built_in\">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Attempt an OF style match first */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (of_driver_match_device(dev, drv))\t<span class=\"comment\">// 使用设备树匹配，of表示Open Firmware</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try ACPI style match */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try to match against the id table */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdrv-&gt;id_table)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* fall-back to driver name match */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>如果platform_driver中存在id_table，就通过platform_match_id()函数来比较id_table进行匹配；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> struct platform_device_id *<span class=\"title\">platform_match_id</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">const</span> struct platform_device_id *id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            struct platform_device *pdev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (id-&gt;name[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(pdev-&gt;name, id-&gt;name) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            pdev-&gt;id_entry = id;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        id++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>如果platform_driver中有id_table，用platform_device中的const char  *name和platform_driver中的id_table-&gt;name比较；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcmp</span>(pdev-&gt;name, id-&gt;name);</span><br></pre></td></tr></table></figure>\n\n\n<p>如果platform_driver中没有id_table，用platform_device中的const char  *name和platform_driver中的struct device_driver driver中的name比较；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcmp</span>(pdev-&gt;name, drv-&gt;name);</span><br></pre></td></tr></table></figure>\n\n\n<p>优先比较id_table-&gt;name</p>\n<p>其次比较struct device_driver driver中的name；</p>\n<p>如果比较的两个name相同，match就匹配成功，就会调用driver中的probe函数；</p>\n<h4 id=\"6-probe\"><a href=\"#6-probe\" class=\"headerlink\" title=\"6. probe\"></a>6. probe</h4><p>driver_probe_device()函数通过really_probe()函数，调用drv-&gt;bus-&gt;probe，就是指向platform_bus_type的probe函数指针，即platform_probe()函数，</p>\n<pre class=\"mermaid\">graph TB\n    driver_probe_device(driver_probe_device)-->\n    really_probe(really_probe)-->\n    dev_bus_probe(dev->bus->probe)-->\n    platform_drv_probe(platform_drv_probe)-->\n    drv_probe(drv->probe)\n    really_probe-->drv_probe2(drv->probe)</pre>\n\n\n\n\n\n\n<h4 id=\"7-platform资源\"><a href=\"#7-platform资源\" class=\"headerlink\" title=\"7. platform资源\"></a>7. platform资源</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/ioport.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">resource_size_t</span> start;\t<span class=\"comment\">// 设备在CPU总线的线性起始物理地址</span></span><br><span class=\"line\">    <span class=\"keyword\">resource_size_t</span> <span class=\"built_in\">end</span>;\t<span class=\"comment\">// 设备在CPU总线的线性结尾物理地址</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;\t<span class=\"comment\">// 设备的名称</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;\t<span class=\"comment\">// 设备的标志位</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> desc;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">parent</span>, *<span class=\"title\">sibling</span>, *<span class=\"title\">child</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>获取资源</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct resource *<span class=\"title\">platform_get_resource</span><span class=\"params\">(struct platform_device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>资源类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/ioport.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_TYPE_BITS    0x00001f00  <span class=\"comment\">/* Resource type */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_IO       0x00000100  <span class=\"comment\">/* PCI/ISA I/O ports */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_MEM      0x00000200</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_REG      0x00000300  <span class=\"comment\">/* Register offsets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_IRQ      0x00000400</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_DMA      0x00000800</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IORESOURCE_BUS      0x00001000</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>用法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">res</span>;</span></span><br><span class=\"line\">res = platform_get_resource(dev, IORESOURCE_MEM, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h4 id=\"8-实例\"><a href=\"#8-实例\" class=\"headerlink\" title=\"8. 实例\"></a>8. 实例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform_device_register();</span><br><span class=\"line\">platform_device_unregister();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform_driver_register();</span><br><span class=\"line\">platform_driver_unregister();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">res</span>;</span></span><br><span class=\"line\">res = platform_get_resource();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h3 id=\"使用设备树\"><a href=\"#使用设备树\" class=\"headerlink\" title=\"使用设备树\"></a>使用设备树</h3><pre class=\"mermaid\">graph TB\n    Bus(Bus)-->Dts(DTS中构造节点)\n    Bus-->Drv(Drv)</pre>\n\n\n<p>Dev：在DTS中构造设备节点，指定硬件资源</p>\n<p>Drv：</p>\n<p>1）分配、设置、注册file_operations</p>\n<p>2）根据Dev的硬件资源操作硬件</p>\n<p>Drv：</p>\n<pre><code>probe，分配、设置、注册file_operations</code></pre><p>dts–&gt;dtb–&gt;</p>\n<p>内核解析dtb文件，得到device_node结构体，生成platform_device结构体，其中包含硬件资源，硬件资源来源于DTS文件；</p>\n<p>设备树中节点的compatible，用来</p>\n<p>reg是寄存器，和内存基本一样</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">resource</span> *<span class=\"title\">res</span>;</span></span><br><span class=\"line\">res = platform_get_resource</span><br><span class=\"line\"><span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">    led_pin = ;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    of_property_read_s32(platform_device-&gt;dev.of_node, <span class=\"string\">\"pin\"</span>, &amp;ledpin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/base/platform.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">platform_match</span><span class=\"params\">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_device</span> *<span class=\"title\">pdev</span> = <span class=\"title\">to_platform_device</span>(<span class=\"title\">dev</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> *<span class=\"title\">pdrv</span> = <span class=\"title\">to_platform_driver</span>(<span class=\"title\">drv</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdev-&gt;driver_override)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !<span class=\"built_in\">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Attempt an OF style match first */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (of_driver_match_device(dev, drv))\t<span class=\"comment\">// 使用设备树匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try ACPI style match */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Then try to match against the id table */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pdrv-&gt;id_table)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* fall-back to driver name match */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">of_driver_match_device</span><span class=\"params\">(struct device *dev,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">const</span> struct device_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> of_match_device(drv-&gt;of_match_table, dev) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>      *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span>     *<span class=\"title\">bus</span>;</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span>   *<span class=\"title\">of_match_table</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/linux/mod_devicetable.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>    name[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    type[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    compatible[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/device.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> struct of_device_id *<span class=\"title\">of_match_device</span><span class=\"params\">(<span class=\"keyword\">const</span> struct of_device_id *matches,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       <span class=\"keyword\">const</span> struct device *dev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((!matches) || (!dev-&gt;of_node))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> of_match_node(matches, dev-&gt;of_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(of_match_device);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/base.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> struct of_device_id *<span class=\"title\">of_match_node</span><span class=\"params\">(<span class=\"keyword\">const</span> struct of_device_id *matches,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">const</span> struct device_node *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> *<span class=\"title\">match</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">    raw_spin_lock_irqsave(&amp;devtree_lock, flags);</span><br><span class=\"line\">    match = __of_match_node(matches, node);</span><br><span class=\"line\">    raw_spin_unlock_irqrestore(&amp;devtree_lock, flags);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(of_match_node);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/of/base.c</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> *__<span class=\"title\">of_match_node</span>(<span class=\"title\">const</span> <span class=\"title\">struct</span> <span class=\"title\">of_device_id</span> *<span class=\"title\">matches</span>,</span></span><br><span class=\"line\"><span class=\"class\">                       <span class=\"title\">const</span> <span class=\"title\">struct</span> <span class=\"title\">device_node</span> *<span class=\"title\">node</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> *<span class=\"title\">best_match</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> score, best_score = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!matches)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; matches-&gt;name[<span class=\"number\">0</span>] || matches-&gt;type[<span class=\"number\">0</span>] || matches-&gt;compatible[<span class=\"number\">0</span>]; matches++) &#123;</span><br><span class=\"line\">        score = __of_device_is_compatible(node, matches-&gt;compatible,</span><br><span class=\"line\">                          matches-&gt;type, matches-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (score &gt; best_score) &#123;</span><br><span class=\"line\">            best_match = matches;</span><br><span class=\"line\">            best_score = score;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> best_match;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>设备树和驱动的匹配过程如下：</p>\n<pre class=\"mermaid\">graph TB\n    of_driver_match_device(of_driver_match_device)-->\n    of_match_device(of_match_device)-->\n    of_match_node(of_match_node)-->\n    __of_match_node(__of_match_node)-->\n    __of_device_is_compatible(__of_device_is_compatible)\n    __of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n    __of_device_is_compatible--type-->of_compat_cmp\n    __of_device_is_compatible--name-->of_compat_cmp\n    of_compat_cmp-->\n    strcasecmp(strcasecmp)</pre>\n\n\n\n\n\n<p>__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；</p>\n<p>匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；</p>\n<p>platform_device</p>\n<pre><code>struct device dev;\n\n\n    of_node</code></pre><p>对于dts生成的platform_device，dev中含有of_node；</p>\n<p>of_node中含有的属性，取决于设备树；比如：compatible、reg、pin属性；</p>\n<p>compatible属性和of_match_table中的compatible进行比对；</p>\n<p>优先比较：compatible，</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://www.jianshu.com/p/6325f723509b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6325f723509b</a></p>\n<p><a href=\"目录\">回到目录</a></p>"},{"title":"Qemu搭建ARM vexpress开发环境(二)----u-boot启动kernel","date":"2019-08-18T13:00:00.000Z","_content":"\n标签： Qemu\n\n---\n\n在上文《[Qemu搭建ARM vexpress开发环境(一)](https://www.jianshu.com/p/94833e841742)》中已经简单讲述了通过Qemu直接启动Linux内核，并挂载SD卡根文件系统的方法，这种方法是直接启动内核，与实际应用中ARM板的启动方式：u-boot、kernel、rootfs有些不同。现在就来讲述下用Qemu搭建通过u-boot启动Linux内核并挂载根文件系统的方法。\n\n<!--more-->\n\n\n\n## 目录\n\n[TOC]\n\n\n\n## 1. 简述\n\n嵌入式系统要正常运行，应该包含：u-boot、kernel、rootfs、appfs。这几部分在ARM开发板Flash上的位置关系应该类似于下图所示：\n\n| BootLoader | BootParameters | Kernel | Rootfs | Appfs |\n| :--------: | :------------: | :----: | :----: | :---: |\n\n\n\n嵌入式系统的启动流程如下：\n\n```mermaid\ngraph TB\n\tBootLoader(BootLoader)--BootParameters-->Kernel(Kernel)-->Rootfs(Rootfs)-->Appfs(Appfs)\n```\n\nrootfs可以添加到开发板的Flash，也可以不用添加到开发板，而是部署到PC机上，开发板在运行完kernel，要挂载rootfs时，可以通过NFS网络挂载到设定好的PC机上的rootfs根文件系统上（下一篇文章《Qemu搭建ARM vexpress开发环境(三)----NFS网络根文件系统》会详细讲解NFS网络挂载根文件系统的具体操作方法）。\n\n\n\n## 2. 准备u-boot\n\n\n用来使用u-boot启动加载Linux内核\n\n\n\n### 2.1 下载u-boot\n\n从 http://ftp.denx.de/pub/u-boot 网站选择一个u-boot版本源码下载，本文中使用的是u-boot-2020.01版本。\n\n\n\n### 2.2 解压u-boot\n\n解压u-boot:\n```shell\n# tar -xvf u-boot-2020.01.tar.bz2\n```\n\n\n\n### 2.3 编译u-boot\n\n\n\n#### 2.3.1 配置时碰到的问题\n\n\n\n##### 配置命令\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_ca9x4_defconfig\n```\n\n\n\n如果没有修改Makefile和config.mk文件，需要在编译时加上ARCH和CROSS_COMPILE的配置；在编译u-boot时可能会出现一些问题，只要逐个问题解决就可以编译完成了；\n\n```shell\n/bin/sh: 1: bison: not found\nscripts/Makefile.lib:226: recipe for target 'scripts/kconfig/zconf.tab.c' failed\nmake[1]: *** [scripts/kconfig/zconf.tab.c] Error 127\nMakefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed\nmake: *** [vexpress_ca9x4_defconfig] Error 2\n```\n\n\n\n```shell\n# sudo apt-get install bison\n```\n\n\n\n\n\n```shell\n/bin/sh: 1: flex: not found\nscripts/Makefile.lib:218: recipe for target 'scripts/kconfig/zconf.lex.c' failed\nmake[1]: *** [scripts/kconfig/zconf.lex.c] Error 127\nMakefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed\nmake: *** [vexpress_ca9x4_defconfig] Error 2\n```\n\n\n\n```shell\n# sudo apt-get install flex\n```\n\n\n\n```shell\n# make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object -j4\nscripts/kconfig/conf  --syncconfig Kconfig\n  CHK     include/config.h\n  GEN     include/autoconf.mk.dep\n  CFG     u-boot.cfg\n  GEN     include/autoconf.mk\n*** Your GCC is older than 6.0 and is not supported\narch/arm/config.mk:66: recipe for target 'checkgcc6' failed\nmake: *** [checkgcc6] Error 1\n```\n\n\n\n```shell\n# vim arch/arm/config.mk\nifeq ($(CONFIG_$(SPL_)SYS_THUMB_BUILD),y)\n#archprepare: checkthumb checkgcc6\narchprepare: checkthumb\ncheckthumb:\n        @if test \"$(call cc-name)\" = \"gcc\" -a \\\n                        \"$(call cc-version)\" -lt \"0404\"; then \\\n                echo -n '*** Your GCC does not produce working '; \\\n                echo 'binaries in THUMB mode.'; \\\n                echo '*** Your board is configured for THUMB mode.'; \\\n                false; \\\n        fi\n#else\n#archprepare: checkgcc6\nendif\n\n#checkgcc6:\n#        @if test \"$(call cc-name)\" = \"gcc\" -a \\\n#                        \"$(call cc-version)\" -lt \"0600\"; then \\\n#                echo '*** Your GCC is older than 6.0 and is not supported'; \\\n#                false; \\\n#        fi\n```\n\n\n\n#### 2.3.2 生成配置文件\n\n```shell\n# make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object\nmake[1]: Entering directory '/home/xiami/tool/u-boot-2020.01/object'\n  HOSTCC  scripts/basic/fixdep\n  GEN     ./Makefile\n  HOSTCC  scripts/kconfig/conf.o\n  YACC    scripts/kconfig/zconf.tab.c\n  LEX     scripts/kconfig/zconf.lex.c\n  HOSTCC  scripts/kconfig/zconf.tab.o\n  HOSTLD  scripts/kconfig/conf\n#\n# configuration written to .config\n#\nmake[1]: Leaving directory '/home/xiami/tool/u-boot-2020.01/object'\n```\n\n\n\n./configs/vexpress_ca9x4_defconfig\n\n\n\n```shell\n# ls object/.config -l\n-rw-r--r-- 1 xiami xiami 22698 Mar 17 23:20 object/.config\n```\n\n\n\n如果需要修改配置文件中的一些选项，可以通过以下界面操作选择：\n\n```shell\n# make menuconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object\n```\n\n\n\n#### 2.3.3 编译\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object\n```\n\n\n\n#### 2.3.4 简化编译过程\n\n这种方式编译比较直接，但是在调试时，需要多次编译u-boot，参数太多会带来不便，于是可以通过以下方法，修改Makefile和config.mk文件中的ARCH和CROSS_COMPILE选项，在编译的时候就可以省去了在编译命令中添加编译配置的设置。\n\n修改Makefile\n```shell\n# vim Makefile\nCROSS_COMPILE = arm-linux-gnueabi-\n```\n修改config.mk\n```shell\n# vim config.mk\nARCH = arm\n```\n\n\n编译u-boot:\n```shell\n# make vexpress_ca9x4_defconfig\n# make -j4\n```\n\n\n\n### 2.4 启动u-boot\n\n通过Qemu启动命令启动u-boot：\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -nographic -kernel ./u-boot\n\nU-Boot 2020.01 (Mar 17 2020 - 23:21:36 +0800)\n\nDRAM:  512 MiB\nWARNING: Caches not enabled\nFlash: 128 MiB\nMMC:   MMC: 0\n*** Warning - bad CRC, using default environment\n\nIn:    serial\nOut:   serial\nErr:   serial\nNet:   smc911x-0\nHit any key to stop autoboot:  0 \n=>\n```\n\n查看u-boot的版本：\n\n```shell\n=> version\nU-Boot 2020.01 (Mar 20 2020 - 23:01:23 +0800)\n\narm-linux-gnueabi-gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0\nGNU ld (GNU Binutils for Ubuntu) 2.30\n```\n\n\n\n打印u-boot的环境变量：\n```shell\n=> print\narch=arm\nbaudrate=38400\nboard=vexpress\nboard_name=vexpress\n......\nscriptaddr=0x88000000\nstderr=serial\nstdin=serial\nstdout=serial\nvendor=armltd\n\nEnvironment size: 2656/262140 bytes\n```\n\n至此，u-boot启动成功，下一步开始配置u-boot的内核启动参数，来启动Linux内核，并挂在根文件系统。\n\n\n\n## 3. 准备内核\n\n\n\n### 3.1 指定加载地址\n\n使用u-boot引导内核启动，需要内核的uImage镜像：\n\n> 需要将内核编译为uImage格式，需要指定uImage在内存中的加载地址，编译内核时指定：make LOADADDR=? uImage -j4\n\n\n\n如果不指定LOADADDR参数，编译时会报错，如下：\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage -j4 O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n......\n  Kernel: arch/arm/boot/Image is ready\n  Kernel: arch/arm/boot/zImage is ready\nmultiple (or no) load addresses: \nThis is incompatible with uImages\nSpecify LOADADDR on the commandline to build an uImage\n../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed\nmake[2]: *** [arch/arm/boot/uImage] Error 1\narch/arm/Makefile:338: recipe for target 'uImage' failed\nmake[1]: *** [uImage] Error 2\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\nMakefile:146: recipe for target 'sub-make' failed\nmake: *** [sub-make] Error 2\n```\n\n\n\n在内核目录直接编译：\n```shell\n# make LOADADDR=0x60003000 uImage -j4\n```\n\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n......\n  Kernel: arch/arm/boot/Image is ready\n  Kernel: arch/arm/boot/zImage is ready\n  UIMAGE  arch/arm/boot/uImage\n\"mkimage\" command not found - U-Boot images will not be built\n../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed\nmake[2]: *** [arch/arm/boot/uImage] Error 1\narch/arm/Makefile:338: recipe for target 'uImage' failed\nmake[1]: *** [uImage] Error 2\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\nMakefile:146: recipe for target 'sub-make' failed\nmake: *** [sub-make] Error 2\n```\n\n\n\n第一次编译会报错，提示没有找到mkimage工具，需要手动安装u-boot-tools即可；\n\n```shell\n# sudo apt-get install u-boot-tools\n```\n\n\n\n### 3.2 编译uImage\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n......\nLoad Address: 60003000\nEntry Point:  60003000\n  Kernel: arch/arm/boot/uImage is ready\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\n```\n\n\n\n或者在Makefile中添加加载地址配置：\n\n```shell\n# vim arch/arm/boot/Makefile\nLOADADDR ?= 0x60003000\n```\n再编译生成uImage文件:\n```shell\n# make uImage -j4\n```\n\n\n\n## 4. Qemu网络功能设置\n\nQemu虚拟机在u-boot启动时，需要将uImage加载到内存，而uImage从哪里来？可以通过TFTP服务器下载uImage到内存指定地址。而在这之前需要通过桥接方式将网络链接到Ubuntu系统。\n\n\n\n### 4.1 配置Qemu与主机的网络连接\n\n\n\n采用桥接网络连接Host主机通信\n主机内核需要支持tun/tap模块\n\n\n\n### 4.2 配置Ubuntu主机\n\n#### 1) 安装工具\n\n安装桥接网络依赖的两个工具：\n```shell\n# sudo apt install uml-utilities bridge-utils\n```\n\n创建tun设备文件：/dev/net/tun（一般会自动创建）\n\n```shell\n# ls /dev/net/tun -l\ncrw-rw-rw- 1 root root 10, 200 Mar 20 21:31 /dev/net/tun\n```\n\n\n\n#### 2) 配置网络\n\n修改/etc/network/interfaces文件配置网络\n\n```shell\n# sudo vim /etc/network/interfaces\n# interfaces(5) file used by ifup(8) and ifdown(8)\nauto lo\niface lo inet loopback\n\nauto br0\niface br0 inet dhcp\nbridge_ports enp0s25\n```\n\n\n\n#### 3) 添加网络配置脚本\n\n配置/etc/qemu-ifup、/etc/qemu-ifdown脚本；\n\n默认情况下，当qemu使用tap设备时，会执行/etc/qemu-ifup和/etc/qemu-ifdown这两个脚本；需要创建这两个脚本，并加上可执行权限；\n\n```shell\n# cat /etc/qemu-ifup\n#!/bin/sh\n\necho sudo tunctl -u $(id -un) -t $1\nsudo tunctl -u $(id -un) -t $1\n\necho sudo ifconfig $1 0.0.0.0 promisc up\nsudo ifconfig $1 0.0.0.0 promisc up\n\necho sudo brctl addif br0 $1\nsudo brctl addif br0 $1\n\necho brctl show\nbrctl show\n\n# sudo ifconfig br0 192.168.1.102\n```\n\n\n\n```shell\n# ifconfig\nenp0s25: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20<link>\n        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)\n        RX packets 146587  bytes 69384714 (69.3 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 117583  bytes 13689404 (13.6 MB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n        device interrupt 20  memory 0xf3900000-f3920000  \n```\n\n\n\n查询到enp0s25的IP地址是192.168.1.102，需要将br0配置在同一个192.168.1.***网段；\n\n```shell\n# cat /etc/qemu-ifdown\n#!/bin/sh\n\necho sudo brctl delif br0 $1\nsudo brctl delif br0 $1\n\necho sudo tunctl -d $1\nsudo tunctl -d $1\n \necho brctl show\nbrctl show\n```\n\n\n\n```shell\n# chmod a+x /etc/qemu-ifup\n# chmod a+x /etc/qemu-ifdown\n```\n\n重启PC，使新的/etc/network/interfaces配置文件生效；\n\n\n\n### 4.3 关闭防火墙\n\n\n\n#### 1) 关闭防火墙\n\n```shell\n# sudo ufw disable\nFirewall stopped and disabled on system startup\n```\n\n\n\n#### 2) 查看当前防火墙状态\n\n```shell\n# sudo ufw status\nStatus: inactive\n```\n\n\n\n另外，附上开启防火墙的操作方法：\n\n```shell\n# ufw enable\n```\n\n\n\n### 4.4 重启系统，使配置生效\n\n```shell\n# reboot\n```\n或者：\n```shell\n# init 6\n```\n\n\n\n### 4.5 查看Qemu的网络环境\n\n```shell\n# ifconfig\nbr0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20<link>\n        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)\n        RX packets 44667  bytes 16853864 (16.8 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 45161  bytes 32391098 (32.3 MB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n虚拟网口br0即Qemu虚拟机与Linux主机通讯的网口；\n\n在u-boot中测试网络是否接通：\n\n```shell\n=> ping 192.168.1.102\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nsmc911x: MAC 52:54:00:12:34:56\nhost 192.168.1.102 is alive\n```\n\n\n\n## 5. 安装TFTP服务器\n\n创建TFTP服务器，用来给Qemu模拟开发板启动uImage时，下载uImage到内存中。\n\n\n\n### 5.1 安装TFTP工具\n\n\n\n安装Linux主机Host的TFTP服务器工具：\n\n```shell\n# sudo apt install tftp-hpa tftpd-hpa xinetd\n```\n\n\n\n### 5.2 配置\n\n\n\n#### 1) 修改配置文件，设置TFTP服务器目录\n\n```shell\n# sudo vim /etc/default/tftpd-hpa\n......\nTFTP_USERNAME=\"xiami\"\nTFTP_DIRECTORY=\"/home/xiami/qemu/boot-uboot\"\nTFTP_ADDRESS=\"0.0.0.0:69\"\nTFTP_OPTIONS=\"-l -c -s\"\n......\n```\n\n\n\n> 说明：\n>\n> TFTP_USERNAME：必须设置为当前的用户名，或：root\n>\n> TFTP_DIRECTORY：设定TFTP的根目录\n>\n> TFTP_ADDRESS：\n>\n> TFTP_OPTIONS：TFTP启动参数\n>\n> ​\t-l: 以standalone/listen模式启动TFTP服务，而不是从inetd启动，不需要安装xinetd\n>\n> ​\t-c: 可创建新文件，默认，TFTP只允许覆盖原文件，不能创建新文件\n>\n> ​\t-s: 改变TFTP启动的根目录；加入-s后，客户端使用TFTP时，不再需要输入指定目录，填写文件的完整路径，而是使用配置文件中写好的目录；\n\n\n\n#### 2) Linux主机上创建tftp目录\n\n```shell\n# mkdir /home/mcy/tftpboot\n# chmod 777 /home/mcy/tftpboot\n```\n\n\n\n#### 3) 重启tftp服务\n\n```powershell\n# sudo /etc/init.d/tftpd-hpa restart\n[ ok ] Restarting tftpd-hpa (via systemctl): tftpd-hpa.service.\n```\n\n\n\n### 5.3 测试验证\n\n#### 1) 测试tftp服务器\n\n可以使用三种方法，1. 输入真实的IP地址；2. 用localhost代替主机；3. 使用地址127.0.0.1，这个IP地址始终代表本机IP；\n\ntftp 192.168.1.102\n\ntftp localhost\n\ntftp 127.0.0.1\n\n\n\n#### 2) TFTP命令行的基本命令\n\nput: 将文件上传到TFTP根目录\n\nget: 取得TFTP根目录上的文件\n\nquit/q: 退出TFTP服务\n\n\n\n## 6. 设置u-boot中的内核启动参数\n\n\n\n### 6.1 设置u-boot参数\n\nu-boot能够正常启动还不足以引导内核启动，需要在u-boot中设置一些启动参数，在引导内核启动时，将这些启动参数传递给内核；内核启动后挂载SD卡中的文件系统；\n\n这些启动参数，可以在u-boot启动后，手动设置，也可以在u-boot中，把内核启动参数写入vexpress_common.h头文件；\n\n\n\n#### 1） 写入u-boot头文件\n\n修改vexpress_common.h头文件，添加内核启动需要的参数：\n\n```c\n# vim include/configs/vexpress_common.h\n#define CONFIG_BOOTCOMMAND  \\\n    \"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\\n    setenv bootargs 'root=/dev/mmcblk0 rw   \\\n    init=/linuxrc   \\\n    ip=192.168.1.110 console=ttyAMA0';  \\\n    bootm 0x60003000 - 0x60500000;\"\n\n#define CONFIG_IPADDR   192.168.1.110\n#define CONFIG_SERVERIP 192.168.1.104\n#define CONFIGN_NETMASK 255.255.255.0\n```\n\n参数说明：\n\n> CONFIG_IPADDR： 设备的本地IP地址\n>\n> CONFIG_SERVERIP： TFTP下载时的服务器IP地址\n>\n> CONFIG_BOOTCOMMAND： 内核启动的参数设置，包含boot_args\n\n\n\n#### 2） 手动设置\n\n在u-boot启动之后，手动设置环境变量：\n\n```shell\n=> setenv ipaddr 192.168.1.110\n=> setenv serverip 192.168.1.102\n=> setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'\n```\n\n手动设置tftp下载：\n\n```shell\n=> tftp 0x60003000 uImage\t// tftp下载内核镜像\n=> tftp 0x60500000 vexpress-v2p-ca9.dtb\t\t// tftp下载设备树\n=> bootm 0x60003000 - 0x60500000\t// 启动内核\n```\n\n手动设置用来调试比较方便，但是正常使用时，还是将设置参数写入u-boot的vexpress_common.h头文件比较好，免得每次启动都需要输入这么多命令；\n\n\n\n#### 3） 设置挂载nfs网络文件系统\n\n如果需要通过nfs挂载网络文件系统，需要在u-boot中，设置boot_args，如下：\n\n\n```c\n# vim include/configs/vexpress_common.h\n\n#define CONFIG_BOOTCOMMAND  \\\n    \"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\\n    setenv bootargs 'root=/dev/nfs rw   \\\n    nfsroot=192.168.1.102:/home/xiami/qemu/nfs_root init=/linuxrc   \\\n    ip=192.168.1.110 console=ttyAMA0';  \\\n    bootm 0x60003000 - 0x60500000;\"\n\n#define CONFIG_IPADDR   192.168.1.110\n#define CONFIG_SERVERIP 192.168.1.104\n#define CONFIGN_NETMASK 255.255.255.0\n```\n\n\n重新编译u-boot；启动Qemu验证\n\n```shell\n=> print bootcmd\nbootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/nfs rw nfsroot=192.168.1.102:/home/xiami/qemu/boot-uboot/rootfs init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;\n=> print ipaddr\nipaddr=192.168.1.110\n=> print serverip\nserverip=192.168.1.102\n```\n\n网络还没有ping通：\n\n```shell\n=> ping 192.168.1.102\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\n\nARP Retry count exceeded; starting again\nsmc911x: MAC 52:54:00:12:34:56\nping failed; host 192.168.1.102 is not alive\n```\n\n这部分在下一节中再讲述，此处略过；\n\n\n\n### 6.2 启动验证\n\n#### 1） 启动Qemu，并检查启动参数\n\n```powershell\n# cat boot.sh\n#! /bin/sh\nsudo qemu-system-arm \\\n\t-M vexpress-a9 \\\n\t-m 512M \\\n\t-kernel ./u-boot \\\n\t-nographic \\\n\t-append console=ttyAMA0 \\\n\t-sd rootfs.ext3 \\\n\t-net nic \\\n\t-net tap\n```\n\n\n\nu-boot启动后，查看u-boot中的环境变量：\n\n```shell\n=> print bootcmd\nbootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;\n=> print ipaddr\nipaddr=192.168.1.110\n=> print serverip\nserverip=192.168.1.102\n```\n\n\n\n检查tftp下载网络，在开发板的u-boot中，ping本地PC的tftp服务器，注意，不要用电脑ping开发板，因为u-boot中没有回应机制，是ping不通开发板的；\n\n```shell\n=> ping 192.168.1.102\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nsmc911x: MAC 52:54:00:12:34:56\nhost 192.168.1.102 is alive\n```\n\n\n\n#### 2） 启动验证\n\n\n\n```\n# ./boot-uboot-tftp.sh \nBooting qemu vexpress-ca9\nWARNING: Image format was not specified for 'rootfs.ext3' and probing guessed raw.\n         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.\n         Specify the 'raw' format explicitly to remove the restrictions.\nsudo tunctl -u root -t tap0\nTUNSETIFF: Device or resource busy\nsudo ifconfig tap0 0.0.0.0 promisc up\nsudo brctl addif br0 tap0\nbrctl show\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\nbr0\t\t8000.0021ccd65a96\tno\t\tenp0s25\n\t\t\t\t\t\t\ttap0\n\nU-Boot 2020.01 (Mar 22 2020 - 16:51:32 +0800)\n\nDRAM:  512 MiB\nWARNING: Caches not enabled\nFlash: 128 MiB\nMMC:   MMC: 0\n*** Warning - bad CRC, using default environment\n\nIn:    serial\nOut:   serial\nErr:   serial\nNet:   smc911x-0\nHit any key to stop autoboot:  0 \nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.102; our IP address is 192.168.1.110\nFilename 'uImage'.\nLoad address: 0x60003000\nLoading: #################################################################\n\t #################################################################\n\t #################################################################\n\t #################################################################\n\t ###########\n\t 8.7 MiB/s\ndone\nBytes transferred = 3971576 (3c99f8 hex)\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.102; our IP address is 192.168.1.110\nFilename 'vexpress-v2p-ca9.dtb'.\nLoad address: 0x60500000\nLoading: ##\n\t 4.7 MiB/s\ndone\nBytes transferred = 14692 (3964 hex)\nsmc911x: MAC 52:54:00:12:34:56\n## Booting kernel from Legacy Image at 60003000 ...\n   Image Name:   Linux-4.14.172\n   Image Type:   ARM Linux Kernel Image (uncompressed)\n   Data Size:    3971512 Bytes = 3.8 MiB\n   Load Address: 60003000\n   Entry Point:  60003000\n   Verifying Checksum ... OK\n## Flattened Device Tree blob at 60500000\n   Booting using the fdt blob at 0x60500000\n   Loading Kernel Image\n   Loading Device Tree to 7fe81000, end 7fe87963 ... OK\n\nStarting kernel ...\n\nBooting Linux on physical CPU 0x0\nLinux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020\nCPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr=10c5387d\nCPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache\nOF: fdt: Machine model: V2P-CA9\nMemory policy: Data cache writeback\nCPU: All CPU(s) started in SVC mode.\npercpu: Embedded 15 pages/cpu s32396 r8192 d20852 u61440\nBuilt 1 zonelists, mobility grouping on.  Total pages: 130048\nKernel command line: root=/dev/mmcblk0 rw       init=/linuxrc       ip=192.168.1.110 console=ttyAMA0\nlog_buf_len individual max cpu contribution: 4096 bytes\nlog_buf_len total cpu_extra contributions: 12288 bytes\nlog_buf_len min size: 16384 bytes\nlog_buf_len: 32768 bytes\nearly log buf free: 14980(91%)\nPID hash table entries: 2048 (order: 1, 8192 bytes)\nDentry cache hash table entries: 65536 (order: 6, 262144 bytes)\nInode-cache hash table entries: 32768 (order: 5, 131072 bytes)\nMemory: 509616K/524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14672K reserved, 0K cma-reserved)\nVirtual kernel memory layout:\n    vector  : 0xffff0000 - 0xffff1000   (   4 kB)\n    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)\n    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)\n    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)\n    modules : 0x7f000000 - 0x80000000   (  16 MB)\n      .text : 0x80008000 - 0x80700000   (7136 kB)\n      .init : 0x80900000 - 0x80a00000   (1024 kB)\n      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)\n       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)\nSLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1\nHierarchical RCU implementation.\n\tRCU event tracing is enabled.\n\tRCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.\n\n......\n\nIP-Config: Guessing netmask 255.255.255.0\nIP-Config: Complete:\n     device=eth0, hwaddr=52:54:00:12:34:56, ipaddr=192.168.1.110, mask=255.255.255.0, gw=255.255.255.255\n     host=192.168.1.110, domain=, nis-domain=(none)\n     bootserver=255.255.255.255, rootserver=255.255.255.255, rootpath=\nALSA device list:\n  #0: ARM AC'97 Interface PL041 rev0 at 0x10004000, irq 30\nEXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem\nrandom: fast init done\nEXT4-fs (mmcblk0): recovery complete\nEXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)\nVFS: Mounted root (ext3 filesystem) on device 179:0.\nFreeing unused kernel memory: 1024K\nrandom: crng init done\nHello Linux Qemu!\n\nPlease press Enter to activate this console. \n/ # \n```\n\n\n\n\n\n\n\n```\n=> reset\nresetting ...\n\n\nU-Boot 2017.05 (Jul 24 2019 - 21:52:28 +0800)\n\nDRAM:  512 MiB\nWARNING: Caches not enabled\nFlash: 128 MiB\nMMC:   MMC: 0\n*** Warning - bad CRC, using default environment\n\nIn:    serial\nOut:   serial\nErr:   serial\nNet:   smc911x-0\nHit any key to stop autoboot:  0 \nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.104; our IP address is 192.168.1.110\nFilename 'uImage'.\nLoad address: 0x60003000\nLoading: #################################################################\n\t #################################################################\n\t #################################################################\n\t ##################################################\n\t 1.3 MiB/s\ndone\nBytes transferred = 3581920 (36a7e0 hex)\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.104; our IP address is 192.168.1.110\nFilename 'vexpress-v2p-ca9.dtb'.\nLoad address: 0x60500000\nLoading: #\n\t 250 KiB/s\ndone\nBytes transferred = 14360 (3818 hex)\nsmc911x: MAC 52:54:00:12:34:56\n## Booting kernel from Legacy Image at 60003000 ...\n   Image Name:   Linux-4.4.157\n   Image Type:   ARM Linux Kernel Image (uncompressed)\n   Data Size:    3581856 Bytes = 3.4 MiB\n   Load Address: 60003000\n   Entry Point:  60003000\n   Verifying Checksum ... OK\n## Flattened Device Tree blob at 60500000\n   Booting using the fdt blob at 0x60500000\n   Loading Kernel Image ... OK\n   Loading Device Tree to 7fed4000, end 7feda817 ... OK\n\n\n```\n\n至此，通过u-boot加载kernel，并挂载SD卡文件系统已经成功；\n\n\n\n### 7. 总结\n\nSD卡中rootfs目录是一个简易的根文件系统，可以将它制作成一个镜像文件，将镜像文件烧写到开发板，或者通过Qemu中的u-boot启动Linux内核后挂载到镜像文件上。也可以设置为通过NFS网络文件系统启动，参考下一篇文章《[Qemu搭建ARM vexpress开发环境(三)----NFS网络根文件系统](https://www.jianshu.com/p/cf46f7225db6)》。\n\n\n\n\n\n","source":"_posts/Qemu搭建ARM-vexpress开发环境(二)----u-boot启动kernel.md","raw":"---\ntitle: Qemu搭建ARM vexpress开发环境(二)----u-boot启动kernel\ndate: 2019-08-18 21:00:00\ntags: Qemu\n\n---\n\n标签： Qemu\n\n---\n\n在上文《[Qemu搭建ARM vexpress开发环境(一)](https://www.jianshu.com/p/94833e841742)》中已经简单讲述了通过Qemu直接启动Linux内核，并挂载SD卡根文件系统的方法，这种方法是直接启动内核，与实际应用中ARM板的启动方式：u-boot、kernel、rootfs有些不同。现在就来讲述下用Qemu搭建通过u-boot启动Linux内核并挂载根文件系统的方法。\n\n<!--more-->\n\n\n\n## 目录\n\n[TOC]\n\n\n\n## 1. 简述\n\n嵌入式系统要正常运行，应该包含：u-boot、kernel、rootfs、appfs。这几部分在ARM开发板Flash上的位置关系应该类似于下图所示：\n\n| BootLoader | BootParameters | Kernel | Rootfs | Appfs |\n| :--------: | :------------: | :----: | :----: | :---: |\n\n\n\n嵌入式系统的启动流程如下：\n\n```mermaid\ngraph TB\n\tBootLoader(BootLoader)--BootParameters-->Kernel(Kernel)-->Rootfs(Rootfs)-->Appfs(Appfs)\n```\n\nrootfs可以添加到开发板的Flash，也可以不用添加到开发板，而是部署到PC机上，开发板在运行完kernel，要挂载rootfs时，可以通过NFS网络挂载到设定好的PC机上的rootfs根文件系统上（下一篇文章《Qemu搭建ARM vexpress开发环境(三)----NFS网络根文件系统》会详细讲解NFS网络挂载根文件系统的具体操作方法）。\n\n\n\n## 2. 准备u-boot\n\n\n用来使用u-boot启动加载Linux内核\n\n\n\n### 2.1 下载u-boot\n\n从 http://ftp.denx.de/pub/u-boot 网站选择一个u-boot版本源码下载，本文中使用的是u-boot-2020.01版本。\n\n\n\n### 2.2 解压u-boot\n\n解压u-boot:\n```shell\n# tar -xvf u-boot-2020.01.tar.bz2\n```\n\n\n\n### 2.3 编译u-boot\n\n\n\n#### 2.3.1 配置时碰到的问题\n\n\n\n##### 配置命令\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_ca9x4_defconfig\n```\n\n\n\n如果没有修改Makefile和config.mk文件，需要在编译时加上ARCH和CROSS_COMPILE的配置；在编译u-boot时可能会出现一些问题，只要逐个问题解决就可以编译完成了；\n\n```shell\n/bin/sh: 1: bison: not found\nscripts/Makefile.lib:226: recipe for target 'scripts/kconfig/zconf.tab.c' failed\nmake[1]: *** [scripts/kconfig/zconf.tab.c] Error 127\nMakefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed\nmake: *** [vexpress_ca9x4_defconfig] Error 2\n```\n\n\n\n```shell\n# sudo apt-get install bison\n```\n\n\n\n\n\n```shell\n/bin/sh: 1: flex: not found\nscripts/Makefile.lib:218: recipe for target 'scripts/kconfig/zconf.lex.c' failed\nmake[1]: *** [scripts/kconfig/zconf.lex.c] Error 127\nMakefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed\nmake: *** [vexpress_ca9x4_defconfig] Error 2\n```\n\n\n\n```shell\n# sudo apt-get install flex\n```\n\n\n\n```shell\n# make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object -j4\nscripts/kconfig/conf  --syncconfig Kconfig\n  CHK     include/config.h\n  GEN     include/autoconf.mk.dep\n  CFG     u-boot.cfg\n  GEN     include/autoconf.mk\n*** Your GCC is older than 6.0 and is not supported\narch/arm/config.mk:66: recipe for target 'checkgcc6' failed\nmake: *** [checkgcc6] Error 1\n```\n\n\n\n```shell\n# vim arch/arm/config.mk\nifeq ($(CONFIG_$(SPL_)SYS_THUMB_BUILD),y)\n#archprepare: checkthumb checkgcc6\narchprepare: checkthumb\ncheckthumb:\n        @if test \"$(call cc-name)\" = \"gcc\" -a \\\n                        \"$(call cc-version)\" -lt \"0404\"; then \\\n                echo -n '*** Your GCC does not produce working '; \\\n                echo 'binaries in THUMB mode.'; \\\n                echo '*** Your board is configured for THUMB mode.'; \\\n                false; \\\n        fi\n#else\n#archprepare: checkgcc6\nendif\n\n#checkgcc6:\n#        @if test \"$(call cc-name)\" = \"gcc\" -a \\\n#                        \"$(call cc-version)\" -lt \"0600\"; then \\\n#                echo '*** Your GCC is older than 6.0 and is not supported'; \\\n#                false; \\\n#        fi\n```\n\n\n\n#### 2.3.2 生成配置文件\n\n```shell\n# make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object\nmake[1]: Entering directory '/home/xiami/tool/u-boot-2020.01/object'\n  HOSTCC  scripts/basic/fixdep\n  GEN     ./Makefile\n  HOSTCC  scripts/kconfig/conf.o\n  YACC    scripts/kconfig/zconf.tab.c\n  LEX     scripts/kconfig/zconf.lex.c\n  HOSTCC  scripts/kconfig/zconf.tab.o\n  HOSTLD  scripts/kconfig/conf\n#\n# configuration written to .config\n#\nmake[1]: Leaving directory '/home/xiami/tool/u-boot-2020.01/object'\n```\n\n\n\n./configs/vexpress_ca9x4_defconfig\n\n\n\n```shell\n# ls object/.config -l\n-rw-r--r-- 1 xiami xiami 22698 Mar 17 23:20 object/.config\n```\n\n\n\n如果需要修改配置文件中的一些选项，可以通过以下界面操作选择：\n\n```shell\n# make menuconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object\n```\n\n\n\n#### 2.3.3 编译\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object\n```\n\n\n\n#### 2.3.4 简化编译过程\n\n这种方式编译比较直接，但是在调试时，需要多次编译u-boot，参数太多会带来不便，于是可以通过以下方法，修改Makefile和config.mk文件中的ARCH和CROSS_COMPILE选项，在编译的时候就可以省去了在编译命令中添加编译配置的设置。\n\n修改Makefile\n```shell\n# vim Makefile\nCROSS_COMPILE = arm-linux-gnueabi-\n```\n修改config.mk\n```shell\n# vim config.mk\nARCH = arm\n```\n\n\n编译u-boot:\n```shell\n# make vexpress_ca9x4_defconfig\n# make -j4\n```\n\n\n\n### 2.4 启动u-boot\n\n通过Qemu启动命令启动u-boot：\n```shell\n# qemu-system-arm -M vexpress-a9 -m 512M -nographic -kernel ./u-boot\n\nU-Boot 2020.01 (Mar 17 2020 - 23:21:36 +0800)\n\nDRAM:  512 MiB\nWARNING: Caches not enabled\nFlash: 128 MiB\nMMC:   MMC: 0\n*** Warning - bad CRC, using default environment\n\nIn:    serial\nOut:   serial\nErr:   serial\nNet:   smc911x-0\nHit any key to stop autoboot:  0 \n=>\n```\n\n查看u-boot的版本：\n\n```shell\n=> version\nU-Boot 2020.01 (Mar 20 2020 - 23:01:23 +0800)\n\narm-linux-gnueabi-gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0\nGNU ld (GNU Binutils for Ubuntu) 2.30\n```\n\n\n\n打印u-boot的环境变量：\n```shell\n=> print\narch=arm\nbaudrate=38400\nboard=vexpress\nboard_name=vexpress\n......\nscriptaddr=0x88000000\nstderr=serial\nstdin=serial\nstdout=serial\nvendor=armltd\n\nEnvironment size: 2656/262140 bytes\n```\n\n至此，u-boot启动成功，下一步开始配置u-boot的内核启动参数，来启动Linux内核，并挂在根文件系统。\n\n\n\n## 3. 准备内核\n\n\n\n### 3.1 指定加载地址\n\n使用u-boot引导内核启动，需要内核的uImage镜像：\n\n> 需要将内核编译为uImage格式，需要指定uImage在内存中的加载地址，编译内核时指定：make LOADADDR=? uImage -j4\n\n\n\n如果不指定LOADADDR参数，编译时会报错，如下：\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage -j4 O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n......\n  Kernel: arch/arm/boot/Image is ready\n  Kernel: arch/arm/boot/zImage is ready\nmultiple (or no) load addresses: \nThis is incompatible with uImages\nSpecify LOADADDR on the commandline to build an uImage\n../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed\nmake[2]: *** [arch/arm/boot/uImage] Error 1\narch/arm/Makefile:338: recipe for target 'uImage' failed\nmake[1]: *** [uImage] Error 2\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\nMakefile:146: recipe for target 'sub-make' failed\nmake: *** [sub-make] Error 2\n```\n\n\n\n在内核目录直接编译：\n```shell\n# make LOADADDR=0x60003000 uImage -j4\n```\n\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n......\n  Kernel: arch/arm/boot/Image is ready\n  Kernel: arch/arm/boot/zImage is ready\n  UIMAGE  arch/arm/boot/uImage\n\"mkimage\" command not found - U-Boot images will not be built\n../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed\nmake[2]: *** [arch/arm/boot/uImage] Error 1\narch/arm/Makefile:338: recipe for target 'uImage' failed\nmake[1]: *** [uImage] Error 2\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\nMakefile:146: recipe for target 'sub-make' failed\nmake: *** [sub-make] Error 2\n```\n\n\n\n第一次编译会报错，提示没有找到mkimage工具，需要手动安装u-boot-tools即可；\n\n```shell\n# sudo apt-get install u-boot-tools\n```\n\n\n\n### 3.2 编译uImage\n\n```shell\n# make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object\nmake[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'\n......\nLoad Address: 60003000\nEntry Point:  60003000\n  Kernel: arch/arm/boot/uImage is ready\nmake[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'\n```\n\n\n\n或者在Makefile中添加加载地址配置：\n\n```shell\n# vim arch/arm/boot/Makefile\nLOADADDR ?= 0x60003000\n```\n再编译生成uImage文件:\n```shell\n# make uImage -j4\n```\n\n\n\n## 4. Qemu网络功能设置\n\nQemu虚拟机在u-boot启动时，需要将uImage加载到内存，而uImage从哪里来？可以通过TFTP服务器下载uImage到内存指定地址。而在这之前需要通过桥接方式将网络链接到Ubuntu系统。\n\n\n\n### 4.1 配置Qemu与主机的网络连接\n\n\n\n采用桥接网络连接Host主机通信\n主机内核需要支持tun/tap模块\n\n\n\n### 4.2 配置Ubuntu主机\n\n#### 1) 安装工具\n\n安装桥接网络依赖的两个工具：\n```shell\n# sudo apt install uml-utilities bridge-utils\n```\n\n创建tun设备文件：/dev/net/tun（一般会自动创建）\n\n```shell\n# ls /dev/net/tun -l\ncrw-rw-rw- 1 root root 10, 200 Mar 20 21:31 /dev/net/tun\n```\n\n\n\n#### 2) 配置网络\n\n修改/etc/network/interfaces文件配置网络\n\n```shell\n# sudo vim /etc/network/interfaces\n# interfaces(5) file used by ifup(8) and ifdown(8)\nauto lo\niface lo inet loopback\n\nauto br0\niface br0 inet dhcp\nbridge_ports enp0s25\n```\n\n\n\n#### 3) 添加网络配置脚本\n\n配置/etc/qemu-ifup、/etc/qemu-ifdown脚本；\n\n默认情况下，当qemu使用tap设备时，会执行/etc/qemu-ifup和/etc/qemu-ifdown这两个脚本；需要创建这两个脚本，并加上可执行权限；\n\n```shell\n# cat /etc/qemu-ifup\n#!/bin/sh\n\necho sudo tunctl -u $(id -un) -t $1\nsudo tunctl -u $(id -un) -t $1\n\necho sudo ifconfig $1 0.0.0.0 promisc up\nsudo ifconfig $1 0.0.0.0 promisc up\n\necho sudo brctl addif br0 $1\nsudo brctl addif br0 $1\n\necho brctl show\nbrctl show\n\n# sudo ifconfig br0 192.168.1.102\n```\n\n\n\n```shell\n# ifconfig\nenp0s25: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20<link>\n        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)\n        RX packets 146587  bytes 69384714 (69.3 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 117583  bytes 13689404 (13.6 MB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n        device interrupt 20  memory 0xf3900000-f3920000  \n```\n\n\n\n查询到enp0s25的IP地址是192.168.1.102，需要将br0配置在同一个192.168.1.***网段；\n\n```shell\n# cat /etc/qemu-ifdown\n#!/bin/sh\n\necho sudo brctl delif br0 $1\nsudo brctl delif br0 $1\n\necho sudo tunctl -d $1\nsudo tunctl -d $1\n \necho brctl show\nbrctl show\n```\n\n\n\n```shell\n# chmod a+x /etc/qemu-ifup\n# chmod a+x /etc/qemu-ifdown\n```\n\n重启PC，使新的/etc/network/interfaces配置文件生效；\n\n\n\n### 4.3 关闭防火墙\n\n\n\n#### 1) 关闭防火墙\n\n```shell\n# sudo ufw disable\nFirewall stopped and disabled on system startup\n```\n\n\n\n#### 2) 查看当前防火墙状态\n\n```shell\n# sudo ufw status\nStatus: inactive\n```\n\n\n\n另外，附上开启防火墙的操作方法：\n\n```shell\n# ufw enable\n```\n\n\n\n### 4.4 重启系统，使配置生效\n\n```shell\n# reboot\n```\n或者：\n```shell\n# init 6\n```\n\n\n\n### 4.5 查看Qemu的网络环境\n\n```shell\n# ifconfig\nbr0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20<link>\n        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)\n        RX packets 44667  bytes 16853864 (16.8 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 45161  bytes 32391098 (32.3 MB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n虚拟网口br0即Qemu虚拟机与Linux主机通讯的网口；\n\n在u-boot中测试网络是否接通：\n\n```shell\n=> ping 192.168.1.102\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nsmc911x: MAC 52:54:00:12:34:56\nhost 192.168.1.102 is alive\n```\n\n\n\n## 5. 安装TFTP服务器\n\n创建TFTP服务器，用来给Qemu模拟开发板启动uImage时，下载uImage到内存中。\n\n\n\n### 5.1 安装TFTP工具\n\n\n\n安装Linux主机Host的TFTP服务器工具：\n\n```shell\n# sudo apt install tftp-hpa tftpd-hpa xinetd\n```\n\n\n\n### 5.2 配置\n\n\n\n#### 1) 修改配置文件，设置TFTP服务器目录\n\n```shell\n# sudo vim /etc/default/tftpd-hpa\n......\nTFTP_USERNAME=\"xiami\"\nTFTP_DIRECTORY=\"/home/xiami/qemu/boot-uboot\"\nTFTP_ADDRESS=\"0.0.0.0:69\"\nTFTP_OPTIONS=\"-l -c -s\"\n......\n```\n\n\n\n> 说明：\n>\n> TFTP_USERNAME：必须设置为当前的用户名，或：root\n>\n> TFTP_DIRECTORY：设定TFTP的根目录\n>\n> TFTP_ADDRESS：\n>\n> TFTP_OPTIONS：TFTP启动参数\n>\n> ​\t-l: 以standalone/listen模式启动TFTP服务，而不是从inetd启动，不需要安装xinetd\n>\n> ​\t-c: 可创建新文件，默认，TFTP只允许覆盖原文件，不能创建新文件\n>\n> ​\t-s: 改变TFTP启动的根目录；加入-s后，客户端使用TFTP时，不再需要输入指定目录，填写文件的完整路径，而是使用配置文件中写好的目录；\n\n\n\n#### 2) Linux主机上创建tftp目录\n\n```shell\n# mkdir /home/mcy/tftpboot\n# chmod 777 /home/mcy/tftpboot\n```\n\n\n\n#### 3) 重启tftp服务\n\n```powershell\n# sudo /etc/init.d/tftpd-hpa restart\n[ ok ] Restarting tftpd-hpa (via systemctl): tftpd-hpa.service.\n```\n\n\n\n### 5.3 测试验证\n\n#### 1) 测试tftp服务器\n\n可以使用三种方法，1. 输入真实的IP地址；2. 用localhost代替主机；3. 使用地址127.0.0.1，这个IP地址始终代表本机IP；\n\ntftp 192.168.1.102\n\ntftp localhost\n\ntftp 127.0.0.1\n\n\n\n#### 2) TFTP命令行的基本命令\n\nput: 将文件上传到TFTP根目录\n\nget: 取得TFTP根目录上的文件\n\nquit/q: 退出TFTP服务\n\n\n\n## 6. 设置u-boot中的内核启动参数\n\n\n\n### 6.1 设置u-boot参数\n\nu-boot能够正常启动还不足以引导内核启动，需要在u-boot中设置一些启动参数，在引导内核启动时，将这些启动参数传递给内核；内核启动后挂载SD卡中的文件系统；\n\n这些启动参数，可以在u-boot启动后，手动设置，也可以在u-boot中，把内核启动参数写入vexpress_common.h头文件；\n\n\n\n#### 1） 写入u-boot头文件\n\n修改vexpress_common.h头文件，添加内核启动需要的参数：\n\n```c\n# vim include/configs/vexpress_common.h\n#define CONFIG_BOOTCOMMAND  \\\n    \"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\\n    setenv bootargs 'root=/dev/mmcblk0 rw   \\\n    init=/linuxrc   \\\n    ip=192.168.1.110 console=ttyAMA0';  \\\n    bootm 0x60003000 - 0x60500000;\"\n\n#define CONFIG_IPADDR   192.168.1.110\n#define CONFIG_SERVERIP 192.168.1.104\n#define CONFIGN_NETMASK 255.255.255.0\n```\n\n参数说明：\n\n> CONFIG_IPADDR： 设备的本地IP地址\n>\n> CONFIG_SERVERIP： TFTP下载时的服务器IP地址\n>\n> CONFIG_BOOTCOMMAND： 内核启动的参数设置，包含boot_args\n\n\n\n#### 2） 手动设置\n\n在u-boot启动之后，手动设置环境变量：\n\n```shell\n=> setenv ipaddr 192.168.1.110\n=> setenv serverip 192.168.1.102\n=> setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'\n```\n\n手动设置tftp下载：\n\n```shell\n=> tftp 0x60003000 uImage\t// tftp下载内核镜像\n=> tftp 0x60500000 vexpress-v2p-ca9.dtb\t\t// tftp下载设备树\n=> bootm 0x60003000 - 0x60500000\t// 启动内核\n```\n\n手动设置用来调试比较方便，但是正常使用时，还是将设置参数写入u-boot的vexpress_common.h头文件比较好，免得每次启动都需要输入这么多命令；\n\n\n\n#### 3） 设置挂载nfs网络文件系统\n\n如果需要通过nfs挂载网络文件系统，需要在u-boot中，设置boot_args，如下：\n\n\n```c\n# vim include/configs/vexpress_common.h\n\n#define CONFIG_BOOTCOMMAND  \\\n    \"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\\n    setenv bootargs 'root=/dev/nfs rw   \\\n    nfsroot=192.168.1.102:/home/xiami/qemu/nfs_root init=/linuxrc   \\\n    ip=192.168.1.110 console=ttyAMA0';  \\\n    bootm 0x60003000 - 0x60500000;\"\n\n#define CONFIG_IPADDR   192.168.1.110\n#define CONFIG_SERVERIP 192.168.1.104\n#define CONFIGN_NETMASK 255.255.255.0\n```\n\n\n重新编译u-boot；启动Qemu验证\n\n```shell\n=> print bootcmd\nbootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/nfs rw nfsroot=192.168.1.102:/home/xiami/qemu/boot-uboot/rootfs init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;\n=> print ipaddr\nipaddr=192.168.1.110\n=> print serverip\nserverip=192.168.1.102\n```\n\n网络还没有ping通：\n\n```shell\n=> ping 192.168.1.102\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\n\nARP Retry count exceeded; starting again\nsmc911x: MAC 52:54:00:12:34:56\nping failed; host 192.168.1.102 is not alive\n```\n\n这部分在下一节中再讲述，此处略过；\n\n\n\n### 6.2 启动验证\n\n#### 1） 启动Qemu，并检查启动参数\n\n```powershell\n# cat boot.sh\n#! /bin/sh\nsudo qemu-system-arm \\\n\t-M vexpress-a9 \\\n\t-m 512M \\\n\t-kernel ./u-boot \\\n\t-nographic \\\n\t-append console=ttyAMA0 \\\n\t-sd rootfs.ext3 \\\n\t-net nic \\\n\t-net tap\n```\n\n\n\nu-boot启动后，查看u-boot中的环境变量：\n\n```shell\n=> print bootcmd\nbootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;\n=> print ipaddr\nipaddr=192.168.1.110\n=> print serverip\nserverip=192.168.1.102\n```\n\n\n\n检查tftp下载网络，在开发板的u-boot中，ping本地PC的tftp服务器，注意，不要用电脑ping开发板，因为u-boot中没有回应机制，是ping不通开发板的；\n\n```shell\n=> ping 192.168.1.102\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nsmc911x: MAC 52:54:00:12:34:56\nhost 192.168.1.102 is alive\n```\n\n\n\n#### 2） 启动验证\n\n\n\n```\n# ./boot-uboot-tftp.sh \nBooting qemu vexpress-ca9\nWARNING: Image format was not specified for 'rootfs.ext3' and probing guessed raw.\n         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.\n         Specify the 'raw' format explicitly to remove the restrictions.\nsudo tunctl -u root -t tap0\nTUNSETIFF: Device or resource busy\nsudo ifconfig tap0 0.0.0.0 promisc up\nsudo brctl addif br0 tap0\nbrctl show\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\nbr0\t\t8000.0021ccd65a96\tno\t\tenp0s25\n\t\t\t\t\t\t\ttap0\n\nU-Boot 2020.01 (Mar 22 2020 - 16:51:32 +0800)\n\nDRAM:  512 MiB\nWARNING: Caches not enabled\nFlash: 128 MiB\nMMC:   MMC: 0\n*** Warning - bad CRC, using default environment\n\nIn:    serial\nOut:   serial\nErr:   serial\nNet:   smc911x-0\nHit any key to stop autoboot:  0 \nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.102; our IP address is 192.168.1.110\nFilename 'uImage'.\nLoad address: 0x60003000\nLoading: #################################################################\n\t #################################################################\n\t #################################################################\n\t #################################################################\n\t ###########\n\t 8.7 MiB/s\ndone\nBytes transferred = 3971576 (3c99f8 hex)\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.102; our IP address is 192.168.1.110\nFilename 'vexpress-v2p-ca9.dtb'.\nLoad address: 0x60500000\nLoading: ##\n\t 4.7 MiB/s\ndone\nBytes transferred = 14692 (3964 hex)\nsmc911x: MAC 52:54:00:12:34:56\n## Booting kernel from Legacy Image at 60003000 ...\n   Image Name:   Linux-4.14.172\n   Image Type:   ARM Linux Kernel Image (uncompressed)\n   Data Size:    3971512 Bytes = 3.8 MiB\n   Load Address: 60003000\n   Entry Point:  60003000\n   Verifying Checksum ... OK\n## Flattened Device Tree blob at 60500000\n   Booting using the fdt blob at 0x60500000\n   Loading Kernel Image\n   Loading Device Tree to 7fe81000, end 7fe87963 ... OK\n\nStarting kernel ...\n\nBooting Linux on physical CPU 0x0\nLinux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020\nCPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr=10c5387d\nCPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache\nOF: fdt: Machine model: V2P-CA9\nMemory policy: Data cache writeback\nCPU: All CPU(s) started in SVC mode.\npercpu: Embedded 15 pages/cpu s32396 r8192 d20852 u61440\nBuilt 1 zonelists, mobility grouping on.  Total pages: 130048\nKernel command line: root=/dev/mmcblk0 rw       init=/linuxrc       ip=192.168.1.110 console=ttyAMA0\nlog_buf_len individual max cpu contribution: 4096 bytes\nlog_buf_len total cpu_extra contributions: 12288 bytes\nlog_buf_len min size: 16384 bytes\nlog_buf_len: 32768 bytes\nearly log buf free: 14980(91%)\nPID hash table entries: 2048 (order: 1, 8192 bytes)\nDentry cache hash table entries: 65536 (order: 6, 262144 bytes)\nInode-cache hash table entries: 32768 (order: 5, 131072 bytes)\nMemory: 509616K/524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14672K reserved, 0K cma-reserved)\nVirtual kernel memory layout:\n    vector  : 0xffff0000 - 0xffff1000   (   4 kB)\n    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)\n    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)\n    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)\n    modules : 0x7f000000 - 0x80000000   (  16 MB)\n      .text : 0x80008000 - 0x80700000   (7136 kB)\n      .init : 0x80900000 - 0x80a00000   (1024 kB)\n      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)\n       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)\nSLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1\nHierarchical RCU implementation.\n\tRCU event tracing is enabled.\n\tRCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.\n\n......\n\nIP-Config: Guessing netmask 255.255.255.0\nIP-Config: Complete:\n     device=eth0, hwaddr=52:54:00:12:34:56, ipaddr=192.168.1.110, mask=255.255.255.0, gw=255.255.255.255\n     host=192.168.1.110, domain=, nis-domain=(none)\n     bootserver=255.255.255.255, rootserver=255.255.255.255, rootpath=\nALSA device list:\n  #0: ARM AC'97 Interface PL041 rev0 at 0x10004000, irq 30\nEXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem\nrandom: fast init done\nEXT4-fs (mmcblk0): recovery complete\nEXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)\nVFS: Mounted root (ext3 filesystem) on device 179:0.\nFreeing unused kernel memory: 1024K\nrandom: crng init done\nHello Linux Qemu!\n\nPlease press Enter to activate this console. \n/ # \n```\n\n\n\n\n\n\n\n```\n=> reset\nresetting ...\n\n\nU-Boot 2017.05 (Jul 24 2019 - 21:52:28 +0800)\n\nDRAM:  512 MiB\nWARNING: Caches not enabled\nFlash: 128 MiB\nMMC:   MMC: 0\n*** Warning - bad CRC, using default environment\n\nIn:    serial\nOut:   serial\nErr:   serial\nNet:   smc911x-0\nHit any key to stop autoboot:  0 \nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.104; our IP address is 192.168.1.110\nFilename 'uImage'.\nLoad address: 0x60003000\nLoading: #################################################################\n\t #################################################################\n\t #################################################################\n\t ##################################################\n\t 1.3 MiB/s\ndone\nBytes transferred = 3581920 (36a7e0 hex)\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: MAC 52:54:00:12:34:56\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing smc911x-0 device\nTFTP from server 192.168.1.104; our IP address is 192.168.1.110\nFilename 'vexpress-v2p-ca9.dtb'.\nLoad address: 0x60500000\nLoading: #\n\t 250 KiB/s\ndone\nBytes transferred = 14360 (3818 hex)\nsmc911x: MAC 52:54:00:12:34:56\n## Booting kernel from Legacy Image at 60003000 ...\n   Image Name:   Linux-4.4.157\n   Image Type:   ARM Linux Kernel Image (uncompressed)\n   Data Size:    3581856 Bytes = 3.4 MiB\n   Load Address: 60003000\n   Entry Point:  60003000\n   Verifying Checksum ... OK\n## Flattened Device Tree blob at 60500000\n   Booting using the fdt blob at 0x60500000\n   Loading Kernel Image ... OK\n   Loading Device Tree to 7fed4000, end 7feda817 ... OK\n\n\n```\n\n至此，通过u-boot加载kernel，并挂载SD卡文件系统已经成功；\n\n\n\n### 7. 总结\n\nSD卡中rootfs目录是一个简易的根文件系统，可以将它制作成一个镜像文件，将镜像文件烧写到开发板，或者通过Qemu中的u-boot启动Linux内核后挂载到镜像文件上。也可以设置为通过NFS网络文件系统启动，参考下一篇文章《[Qemu搭建ARM vexpress开发环境(三)----NFS网络根文件系统](https://www.jianshu.com/p/cf46f7225db6)》。\n\n\n\n\n\n","slug":"Qemu搭建ARM-vexpress开发环境(二)----u-boot启动kernel","published":1,"updated":"2020-05-07T13:53:36.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv3000hdqg1949q71rj","content":"<p>标签： Qemu</p>\n<hr>\n<p>在上文《<a href=\"https://www.jianshu.com/p/94833e841742\" target=\"_blank\" rel=\"noopener\">Qemu搭建ARM vexpress开发环境(一)</a>》中已经简单讲述了通过Qemu直接启动Linux内核，并挂载SD卡根文件系统的方法，这种方法是直接启动内核，与实际应用中ARM板的启动方式：u-boot、kernel、rootfs有些不同。现在就来讲述下用Qemu搭建通过u-boot启动Linux内核并挂载根文件系统的方法。</p>\n<a id=\"more\"></a>\n\n\n\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>[TOC]</p>\n<h2 id=\"1-简述\"><a href=\"#1-简述\" class=\"headerlink\" title=\"1. 简述\"></a>1. 简述</h2><p>嵌入式系统要正常运行，应该包含：u-boot、kernel、rootfs、appfs。这几部分在ARM开发板Flash上的位置关系应该类似于下图所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">BootLoader</th>\n<th align=\"center\">BootParameters</th>\n<th align=\"center\">Kernel</th>\n<th align=\"center\">Rootfs</th>\n<th align=\"center\">Appfs</th>\n</tr>\n</thead>\n</table>\n<p>嵌入式系统的启动流程如下：</p>\n<pre class=\"mermaid\">graph TB\n    BootLoader(BootLoader)--BootParameters-->Kernel(Kernel)-->Rootfs(Rootfs)-->Appfs(Appfs)</pre>\n\n<p>rootfs可以添加到开发板的Flash，也可以不用添加到开发板，而是部署到PC机上，开发板在运行完kernel，要挂载rootfs时，可以通过NFS网络挂载到设定好的PC机上的rootfs根文件系统上（下一篇文章《Qemu搭建ARM vexpress开发环境(三)—-NFS网络根文件系统》会详细讲解NFS网络挂载根文件系统的具体操作方法）。</p>\n<h2 id=\"2-准备u-boot\"><a href=\"#2-准备u-boot\" class=\"headerlink\" title=\"2. 准备u-boot\"></a>2. 准备u-boot</h2><p>用来使用u-boot启动加载Linux内核</p>\n<h3 id=\"2-1-下载u-boot\"><a href=\"#2-1-下载u-boot\" class=\"headerlink\" title=\"2.1 下载u-boot\"></a>2.1 下载u-boot</h3><p>从 <a href=\"http://ftp.denx.de/pub/u-boot\" target=\"_blank\" rel=\"noopener\">http://ftp.denx.de/pub/u-boot</a> 网站选择一个u-boot版本源码下载，本文中使用的是u-boot-2020.01版本。</p>\n<h3 id=\"2-2-解压u-boot\"><a href=\"#2-2-解压u-boot\" class=\"headerlink\" title=\"2.2 解压u-boot\"></a>2.2 解压u-boot</h3><p>解压u-boot:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf u-boot-2020.01.tar.bz2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-编译u-boot\"><a href=\"#2-3-编译u-boot\" class=\"headerlink\" title=\"2.3 编译u-boot\"></a>2.3 编译u-boot</h3><h4 id=\"2-3-1-配置时碰到的问题\"><a href=\"#2-3-1-配置时碰到的问题\" class=\"headerlink\" title=\"2.3.1 配置时碰到的问题\"></a>2.3.1 配置时碰到的问题</h4><h5 id=\"配置命令\"><a href=\"#配置命令\" class=\"headerlink\" title=\"配置命令\"></a>配置命令</h5><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_ca9x4_defconfig</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果没有修改Makefile和config.mk文件，需要在编译时加上ARCH和CROSS_COMPILE的配置；在编译u-boot时可能会出现一些问题，只要逐个问题解决就可以编译完成了；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh: 1: bison: not found</span><br><span class=\"line\">scripts/Makefile.lib:226: recipe for target 'scripts/kconfig/zconf.tab.c' failed</span><br><span class=\"line\">make[1]: *** [scripts/kconfig/zconf.tab.c] Error 127</span><br><span class=\"line\">Makefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed</span><br><span class=\"line\">make: *** [vexpress_ca9x4_defconfig] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install bison</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh: 1: flex: not found</span><br><span class=\"line\">scripts/Makefile.lib:218: recipe for target 'scripts/kconfig/zconf.lex.c' failed</span><br><span class=\"line\">make[1]: *** [scripts/kconfig/zconf.lex.c] Error 127</span><br><span class=\"line\">Makefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed</span><br><span class=\"line\">make: *** [vexpress_ca9x4_defconfig] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install flex</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object -j4</span></span><br><span class=\"line\">scripts/kconfig/conf  --syncconfig Kconfig</span><br><span class=\"line\">  CHK     include/config.h</span><br><span class=\"line\">  GEN     include/autoconf.mk.dep</span><br><span class=\"line\">  CFG     u-boot.cfg</span><br><span class=\"line\">  GEN     include/autoconf.mk</span><br><span class=\"line\">*** Your GCC is older than 6.0 and is not supported</span><br><span class=\"line\">arch/arm/config.mk:66: recipe for target 'checkgcc6' failed</span><br><span class=\"line\">make: *** [checkgcc6] Error 1</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim arch/arm/config.mk</span></span><br><span class=\"line\">ifeq ($(CONFIG_$(SPL_)SYS_THUMB_BUILD),y)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">archprepare: checkthumb checkgcc6</span></span><br><span class=\"line\">archprepare: checkthumb</span><br><span class=\"line\">checkthumb:</span><br><span class=\"line\">        @if test \"$(call cc-name)\" = \"gcc\" -a \\</span><br><span class=\"line\">                        \"$(call cc-version)\" -lt \"0404\"; then \\</span><br><span class=\"line\">                echo -n '*** Your GCC does not produce working '; \\</span><br><span class=\"line\">                echo 'binaries in THUMB mode.'; \\</span><br><span class=\"line\">                echo '*** Your board is configured for THUMB mode.'; \\</span><br><span class=\"line\">                false; \\</span><br><span class=\"line\">        fi</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">archprepare: checkgcc6</span></span><br><span class=\"line\">endif</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">checkgcc6:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">        @<span class=\"keyword\">if</span> <span class=\"built_in\">test</span> <span class=\"string\">\"<span class=\"variable\">$(call cc-name)</span>\"</span> = <span class=\"string\">\"gcc\"</span> -a \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                        <span class=\"string\">\"<span class=\"variable\">$(call cc-version)</span>\"</span> -lt <span class=\"string\">\"0600\"</span>; <span class=\"keyword\">then</span> \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                <span class=\"built_in\">echo</span> <span class=\"string\">'*** Your GCC is older than 6.0 and is not supported'</span>; \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                <span class=\"literal\">false</span>; \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">        <span class=\"keyword\">fi</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-3-2-生成配置文件\"><a href=\"#2-3-2-生成配置文件\" class=\"headerlink\" title=\"2.3.2 生成配置文件\"></a>2.3.2 生成配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/u-boot-2020.01/object'</span><br><span class=\"line\">  HOSTCC  scripts/basic/fixdep</span><br><span class=\"line\">  GEN     ./Makefile</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/conf.o</span><br><span class=\"line\">  YACC    scripts/kconfig/zconf.tab.c</span><br><span class=\"line\">  LEX     scripts/kconfig/zconf.lex.c</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class=\"line\">  HOSTLD  scripts/kconfig/conf</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> configuration written to .config</span></span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/u-boot-2020.01/object'</span><br></pre></td></tr></table></figure>\n\n\n\n<p>./configs/vexpress_ca9x4_defconfig</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls object/.config -l</span></span><br><span class=\"line\">-rw-r--r-- 1 xiami xiami 22698 Mar 17 23:20 object/.config</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果需要修改配置文件中的一些选项，可以通过以下界面操作选择：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make menuconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-3-3-编译\"><a href=\"#2-3-3-编译\" class=\"headerlink\" title=\"2.3.3 编译\"></a>2.3.3 编译</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-3-4-简化编译过程\"><a href=\"#2-3-4-简化编译过程\" class=\"headerlink\" title=\"2.3.4 简化编译过程\"></a>2.3.4 简化编译过程</h4><p>这种方式编译比较直接，但是在调试时，需要多次编译u-boot，参数太多会带来不便，于是可以通过以下方法，修改Makefile和config.mk文件中的ARCH和CROSS_COMPILE选项，在编译的时候就可以省去了在编译命令中添加编译配置的设置。</p>\n<p>修改Makefile</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim Makefile</span></span><br><span class=\"line\">CROSS_COMPILE = arm-linux-gnueabi-</span><br></pre></td></tr></table></figure>\n<p>修改config.mk</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim config.mk</span></span><br><span class=\"line\">ARCH = arm</span><br></pre></td></tr></table></figure>\n\n\n<p>编译u-boot:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_ca9x4_defconfig</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make -j4</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-启动u-boot\"><a href=\"#2-4-启动u-boot\" class=\"headerlink\" title=\"2.4 启动u-boot\"></a>2.4 启动u-boot</h3><p>通过Qemu启动命令启动u-boot：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -nographic -kernel ./u-boot</span></span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot 2020.01 (Mar 17 2020 - 23:21:36 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">DRAM:  512 MiB</span><br><span class=\"line\">WARNING: Caches not enabled</span><br><span class=\"line\">Flash: 128 MiB</span><br><span class=\"line\">MMC:   MMC: 0</span><br><span class=\"line\">*** Warning - bad CRC, using default environment</span><br><span class=\"line\"></span><br><span class=\"line\">In:    serial</span><br><span class=\"line\">Out:   serial</span><br><span class=\"line\">Err:   serial</span><br><span class=\"line\">Net:   smc911x-0</span><br><span class=\"line\">Hit any key to stop autoboot:  0 </span><br><span class=\"line\">=&gt;</span><br></pre></td></tr></table></figure>\n\n<p>查看u-boot的版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; version</span><br><span class=\"line\">U-Boot 2020.01 (Mar 20 2020 - 23:01:23 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">arm-linux-gnueabi-gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0</span><br><span class=\"line\">GNU ld (GNU Binutils for Ubuntu) 2.30</span><br></pre></td></tr></table></figure>\n\n\n\n<p>打印u-boot的环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; print</span><br><span class=\"line\">arch=arm</span><br><span class=\"line\">baudrate=38400</span><br><span class=\"line\">board=vexpress</span><br><span class=\"line\">board_name=vexpress</span><br><span class=\"line\">......</span><br><span class=\"line\">scriptaddr=0x88000000</span><br><span class=\"line\">stderr=serial</span><br><span class=\"line\">stdin=serial</span><br><span class=\"line\">stdout=serial</span><br><span class=\"line\">vendor=armltd</span><br><span class=\"line\"></span><br><span class=\"line\">Environment size: 2656/262140 bytes</span><br></pre></td></tr></table></figure>\n\n<p>至此，u-boot启动成功，下一步开始配置u-boot的内核启动参数，来启动Linux内核，并挂在根文件系统。</p>\n<h2 id=\"3-准备内核\"><a href=\"#3-准备内核\" class=\"headerlink\" title=\"3. 准备内核\"></a>3. 准备内核</h2><h3 id=\"3-1-指定加载地址\"><a href=\"#3-1-指定加载地址\" class=\"headerlink\" title=\"3.1 指定加载地址\"></a>3.1 指定加载地址</h3><p>使用u-boot引导内核启动，需要内核的uImage镜像：</p>\n<blockquote>\n<p>需要将内核编译为uImage格式，需要指定uImage在内存中的加载地址，编译内核时指定：make LOADADDR=? uImage -j4</p>\n</blockquote>\n<p>如果不指定LOADADDR参数，编译时会报错，如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage -j4 O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">......</span><br><span class=\"line\">  Kernel: arch/arm/boot/Image is ready</span><br><span class=\"line\">  Kernel: arch/arm/boot/zImage is ready</span><br><span class=\"line\">multiple (or no) load addresses: </span><br><span class=\"line\">This is incompatible with uImages</span><br><span class=\"line\">Specify LOADADDR on the commandline to build an uImage</span><br><span class=\"line\">../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed</span><br><span class=\"line\">make[2]: *** [arch/arm/boot/uImage] Error 1</span><br><span class=\"line\">arch/arm/Makefile:338: recipe for target 'uImage' failed</span><br><span class=\"line\">make[1]: *** [uImage] Error 2</span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">Makefile:146: recipe for target 'sub-make' failed</span><br><span class=\"line\">make: *** [sub-make] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在内核目录直接编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make LOADADDR=0x60003000 uImage -j4</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">......</span><br><span class=\"line\">  Kernel: arch/arm/boot/Image is ready</span><br><span class=\"line\">  Kernel: arch/arm/boot/zImage is ready</span><br><span class=\"line\">  UIMAGE  arch/arm/boot/uImage</span><br><span class=\"line\">\"mkimage\" command not found - U-Boot images will not be built</span><br><span class=\"line\">../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed</span><br><span class=\"line\">make[2]: *** [arch/arm/boot/uImage] Error 1</span><br><span class=\"line\">arch/arm/Makefile:338: recipe for target 'uImage' failed</span><br><span class=\"line\">make[1]: *** [uImage] Error 2</span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">Makefile:146: recipe for target 'sub-make' failed</span><br><span class=\"line\">make: *** [sub-make] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第一次编译会报错，提示没有找到mkimage工具，需要手动安装u-boot-tools即可；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install u-boot-tools</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-2-编译uImage\"><a href=\"#3-2-编译uImage\" class=\"headerlink\" title=\"3.2 编译uImage\"></a>3.2 编译uImage</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">......</span><br><span class=\"line\">Load Address: 60003000</span><br><span class=\"line\">Entry Point:  60003000</span><br><span class=\"line\">  Kernel: arch/arm/boot/uImage is ready</span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br></pre></td></tr></table></figure>\n\n\n\n<p>或者在Makefile中添加加载地址配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim arch/arm/boot/Makefile</span></span><br><span class=\"line\">LOADADDR ?= 0x60003000</span><br></pre></td></tr></table></figure>\n<p>再编译生成uImage文件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make uImage -j4</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-Qemu网络功能设置\"><a href=\"#4-Qemu网络功能设置\" class=\"headerlink\" title=\"4. Qemu网络功能设置\"></a>4. Qemu网络功能设置</h2><p>Qemu虚拟机在u-boot启动时，需要将uImage加载到内存，而uImage从哪里来？可以通过TFTP服务器下载uImage到内存指定地址。而在这之前需要通过桥接方式将网络链接到Ubuntu系统。</p>\n<h3 id=\"4-1-配置Qemu与主机的网络连接\"><a href=\"#4-1-配置Qemu与主机的网络连接\" class=\"headerlink\" title=\"4.1 配置Qemu与主机的网络连接\"></a>4.1 配置Qemu与主机的网络连接</h3><p>采用桥接网络连接Host主机通信<br>主机内核需要支持tun/tap模块</p>\n<h3 id=\"4-2-配置Ubuntu主机\"><a href=\"#4-2-配置Ubuntu主机\" class=\"headerlink\" title=\"4.2 配置Ubuntu主机\"></a>4.2 配置Ubuntu主机</h3><h4 id=\"1-安装工具\"><a href=\"#1-安装工具\" class=\"headerlink\" title=\"1) 安装工具\"></a>1) 安装工具</h4><p>安装桥接网络依赖的两个工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install uml-utilities bridge-utils</span></span><br></pre></td></tr></table></figure>\n\n<p>创建tun设备文件：/dev/net/tun（一般会自动创建）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /dev/net/tun -l</span></span><br><span class=\"line\">crw-rw-rw- 1 root root 10, 200 Mar 20 21:31 /dev/net/tun</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-配置网络\"><a href=\"#2-配置网络\" class=\"headerlink\" title=\"2) 配置网络\"></a>2) 配置网络</h4><p>修改/etc/network/interfaces文件配置网络</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo vim /etc/network/interfaces</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class=\"line\">auto lo</span><br><span class=\"line\">iface lo inet loopback</span><br><span class=\"line\"></span><br><span class=\"line\">auto br0</span><br><span class=\"line\">iface br0 inet dhcp</span><br><span class=\"line\">bridge_ports enp0s25</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-添加网络配置脚本\"><a href=\"#3-添加网络配置脚本\" class=\"headerlink\" title=\"3) 添加网络配置脚本\"></a>3) 添加网络配置脚本</h4><p>配置/etc/qemu-ifup、/etc/qemu-ifdown脚本；</p>\n<p>默认情况下，当qemu使用tap设备时，会执行/etc/qemu-ifup和/etc/qemu-ifdown这两个脚本；需要创建这两个脚本，并加上可执行权限；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/qemu-ifup</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo tunctl -u $(id -un) -t $1</span><br><span class=\"line\">sudo tunctl -u $(id -un) -t $1</span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo ifconfig $1 0.0.0.0 promisc up</span><br><span class=\"line\">sudo ifconfig $1 0.0.0.0 promisc up</span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo brctl addif br0 $1</span><br><span class=\"line\">sudo brctl addif br0 $1</span><br><span class=\"line\"></span><br><span class=\"line\">echo brctl show</span><br><span class=\"line\">brctl show</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ifconfig br0 192.168.1.102</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class=\"line\">        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 146587  bytes 69384714 (69.3 MB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 117583  bytes 13689404 (13.6 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\">        device interrupt 20  memory 0xf3900000-f3920000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>查询到enp0s25的IP地址是192.168.1.102，需要将br0配置在同一个192.168.1.***网段；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/qemu-ifdown</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo brctl delif br0 $1</span><br><span class=\"line\">sudo brctl delif br0 $1</span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo tunctl -d $1</span><br><span class=\"line\">sudo tunctl -d $1</span><br><span class=\"line\"> </span><br><span class=\"line\">echo brctl show</span><br><span class=\"line\">brctl show</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chmod a+x /etc/qemu-ifup</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chmod a+x /etc/qemu-ifdown</span></span><br></pre></td></tr></table></figure>\n\n<p>重启PC，使新的/etc/network/interfaces配置文件生效；</p>\n<h3 id=\"4-3-关闭防火墙\"><a href=\"#4-3-关闭防火墙\" class=\"headerlink\" title=\"4.3 关闭防火墙\"></a>4.3 关闭防火墙</h3><h4 id=\"1-关闭防火墙\"><a href=\"#1-关闭防火墙\" class=\"headerlink\" title=\"1) 关闭防火墙\"></a>1) 关闭防火墙</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ufw <span class=\"built_in\">disable</span></span></span><br><span class=\"line\">Firewall stopped and disabled on system startup</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-查看当前防火墙状态\"><a href=\"#2-查看当前防火墙状态\" class=\"headerlink\" title=\"2) 查看当前防火墙状态\"></a>2) 查看当前防火墙状态</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ufw status</span></span><br><span class=\"line\">Status: inactive</span><br></pre></td></tr></table></figure>\n\n\n\n<p>另外，附上开启防火墙的操作方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ufw <span class=\"built_in\">enable</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-4-重启系统，使配置生效\"><a href=\"#4-4-重启系统，使配置生效\" class=\"headerlink\" title=\"4.4 重启系统，使配置生效\"></a>4.4 重启系统，使配置生效</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> reboot</span></span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> init 6</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-5-查看Qemu的网络环境\"><a href=\"#4-5-查看Qemu的网络环境\" class=\"headerlink\" title=\"4.5 查看Qemu的网络环境\"></a>4.5 查看Qemu的网络环境</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class=\"line\">        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 44667  bytes 16853864 (16.8 MB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 45161  bytes 32391098 (32.3 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n\n<p>虚拟网口br0即Qemu虚拟机与Linux主机通讯的网口；</p>\n<p>在u-boot中测试网络是否接通：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; ping 192.168.1.102</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">host 192.168.1.102 is alive</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-安装TFTP服务器\"><a href=\"#5-安装TFTP服务器\" class=\"headerlink\" title=\"5. 安装TFTP服务器\"></a>5. 安装TFTP服务器</h2><p>创建TFTP服务器，用来给Qemu模拟开发板启动uImage时，下载uImage到内存中。</p>\n<h3 id=\"5-1-安装TFTP工具\"><a href=\"#5-1-安装TFTP工具\" class=\"headerlink\" title=\"5.1 安装TFTP工具\"></a>5.1 安装TFTP工具</h3><p>安装Linux主机Host的TFTP服务器工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install tftp-hpa tftpd-hpa xinetd</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-2-配置\"><a href=\"#5-2-配置\" class=\"headerlink\" title=\"5.2 配置\"></a>5.2 配置</h3><h4 id=\"1-修改配置文件，设置TFTP服务器目录\"><a href=\"#1-修改配置文件，设置TFTP服务器目录\" class=\"headerlink\" title=\"1) 修改配置文件，设置TFTP服务器目录\"></a>1) 修改配置文件，设置TFTP服务器目录</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo vim /etc/default/tftpd-hpa</span></span><br><span class=\"line\">......</span><br><span class=\"line\">TFTP_USERNAME=\"xiami\"</span><br><span class=\"line\">TFTP_DIRECTORY=\"/home/xiami/qemu/boot-uboot\"</span><br><span class=\"line\">TFTP_ADDRESS=\"0.0.0.0:69\"</span><br><span class=\"line\">TFTP_OPTIONS=\"-l -c -s\"</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>说明：</p>\n<p>TFTP_USERNAME：必须设置为当前的用户名，或：root</p>\n<p>TFTP_DIRECTORY：设定TFTP的根目录</p>\n<p>TFTP_ADDRESS：</p>\n<p>TFTP_OPTIONS：TFTP启动参数</p>\n<p>​    -l: 以standalone/listen模式启动TFTP服务，而不是从inetd启动，不需要安装xinetd</p>\n<p>​    -c: 可创建新文件，默认，TFTP只允许覆盖原文件，不能创建新文件</p>\n<p>​    -s: 改变TFTP启动的根目录；加入-s后，客户端使用TFTP时，不再需要输入指定目录，填写文件的完整路径，而是使用配置文件中写好的目录；</p>\n</blockquote>\n<h4 id=\"2-Linux主机上创建tftp目录\"><a href=\"#2-Linux主机上创建tftp目录\" class=\"headerlink\" title=\"2) Linux主机上创建tftp目录\"></a>2) Linux主机上创建tftp目录</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir /home/mcy/tftpboot</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chmod 777 /home/mcy/tftpboot</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-重启tftp服务\"><a href=\"#3-重启tftp服务\" class=\"headerlink\" title=\"3) 重启tftp服务\"></a>3) 重启tftp服务</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sudo /etc/init.d/tftpd-hpa restart</span></span><br><span class=\"line\">[ <span class=\"type\">ok</span> ] Restarting tftpd<span class=\"literal\">-hpa</span> (via systemctl): tftpd<span class=\"literal\">-hpa</span>.service.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3-测试验证\"><a href=\"#5-3-测试验证\" class=\"headerlink\" title=\"5.3 测试验证\"></a>5.3 测试验证</h3><h4 id=\"1-测试tftp服务器\"><a href=\"#1-测试tftp服务器\" class=\"headerlink\" title=\"1) 测试tftp服务器\"></a>1) 测试tftp服务器</h4><p>可以使用三种方法，1. 输入真实的IP地址；2. 用localhost代替主机；3. 使用地址127.0.0.1，这个IP地址始终代表本机IP；</p>\n<p>tftp 192.168.1.102</p>\n<p>tftp localhost</p>\n<p>tftp 127.0.0.1</p>\n<h4 id=\"2-TFTP命令行的基本命令\"><a href=\"#2-TFTP命令行的基本命令\" class=\"headerlink\" title=\"2) TFTP命令行的基本命令\"></a>2) TFTP命令行的基本命令</h4><p>put: 将文件上传到TFTP根目录</p>\n<p>get: 取得TFTP根目录上的文件</p>\n<p>quit/q: 退出TFTP服务</p>\n<h2 id=\"6-设置u-boot中的内核启动参数\"><a href=\"#6-设置u-boot中的内核启动参数\" class=\"headerlink\" title=\"6. 设置u-boot中的内核启动参数\"></a>6. 设置u-boot中的内核启动参数</h2><h3 id=\"6-1-设置u-boot参数\"><a href=\"#6-1-设置u-boot参数\" class=\"headerlink\" title=\"6.1 设置u-boot参数\"></a>6.1 设置u-boot参数</h3><p>u-boot能够正常启动还不足以引导内核启动，需要在u-boot中设置一些启动参数，在引导内核启动时，将这些启动参数传递给内核；内核启动后挂载SD卡中的文件系统；</p>\n<p>这些启动参数，可以在u-boot启动后，手动设置，也可以在u-boot中，把内核启动参数写入vexpress_common.h头文件；</p>\n<h4 id=\"1）-写入u-boot头文件\"><a href=\"#1）-写入u-boot头文件\" class=\"headerlink\" title=\"1） 写入u-boot头文件\"></a>1） 写入u-boot头文件</h4><p>修改vexpress_common.h头文件，添加内核启动需要的参数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># vim <span class=\"meta-keyword\">include</span>/configs/vexpress_common.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_BOOTCOMMAND  \\</span></span><br><span class=\"line\">    <span class=\"string\">\"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\</span></span><br><span class=\"line\"><span class=\"string\">    setenv bootargs 'root=/dev/mmcblk0 rw   \\</span></span><br><span class=\"line\"><span class=\"string\">    init=/linuxrc   \\</span></span><br><span class=\"line\"><span class=\"string\">    ip=192.168.1.110 console=ttyAMA0';  \\</span></span><br><span class=\"line\"><span class=\"string\">    bootm 0x60003000 - 0x60500000;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_IPADDR   192.168.1.110</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_SERVERIP 192.168.1.104</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIGN_NETMASK 255.255.255.0</span></span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<blockquote>\n<p>CONFIG_IPADDR： 设备的本地IP地址</p>\n<p>CONFIG_SERVERIP： TFTP下载时的服务器IP地址</p>\n<p>CONFIG_BOOTCOMMAND： 内核启动的参数设置，包含boot_args</p>\n</blockquote>\n<h4 id=\"2）-手动设置\"><a href=\"#2）-手动设置\" class=\"headerlink\" title=\"2） 手动设置\"></a>2） 手动设置</h4><p>在u-boot启动之后，手动设置环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; setenv ipaddr 192.168.1.110</span><br><span class=\"line\">=&gt; setenv serverip 192.168.1.102</span><br><span class=\"line\">=&gt; setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'</span><br></pre></td></tr></table></figure>\n\n<p>手动设置tftp下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; tftp 0x60003000 uImage\t// tftp下载内核镜像</span><br><span class=\"line\">=&gt; tftp 0x60500000 vexpress-v2p-ca9.dtb\t\t// tftp下载设备树</span><br><span class=\"line\">=&gt; bootm 0x60003000 - 0x60500000\t// 启动内核</span><br></pre></td></tr></table></figure>\n\n<p>手动设置用来调试比较方便，但是正常使用时，还是将设置参数写入u-boot的vexpress_common.h头文件比较好，免得每次启动都需要输入这么多命令；</p>\n<h4 id=\"3）-设置挂载nfs网络文件系统\"><a href=\"#3）-设置挂载nfs网络文件系统\" class=\"headerlink\" title=\"3） 设置挂载nfs网络文件系统\"></a>3） 设置挂载nfs网络文件系统</h4><p>如果需要通过nfs挂载网络文件系统，需要在u-boot中，设置boot_args，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># vim <span class=\"meta-keyword\">include</span>/configs/vexpress_common.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_BOOTCOMMAND  \\</span></span><br><span class=\"line\">    <span class=\"string\">\"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\</span></span><br><span class=\"line\"><span class=\"string\">    setenv bootargs 'root=/dev/nfs rw   \\</span></span><br><span class=\"line\"><span class=\"string\">    nfsroot=192.168.1.102:/home/xiami/qemu/nfs_root init=/linuxrc   \\</span></span><br><span class=\"line\"><span class=\"string\">    ip=192.168.1.110 console=ttyAMA0';  \\</span></span><br><span class=\"line\"><span class=\"string\">    bootm 0x60003000 - 0x60500000;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_IPADDR   192.168.1.110</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_SERVERIP 192.168.1.104</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIGN_NETMASK 255.255.255.0</span></span><br></pre></td></tr></table></figure>\n\n\n<p>重新编译u-boot；启动Qemu验证</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; print bootcmd</span><br><span class=\"line\">bootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/nfs rw nfsroot=192.168.1.102:/home/xiami/qemu/boot-uboot/rootfs init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;</span><br><span class=\"line\">=&gt; print ipaddr</span><br><span class=\"line\">ipaddr=192.168.1.110</span><br><span class=\"line\">=&gt; print serverip</span><br><span class=\"line\">serverip=192.168.1.102</span><br></pre></td></tr></table></figure>\n\n<p>网络还没有ping通：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; ping 192.168.1.102</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\"></span><br><span class=\"line\">ARP Retry count exceeded; starting again</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">ping failed; host 192.168.1.102 is not alive</span><br></pre></td></tr></table></figure>\n\n<p>这部分在下一节中再讲述，此处略过；</p>\n<h3 id=\"6-2-启动验证\"><a href=\"#6-2-启动验证\" class=\"headerlink\" title=\"6.2 启动验证\"></a>6.2 启动验证</h3><h4 id=\"1）-启动Qemu，并检查启动参数\"><a href=\"#1）-启动Qemu，并检查启动参数\" class=\"headerlink\" title=\"1） 启动Qemu，并检查启动参数\"></a>1） 启动Qemu，并检查启动参数</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cat boot.sh</span></span><br><span class=\"line\"><span class=\"comment\">#! /bin/sh</span></span><br><span class=\"line\">sudo qemu<span class=\"literal\">-system</span><span class=\"literal\">-arm</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-M</span> vexpress<span class=\"literal\">-a9</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-m</span> <span class=\"number\">512</span>M \\</span><br><span class=\"line\">\t<span class=\"literal\">-kernel</span> ./u<span class=\"literal\">-boot</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-nographic</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-append</span> console=ttyAMA0 \\</span><br><span class=\"line\">\t<span class=\"literal\">-sd</span> rootfs.ext3 \\</span><br><span class=\"line\">\t<span class=\"literal\">-net</span> nic \\</span><br><span class=\"line\">\t<span class=\"literal\">-net</span> tap</span><br></pre></td></tr></table></figure>\n\n\n\n<p>u-boot启动后，查看u-boot中的环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; print bootcmd</span><br><span class=\"line\">bootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;</span><br><span class=\"line\">=&gt; print ipaddr</span><br><span class=\"line\">ipaddr=192.168.1.110</span><br><span class=\"line\">=&gt; print serverip</span><br><span class=\"line\">serverip=192.168.1.102</span><br></pre></td></tr></table></figure>\n\n\n\n<p>检查tftp下载网络，在开发板的u-boot中，ping本地PC的tftp服务器，注意，不要用电脑ping开发板，因为u-boot中没有回应机制，是ping不通开发板的；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; ping 192.168.1.102</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">host 192.168.1.102 is alive</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）-启动验证\"><a href=\"#2）-启动验证\" class=\"headerlink\" title=\"2） 启动验证\"></a>2） 启动验证</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .&#x2F;boot-uboot-tftp.sh </span><br><span class=\"line\">Booting qemu vexpress-ca9</span><br><span class=\"line\">WARNING: Image format was not specified for &#39;rootfs.ext3&#39; and probing guessed raw.</span><br><span class=\"line\">         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.</span><br><span class=\"line\">         Specify the &#39;raw&#39; format explicitly to remove the restrictions.</span><br><span class=\"line\">sudo tunctl -u root -t tap0</span><br><span class=\"line\">TUNSETIFF: Device or resource busy</span><br><span class=\"line\">sudo ifconfig tap0 0.0.0.0 promisc up</span><br><span class=\"line\">sudo brctl addif br0 tap0</span><br><span class=\"line\">brctl show</span><br><span class=\"line\">bridge name\tbridge id\t\tSTP enabled\tinterfaces</span><br><span class=\"line\">br0\t\t8000.0021ccd65a96\tno\t\tenp0s25</span><br><span class=\"line\">\t\t\t\t\t\t\ttap0</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot 2020.01 (Mar 22 2020 - 16:51:32 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">DRAM:  512 MiB</span><br><span class=\"line\">WARNING: Caches not enabled</span><br><span class=\"line\">Flash: 128 MiB</span><br><span class=\"line\">MMC:   MMC: 0</span><br><span class=\"line\">*** Warning - bad CRC, using default environment</span><br><span class=\"line\"></span><br><span class=\"line\">In:    serial</span><br><span class=\"line\">Out:   serial</span><br><span class=\"line\">Err:   serial</span><br><span class=\"line\">Net:   smc911x-0</span><br><span class=\"line\">Hit any key to stop autoboot:  0 </span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.102; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;uImage&#39;.</span><br><span class=\"line\">Load address: 0x60003000</span><br><span class=\"line\">Loading: #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t ###########</span><br><span class=\"line\">\t 8.7 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 3971576 (3c99f8 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.102; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;vexpress-v2p-ca9.dtb&#39;.</span><br><span class=\"line\">Load address: 0x60500000</span><br><span class=\"line\">Loading: ##</span><br><span class=\"line\">\t 4.7 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 14692 (3964 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">## Booting kernel from Legacy Image at 60003000 ...</span><br><span class=\"line\">   Image Name:   Linux-4.14.172</span><br><span class=\"line\">   Image Type:   ARM Linux Kernel Image (uncompressed)</span><br><span class=\"line\">   Data Size:    3971512 Bytes &#x3D; 3.8 MiB</span><br><span class=\"line\">   Load Address: 60003000</span><br><span class=\"line\">   Entry Point:  60003000</span><br><span class=\"line\">   Verifying Checksum ... OK</span><br><span class=\"line\">## Flattened Device Tree blob at 60500000</span><br><span class=\"line\">   Booting using the fdt blob at 0x60500000</span><br><span class=\"line\">   Loading Kernel Image</span><br><span class=\"line\">   Loading Device Tree to 7fe81000, end 7fe87963 ... OK</span><br><span class=\"line\"></span><br><span class=\"line\">Starting kernel ...</span><br><span class=\"line\"></span><br><span class=\"line\">Booting Linux on physical CPU 0x0</span><br><span class=\"line\">Linux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020</span><br><span class=\"line\">CPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr&#x3D;10c5387d</span><br><span class=\"line\">CPU: PIPT &#x2F; VIPT nonaliasing data cache, VIPT nonaliasing instruction cache</span><br><span class=\"line\">OF: fdt: Machine model: V2P-CA9</span><br><span class=\"line\">Memory policy: Data cache writeback</span><br><span class=\"line\">CPU: All CPU(s) started in SVC mode.</span><br><span class=\"line\">percpu: Embedded 15 pages&#x2F;cpu s32396 r8192 d20852 u61440</span><br><span class=\"line\">Built 1 zonelists, mobility grouping on.  Total pages: 130048</span><br><span class=\"line\">Kernel command line: root&#x3D;&#x2F;dev&#x2F;mmcblk0 rw       init&#x3D;&#x2F;linuxrc       ip&#x3D;192.168.1.110 console&#x3D;ttyAMA0</span><br><span class=\"line\">log_buf_len individual max cpu contribution: 4096 bytes</span><br><span class=\"line\">log_buf_len total cpu_extra contributions: 12288 bytes</span><br><span class=\"line\">log_buf_len min size: 16384 bytes</span><br><span class=\"line\">log_buf_len: 32768 bytes</span><br><span class=\"line\">early log buf free: 14980(91%)</span><br><span class=\"line\">PID hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class=\"line\">Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)</span><br><span class=\"line\">Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)</span><br><span class=\"line\">Memory: 509616K&#x2F;524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14672K reserved, 0K cma-reserved)</span><br><span class=\"line\">Virtual kernel memory layout:</span><br><span class=\"line\">    vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class=\"line\">    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class=\"line\">    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)</span><br><span class=\"line\">    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)</span><br><span class=\"line\">    modules : 0x7f000000 - 0x80000000   (  16 MB)</span><br><span class=\"line\">      .text : 0x80008000 - 0x80700000   (7136 kB)</span><br><span class=\"line\">      .init : 0x80900000 - 0x80a00000   (1024 kB)</span><br><span class=\"line\">      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)</span><br><span class=\"line\">       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)</span><br><span class=\"line\">SLUB: HWalign&#x3D;64, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;4, Nodes&#x3D;1</span><br><span class=\"line\">Hierarchical RCU implementation.</span><br><span class=\"line\">\tRCU event tracing is enabled.</span><br><span class=\"line\">\tRCU restricting CPUs from NR_CPUS&#x3D;8 to nr_cpu_ids&#x3D;4.</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">IP-Config: Guessing netmask 255.255.255.0</span><br><span class=\"line\">IP-Config: Complete:</span><br><span class=\"line\">     device&#x3D;eth0, hwaddr&#x3D;52:54:00:12:34:56, ipaddr&#x3D;192.168.1.110, mask&#x3D;255.255.255.0, gw&#x3D;255.255.255.255</span><br><span class=\"line\">     host&#x3D;192.168.1.110, domain&#x3D;, nis-domain&#x3D;(none)</span><br><span class=\"line\">     bootserver&#x3D;255.255.255.255, rootserver&#x3D;255.255.255.255, rootpath&#x3D;</span><br><span class=\"line\">ALSA device list:</span><br><span class=\"line\">  #0: ARM AC&#39;97 Interface PL041 rev0 at 0x10004000, irq 30</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem</span><br><span class=\"line\">random: fast init done</span><br><span class=\"line\">EXT4-fs (mmcblk0): recovery complete</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class=\"line\">VFS: Mounted root (ext3 filesystem) on device 179:0.</span><br><span class=\"line\">Freeing unused kernel memory: 1024K</span><br><span class=\"line\">random: crng init done</span><br><span class=\"line\">Hello Linux Qemu!</span><br><span class=\"line\"></span><br><span class=\"line\">Please press Enter to activate this console. </span><br><span class=\"line\">&#x2F; #</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; reset</span><br><span class=\"line\">resetting ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot 2017.05 (Jul 24 2019 - 21:52:28 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">DRAM:  512 MiB</span><br><span class=\"line\">WARNING: Caches not enabled</span><br><span class=\"line\">Flash: 128 MiB</span><br><span class=\"line\">MMC:   MMC: 0</span><br><span class=\"line\">*** Warning - bad CRC, using default environment</span><br><span class=\"line\"></span><br><span class=\"line\">In:    serial</span><br><span class=\"line\">Out:   serial</span><br><span class=\"line\">Err:   serial</span><br><span class=\"line\">Net:   smc911x-0</span><br><span class=\"line\">Hit any key to stop autoboot:  0 </span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.104; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;uImage&#39;.</span><br><span class=\"line\">Load address: 0x60003000</span><br><span class=\"line\">Loading: #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t ##################################################</span><br><span class=\"line\">\t 1.3 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 3581920 (36a7e0 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.104; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;vexpress-v2p-ca9.dtb&#39;.</span><br><span class=\"line\">Load address: 0x60500000</span><br><span class=\"line\">Loading: #</span><br><span class=\"line\">\t 250 KiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 14360 (3818 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">## Booting kernel from Legacy Image at 60003000 ...</span><br><span class=\"line\">   Image Name:   Linux-4.4.157</span><br><span class=\"line\">   Image Type:   ARM Linux Kernel Image (uncompressed)</span><br><span class=\"line\">   Data Size:    3581856 Bytes &#x3D; 3.4 MiB</span><br><span class=\"line\">   Load Address: 60003000</span><br><span class=\"line\">   Entry Point:  60003000</span><br><span class=\"line\">   Verifying Checksum ... OK</span><br><span class=\"line\">## Flattened Device Tree blob at 60500000</span><br><span class=\"line\">   Booting using the fdt blob at 0x60500000</span><br><span class=\"line\">   Loading Kernel Image ... OK</span><br><span class=\"line\">   Loading Device Tree to 7fed4000, end 7feda817 ... OK</span><br></pre></td></tr></table></figure>\n\n<p>至此，通过u-boot加载kernel，并挂载SD卡文件系统已经成功；</p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><p>SD卡中rootfs目录是一个简易的根文件系统，可以将它制作成一个镜像文件，将镜像文件烧写到开发板，或者通过Qemu中的u-boot启动Linux内核后挂载到镜像文件上。也可以设置为通过NFS网络文件系统启动，参考下一篇文章《<a href=\"https://www.jianshu.com/p/cf46f7225db6\" target=\"_blank\" rel=\"noopener\">Qemu搭建ARM vexpress开发环境(三)—-NFS网络根文件系统</a>》。</p>\n","site":{"data":{}},"excerpt":"<p>标签： Qemu</p>\n<hr>\n<p>在上文《<a href=\"https://www.jianshu.com/p/94833e841742\" target=\"_blank\" rel=\"noopener\">Qemu搭建ARM vexpress开发环境(一)</a>》中已经简单讲述了通过Qemu直接启动Linux内核，并挂载SD卡根文件系统的方法，这种方法是直接启动内核，与实际应用中ARM板的启动方式：u-boot、kernel、rootfs有些不同。现在就来讲述下用Qemu搭建通过u-boot启动Linux内核并挂载根文件系统的方法。</p>","more":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>[TOC]</p>\n<h2 id=\"1-简述\"><a href=\"#1-简述\" class=\"headerlink\" title=\"1. 简述\"></a>1. 简述</h2><p>嵌入式系统要正常运行，应该包含：u-boot、kernel、rootfs、appfs。这几部分在ARM开发板Flash上的位置关系应该类似于下图所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">BootLoader</th>\n<th align=\"center\">BootParameters</th>\n<th align=\"center\">Kernel</th>\n<th align=\"center\">Rootfs</th>\n<th align=\"center\">Appfs</th>\n</tr>\n</thead>\n</table>\n<p>嵌入式系统的启动流程如下：</p>\n<pre class=\"mermaid\">graph TB\n    BootLoader(BootLoader)--BootParameters-->Kernel(Kernel)-->Rootfs(Rootfs)-->Appfs(Appfs)</pre>\n\n<p>rootfs可以添加到开发板的Flash，也可以不用添加到开发板，而是部署到PC机上，开发板在运行完kernel，要挂载rootfs时，可以通过NFS网络挂载到设定好的PC机上的rootfs根文件系统上（下一篇文章《Qemu搭建ARM vexpress开发环境(三)—-NFS网络根文件系统》会详细讲解NFS网络挂载根文件系统的具体操作方法）。</p>\n<h2 id=\"2-准备u-boot\"><a href=\"#2-准备u-boot\" class=\"headerlink\" title=\"2. 准备u-boot\"></a>2. 准备u-boot</h2><p>用来使用u-boot启动加载Linux内核</p>\n<h3 id=\"2-1-下载u-boot\"><a href=\"#2-1-下载u-boot\" class=\"headerlink\" title=\"2.1 下载u-boot\"></a>2.1 下载u-boot</h3><p>从 <a href=\"http://ftp.denx.de/pub/u-boot\" target=\"_blank\" rel=\"noopener\">http://ftp.denx.de/pub/u-boot</a> 网站选择一个u-boot版本源码下载，本文中使用的是u-boot-2020.01版本。</p>\n<h3 id=\"2-2-解压u-boot\"><a href=\"#2-2-解压u-boot\" class=\"headerlink\" title=\"2.2 解压u-boot\"></a>2.2 解压u-boot</h3><p>解压u-boot:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tar -xvf u-boot-2020.01.tar.bz2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-编译u-boot\"><a href=\"#2-3-编译u-boot\" class=\"headerlink\" title=\"2.3 编译u-boot\"></a>2.3 编译u-boot</h3><h4 id=\"2-3-1-配置时碰到的问题\"><a href=\"#2-3-1-配置时碰到的问题\" class=\"headerlink\" title=\"2.3.1 配置时碰到的问题\"></a>2.3.1 配置时碰到的问题</h4><h5 id=\"配置命令\"><a href=\"#配置命令\" class=\"headerlink\" title=\"配置命令\"></a>配置命令</h5><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_ca9x4_defconfig</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果没有修改Makefile和config.mk文件，需要在编译时加上ARCH和CROSS_COMPILE的配置；在编译u-boot时可能会出现一些问题，只要逐个问题解决就可以编译完成了；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh: 1: bison: not found</span><br><span class=\"line\">scripts/Makefile.lib:226: recipe for target 'scripts/kconfig/zconf.tab.c' failed</span><br><span class=\"line\">make[1]: *** [scripts/kconfig/zconf.tab.c] Error 127</span><br><span class=\"line\">Makefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed</span><br><span class=\"line\">make: *** [vexpress_ca9x4_defconfig] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install bison</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh: 1: flex: not found</span><br><span class=\"line\">scripts/Makefile.lib:218: recipe for target 'scripts/kconfig/zconf.lex.c' failed</span><br><span class=\"line\">make[1]: *** [scripts/kconfig/zconf.lex.c] Error 127</span><br><span class=\"line\">Makefile:539: recipe for target 'vexpress_ca9x4_defconfig' failed</span><br><span class=\"line\">make: *** [vexpress_ca9x4_defconfig] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install flex</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object -j4</span></span><br><span class=\"line\">scripts/kconfig/conf  --syncconfig Kconfig</span><br><span class=\"line\">  CHK     include/config.h</span><br><span class=\"line\">  GEN     include/autoconf.mk.dep</span><br><span class=\"line\">  CFG     u-boot.cfg</span><br><span class=\"line\">  GEN     include/autoconf.mk</span><br><span class=\"line\">*** Your GCC is older than 6.0 and is not supported</span><br><span class=\"line\">arch/arm/config.mk:66: recipe for target 'checkgcc6' failed</span><br><span class=\"line\">make: *** [checkgcc6] Error 1</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim arch/arm/config.mk</span></span><br><span class=\"line\">ifeq ($(CONFIG_$(SPL_)SYS_THUMB_BUILD),y)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">archprepare: checkthumb checkgcc6</span></span><br><span class=\"line\">archprepare: checkthumb</span><br><span class=\"line\">checkthumb:</span><br><span class=\"line\">        @if test \"$(call cc-name)\" = \"gcc\" -a \\</span><br><span class=\"line\">                        \"$(call cc-version)\" -lt \"0404\"; then \\</span><br><span class=\"line\">                echo -n '*** Your GCC does not produce working '; \\</span><br><span class=\"line\">                echo 'binaries in THUMB mode.'; \\</span><br><span class=\"line\">                echo '*** Your board is configured for THUMB mode.'; \\</span><br><span class=\"line\">                false; \\</span><br><span class=\"line\">        fi</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">archprepare: checkgcc6</span></span><br><span class=\"line\">endif</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">checkgcc6:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">        @<span class=\"keyword\">if</span> <span class=\"built_in\">test</span> <span class=\"string\">\"<span class=\"variable\">$(call cc-name)</span>\"</span> = <span class=\"string\">\"gcc\"</span> -a \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                        <span class=\"string\">\"<span class=\"variable\">$(call cc-version)</span>\"</span> -lt <span class=\"string\">\"0600\"</span>; <span class=\"keyword\">then</span> \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                <span class=\"built_in\">echo</span> <span class=\"string\">'*** Your GCC is older than 6.0 and is not supported'</span>; \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                <span class=\"literal\">false</span>; \\</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">        <span class=\"keyword\">fi</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-3-2-生成配置文件\"><a href=\"#2-3-2-生成配置文件\" class=\"headerlink\" title=\"2.3.2 生成配置文件\"></a>2.3.2 生成配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_ca9x4_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/u-boot-2020.01/object'</span><br><span class=\"line\">  HOSTCC  scripts/basic/fixdep</span><br><span class=\"line\">  GEN     ./Makefile</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/conf.o</span><br><span class=\"line\">  YACC    scripts/kconfig/zconf.tab.c</span><br><span class=\"line\">  LEX     scripts/kconfig/zconf.lex.c</span><br><span class=\"line\">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class=\"line\">  HOSTLD  scripts/kconfig/conf</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> configuration written to .config</span></span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/u-boot-2020.01/object'</span><br></pre></td></tr></table></figure>\n\n\n\n<p>./configs/vexpress_ca9x4_defconfig</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls object/.config -l</span></span><br><span class=\"line\">-rw-r--r-- 1 xiami xiami 22698 Mar 17 23:20 object/.config</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果需要修改配置文件中的一些选项，可以通过以下界面操作选择：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make menuconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- O=./object</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-3-3-编译\"><a href=\"#2-3-3-编译\" class=\"headerlink\" title=\"2.3.3 编译\"></a>2.3.3 编译</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 O=./object</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-3-4-简化编译过程\"><a href=\"#2-3-4-简化编译过程\" class=\"headerlink\" title=\"2.3.4 简化编译过程\"></a>2.3.4 简化编译过程</h4><p>这种方式编译比较直接，但是在调试时，需要多次编译u-boot，参数太多会带来不便，于是可以通过以下方法，修改Makefile和config.mk文件中的ARCH和CROSS_COMPILE选项，在编译的时候就可以省去了在编译命令中添加编译配置的设置。</p>\n<p>修改Makefile</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim Makefile</span></span><br><span class=\"line\">CROSS_COMPILE = arm-linux-gnueabi-</span><br></pre></td></tr></table></figure>\n<p>修改config.mk</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim config.mk</span></span><br><span class=\"line\">ARCH = arm</span><br></pre></td></tr></table></figure>\n\n\n<p>编译u-boot:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make vexpress_ca9x4_defconfig</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make -j4</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-启动u-boot\"><a href=\"#2-4-启动u-boot\" class=\"headerlink\" title=\"2.4 启动u-boot\"></a>2.4 启动u-boot</h3><p>通过Qemu启动命令启动u-boot：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> qemu-system-arm -M vexpress-a9 -m 512M -nographic -kernel ./u-boot</span></span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot 2020.01 (Mar 17 2020 - 23:21:36 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">DRAM:  512 MiB</span><br><span class=\"line\">WARNING: Caches not enabled</span><br><span class=\"line\">Flash: 128 MiB</span><br><span class=\"line\">MMC:   MMC: 0</span><br><span class=\"line\">*** Warning - bad CRC, using default environment</span><br><span class=\"line\"></span><br><span class=\"line\">In:    serial</span><br><span class=\"line\">Out:   serial</span><br><span class=\"line\">Err:   serial</span><br><span class=\"line\">Net:   smc911x-0</span><br><span class=\"line\">Hit any key to stop autoboot:  0 </span><br><span class=\"line\">=&gt;</span><br></pre></td></tr></table></figure>\n\n<p>查看u-boot的版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; version</span><br><span class=\"line\">U-Boot 2020.01 (Mar 20 2020 - 23:01:23 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">arm-linux-gnueabi-gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0</span><br><span class=\"line\">GNU ld (GNU Binutils for Ubuntu) 2.30</span><br></pre></td></tr></table></figure>\n\n\n\n<p>打印u-boot的环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; print</span><br><span class=\"line\">arch=arm</span><br><span class=\"line\">baudrate=38400</span><br><span class=\"line\">board=vexpress</span><br><span class=\"line\">board_name=vexpress</span><br><span class=\"line\">......</span><br><span class=\"line\">scriptaddr=0x88000000</span><br><span class=\"line\">stderr=serial</span><br><span class=\"line\">stdin=serial</span><br><span class=\"line\">stdout=serial</span><br><span class=\"line\">vendor=armltd</span><br><span class=\"line\"></span><br><span class=\"line\">Environment size: 2656/262140 bytes</span><br></pre></td></tr></table></figure>\n\n<p>至此，u-boot启动成功，下一步开始配置u-boot的内核启动参数，来启动Linux内核，并挂在根文件系统。</p>\n<h2 id=\"3-准备内核\"><a href=\"#3-准备内核\" class=\"headerlink\" title=\"3. 准备内核\"></a>3. 准备内核</h2><h3 id=\"3-1-指定加载地址\"><a href=\"#3-1-指定加载地址\" class=\"headerlink\" title=\"3.1 指定加载地址\"></a>3.1 指定加载地址</h3><p>使用u-boot引导内核启动，需要内核的uImage镜像：</p>\n<blockquote>\n<p>需要将内核编译为uImage格式，需要指定uImage在内存中的加载地址，编译内核时指定：make LOADADDR=? uImage -j4</p>\n</blockquote>\n<p>如果不指定LOADADDR参数，编译时会报错，如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage -j4 O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">......</span><br><span class=\"line\">  Kernel: arch/arm/boot/Image is ready</span><br><span class=\"line\">  Kernel: arch/arm/boot/zImage is ready</span><br><span class=\"line\">multiple (or no) load addresses: </span><br><span class=\"line\">This is incompatible with uImages</span><br><span class=\"line\">Specify LOADADDR on the commandline to build an uImage</span><br><span class=\"line\">../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed</span><br><span class=\"line\">make[2]: *** [arch/arm/boot/uImage] Error 1</span><br><span class=\"line\">arch/arm/Makefile:338: recipe for target 'uImage' failed</span><br><span class=\"line\">make[1]: *** [uImage] Error 2</span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">Makefile:146: recipe for target 'sub-make' failed</span><br><span class=\"line\">make: *** [sub-make] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在内核目录直接编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make LOADADDR=0x60003000 uImage -j4</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">......</span><br><span class=\"line\">  Kernel: arch/arm/boot/Image is ready</span><br><span class=\"line\">  Kernel: arch/arm/boot/zImage is ready</span><br><span class=\"line\">  UIMAGE  arch/arm/boot/uImage</span><br><span class=\"line\">\"mkimage\" command not found - U-Boot images will not be built</span><br><span class=\"line\">../arch/arm/boot/Makefile:79: recipe for target 'arch/arm/boot/uImage' failed</span><br><span class=\"line\">make[2]: *** [arch/arm/boot/uImage] Error 1</span><br><span class=\"line\">arch/arm/Makefile:338: recipe for target 'uImage' failed</span><br><span class=\"line\">make[1]: *** [uImage] Error 2</span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">Makefile:146: recipe for target 'sub-make' failed</span><br><span class=\"line\">make: *** [sub-make] Error 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第一次编译会报错，提示没有找到mkimage工具，需要手动安装u-boot-tools即可；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install u-boot-tools</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-2-编译uImage\"><a href=\"#3-2-编译uImage\" class=\"headerlink\" title=\"3.2 编译uImage\"></a>3.2 编译uImage</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j4 O=./object</span></span><br><span class=\"line\">make[1]: Entering directory '/home/xiami/tool/linux-4.14.172/object'</span><br><span class=\"line\">......</span><br><span class=\"line\">Load Address: 60003000</span><br><span class=\"line\">Entry Point:  60003000</span><br><span class=\"line\">  Kernel: arch/arm/boot/uImage is ready</span><br><span class=\"line\">make[1]: Leaving directory '/home/xiami/tool/linux-4.14.172/object'</span><br></pre></td></tr></table></figure>\n\n\n\n<p>或者在Makefile中添加加载地址配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim arch/arm/boot/Makefile</span></span><br><span class=\"line\">LOADADDR ?= 0x60003000</span><br></pre></td></tr></table></figure>\n<p>再编译生成uImage文件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> make uImage -j4</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-Qemu网络功能设置\"><a href=\"#4-Qemu网络功能设置\" class=\"headerlink\" title=\"4. Qemu网络功能设置\"></a>4. Qemu网络功能设置</h2><p>Qemu虚拟机在u-boot启动时，需要将uImage加载到内存，而uImage从哪里来？可以通过TFTP服务器下载uImage到内存指定地址。而在这之前需要通过桥接方式将网络链接到Ubuntu系统。</p>\n<h3 id=\"4-1-配置Qemu与主机的网络连接\"><a href=\"#4-1-配置Qemu与主机的网络连接\" class=\"headerlink\" title=\"4.1 配置Qemu与主机的网络连接\"></a>4.1 配置Qemu与主机的网络连接</h3><p>采用桥接网络连接Host主机通信<br>主机内核需要支持tun/tap模块</p>\n<h3 id=\"4-2-配置Ubuntu主机\"><a href=\"#4-2-配置Ubuntu主机\" class=\"headerlink\" title=\"4.2 配置Ubuntu主机\"></a>4.2 配置Ubuntu主机</h3><h4 id=\"1-安装工具\"><a href=\"#1-安装工具\" class=\"headerlink\" title=\"1) 安装工具\"></a>1) 安装工具</h4><p>安装桥接网络依赖的两个工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install uml-utilities bridge-utils</span></span><br></pre></td></tr></table></figure>\n\n<p>创建tun设备文件：/dev/net/tun（一般会自动创建）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /dev/net/tun -l</span></span><br><span class=\"line\">crw-rw-rw- 1 root root 10, 200 Mar 20 21:31 /dev/net/tun</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-配置网络\"><a href=\"#2-配置网络\" class=\"headerlink\" title=\"2) 配置网络\"></a>2) 配置网络</h4><p>修改/etc/network/interfaces文件配置网络</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo vim /etc/network/interfaces</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class=\"line\">auto lo</span><br><span class=\"line\">iface lo inet loopback</span><br><span class=\"line\"></span><br><span class=\"line\">auto br0</span><br><span class=\"line\">iface br0 inet dhcp</span><br><span class=\"line\">bridge_ports enp0s25</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-添加网络配置脚本\"><a href=\"#3-添加网络配置脚本\" class=\"headerlink\" title=\"3) 添加网络配置脚本\"></a>3) 添加网络配置脚本</h4><p>配置/etc/qemu-ifup、/etc/qemu-ifdown脚本；</p>\n<p>默认情况下，当qemu使用tap设备时，会执行/etc/qemu-ifup和/etc/qemu-ifdown这两个脚本；需要创建这两个脚本，并加上可执行权限；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/qemu-ifup</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo tunctl -u $(id -un) -t $1</span><br><span class=\"line\">sudo tunctl -u $(id -un) -t $1</span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo ifconfig $1 0.0.0.0 promisc up</span><br><span class=\"line\">sudo ifconfig $1 0.0.0.0 promisc up</span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo brctl addif br0 $1</span><br><span class=\"line\">sudo brctl addif br0 $1</span><br><span class=\"line\"></span><br><span class=\"line\">echo brctl show</span><br><span class=\"line\">brctl show</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ifconfig br0 192.168.1.102</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class=\"line\">        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 146587  bytes 69384714 (69.3 MB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 117583  bytes 13689404 (13.6 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\">        device interrupt 20  memory 0xf3900000-f3920000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>查询到enp0s25的IP地址是192.168.1.102，需要将br0配置在同一个192.168.1.***网段；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/qemu-ifdown</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo brctl delif br0 $1</span><br><span class=\"line\">sudo brctl delif br0 $1</span><br><span class=\"line\"></span><br><span class=\"line\">echo sudo tunctl -d $1</span><br><span class=\"line\">sudo tunctl -d $1</span><br><span class=\"line\"> </span><br><span class=\"line\">echo brctl show</span><br><span class=\"line\">brctl show</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chmod a+x /etc/qemu-ifup</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chmod a+x /etc/qemu-ifdown</span></span><br></pre></td></tr></table></figure>\n\n<p>重启PC，使新的/etc/network/interfaces配置文件生效；</p>\n<h3 id=\"4-3-关闭防火墙\"><a href=\"#4-3-关闭防火墙\" class=\"headerlink\" title=\"4.3 关闭防火墙\"></a>4.3 关闭防火墙</h3><h4 id=\"1-关闭防火墙\"><a href=\"#1-关闭防火墙\" class=\"headerlink\" title=\"1) 关闭防火墙\"></a>1) 关闭防火墙</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ufw <span class=\"built_in\">disable</span></span></span><br><span class=\"line\">Firewall stopped and disabled on system startup</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-查看当前防火墙状态\"><a href=\"#2-查看当前防火墙状态\" class=\"headerlink\" title=\"2) 查看当前防火墙状态\"></a>2) 查看当前防火墙状态</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ufw status</span></span><br><span class=\"line\">Status: inactive</span><br></pre></td></tr></table></figure>\n\n\n\n<p>另外，附上开启防火墙的操作方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ufw <span class=\"built_in\">enable</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-4-重启系统，使配置生效\"><a href=\"#4-4-重启系统，使配置生效\" class=\"headerlink\" title=\"4.4 重启系统，使配置生效\"></a>4.4 重启系统，使配置生效</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> reboot</span></span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> init 6</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-5-查看Qemu的网络环境\"><a href=\"#4-5-查看Qemu的网络环境\" class=\"headerlink\" title=\"4.5 查看Qemu的网络环境\"></a>4.5 查看Qemu的网络环境</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.1.102  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class=\"line\">        inet6 ****::***:****:****:****  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether **:**:**:**:**:**  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 44667  bytes 16853864 (16.8 MB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 45161  bytes 32391098 (32.3 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n\n<p>虚拟网口br0即Qemu虚拟机与Linux主机通讯的网口；</p>\n<p>在u-boot中测试网络是否接通：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; ping 192.168.1.102</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">host 192.168.1.102 is alive</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-安装TFTP服务器\"><a href=\"#5-安装TFTP服务器\" class=\"headerlink\" title=\"5. 安装TFTP服务器\"></a>5. 安装TFTP服务器</h2><p>创建TFTP服务器，用来给Qemu模拟开发板启动uImage时，下载uImage到内存中。</p>\n<h3 id=\"5-1-安装TFTP工具\"><a href=\"#5-1-安装TFTP工具\" class=\"headerlink\" title=\"5.1 安装TFTP工具\"></a>5.1 安装TFTP工具</h3><p>安装Linux主机Host的TFTP服务器工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install tftp-hpa tftpd-hpa xinetd</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-2-配置\"><a href=\"#5-2-配置\" class=\"headerlink\" title=\"5.2 配置\"></a>5.2 配置</h3><h4 id=\"1-修改配置文件，设置TFTP服务器目录\"><a href=\"#1-修改配置文件，设置TFTP服务器目录\" class=\"headerlink\" title=\"1) 修改配置文件，设置TFTP服务器目录\"></a>1) 修改配置文件，设置TFTP服务器目录</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo vim /etc/default/tftpd-hpa</span></span><br><span class=\"line\">......</span><br><span class=\"line\">TFTP_USERNAME=\"xiami\"</span><br><span class=\"line\">TFTP_DIRECTORY=\"/home/xiami/qemu/boot-uboot\"</span><br><span class=\"line\">TFTP_ADDRESS=\"0.0.0.0:69\"</span><br><span class=\"line\">TFTP_OPTIONS=\"-l -c -s\"</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>说明：</p>\n<p>TFTP_USERNAME：必须设置为当前的用户名，或：root</p>\n<p>TFTP_DIRECTORY：设定TFTP的根目录</p>\n<p>TFTP_ADDRESS：</p>\n<p>TFTP_OPTIONS：TFTP启动参数</p>\n<p>​    -l: 以standalone/listen模式启动TFTP服务，而不是从inetd启动，不需要安装xinetd</p>\n<p>​    -c: 可创建新文件，默认，TFTP只允许覆盖原文件，不能创建新文件</p>\n<p>​    -s: 改变TFTP启动的根目录；加入-s后，客户端使用TFTP时，不再需要输入指定目录，填写文件的完整路径，而是使用配置文件中写好的目录；</p>\n</blockquote>\n<h4 id=\"2-Linux主机上创建tftp目录\"><a href=\"#2-Linux主机上创建tftp目录\" class=\"headerlink\" title=\"2) Linux主机上创建tftp目录\"></a>2) Linux主机上创建tftp目录</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir /home/mcy/tftpboot</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chmod 777 /home/mcy/tftpboot</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-重启tftp服务\"><a href=\"#3-重启tftp服务\" class=\"headerlink\" title=\"3) 重启tftp服务\"></a>3) 重启tftp服务</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sudo /etc/init.d/tftpd-hpa restart</span></span><br><span class=\"line\">[ <span class=\"type\">ok</span> ] Restarting tftpd<span class=\"literal\">-hpa</span> (via systemctl): tftpd<span class=\"literal\">-hpa</span>.service.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3-测试验证\"><a href=\"#5-3-测试验证\" class=\"headerlink\" title=\"5.3 测试验证\"></a>5.3 测试验证</h3><h4 id=\"1-测试tftp服务器\"><a href=\"#1-测试tftp服务器\" class=\"headerlink\" title=\"1) 测试tftp服务器\"></a>1) 测试tftp服务器</h4><p>可以使用三种方法，1. 输入真实的IP地址；2. 用localhost代替主机；3. 使用地址127.0.0.1，这个IP地址始终代表本机IP；</p>\n<p>tftp 192.168.1.102</p>\n<p>tftp localhost</p>\n<p>tftp 127.0.0.1</p>\n<h4 id=\"2-TFTP命令行的基本命令\"><a href=\"#2-TFTP命令行的基本命令\" class=\"headerlink\" title=\"2) TFTP命令行的基本命令\"></a>2) TFTP命令行的基本命令</h4><p>put: 将文件上传到TFTP根目录</p>\n<p>get: 取得TFTP根目录上的文件</p>\n<p>quit/q: 退出TFTP服务</p>\n<h2 id=\"6-设置u-boot中的内核启动参数\"><a href=\"#6-设置u-boot中的内核启动参数\" class=\"headerlink\" title=\"6. 设置u-boot中的内核启动参数\"></a>6. 设置u-boot中的内核启动参数</h2><h3 id=\"6-1-设置u-boot参数\"><a href=\"#6-1-设置u-boot参数\" class=\"headerlink\" title=\"6.1 设置u-boot参数\"></a>6.1 设置u-boot参数</h3><p>u-boot能够正常启动还不足以引导内核启动，需要在u-boot中设置一些启动参数，在引导内核启动时，将这些启动参数传递给内核；内核启动后挂载SD卡中的文件系统；</p>\n<p>这些启动参数，可以在u-boot启动后，手动设置，也可以在u-boot中，把内核启动参数写入vexpress_common.h头文件；</p>\n<h4 id=\"1）-写入u-boot头文件\"><a href=\"#1）-写入u-boot头文件\" class=\"headerlink\" title=\"1） 写入u-boot头文件\"></a>1） 写入u-boot头文件</h4><p>修改vexpress_common.h头文件，添加内核启动需要的参数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># vim <span class=\"meta-keyword\">include</span>/configs/vexpress_common.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_BOOTCOMMAND  \\</span></span><br><span class=\"line\">    <span class=\"string\">\"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\</span></span><br><span class=\"line\"><span class=\"string\">    setenv bootargs 'root=/dev/mmcblk0 rw   \\</span></span><br><span class=\"line\"><span class=\"string\">    init=/linuxrc   \\</span></span><br><span class=\"line\"><span class=\"string\">    ip=192.168.1.110 console=ttyAMA0';  \\</span></span><br><span class=\"line\"><span class=\"string\">    bootm 0x60003000 - 0x60500000;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_IPADDR   192.168.1.110</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_SERVERIP 192.168.1.104</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIGN_NETMASK 255.255.255.0</span></span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<blockquote>\n<p>CONFIG_IPADDR： 设备的本地IP地址</p>\n<p>CONFIG_SERVERIP： TFTP下载时的服务器IP地址</p>\n<p>CONFIG_BOOTCOMMAND： 内核启动的参数设置，包含boot_args</p>\n</blockquote>\n<h4 id=\"2）-手动设置\"><a href=\"#2）-手动设置\" class=\"headerlink\" title=\"2） 手动设置\"></a>2） 手动设置</h4><p>在u-boot启动之后，手动设置环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; setenv ipaddr 192.168.1.110</span><br><span class=\"line\">=&gt; setenv serverip 192.168.1.102</span><br><span class=\"line\">=&gt; setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'</span><br></pre></td></tr></table></figure>\n\n<p>手动设置tftp下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; tftp 0x60003000 uImage\t// tftp下载内核镜像</span><br><span class=\"line\">=&gt; tftp 0x60500000 vexpress-v2p-ca9.dtb\t\t// tftp下载设备树</span><br><span class=\"line\">=&gt; bootm 0x60003000 - 0x60500000\t// 启动内核</span><br></pre></td></tr></table></figure>\n\n<p>手动设置用来调试比较方便，但是正常使用时，还是将设置参数写入u-boot的vexpress_common.h头文件比较好，免得每次启动都需要输入这么多命令；</p>\n<h4 id=\"3）-设置挂载nfs网络文件系统\"><a href=\"#3）-设置挂载nfs网络文件系统\" class=\"headerlink\" title=\"3） 设置挂载nfs网络文件系统\"></a>3） 设置挂载nfs网络文件系统</h4><p>如果需要通过nfs挂载网络文件系统，需要在u-boot中，设置boot_args，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># vim <span class=\"meta-keyword\">include</span>/configs/vexpress_common.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_BOOTCOMMAND  \\</span></span><br><span class=\"line\">    <span class=\"string\">\"tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;  \\</span></span><br><span class=\"line\"><span class=\"string\">    setenv bootargs 'root=/dev/nfs rw   \\</span></span><br><span class=\"line\"><span class=\"string\">    nfsroot=192.168.1.102:/home/xiami/qemu/nfs_root init=/linuxrc   \\</span></span><br><span class=\"line\"><span class=\"string\">    ip=192.168.1.110 console=ttyAMA0';  \\</span></span><br><span class=\"line\"><span class=\"string\">    bootm 0x60003000 - 0x60500000;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_IPADDR   192.168.1.110</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_SERVERIP 192.168.1.104</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIGN_NETMASK 255.255.255.0</span></span><br></pre></td></tr></table></figure>\n\n\n<p>重新编译u-boot；启动Qemu验证</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; print bootcmd</span><br><span class=\"line\">bootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/nfs rw nfsroot=192.168.1.102:/home/xiami/qemu/boot-uboot/rootfs init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;</span><br><span class=\"line\">=&gt; print ipaddr</span><br><span class=\"line\">ipaddr=192.168.1.110</span><br><span class=\"line\">=&gt; print serverip</span><br><span class=\"line\">serverip=192.168.1.102</span><br></pre></td></tr></table></figure>\n\n<p>网络还没有ping通：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; ping 192.168.1.102</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\"></span><br><span class=\"line\">ARP Retry count exceeded; starting again</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">ping failed; host 192.168.1.102 is not alive</span><br></pre></td></tr></table></figure>\n\n<p>这部分在下一节中再讲述，此处略过；</p>\n<h3 id=\"6-2-启动验证\"><a href=\"#6-2-启动验证\" class=\"headerlink\" title=\"6.2 启动验证\"></a>6.2 启动验证</h3><h4 id=\"1）-启动Qemu，并检查启动参数\"><a href=\"#1）-启动Qemu，并检查启动参数\" class=\"headerlink\" title=\"1） 启动Qemu，并检查启动参数\"></a>1） 启动Qemu，并检查启动参数</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cat boot.sh</span></span><br><span class=\"line\"><span class=\"comment\">#! /bin/sh</span></span><br><span class=\"line\">sudo qemu<span class=\"literal\">-system</span><span class=\"literal\">-arm</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-M</span> vexpress<span class=\"literal\">-a9</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-m</span> <span class=\"number\">512</span>M \\</span><br><span class=\"line\">\t<span class=\"literal\">-kernel</span> ./u<span class=\"literal\">-boot</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-nographic</span> \\</span><br><span class=\"line\">\t<span class=\"literal\">-append</span> console=ttyAMA0 \\</span><br><span class=\"line\">\t<span class=\"literal\">-sd</span> rootfs.ext3 \\</span><br><span class=\"line\">\t<span class=\"literal\">-net</span> nic \\</span><br><span class=\"line\">\t<span class=\"literal\">-net</span> tap</span><br></pre></td></tr></table></figure>\n\n\n\n<p>u-boot启动后，查看u-boot中的环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; print bootcmd</span><br><span class=\"line\">bootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/mmcblk0 rw init=/linuxrc ip=192.168.1.110 console=ttyAMA0'; bootm 0x60003000 - 0x60500000;</span><br><span class=\"line\">=&gt; print ipaddr</span><br><span class=\"line\">ipaddr=192.168.1.110</span><br><span class=\"line\">=&gt; print serverip</span><br><span class=\"line\">serverip=192.168.1.102</span><br></pre></td></tr></table></figure>\n\n\n\n<p>检查tftp下载网络，在开发板的u-boot中，ping本地PC的tftp服务器，注意，不要用电脑ping开发板，因为u-boot中没有回应机制，是ping不通开发板的；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; ping 192.168.1.102</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">host 192.168.1.102 is alive</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）-启动验证\"><a href=\"#2）-启动验证\" class=\"headerlink\" title=\"2） 启动验证\"></a>2） 启动验证</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .&#x2F;boot-uboot-tftp.sh </span><br><span class=\"line\">Booting qemu vexpress-ca9</span><br><span class=\"line\">WARNING: Image format was not specified for &#39;rootfs.ext3&#39; and probing guessed raw.</span><br><span class=\"line\">         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.</span><br><span class=\"line\">         Specify the &#39;raw&#39; format explicitly to remove the restrictions.</span><br><span class=\"line\">sudo tunctl -u root -t tap0</span><br><span class=\"line\">TUNSETIFF: Device or resource busy</span><br><span class=\"line\">sudo ifconfig tap0 0.0.0.0 promisc up</span><br><span class=\"line\">sudo brctl addif br0 tap0</span><br><span class=\"line\">brctl show</span><br><span class=\"line\">bridge name\tbridge id\t\tSTP enabled\tinterfaces</span><br><span class=\"line\">br0\t\t8000.0021ccd65a96\tno\t\tenp0s25</span><br><span class=\"line\">\t\t\t\t\t\t\ttap0</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot 2020.01 (Mar 22 2020 - 16:51:32 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">DRAM:  512 MiB</span><br><span class=\"line\">WARNING: Caches not enabled</span><br><span class=\"line\">Flash: 128 MiB</span><br><span class=\"line\">MMC:   MMC: 0</span><br><span class=\"line\">*** Warning - bad CRC, using default environment</span><br><span class=\"line\"></span><br><span class=\"line\">In:    serial</span><br><span class=\"line\">Out:   serial</span><br><span class=\"line\">Err:   serial</span><br><span class=\"line\">Net:   smc911x-0</span><br><span class=\"line\">Hit any key to stop autoboot:  0 </span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.102; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;uImage&#39;.</span><br><span class=\"line\">Load address: 0x60003000</span><br><span class=\"line\">Loading: #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t ###########</span><br><span class=\"line\">\t 8.7 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 3971576 (3c99f8 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.102; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;vexpress-v2p-ca9.dtb&#39;.</span><br><span class=\"line\">Load address: 0x60500000</span><br><span class=\"line\">Loading: ##</span><br><span class=\"line\">\t 4.7 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 14692 (3964 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">## Booting kernel from Legacy Image at 60003000 ...</span><br><span class=\"line\">   Image Name:   Linux-4.14.172</span><br><span class=\"line\">   Image Type:   ARM Linux Kernel Image (uncompressed)</span><br><span class=\"line\">   Data Size:    3971512 Bytes &#x3D; 3.8 MiB</span><br><span class=\"line\">   Load Address: 60003000</span><br><span class=\"line\">   Entry Point:  60003000</span><br><span class=\"line\">   Verifying Checksum ... OK</span><br><span class=\"line\">## Flattened Device Tree blob at 60500000</span><br><span class=\"line\">   Booting using the fdt blob at 0x60500000</span><br><span class=\"line\">   Loading Kernel Image</span><br><span class=\"line\">   Loading Device Tree to 7fe81000, end 7fe87963 ... OK</span><br><span class=\"line\"></span><br><span class=\"line\">Starting kernel ...</span><br><span class=\"line\"></span><br><span class=\"line\">Booting Linux on physical CPU 0x0</span><br><span class=\"line\">Linux version 4.14.172 (xiami@xiami) (gcc version 7.5.0 (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04)) #1 SMP Sun Mar 15 12:27:54 CST 2020</span><br><span class=\"line\">CPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr&#x3D;10c5387d</span><br><span class=\"line\">CPU: PIPT &#x2F; VIPT nonaliasing data cache, VIPT nonaliasing instruction cache</span><br><span class=\"line\">OF: fdt: Machine model: V2P-CA9</span><br><span class=\"line\">Memory policy: Data cache writeback</span><br><span class=\"line\">CPU: All CPU(s) started in SVC mode.</span><br><span class=\"line\">percpu: Embedded 15 pages&#x2F;cpu s32396 r8192 d20852 u61440</span><br><span class=\"line\">Built 1 zonelists, mobility grouping on.  Total pages: 130048</span><br><span class=\"line\">Kernel command line: root&#x3D;&#x2F;dev&#x2F;mmcblk0 rw       init&#x3D;&#x2F;linuxrc       ip&#x3D;192.168.1.110 console&#x3D;ttyAMA0</span><br><span class=\"line\">log_buf_len individual max cpu contribution: 4096 bytes</span><br><span class=\"line\">log_buf_len total cpu_extra contributions: 12288 bytes</span><br><span class=\"line\">log_buf_len min size: 16384 bytes</span><br><span class=\"line\">log_buf_len: 32768 bytes</span><br><span class=\"line\">early log buf free: 14980(91%)</span><br><span class=\"line\">PID hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class=\"line\">Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)</span><br><span class=\"line\">Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)</span><br><span class=\"line\">Memory: 509616K&#x2F;524288K available (6144K kernel code, 403K rwdata, 1372K rodata, 1024K init, 161K bss, 14672K reserved, 0K cma-reserved)</span><br><span class=\"line\">Virtual kernel memory layout:</span><br><span class=\"line\">    vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class=\"line\">    fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class=\"line\">    vmalloc : 0xa0800000 - 0xff800000   (1520 MB)</span><br><span class=\"line\">    lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)</span><br><span class=\"line\">    modules : 0x7f000000 - 0x80000000   (  16 MB)</span><br><span class=\"line\">      .text : 0x80008000 - 0x80700000   (7136 kB)</span><br><span class=\"line\">      .init : 0x80900000 - 0x80a00000   (1024 kB)</span><br><span class=\"line\">      .data : 0x80a00000 - 0x80a64f90   ( 404 kB)</span><br><span class=\"line\">       .bss : 0x80a6bd00 - 0x80a94468   ( 162 kB)</span><br><span class=\"line\">SLUB: HWalign&#x3D;64, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;4, Nodes&#x3D;1</span><br><span class=\"line\">Hierarchical RCU implementation.</span><br><span class=\"line\">\tRCU event tracing is enabled.</span><br><span class=\"line\">\tRCU restricting CPUs from NR_CPUS&#x3D;8 to nr_cpu_ids&#x3D;4.</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">IP-Config: Guessing netmask 255.255.255.0</span><br><span class=\"line\">IP-Config: Complete:</span><br><span class=\"line\">     device&#x3D;eth0, hwaddr&#x3D;52:54:00:12:34:56, ipaddr&#x3D;192.168.1.110, mask&#x3D;255.255.255.0, gw&#x3D;255.255.255.255</span><br><span class=\"line\">     host&#x3D;192.168.1.110, domain&#x3D;, nis-domain&#x3D;(none)</span><br><span class=\"line\">     bootserver&#x3D;255.255.255.255, rootserver&#x3D;255.255.255.255, rootpath&#x3D;</span><br><span class=\"line\">ALSA device list:</span><br><span class=\"line\">  #0: ARM AC&#39;97 Interface PL041 rev0 at 0x10004000, irq 30</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounting ext3 file system using the ext4 subsystem</span><br><span class=\"line\">random: fast init done</span><br><span class=\"line\">EXT4-fs (mmcblk0): recovery complete</span><br><span class=\"line\">EXT4-fs (mmcblk0): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class=\"line\">VFS: Mounted root (ext3 filesystem) on device 179:0.</span><br><span class=\"line\">Freeing unused kernel memory: 1024K</span><br><span class=\"line\">random: crng init done</span><br><span class=\"line\">Hello Linux Qemu!</span><br><span class=\"line\"></span><br><span class=\"line\">Please press Enter to activate this console. </span><br><span class=\"line\">&#x2F; #</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; reset</span><br><span class=\"line\">resetting ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot 2017.05 (Jul 24 2019 - 21:52:28 +0800)</span><br><span class=\"line\"></span><br><span class=\"line\">DRAM:  512 MiB</span><br><span class=\"line\">WARNING: Caches not enabled</span><br><span class=\"line\">Flash: 128 MiB</span><br><span class=\"line\">MMC:   MMC: 0</span><br><span class=\"line\">*** Warning - bad CRC, using default environment</span><br><span class=\"line\"></span><br><span class=\"line\">In:    serial</span><br><span class=\"line\">Out:   serial</span><br><span class=\"line\">Err:   serial</span><br><span class=\"line\">Net:   smc911x-0</span><br><span class=\"line\">Hit any key to stop autoboot:  0 </span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.104; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;uImage&#39;.</span><br><span class=\"line\">Load address: 0x60003000</span><br><span class=\"line\">Loading: #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t ##################################################</span><br><span class=\"line\">\t 1.3 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 3581920 (36a7e0 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.104; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;vexpress-v2p-ca9.dtb&#39;.</span><br><span class=\"line\">Load address: 0x60500000</span><br><span class=\"line\">Loading: #</span><br><span class=\"line\">\t 250 KiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 14360 (3818 hex)</span><br><span class=\"line\">smc911x: MAC 52:54:00:12:34:56</span><br><span class=\"line\">## Booting kernel from Legacy Image at 60003000 ...</span><br><span class=\"line\">   Image Name:   Linux-4.4.157</span><br><span class=\"line\">   Image Type:   ARM Linux Kernel Image (uncompressed)</span><br><span class=\"line\">   Data Size:    3581856 Bytes &#x3D; 3.4 MiB</span><br><span class=\"line\">   Load Address: 60003000</span><br><span class=\"line\">   Entry Point:  60003000</span><br><span class=\"line\">   Verifying Checksum ... OK</span><br><span class=\"line\">## Flattened Device Tree blob at 60500000</span><br><span class=\"line\">   Booting using the fdt blob at 0x60500000</span><br><span class=\"line\">   Loading Kernel Image ... OK</span><br><span class=\"line\">   Loading Device Tree to 7fed4000, end 7feda817 ... OK</span><br></pre></td></tr></table></figure>\n\n<p>至此，通过u-boot加载kernel，并挂载SD卡文件系统已经成功；</p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><p>SD卡中rootfs目录是一个简易的根文件系统，可以将它制作成一个镜像文件，将镜像文件烧写到开发板，或者通过Qemu中的u-boot启动Linux内核后挂载到镜像文件上。也可以设置为通过NFS网络文件系统启动，参考下一篇文章《<a href=\"https://www.jianshu.com/p/cf46f7225db6\" target=\"_blank\" rel=\"noopener\">Qemu搭建ARM vexpress开发环境(三)—-NFS网络根文件系统</a>》。</p>"},{"title":"Ubuntu+Hexo+Github搭建个人博客","date":"2019-07-28T15:26:48.000Z","_content":"\n\n\n### 1. 简介\n\n以前部署的Hexo博客是在Windows上搭建的，在Windows系统使用很方便，碰到一些问题也都能够解决；现在安装了Ubuntu-18.04.1系统，需要重新使用Hexo搭建博客；为了兼容以前的windows博客，还需要将以前Windows系统的博客迁移到Ubuntu系统下使用；\n\n<!--more-->\n\n\n\n#### 环境\n\n```shell\n# uname -a\nLinux xiami 5.3.0-40-generic #32~18.04.1-Ubuntu SMP Mon Feb 3 14:05:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n\n\n搭建博客需要安装的软件：\n\n> git\n> node.js\n> hexo\n\n\n\n### 2. Git安装及配置\n\n#### 2.1 安装Git\n\n使用命令安装Git工具：\n\n```shell\n# sudo apt install git\n```\n\n查看是否安张成功：\n\n```shell\n# git --version\ngit version 2.17.1\n```\n\n\n\n#### 2.2 创建Git仓库\n\n打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“\nInitialize this repository with a README”；\n\n进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\n\n![Image](Ubuntu-Hexo-Github搭建个人博客/Image.png)\n\n![Image2](Ubuntu-Hexo-Github搭建个人博客/Image2.png)\n\n\n\n#### 2.3 配置git仓库\n\n如果是第一次使用git，就需要先配置git环境，否则可以跳过；\n\n```shell\n# git config --global user.name \"Mshrimp\"\n# git config --global user.email \"******@outlook.com\"\n```\n\n在没有配置git环境之前，~/.ssh是不存在的\n\n```shell\n# cd ~/.ssh\nbash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory\n```\n\n使用ssh-keygen生成私钥和公钥\n\n```shell\n# ssh-keygen -t rsa -C \"chiyuan.ma@outlook.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):\nCreated directory '/c/Users/Kevin-TP/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com\nThe key's randomart image is:\n+---[RSA 3072]----+\n|                 |\n|               . |\n|      . + +   +  |\n|     o B * + * + |\n|      B S + * X  |\n|     . X = * = o |\n|      . B + + o E|\n|      .+ o = o . |\n|     .o...= .    |\n+----[SHA256]-----+\n```\n\n从以上的操作打印可以知道，生成的密钥和公钥的保存路径\n\n```shell\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\n```\n\n查看生成的密钥和公钥\n\n```shell\n# cd ~/.ssh\n# ls\nid_rsa  id_rsa.pub\n# cat id_rsa.pub\nssh-rsa \n......\n```\n\n\n\n#### 2.4 添加公钥\n\n把本地公钥添加到github中；在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；\n\n![Image4](Ubuntu-Hexo-Github搭建个人博客/Image4.png)\n\n![Image5](Ubuntu-Hexo-Github搭建个人博客/Image5.png)\n\n\n\n使用“ssh -T git@github.com”命令，测试添加ssh是否成功；\n\n```shell\n# ssh -T git@github.com\n......\nHi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n\n\n### 3. Node安装\n\n命令行安装：\n\n```shell\n# sudo apt-get install nodejs\n# sudo apt install npm\n```\n\n查看nodejs工具是否安装成功：\n\n```shell\n# nodejs -v\nv8.10.0\n```\n\n\n\n### 4. Hexo安装及配置\n\n先创建一个hexo操作的文件目录\n\n![Image1](Ubuntu-Hexo-Github搭建个人博客/Image1.png)\n\n如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；\n\n#### 4.1 安装hexo\n\n```shell\n# npm install hexo-cli -g\n# npm install hexo -g\n```\n\n\n\n检查hexo是否安装成功\n\n```shell\n# hexo -v\nhexo: 4.2.0\nhexo-cli: 3.1.0\nos: Linux 5.3.0-45-generic linux x64\nhttp_parser: 2.7.1\nnode: 8.10.0\nv8: 6.2.414.50\nuv: 1.18.0\nzlib: 1.2.11\nares: 1.14.0\nmodules: 57\nnghttp2: 1.30.0\nopenssl: 1.0.2n\nicu: 60.2\nunicode: 10.0\ncldr: 32.0.1\ntz: 2017c\n```\n\n#### 4.2 初始化hexo文件夹\n\n```shell\n# hexo init\n```\n\n看到“Start blogging with Hexo！”打印，说明初始化完成；\n\n输入npm install，安装所需要的组件\n\n```shell\n# npm install\n```\n\nhexo已经安装并初始化完成；\n\n```shell\n# ls\n_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/\n```\n\n到此，hexo环境安装完成。\n\n#### 4.3 Hexo操作\n\n```shell\n# hexo g #generate 生成静态文件\n# hexo s #server 启动服务器。\n// 默认情况下，访问网址为： [http://localhost:4000/]\n```\n\n在浏览器地址栏输入“http://localhost:4000/”打开页面，是一个空的博客网页；\n\n![Image3](Ubuntu-Hexo-Github搭建个人博客/Image3.JPG)\n\n\n\n#### 4.4 将git库和hexo链接起来\n\n\n\n配置Deployment\n\n在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；\n\n```shell\ndeploy:\n  type: git\n  repository: git@github.com:Mshrimp/Mshrimp.github.io.git\n  branch: master\n```\n\n\nHexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；\n\n```shell\n# npm install hexo-deployer-git --save\n\nnpm WARN babel-eslint@10.1.0 requires a peer of eslint@>= 4.12.1 but none is \ninstalled. You must install peer dependencies yourself.\n\n+ hexo-deployer-git@1.0.0\nadded 1 package from 1 contributor, removed 4 packages and updated 14 packages in \n5.684s\n```\n\n修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；\n\n```shell\n# hexo deploy\n```\n\n\n至此，一个空的博客已经搭建完成，下一步，添加博客文章；\n\n\n\n### 5. 更换主题\n\n由于不太喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先从Github中将yilia主题的源码下载到博客目录的themes目录下（感谢yilia主题作者的无私奉献）；\n\n```powershell\n# git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n在博客根目录下，修改_config.yml文件的themes：\n\n```shell\nthemes: yilia\n```\n\n这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；\n\n效果如下：\n\n![themes-yilia](Ubuntu-Hexo-Github搭建个人博客/themes-yilia.png)\n\n\n\n其他好用的主题：\n\n```shell\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n\n\n### 6. 博客迁移\n\n#### 6.1 常规迁移\n\n以前部署的Hexo博客是在Windows上搭建的，现在安装了Ubuntu-18.04.1，需要重新搭建博客；为了兼容以前的windows博客，需要使用以前的Hexo下的几个文件夹：\n\n```shell\n_config.yml  package.json  source/  themes/\n```\n\n这时，在Ubuntu系统上创建文件夹hexo，以hexo为主目录搭建博客环境：\n\n```shell\n# mkdir hexo\n# cd hexo\n# hexo init\n```\n\n将上边四个文件或文件夹复制到hexo目录替换：\n\n```shell\n# cp _config.yml  package.json  source  themes . -rf\n```\n\n之后就可以按照hexo命令进行操作了；\n\n\n\n#### 6.2 特殊情况\n\n由于我的实际情况是，不但将hexo中的博客文件保存在了Github上，还将hexo生成的环境工程，以并保存在Github同一个工程的其他分支了，如：ubuntu分支；这样我就可以一并保存所有文件了；\n\n在这种特殊情况下，博客迁移操作原理上和常规迁移一样，只是操作稍微不同；\n\n将以前用的工程在Ubuntu环境中克隆下来，Mshrimp.github.io；\n\n新建hexo目录，并初始化hexo目录：\n\n```shell\n# mkdir hexo\n# cd hexo\n# hexo init\n# ls\n_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/\n```\n\n将hexo中生成的文件或文件夹复制到Mshrimp.github.io目录替换：\n\n```shell\nnode_modules/  package-lock.json  scaffolds/\n```\n\n这个操作，和常规迁移的区别是，复制的方向相反，其余都一样；\n\n","source":"_posts/Ubuntu-Hexo-Github搭建个人博客.md","raw":"---\ntitle: Ubuntu+Hexo+Github搭建个人博客\ndate: 2019-07-28 23:26:48\ntags: Hexo\n---\n\n\n\n### 1. 简介\n\n以前部署的Hexo博客是在Windows上搭建的，在Windows系统使用很方便，碰到一些问题也都能够解决；现在安装了Ubuntu-18.04.1系统，需要重新使用Hexo搭建博客；为了兼容以前的windows博客，还需要将以前Windows系统的博客迁移到Ubuntu系统下使用；\n\n<!--more-->\n\n\n\n#### 环境\n\n```shell\n# uname -a\nLinux xiami 5.3.0-40-generic #32~18.04.1-Ubuntu SMP Mon Feb 3 14:05:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n\n\n搭建博客需要安装的软件：\n\n> git\n> node.js\n> hexo\n\n\n\n### 2. Git安装及配置\n\n#### 2.1 安装Git\n\n使用命令安装Git工具：\n\n```shell\n# sudo apt install git\n```\n\n查看是否安张成功：\n\n```shell\n# git --version\ngit version 2.17.1\n```\n\n\n\n#### 2.2 创建Git仓库\n\n打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“\nInitialize this repository with a README”；\n\n进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\n\n![Image](Ubuntu-Hexo-Github搭建个人博客/Image.png)\n\n![Image2](Ubuntu-Hexo-Github搭建个人博客/Image2.png)\n\n\n\n#### 2.3 配置git仓库\n\n如果是第一次使用git，就需要先配置git环境，否则可以跳过；\n\n```shell\n# git config --global user.name \"Mshrimp\"\n# git config --global user.email \"******@outlook.com\"\n```\n\n在没有配置git环境之前，~/.ssh是不存在的\n\n```shell\n# cd ~/.ssh\nbash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory\n```\n\n使用ssh-keygen生成私钥和公钥\n\n```shell\n# ssh-keygen -t rsa -C \"chiyuan.ma@outlook.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):\nCreated directory '/c/Users/Kevin-TP/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com\nThe key's randomart image is:\n+---[RSA 3072]----+\n|                 |\n|               . |\n|      . + +   +  |\n|     o B * + * + |\n|      B S + * X  |\n|     . X = * = o |\n|      . B + + o E|\n|      .+ o = o . |\n|     .o...= .    |\n+----[SHA256]-----+\n```\n\n从以上的操作打印可以知道，生成的密钥和公钥的保存路径\n\n```shell\nYour identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.\nYour public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.\n```\n\n查看生成的密钥和公钥\n\n```shell\n# cd ~/.ssh\n# ls\nid_rsa  id_rsa.pub\n# cat id_rsa.pub\nssh-rsa \n......\n```\n\n\n\n#### 2.4 添加公钥\n\n把本地公钥添加到github中；在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；\n\n![Image4](Ubuntu-Hexo-Github搭建个人博客/Image4.png)\n\n![Image5](Ubuntu-Hexo-Github搭建个人博客/Image5.png)\n\n\n\n使用“ssh -T git@github.com”命令，测试添加ssh是否成功；\n\n```shell\n# ssh -T git@github.com\n......\nHi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n\n\n### 3. Node安装\n\n命令行安装：\n\n```shell\n# sudo apt-get install nodejs\n# sudo apt install npm\n```\n\n查看nodejs工具是否安装成功：\n\n```shell\n# nodejs -v\nv8.10.0\n```\n\n\n\n### 4. Hexo安装及配置\n\n先创建一个hexo操作的文件目录\n\n![Image1](Ubuntu-Hexo-Github搭建个人博客/Image1.png)\n\n如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；\n\n#### 4.1 安装hexo\n\n```shell\n# npm install hexo-cli -g\n# npm install hexo -g\n```\n\n\n\n检查hexo是否安装成功\n\n```shell\n# hexo -v\nhexo: 4.2.0\nhexo-cli: 3.1.0\nos: Linux 5.3.0-45-generic linux x64\nhttp_parser: 2.7.1\nnode: 8.10.0\nv8: 6.2.414.50\nuv: 1.18.0\nzlib: 1.2.11\nares: 1.14.0\nmodules: 57\nnghttp2: 1.30.0\nopenssl: 1.0.2n\nicu: 60.2\nunicode: 10.0\ncldr: 32.0.1\ntz: 2017c\n```\n\n#### 4.2 初始化hexo文件夹\n\n```shell\n# hexo init\n```\n\n看到“Start blogging with Hexo！”打印，说明初始化完成；\n\n输入npm install，安装所需要的组件\n\n```shell\n# npm install\n```\n\nhexo已经安装并初始化完成；\n\n```shell\n# ls\n_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/\n```\n\n到此，hexo环境安装完成。\n\n#### 4.3 Hexo操作\n\n```shell\n# hexo g #generate 生成静态文件\n# hexo s #server 启动服务器。\n// 默认情况下，访问网址为： [http://localhost:4000/]\n```\n\n在浏览器地址栏输入“http://localhost:4000/”打开页面，是一个空的博客网页；\n\n![Image3](Ubuntu-Hexo-Github搭建个人博客/Image3.JPG)\n\n\n\n#### 4.4 将git库和hexo链接起来\n\n\n\n配置Deployment\n\n在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；\n\n```shell\ndeploy:\n  type: git\n  repository: git@github.com:Mshrimp/Mshrimp.github.io.git\n  branch: master\n```\n\n\nHexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；\n\n```shell\n# npm install hexo-deployer-git --save\n\nnpm WARN babel-eslint@10.1.0 requires a peer of eslint@>= 4.12.1 but none is \ninstalled. You must install peer dependencies yourself.\n\n+ hexo-deployer-git@1.0.0\nadded 1 package from 1 contributor, removed 4 packages and updated 14 packages in \n5.684s\n```\n\n修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；\n\n```shell\n# hexo deploy\n```\n\n\n至此，一个空的博客已经搭建完成，下一步，添加博客文章；\n\n\n\n### 5. 更换主题\n\n由于不太喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先从Github中将yilia主题的源码下载到博客目录的themes目录下（感谢yilia主题作者的无私奉献）；\n\n```powershell\n# git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n在博客根目录下，修改_config.yml文件的themes：\n\n```shell\nthemes: yilia\n```\n\n这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；\n\n效果如下：\n\n![themes-yilia](Ubuntu-Hexo-Github搭建个人博客/themes-yilia.png)\n\n\n\n其他好用的主题：\n\n```shell\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n\n\n### 6. 博客迁移\n\n#### 6.1 常规迁移\n\n以前部署的Hexo博客是在Windows上搭建的，现在安装了Ubuntu-18.04.1，需要重新搭建博客；为了兼容以前的windows博客，需要使用以前的Hexo下的几个文件夹：\n\n```shell\n_config.yml  package.json  source/  themes/\n```\n\n这时，在Ubuntu系统上创建文件夹hexo，以hexo为主目录搭建博客环境：\n\n```shell\n# mkdir hexo\n# cd hexo\n# hexo init\n```\n\n将上边四个文件或文件夹复制到hexo目录替换：\n\n```shell\n# cp _config.yml  package.json  source  themes . -rf\n```\n\n之后就可以按照hexo命令进行操作了；\n\n\n\n#### 6.2 特殊情况\n\n由于我的实际情况是，不但将hexo中的博客文件保存在了Github上，还将hexo生成的环境工程，以并保存在Github同一个工程的其他分支了，如：ubuntu分支；这样我就可以一并保存所有文件了；\n\n在这种特殊情况下，博客迁移操作原理上和常规迁移一样，只是操作稍微不同；\n\n将以前用的工程在Ubuntu环境中克隆下来，Mshrimp.github.io；\n\n新建hexo目录，并初始化hexo目录：\n\n```shell\n# mkdir hexo\n# cd hexo\n# hexo init\n# ls\n_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/\n```\n\n将hexo中生成的文件或文件夹复制到Mshrimp.github.io目录替换：\n\n```shell\nnode_modules/  package-lock.json  scaffolds/\n```\n\n这个操作，和常规迁移的区别是，复制的方向相反，其余都一样；\n\n","slug":"Ubuntu-Hexo-Github搭建个人博客","published":1,"updated":"2020-05-06T14:32:52.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv4000jdqg15jj06p3p","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>以前部署的Hexo博客是在Windows上搭建的，在Windows系统使用很方便，碰到一些问题也都能够解决；现在安装了Ubuntu-18.04.1系统，需要重新使用Hexo搭建博客；为了兼容以前的windows博客，还需要将以前Windows系统的博客迁移到Ubuntu系统下使用；</p>\n<a id=\"more\"></a>\n\n\n\n<h4 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uname -a</span></span><br><span class=\"line\">Linux xiami 5.3.0-40-generic #32~18.04.1-Ubuntu SMP Mon Feb 3 14:05:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>\n\n\n\n<p>搭建博客需要安装的软件：</p>\n<blockquote>\n<p>git<br>node.js<br>hexo</p>\n</blockquote>\n<h3 id=\"2-Git安装及配置\"><a href=\"#2-Git安装及配置\" class=\"headerlink\" title=\"2. Git安装及配置\"></a>2. Git安装及配置</h3><h4 id=\"2-1-安装Git\"><a href=\"#2-1-安装Git\" class=\"headerlink\" title=\"2.1 安装Git\"></a>2.1 安装Git</h4><p>使用命令安装Git工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install git</span></span><br></pre></td></tr></table></figure>\n\n<p>查看是否安张成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git --version</span></span><br><span class=\"line\">git version 2.17.1</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-创建Git仓库\"><a href=\"#2-2-创建Git仓库\" class=\"headerlink\" title=\"2.2 创建Git仓库\"></a>2.2 创建Git仓库</h4><p>打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“<br>Initialize this repository with a README”；</p>\n<p>进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：<a href=\"https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\">https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。</a></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image.png\" alt=\"Image\"></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image2.png\" alt=\"Image2\"></p>\n<h4 id=\"2-3-配置git仓库\"><a href=\"#2-3-配置git仓库\" class=\"headerlink\" title=\"2.3 配置git仓库\"></a>2.3 配置git仓库</h4><p>如果是第一次使用git，就需要先配置git环境，否则可以跳过；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.name <span class=\"string\">\"Mshrimp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.email <span class=\"string\">\"******@outlook.com\"</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在没有配置git环境之前，~/.ssh是不存在的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\">bash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory</span><br></pre></td></tr></table></figure>\n\n<p>使用ssh-keygen生成私钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh-keygen -t rsa -C <span class=\"string\">\"chiyuan.ma@outlook.com\"</span></span></span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):</span><br><span class=\"line\">Created directory '/c/Users/Kevin-TP/.ssh'.</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\">Your identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com</span><br><span class=\"line\">The key's randomart image is:</span><br><span class=\"line\">+---[RSA 3072]----+</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">|               . |</span><br><span class=\"line\">|      . + +   +  |</span><br><span class=\"line\">|     o B * + * + |</span><br><span class=\"line\">|      B S + * X  |</span><br><span class=\"line\">|     . X = * = o |</span><br><span class=\"line\">|      . B + + o E|</span><br><span class=\"line\">|      .+ o = o . |</span><br><span class=\"line\">|     .o...= .    |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>\n\n<p>从以上的操作打印可以知道，生成的密钥和公钥的保存路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure>\n\n<p>查看生成的密钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">id_rsa  id_rsa.pub</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat id_rsa.pub</span></span><br><span class=\"line\">ssh-rsa </span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-4-添加公钥\"><a href=\"#2-4-添加公钥\" class=\"headerlink\" title=\"2.4 添加公钥\"></a>2.4 添加公钥</h4><p>把本地公钥添加到github中；在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；</p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image4.png\" alt=\"Image4\"></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image5.png\" alt=\"Image5\"></p>\n<p>使用“ssh -T <a href=\"mailto:git@github.com\">git@github.com</a>”命令，测试添加ssh是否成功；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh -T git@github.com</span></span><br><span class=\"line\">......</span><br><span class=\"line\">Hi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-Node安装\"><a href=\"#3-Node安装\" class=\"headerlink\" title=\"3. Node安装\"></a>3. Node安装</h3><p>命令行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install nodejs</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install npm</span></span><br></pre></td></tr></table></figure>\n\n<p>查看nodejs工具是否安装成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nodejs -v</span></span><br><span class=\"line\">v8.10.0</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-Hexo安装及配置\"><a href=\"#4-Hexo安装及配置\" class=\"headerlink\" title=\"4. Hexo安装及配置\"></a>4. Hexo安装及配置</h3><p>先创建一个hexo操作的文件目录</p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image1.png\" alt=\"Image1\"></p>\n<p>如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；</p>\n<h4 id=\"4-1-安装hexo\"><a href=\"#4-1-安装hexo\" class=\"headerlink\" title=\"4.1 安装hexo\"></a>4.1 安装hexo</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo-cli -g</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo -g</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>检查hexo是否安装成功</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo -v</span></span><br><span class=\"line\">hexo: 4.2.0</span><br><span class=\"line\">hexo-cli: 3.1.0</span><br><span class=\"line\">os: Linux 5.3.0-45-generic linux x64</span><br><span class=\"line\">http_parser: 2.7.1</span><br><span class=\"line\">node: 8.10.0</span><br><span class=\"line\">v8: 6.2.414.50</span><br><span class=\"line\">uv: 1.18.0</span><br><span class=\"line\">zlib: 1.2.11</span><br><span class=\"line\">ares: 1.14.0</span><br><span class=\"line\">modules: 57</span><br><span class=\"line\">nghttp2: 1.30.0</span><br><span class=\"line\">openssl: 1.0.2n</span><br><span class=\"line\">icu: 60.2</span><br><span class=\"line\">unicode: 10.0</span><br><span class=\"line\">cldr: 32.0.1</span><br><span class=\"line\">tz: 2017c</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-初始化hexo文件夹\"><a href=\"#4-2-初始化hexo文件夹\" class=\"headerlink\" title=\"4.2 初始化hexo文件夹\"></a>4.2 初始化hexo文件夹</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br></pre></td></tr></table></figure>\n\n<p>看到“Start blogging with Hexo！”打印，说明初始化完成；</p>\n<p>输入npm install，安装所需要的组件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n\n<p>hexo已经安装并初始化完成；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>到此，hexo环境安装完成。</p>\n<h4 id=\"4-3-Hexo操作\"><a href=\"#4-3-Hexo操作\" class=\"headerlink\" title=\"4.3 Hexo操作\"></a>4.3 Hexo操作</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g <span class=\"comment\">#generate 生成静态文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo s <span class=\"comment\">#server 启动服务器。</span></span></span><br><span class=\"line\">// 默认情况下，访问网址为： [http://localhost:4000/]</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器地址栏输入“<a href=\"http://localhost:4000/”打开页面，是一个空的博客网页；\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/”打开页面，是一个空的博客网页；</a></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image3.JPG\" alt=\"Image3\"></p>\n<h4 id=\"4-4-将git库和hexo链接起来\"><a href=\"#4-4-将git库和hexo链接起来\" class=\"headerlink\" title=\"4.4 将git库和hexo链接起来\"></a>4.4 将git库和hexo链接起来</h4><p>配置Deployment</p>\n<p>在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Mshrimp/Mshrimp.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n<p>HexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo-deployer-git --save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN babel-eslint@10.1.0 requires a peer of eslint@&gt;= 4.12.1 but none is </span><br><span class=\"line\">installed. You must install peer dependencies yourself.</span><br><span class=\"line\"></span><br><span class=\"line\">+ hexo-deployer-git@1.0.0</span><br><span class=\"line\">added 1 package from 1 contributor, removed 4 packages and updated 14 packages in </span><br><span class=\"line\">5.684s</span><br></pre></td></tr></table></figure>\n\n<p>修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo deploy</span></span><br></pre></td></tr></table></figure>\n\n\n<p>至此，一个空的博客已经搭建完成，下一步，添加博客文章；</p>\n<h3 id=\"5-更换主题\"><a href=\"#5-更换主题\" class=\"headerlink\" title=\"5. 更换主题\"></a>5. 更换主题</h3><p>由于不太喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先从Github中将yilia主题的源码下载到博客目录的themes目录下（感谢yilia主题作者的无私奉献）；</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure>\n\n<p>在博客根目录下，修改_config.yml文件的themes：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">themes: yilia</span><br></pre></td></tr></table></figure>\n\n<p>这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；</p>\n<p>效果如下：</p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/themes-yilia.png\" alt=\"themes-yilia\"></p>\n<p>其他好用的主题：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-博客迁移\"><a href=\"#6-博客迁移\" class=\"headerlink\" title=\"6. 博客迁移\"></a>6. 博客迁移</h3><h4 id=\"6-1-常规迁移\"><a href=\"#6-1-常规迁移\" class=\"headerlink\" title=\"6.1 常规迁移\"></a>6.1 常规迁移</h4><p>以前部署的Hexo博客是在Windows上搭建的，现在安装了Ubuntu-18.04.1，需要重新搭建博客；为了兼容以前的windows博客，需要使用以前的Hexo下的几个文件夹：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml  package.json  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>这时，在Ubuntu系统上创建文件夹hexo，以hexo为主目录搭建博客环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br></pre></td></tr></table></figure>\n\n<p>将上边四个文件或文件夹复制到hexo目录替换：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp _config.yml  package.json  <span class=\"built_in\">source</span>  themes . -rf</span></span><br></pre></td></tr></table></figure>\n\n<p>之后就可以按照hexo命令进行操作了；</p>\n<h4 id=\"6-2-特殊情况\"><a href=\"#6-2-特殊情况\" class=\"headerlink\" title=\"6.2 特殊情况\"></a>6.2 特殊情况</h4><p>由于我的实际情况是，不但将hexo中的博客文件保存在了Github上，还将hexo生成的环境工程，以并保存在Github同一个工程的其他分支了，如：ubuntu分支；这样我就可以一并保存所有文件了；</p>\n<p>在这种特殊情况下，博客迁移操作原理上和常规迁移一样，只是操作稍微不同；</p>\n<p>将以前用的工程在Ubuntu环境中克隆下来，Mshrimp.github.io；</p>\n<p>新建hexo目录，并初始化hexo目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>将hexo中生成的文件或文件夹复制到Mshrimp.github.io目录替换：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_modules/  package-lock.json  scaffolds/</span><br></pre></td></tr></table></figure>\n\n<p>这个操作，和常规迁移的区别是，复制的方向相反，其余都一样；</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>以前部署的Hexo博客是在Windows上搭建的，在Windows系统使用很方便，碰到一些问题也都能够解决；现在安装了Ubuntu-18.04.1系统，需要重新使用Hexo搭建博客；为了兼容以前的windows博客，还需要将以前Windows系统的博客迁移到Ubuntu系统下使用；</p>","more":"<h4 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uname -a</span></span><br><span class=\"line\">Linux xiami 5.3.0-40-generic #32~18.04.1-Ubuntu SMP Mon Feb 3 14:05:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>\n\n\n\n<p>搭建博客需要安装的软件：</p>\n<blockquote>\n<p>git<br>node.js<br>hexo</p>\n</blockquote>\n<h3 id=\"2-Git安装及配置\"><a href=\"#2-Git安装及配置\" class=\"headerlink\" title=\"2. Git安装及配置\"></a>2. Git安装及配置</h3><h4 id=\"2-1-安装Git\"><a href=\"#2-1-安装Git\" class=\"headerlink\" title=\"2.1 安装Git\"></a>2.1 安装Git</h4><p>使用命令安装Git工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install git</span></span><br></pre></td></tr></table></figure>\n\n<p>查看是否安张成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git --version</span></span><br><span class=\"line\">git version 2.17.1</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-创建Git仓库\"><a href=\"#2-2-创建Git仓库\" class=\"headerlink\" title=\"2.2 创建Git仓库\"></a>2.2 创建Git仓库</h4><p>打开GitHub，点击“New repository”，创建一个新仓库，用来专门存放博客日志信息；仓库名要按照格式：账户名.github.io，比如：Mshrimp.github.io；否则，后边的操作会出现问题；创建仓库时勾选上“<br>Initialize this repository with a README”；</p>\n<p>进入创建好的仓库Mshrimp.github.io，点击右侧的“Settings”，向下拉找到Github Pages，会看到网站是：<a href=\"https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。\">https://mshrimp.github.io/，点击就可以访问，也可以通过外网访问，这时这个博客项目已经部署到网站上了，但是是个空的网站，没有内容；这个网址是博客的默认地址，如果有兴趣可以自己购买域名换成想要的地址。</a></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image.png\" alt=\"Image\"></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image2.png\" alt=\"Image2\"></p>\n<h4 id=\"2-3-配置git仓库\"><a href=\"#2-3-配置git仓库\" class=\"headerlink\" title=\"2.3 配置git仓库\"></a>2.3 配置git仓库</h4><p>如果是第一次使用git，就需要先配置git环境，否则可以跳过；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.name <span class=\"string\">\"Mshrimp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git config --global user.email <span class=\"string\">\"******@outlook.com\"</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在没有配置git环境之前，~/.ssh是不存在的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\">bash: cd: /c/Users/Kevin-TP/.ssh: No such file or directory</span><br></pre></td></tr></table></figure>\n\n<p>使用ssh-keygen生成私钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh-keygen -t rsa -C <span class=\"string\">\"chiyuan.ma@outlook.com\"</span></span></span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/c/Users/Kevin-TP/.ssh/id_rsa):</span><br><span class=\"line\">Created directory '/c/Users/Kevin-TP/.ssh'.</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\">Your identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:pHNkvs9RsOToxmFH6gnkOb7j/dlRSc4c6TkOvGQ6fcc chiyuan.ma@outlook.com</span><br><span class=\"line\">The key's randomart image is:</span><br><span class=\"line\">+---[RSA 3072]----+</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">|               . |</span><br><span class=\"line\">|      . + +   +  |</span><br><span class=\"line\">|     o B * + * + |</span><br><span class=\"line\">|      B S + * X  |</span><br><span class=\"line\">|     . X = * = o |</span><br><span class=\"line\">|      . B + + o E|</span><br><span class=\"line\">|      .+ o = o . |</span><br><span class=\"line\">|     .o...= .    |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>\n\n<p>从以上的操作打印可以知道，生成的密钥和公钥的保存路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your identification has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /c/Users/Kevin-TP/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure>\n\n<p>查看生成的密钥和公钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~/.ssh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">id_rsa  id_rsa.pub</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat id_rsa.pub</span></span><br><span class=\"line\">ssh-rsa </span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-4-添加公钥\"><a href=\"#2-4-添加公钥\" class=\"headerlink\" title=\"2.4 添加公钥\"></a>2.4 添加公钥</h4><p>把本地公钥添加到github中；在GitHub中，点击右侧图像下拉选项，选择“Settings”，在“SSH and GPG keys”中，点击“New SSH key”，并将~/.ssh/id_rsa.pub文件里的内容复制上去，保存退出；</p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image4.png\" alt=\"Image4\"></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image5.png\" alt=\"Image5\"></p>\n<p>使用“ssh -T <a href=\"mailto:git@github.com\">git@github.com</a>”命令，测试添加ssh是否成功；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh -T git@github.com</span></span><br><span class=\"line\">......</span><br><span class=\"line\">Hi Mshrimp! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-Node安装\"><a href=\"#3-Node安装\" class=\"headerlink\" title=\"3. Node安装\"></a>3. Node安装</h3><p>命令行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt-get install nodejs</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo apt install npm</span></span><br></pre></td></tr></table></figure>\n\n<p>查看nodejs工具是否安装成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nodejs -v</span></span><br><span class=\"line\">v8.10.0</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-Hexo安装及配置\"><a href=\"#4-Hexo安装及配置\" class=\"headerlink\" title=\"4. Hexo安装及配置\"></a>4. Hexo安装及配置</h3><p>先创建一个hexo操作的文件目录</p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image1.png\" alt=\"Image1\"></p>\n<p>如果使用的是Linux系统，可以直接在命令行中输入命令操作，如果是windows系统，用管理员权限打开“命令提示符”，使用命令在电脑上安装hexo；或者，在hexo目录上右键，选择“Git Bash Here”，用git bash工具打开hexo目录，在git bash中使用命令操作；</p>\n<h4 id=\"4-1-安装hexo\"><a href=\"#4-1-安装hexo\" class=\"headerlink\" title=\"4.1 安装hexo\"></a>4.1 安装hexo</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo-cli -g</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo -g</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>检查hexo是否安装成功</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo -v</span></span><br><span class=\"line\">hexo: 4.2.0</span><br><span class=\"line\">hexo-cli: 3.1.0</span><br><span class=\"line\">os: Linux 5.3.0-45-generic linux x64</span><br><span class=\"line\">http_parser: 2.7.1</span><br><span class=\"line\">node: 8.10.0</span><br><span class=\"line\">v8: 6.2.414.50</span><br><span class=\"line\">uv: 1.18.0</span><br><span class=\"line\">zlib: 1.2.11</span><br><span class=\"line\">ares: 1.14.0</span><br><span class=\"line\">modules: 57</span><br><span class=\"line\">nghttp2: 1.30.0</span><br><span class=\"line\">openssl: 1.0.2n</span><br><span class=\"line\">icu: 60.2</span><br><span class=\"line\">unicode: 10.0</span><br><span class=\"line\">cldr: 32.0.1</span><br><span class=\"line\">tz: 2017c</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-初始化hexo文件夹\"><a href=\"#4-2-初始化hexo文件夹\" class=\"headerlink\" title=\"4.2 初始化hexo文件夹\"></a>4.2 初始化hexo文件夹</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br></pre></td></tr></table></figure>\n\n<p>看到“Start blogging with Hexo！”打印，说明初始化完成；</p>\n<p>输入npm install，安装所需要的组件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n\n<p>hexo已经安装并初始化完成；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>到此，hexo环境安装完成。</p>\n<h4 id=\"4-3-Hexo操作\"><a href=\"#4-3-Hexo操作\" class=\"headerlink\" title=\"4.3 Hexo操作\"></a>4.3 Hexo操作</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo g <span class=\"comment\">#generate 生成静态文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo s <span class=\"comment\">#server 启动服务器。</span></span></span><br><span class=\"line\">// 默认情况下，访问网址为： [http://localhost:4000/]</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器地址栏输入“<a href=\"http://localhost:4000/”打开页面，是一个空的博客网页；\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/”打开页面，是一个空的博客网页；</a></p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Image3.JPG\" alt=\"Image3\"></p>\n<h4 id=\"4-4-将git库和hexo链接起来\"><a href=\"#4-4-将git库和hexo链接起来\" class=\"headerlink\" title=\"4.4 将git库和hexo链接起来\"></a>4.4 将git库和hexo链接起来</h4><p>配置Deployment</p>\n<p>在hexo文件夹中，找到_config.yml文件，修改repository值（在末尾），repository值是github项目里的ssh；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Mshrimp/Mshrimp.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n<p>HexoBlog部署到git，需要安装hexo-deployer-git插件，在blog目录下运行以下命令进行安装；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> npm install hexo-deployer-git --save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN babel-eslint@10.1.0 requires a peer of eslint@&gt;= 4.12.1 but none is </span><br><span class=\"line\">installed. You must install peer dependencies yourself.</span><br><span class=\"line\"></span><br><span class=\"line\">+ hexo-deployer-git@1.0.0</span><br><span class=\"line\">added 1 package from 1 contributor, removed 4 packages and updated 14 packages in </span><br><span class=\"line\">5.684s</span><br></pre></td></tr></table></figure>\n\n<p>修改根目录下_config.yml文件后，需要使用$ hexo deploy部署一下，否则修改内容不会生效；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo deploy</span></span><br></pre></td></tr></table></figure>\n\n\n<p>至此，一个空的博客已经搭建完成，下一步，添加博客文章；</p>\n<h3 id=\"5-更换主题\"><a href=\"#5-更换主题\" class=\"headerlink\" title=\"5. 更换主题\"></a>5. 更换主题</h3><p>由于不太喜欢原来自带的主题，找了一个比较好看的yilia主题，需要先从Github中将yilia主题的源码下载到博客目录的themes目录下（感谢yilia主题作者的无私奉献）；</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure>\n\n<p>在博客根目录下，修改_config.yml文件的themes：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">themes: yilia</span><br></pre></td></tr></table></figure>\n\n<p>这个主题中的一些配置，可以根据需要自行修改，配置文件为themes/yilia/_config.yml；</p>\n<p>效果如下：</p>\n<p><img src=\"/2019/07/28/Ubuntu-Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/themes-yilia.png\" alt=\"themes-yilia\"></p>\n<p>其他好用的主题：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-博客迁移\"><a href=\"#6-博客迁移\" class=\"headerlink\" title=\"6. 博客迁移\"></a>6. 博客迁移</h3><h4 id=\"6-1-常规迁移\"><a href=\"#6-1-常规迁移\" class=\"headerlink\" title=\"6.1 常规迁移\"></a>6.1 常规迁移</h4><p>以前部署的Hexo博客是在Windows上搭建的，现在安装了Ubuntu-18.04.1，需要重新搭建博客；为了兼容以前的windows博客，需要使用以前的Hexo下的几个文件夹：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml  package.json  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>这时，在Ubuntu系统上创建文件夹hexo，以hexo为主目录搭建博客环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br></pre></td></tr></table></figure>\n\n<p>将上边四个文件或文件夹复制到hexo目录替换：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cp _config.yml  package.json  <span class=\"built_in\">source</span>  themes . -rf</span></span><br></pre></td></tr></table></figure>\n\n<p>之后就可以按照hexo命令进行操作了；</p>\n<h4 id=\"6-2-特殊情况\"><a href=\"#6-2-特殊情况\" class=\"headerlink\" title=\"6.2 特殊情况\"></a>6.2 特殊情况</h4><p>由于我的实际情况是，不但将hexo中的博客文件保存在了Github上，还将hexo生成的环境工程，以并保存在Github同一个工程的其他分支了，如：ubuntu分支；这样我就可以一并保存所有文件了；</p>\n<p>在这种特殊情况下，博客迁移操作原理上和常规迁移一样，只是操作稍微不同；</p>\n<p>将以前用的工程在Ubuntu环境中克隆下来，Mshrimp.github.io；</p>\n<p>新建hexo目录，并初始化hexo目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">cd</span> hexo</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexo init</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">_config.yml  node_modules/  package.json  package-lock.json  scaffolds/  source/  themes/</span><br></pre></td></tr></table></figure>\n\n<p>将hexo中生成的文件或文件夹复制到Mshrimp.github.io目录替换：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_modules/  package-lock.json  scaffolds/</span><br></pre></td></tr></table></figure>\n\n<p>这个操作，和常规迁移的区别是，复制的方向相反，其余都一样；</p>"},{"title":"Hello World","date":"2019-07-14T12:24:52.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2019-07-14 20:24:52\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2020-05-07T13:51:18.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv5000ldqg1719s6xiu","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"u-boot引导kernel启动过程","date":"2020-04-19T13:54:40.000Z","_content":"\n\n\n## u-boot引导kernel启动过程\n\n\n\nu-boot引导Linux kernel启动的过程；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n[TOC]\n\n\n### bootm命令\n\n\n\n\nbootm命令用于启动操作系统映像；bootm命令从映像文件的头部获取信息；包括：映像文件的CPU架构、操作系统类型、映像类型、压缩方式、映像文件在内存中的加载地址、映像文件运行的入口地址、映像文件名等；\n\n\n\n\nbootm将映像文件加载到指定的地址，解压映像并传递必要的内核启动参数给内核，最后跳转到入口地址进入内核，开始执行内核；\n\n\n\n\nbootm命令执行有三个步骤：\n\n\n解压Linux内核映像并将其加载到RAM中\n\n\n将ramdisk映像加载到RAM中\n\n\n将控制权交给内核，并向内核传递ramdisk在RAM中的位置和大小等信息\n\n\n\n\n\n\n将映像文件加载到RAM中时，需要确保映像文件的加载地址，不能与内核的位置有重叠；\n\n\n\n\n```c\n// cmd/bootm.c\nU_BOOT_CMD(\n    bootm,  CONFIG_SYS_MAXARGS, 1,  do_bootm,\n    \"boot application image from memory\", bootm_help_text\n);\n```\n\n\n\n\n```mermaid\ngraph TB\n\tbootm(bootm)-->do_bootm(do_bootm)\n```\n\n\n\n\n\n```c\ndo_bootm\n　　->do_bootm_states\n　　　　->bootm_start /bootm_find_os /bootm_find_other\n　　　　　　->bootm_load_os\n　　　　　　->boot_fn = bootm_os_get_boot_func(images->os.os);\n　　　　　　　　([IH_OS_LINUX] = do_bootm_linux,)　　\n　　　　　　->boot_selected_os\n　　　　　　　　->do_bootm_linux\n　　　　　　　　　　->boot_prep_linux\n　　　　　　　　　　　　->image_setup_linux\n　　　　　　　　　　　　　　->boot_fdt_add_mem_rsv_regions\n　　　　　　　　　　　　　　->boot_get_cmdline\n　　　　　　　　　　　　　　->boot_relocate_fdt\n　　　　　　　　　　　　　　->image_setup_libfdt\n　　　　　　　　　　　　->boot_jump_linux\n　　　　　　　　　　　　　　->r2 = (unsigned long)images->ft_addr;\n　　　　　　　　　　　　　　->kernel_entry(0, machid, r2);\n```\n\n\n\n\n\n\n\n\n#### do_bootm\n\n\n\n\n```c\n// cmd/bootm.c\n/*******************************************************************/\n/* bootm - boot application image from image in memory */\n/*******************************************************************/\nint do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\n    /* determine if we have a sub command */\n    argc--; argv++;\n    if (argc > 0) {\n        char *endp;\n\n        simple_strtoul(argv[0], &endp, 16);\n        /* endp pointing to NULL means that argv[0] was just a\n         * valid number, pass it along to the normal bootm processing\n         *\n         * If endp is ':' or '#' assume a FIT identifier so pass\n         * along for normal processing.\n         *\n         * Right now we assume the first arg should never be '-'\n         */\n        if ((*endp != 0) && (*endp != ':') && (*endp != '#'))\n            return do_bootm_subcommand(cmdtp, flag, argc, argv);\n    }\n\n    return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |\n        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |\n        BOOTM_STATE_LOADOS |\n#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH\n        BOOTM_STATE_RAMDISK |\n#endif\n        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |\n        BOOTM_STATE_OS_GO, &images, 1);\n}\n```\n\n\n\n\n```mermaid\ngraph LR\n\tdo_bootm(do_bootm)-->do_bootm_states(do_bootm_states)\n\tdo_bootm-->do_bootm_subcommand(do_bootm_subcommand)-->do_bootm_states\n```\n\n\n\n\n\n\nbootm命令执行的核心操作由do_bootm_states()函数来完成；\n\n\n\n\ndo_bootm_states()函数操作，是由参数states来决定的；\n\n\n```c\n// include/image.h\n#define BOOTM_STATE_START   (0x00000001)\n#define BOOTM_STATE_FINDOS  (0x00000002)\n#define BOOTM_STATE_FINDOTHER   (0x00000004)\n#define BOOTM_STATE_LOADOS  (0x00000008)\n#define BOOTM_STATE_RAMDISK (0x00000010)\n#define BOOTM_STATE_FDT     (0x00000020)\n#define BOOTM_STATE_OS_CMDLINE  (0x00000040)\n#define BOOTM_STATE_OS_BD_T (0x00000080)\n#define BOOTM_STATE_OS_PREP (0x00000100)\n#define BOOTM_STATE_OS_FAKE_GO  (0x00000200)    /* 'Almost' run the OS */\n#define BOOTM_STATE_OS_GO   (0x00000400)\n```\n\n\n\n\ndo_bootm_states()函数的参数images，用来表示bootm命令启动kernel的一些信息，包含了指向os、initrd、fdt的映像信息；是全局变量：\n\n\n```c\n// common/bootm.c\nbootm_headers_t images;     /* pointers to os/initrd/fdt images */\n```\n\n\n\n\n\n\n#### do_bootm_states\n\n\n\n\n\n\n```c\n// common/bootm.c\nint do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],\n            int states, bootm_headers_t *images, int boot_progress)\n{\n    boot_os_fn *boot_fn;\n    ulong iflag = 0;\n    int ret = 0, need_boot_fn;\n    \n    images->state |= states;\n\n    if (states & BOOTM_STATE_START)\n        ret = bootm_start(cmdtp, flag, argc, argv);\n\n    if (!ret && (states & BOOTM_STATE_FINDOS))\n        ret = bootm_find_os(cmdtp, flag, argc, argv);\n\n    if (!ret && (states & BOOTM_STATE_FINDOTHER))\n        ret = bootm_find_other(cmdtp, flag, argc, argv);\n\n    /* Load the OS */\n    if (!ret && (states & BOOTM_STATE_LOADOS)) {\n        iflag = bootm_disable_interrupts();\n        ret = bootm_load_os(images, 0);\n\t\t......\n    }\n\n    /* Relocate the ramdisk */\n#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH\n    if (!ret && (states & BOOTM_STATE_RAMDISK)) {\n        ulong rd_len = images->rd_end - images->rd_start;\n\n        ret = boot_ramdisk_high(&images->lmb, images->rd_start,\n            rd_len, &images->initrd_start, &images->initrd_end);\n\t\t......\n    }\n#endif\n#if IMAGE_ENABLE_OF_LIBFDT && defined(CONFIG_LMB)\n    if (!ret && (states & BOOTM_STATE_FDT)) {\n        boot_fdt_add_mem_rsv_regions(&images->lmb, images->ft_addr);\n        ret = boot_relocate_fdt(&images->lmb, &images->ft_addr,\n                    &images->ft_len);\n    }\n#endif\n\t......\n    boot_fn = bootm_os_get_boot_func(images->os.os);\n    ......\n    if (!ret && (states & BOOTM_STATE_OS_PREP)) {\n        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);\n    }\n    if (!ret && (states & BOOTM_STATE_OS_PREP)) {\n        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);\n    }\n\n#ifdef CONFIG_TRACE\n    /* Pretend to run the OS, then run a user command */\n    if (!ret && (states & BOOTM_STATE_OS_FAKE_GO)) {\n        char *cmd_list = env_get(\"fakegocmd\");\n\n        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,\n                images, boot_fn);\n        if (!ret && cmd_list)\n            ret = run_command_list(cmd_list, -1, flag);\n    }\n#endif\n\t......\n    /* Now run the OS! We hope this doesn't return */\n    if (!ret && (states & BOOTM_STATE_OS_GO))\n        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,\n                images, boot_fn);\n\t......\n}\n```\n\n\n\n\n\n\n```mermaid\ngraph LR\n\tdo_bootm_states(do_bootm_states)-->states(states)\n\tstates--BOOTM_STATE_START-->bootm_start(bootm_start)\n\tstates--BOOTM_STATE_FINDOS-->bootm_find_os(bootm_find_os)\n\tstates--BOOTM_STATE_FINDOTHER-->bootm_find_other(bootm_find_other)\n\tstates--BOOTM_STATE_LOADOS-->bootm_load_os(bootm_load_os)\n\tstates--BOOTM_STATE_RAMDISK-->boot_ramdisk_high(boot_ramdisk_high)\n\tstates--BOOTM_STATE_FDT-->boot_relocate_fdt(boot_relocate_fdt)\n\tstates--BOOTM_STATE_OS_PREP-->boot_fn(boot_fn)\n\tstates--BOOTM_STATE_OS_FAKE_GO-->boot_selected_os1(boot_selected_os)\n\tstates--BOOTM_STATE_OS_GO-->boot_selected_os2(boot_selected_os)\n```\n\n\n\n\n\n\n\n\n#### bootm_start\n\n\n\n\n```c\n// common/bootm.c\nstatic int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc,\n               char * const argv[])\n{\n    memset((void *)&images, 0, sizeof(images));\n    images.verify = env_get_yesno(\"verify\");\n\n    boot_start_lmb(&images);\n\n    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, \"bootm_start\");\n    images.state = BOOTM_STATE_START;\n\n    return 0;\n}\n```\n\n\n\n\n\n#### bootm_find_os\n\n\n\n```c\nstatic int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,\n             char * const argv[])\n{\n    const void *os_hdr;\n    bool ep_found = false;\n    int ret;\n\n    /* get kernel image header, start address and length */\n    os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,\n            &images, &images.os.image_start, &images.os.image_len);\n    if (images.os.image_len == 0) {\n        puts(\"ERROR: can't get kernel image!\\n\");\n        return 1;\n    }   \n\n    /* get image parameters */\n    switch (genimg_get_format(os_hdr)) {\n#if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)\n    case IMAGE_FORMAT_LEGACY:\n        images.os.type = image_get_type(os_hdr);\n        images.os.comp = image_get_comp(os_hdr);\n        images.os.os = image_get_os(os_hdr);\n\n        images.os.end = image_get_image_end(os_hdr);\n        images.os.load = image_get_load(os_hdr);\n        images.os.arch = image_get_arch(os_hdr);\n        break;\n#endif\n    ......\n\t} else if (images.legacy_hdr_valid) {\n        images.ep = image_get_ep(&images.legacy_hdr_os_copy);\n    }\n\t......\n    images.os.start = map_to_sysmem(os_hdr);\n\n    return 0;\n}\n```\n\n\n\n\n\n```mermaid\ngraph LR\n\tbootm_find_os(bootm_find_os)-->boot_get_kernel(boot_get_kernel)\n\tboot_get_kernel-->images_os1(images.os)\n\timages_os1-->image_start(image_start)\n\timages_os1-->image_len(image_len)\n\tbootm_find_os--IMAGE_FORMAT_LEGACY-->images_os(images.os)\n\timages_os-->type(type)\n\timages_os-->comp(comp)\n\timages_os-->os(os)\n\timages_os-->start(start)\n\timages_os-->endend(end)\n\timages_os-->load(load)\n\timages_os-->arch(arch)\n```\n\n\n\n##### boot_get_kernel\n\nboot_get_kernel()函数，获取内核映像的头、起始地址、长度；\n\n\n\n\n\n\n```c\n// common/bootm_os.c\nboot_os_fn *bootm_os_get_boot_func(int os)\n{\n#ifdef CONFIG_NEEDS_MANUAL_RELOC\n    static bool relocated;\n\n    if (!relocated) {\n        int i;\n\n        /* relocate boot function table */\n        for (i = 0; i < ARRAY_SIZE(boot_os); i++)\n            if (boot_os[i] != NULL)\n                boot_os[i] += gd->reloc_off;\n\n        relocated = true;\n    }\n#endif\n    return boot_os[os];\n}\n```\n\n\n\n\n\n\n```c\n// common/bootm_os.c\nstatic boot_os_fn *boot_os[] = {\n    [IH_OS_U_BOOT] = do_bootm_standalone,\n#ifdef CONFIG_BOOTM_LINUX\n    [IH_OS_LINUX] = do_bootm_linux,\n#endif\n......\n};\n```\n\n\n\n\nu-boot中支持bootm命令需要打开CONFIG_BOOTM_LINUX和CONFIG_CMD_BOOTM配置，即：\n\n\n```\nCONFIG_BOOTM_LINUX=y\n```\n\n\n\n\n```mermaid\ngraph TB\n\tdo_bootm_states(do_bootm_states)\n\t-->bootm_os_get_boot_func(bootm_os_get_boot_func)\n\t-->boot_os(\"boot_os[os]\")\n\t-->do_bootm_linux(do_bootm_linux)\n```\n\n\n\n\n\n\n#### image\n\n\n\n\nbootm_headers_t结构是用来表示bootm命令启动kernel的一些信息的结构体，包含了指向os、initrd、fdt的映像信息；\n\n\n\n\n```c\n// common/bootm.c\nbootm_headers_t images;     /* pointers to os/initrd/fdt images */\n```\n\n\nbootm命令中，会根据参数以及参数指向的映像来填充bootm_headers_t结构体中的成员；最后再使用这个结构体中的信息填充kernel启动信息，并跳转到kernel执行；\n\n\n\n\n\n\n```c\n// include/image.h\n/*\n * Legacy and FIT format headers used by do_bootm() and do_bootm_<os>()\n * routines.\n */\ntypedef struct bootm_headers {\n    /*\n     * Legacy os image header, if it is a multi component image\n     * then boot_get_ramdisk() and get_fdt() will attempt to get\n     * data from second and third component accordingly.\n     */\n    image_header_t  *legacy_hdr_os;     /* image header pointer */\n    image_header_t  legacy_hdr_os_copy; /* header copy */\n    ulong       legacy_hdr_valid;\n\n#if IMAGE_ENABLE_FIT\n    const char  *fit_uname_cfg; /* configuration node unit name */\n\n    void        *fit_hdr_os;    /* os FIT image header */\n    const char  *fit_uname_os;  /* os subimage node unit name */\n    int     fit_noffset_os; /* os subimage node offset */\n\n    void        *fit_hdr_rd;    /* init ramdisk FIT image header */\n    const char  *fit_uname_rd;  /* init ramdisk subimage node unit name */\n    int     fit_noffset_rd; /* init ramdisk subimage node offset */\n\n    void        *fit_hdr_fdt;   /* FDT blob FIT image header */\n    const char  *fit_uname_fdt; /* FDT blob subimage node unit name */\n    int     fit_noffset_fdt;/* FDT blob subimage node offset */\n\n    void        *fit_hdr_setup; /* x86 setup FIT image header */\n    const char  *fit_uname_setup; /* x86 setup subimage node name */\n    int     fit_noffset_setup;/* x86 setup subimage node offset */\n#endif\n\n#ifndef USE_HOSTCC\n    image_info_t    os;     /* os image info */\n    ulong       ep;     /* entry point of OS */\n\n    ulong       rd_start, rd_end;/* ramdisk start/end */\n\n    char        *ft_addr;   /* flat dev tree address */\n    ulong       ft_len;     /* length of flat device tree */\n\n    ulong       initrd_start;\n    ulong       initrd_end;\n    ulong       cmdline_start;\n    ulong       cmdline_end;\n    bd_t        *kbd;\n#endif\n\n    int     verify;     /* env_get(\"verify\")[0] != 'n' */\n\n#define BOOTM_STATE_START   (0x00000001)\n#define BOOTM_STATE_FINDOS  (0x00000002)\n#define BOOTM_STATE_FINDOTHER   (0x00000004)\n#define BOOTM_STATE_LOADOS  (0x00000008)\n#define BOOTM_STATE_RAMDISK (0x00000010)\n#define BOOTM_STATE_FDT     (0x00000020)\n#define BOOTM_STATE_OS_CMDLINE  (0x00000040)\n#define BOOTM_STATE_OS_BD_T (0x00000080)\n#define BOOTM_STATE_OS_PREP (0x00000100)\n#define BOOTM_STATE_OS_FAKE_GO  (0x00000200)    /* 'Almost' run the OS */\n#define BOOTM_STATE_OS_GO   (0x00000400)\n    int     state;\n\n#ifdef CONFIG_LMB\n    struct lmb  lmb;        /* for memory mgmt */\n#endif\n} bootm_headers_t;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n#### do_bootm_linux\n\n\n\n\n为了能够正常调用do_bootm_linux函数，需要打开CONFIG_CMD_BOOTM配置；\n\n\n```\nCONFIG_CMD_BOOTM=y\n```\n\n\n因为do_bootm_linux函数是平台相关的函数，需要在arm平台下打开对应的CONFIG_CMD_BOOTM配置；\n\n\n```\narch/arm/lib/Makefile:34:obj-$(CONFIG_CMD_BOOTM) += bootm.o\n```\n\n\n\n\n\n\n\n\n```mermaid\ngraph TB\n    do_bootm_linux(do_bootm_linux)-->boot_prep_linux(boot_prep_linux)\n\tdo_bootm_linux-->boot_jump_linux(boot_jump_linux)\n```\n\n\n\n\n\n\n\n\ndo_bootm_linux()函数是bootm实现的主要入口点\n\n\n```c\n// arch/arm/lib/bootm.c\nint do_bootm_linux(int flag, int argc, char * const argv[],\n           bootm_headers_t *images)\n{\n    if (flag & BOOTM_STATE_OS_PREP) {\n        boot_prep_linux(images);\n        return 0;\n    }\n\n    if (flag & (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) {\n        boot_jump_linux(images, flag);\n        return 0;\n    }\n\n    boot_prep_linux(images);\n    boot_jump_linux(images, flag);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### u-boot给Kernel传参\n\n\n嵌入式环境的Linux内核运行需要通过u-boot来加载并启动运行，在内核启动之前，由u-boot来提供Kernel的运行环境，同时将启动需要的参数传递给Kernel；\n\n\n**传参方法**：将要传递的参数，封装成一个结构体，把这个结构体连续存储在内存的一片区域，将内存区域的物理地址传递给内核，内核在启动时从指定的物理地址中读取参数，并通过parse_tags()来解析参数，就完成了给kernel传参；\n\n\nu-boot中定义这个结构体为tag：\n\n\n```c\n// arch/arm/include/asm/setup.h\nstruct tag {\n    struct tag_header hdr;\n    union {\n        struct tag_core     core;\n        struct tag_mem32    mem;\n        struct tag_videotext    videotext;\n        struct tag_ramdisk  ramdisk;\n        struct tag_initrd   initrd;\n        struct tag_serialnr serialnr;\n        struct tag_revision revision;\n        struct tag_videolfb videolfb;\n        struct tag_cmdline  cmdline;\n        struct tag_acorn    acorn;\n        struct tag_memclk   memclk;\n    } u;\n};\n```\n\n\n这个数据结构在u-boot和kernel中都有定义，并且必须保持一致；\n\n\n其中tag_header为tag头，表明tag的类型和大小，类型是用来区别tag之间不同的处理函数；\n\n\n```c\n// arch/arm/include/asm/setup.h\nstruct tag_header {\n    u32 size;\n    u32 tag;\n};\n```\n\n\n这个链表必须以tag_header.tag = ATAG_CORE开始，以tag_header.tag = ATAG_NONE结束；\n\n\n\n\n#### 应用\n\n\n\n\n\n\n\n\n```c\n// arch/arm/lib/bootm.c\nstatic void boot_prep_linux(bootm_headers_t *images)\n{\n    char *commandline = env_get(\"bootargs\");\n\n    if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len) {\n#ifdef CONFIG_OF_LIBFDT\n        debug(\"using: FDT\\n\");\n        if (image_setup_linux(images)) {\n            printf(\"FDT creation failed! hanging...\");\n            hang();\n        }\n#endif\n    } else if (BOOTM_ENABLE_TAGS) {\n        debug(\"using: ATAGS\\n\");\n        setup_start_tag(gd->bd);\n        if (BOOTM_ENABLE_SERIAL_TAG)\n            setup_serial_tag(&params);\n        if (BOOTM_ENABLE_CMDLINE_TAG)\n            setup_commandline_tag(gd->bd, commandline);\n        if (BOOTM_ENABLE_REVISION_TAG)\n            setup_revision_tag(&params);\n        if (BOOTM_ENABLE_MEMORY_TAGS)\n            setup_memory_tags(gd->bd);\n        if (BOOTM_ENABLE_INITRD_TAG) {\n            if (images->initrd_start && images->initrd_end) {\n                setup_initrd_tag(gd->bd, images->initrd_start,\n                         images->initrd_end);\n            } else if (images->rd_start && images->rd_end) {\n                setup_initrd_tag(gd->bd, images->rd_start,\n                         images->rd_end);\n            }\n        }\n        setup_board_tags(&params);\n        setup_end_tag(gd->bd);\n    } else {\n        printf(\"FDT and ATAGS support not compiled in - hanging\\n\");\n        hang();\n    }\n}\n```\n\n\n\n\n","source":"_posts/u-boot引导kernel启动过程.md","raw":"---\ntitle: u-boot引导kernel启动过程\ndate: 2020-04-19 21:54:40\ntags: u-boot\n---\n\n\n\n## u-boot引导kernel启动过程\n\n\n\nu-boot引导Linux kernel启动的过程；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n[TOC]\n\n\n### bootm命令\n\n\n\n\nbootm命令用于启动操作系统映像；bootm命令从映像文件的头部获取信息；包括：映像文件的CPU架构、操作系统类型、映像类型、压缩方式、映像文件在内存中的加载地址、映像文件运行的入口地址、映像文件名等；\n\n\n\n\nbootm将映像文件加载到指定的地址，解压映像并传递必要的内核启动参数给内核，最后跳转到入口地址进入内核，开始执行内核；\n\n\n\n\nbootm命令执行有三个步骤：\n\n\n解压Linux内核映像并将其加载到RAM中\n\n\n将ramdisk映像加载到RAM中\n\n\n将控制权交给内核，并向内核传递ramdisk在RAM中的位置和大小等信息\n\n\n\n\n\n\n将映像文件加载到RAM中时，需要确保映像文件的加载地址，不能与内核的位置有重叠；\n\n\n\n\n```c\n// cmd/bootm.c\nU_BOOT_CMD(\n    bootm,  CONFIG_SYS_MAXARGS, 1,  do_bootm,\n    \"boot application image from memory\", bootm_help_text\n);\n```\n\n\n\n\n```mermaid\ngraph TB\n\tbootm(bootm)-->do_bootm(do_bootm)\n```\n\n\n\n\n\n```c\ndo_bootm\n　　->do_bootm_states\n　　　　->bootm_start /bootm_find_os /bootm_find_other\n　　　　　　->bootm_load_os\n　　　　　　->boot_fn = bootm_os_get_boot_func(images->os.os);\n　　　　　　　　([IH_OS_LINUX] = do_bootm_linux,)　　\n　　　　　　->boot_selected_os\n　　　　　　　　->do_bootm_linux\n　　　　　　　　　　->boot_prep_linux\n　　　　　　　　　　　　->image_setup_linux\n　　　　　　　　　　　　　　->boot_fdt_add_mem_rsv_regions\n　　　　　　　　　　　　　　->boot_get_cmdline\n　　　　　　　　　　　　　　->boot_relocate_fdt\n　　　　　　　　　　　　　　->image_setup_libfdt\n　　　　　　　　　　　　->boot_jump_linux\n　　　　　　　　　　　　　　->r2 = (unsigned long)images->ft_addr;\n　　　　　　　　　　　　　　->kernel_entry(0, machid, r2);\n```\n\n\n\n\n\n\n\n\n#### do_bootm\n\n\n\n\n```c\n// cmd/bootm.c\n/*******************************************************************/\n/* bootm - boot application image from image in memory */\n/*******************************************************************/\nint do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\n    /* determine if we have a sub command */\n    argc--; argv++;\n    if (argc > 0) {\n        char *endp;\n\n        simple_strtoul(argv[0], &endp, 16);\n        /* endp pointing to NULL means that argv[0] was just a\n         * valid number, pass it along to the normal bootm processing\n         *\n         * If endp is ':' or '#' assume a FIT identifier so pass\n         * along for normal processing.\n         *\n         * Right now we assume the first arg should never be '-'\n         */\n        if ((*endp != 0) && (*endp != ':') && (*endp != '#'))\n            return do_bootm_subcommand(cmdtp, flag, argc, argv);\n    }\n\n    return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |\n        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |\n        BOOTM_STATE_LOADOS |\n#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH\n        BOOTM_STATE_RAMDISK |\n#endif\n        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |\n        BOOTM_STATE_OS_GO, &images, 1);\n}\n```\n\n\n\n\n```mermaid\ngraph LR\n\tdo_bootm(do_bootm)-->do_bootm_states(do_bootm_states)\n\tdo_bootm-->do_bootm_subcommand(do_bootm_subcommand)-->do_bootm_states\n```\n\n\n\n\n\n\nbootm命令执行的核心操作由do_bootm_states()函数来完成；\n\n\n\n\ndo_bootm_states()函数操作，是由参数states来决定的；\n\n\n```c\n// include/image.h\n#define BOOTM_STATE_START   (0x00000001)\n#define BOOTM_STATE_FINDOS  (0x00000002)\n#define BOOTM_STATE_FINDOTHER   (0x00000004)\n#define BOOTM_STATE_LOADOS  (0x00000008)\n#define BOOTM_STATE_RAMDISK (0x00000010)\n#define BOOTM_STATE_FDT     (0x00000020)\n#define BOOTM_STATE_OS_CMDLINE  (0x00000040)\n#define BOOTM_STATE_OS_BD_T (0x00000080)\n#define BOOTM_STATE_OS_PREP (0x00000100)\n#define BOOTM_STATE_OS_FAKE_GO  (0x00000200)    /* 'Almost' run the OS */\n#define BOOTM_STATE_OS_GO   (0x00000400)\n```\n\n\n\n\ndo_bootm_states()函数的参数images，用来表示bootm命令启动kernel的一些信息，包含了指向os、initrd、fdt的映像信息；是全局变量：\n\n\n```c\n// common/bootm.c\nbootm_headers_t images;     /* pointers to os/initrd/fdt images */\n```\n\n\n\n\n\n\n#### do_bootm_states\n\n\n\n\n\n\n```c\n// common/bootm.c\nint do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],\n            int states, bootm_headers_t *images, int boot_progress)\n{\n    boot_os_fn *boot_fn;\n    ulong iflag = 0;\n    int ret = 0, need_boot_fn;\n    \n    images->state |= states;\n\n    if (states & BOOTM_STATE_START)\n        ret = bootm_start(cmdtp, flag, argc, argv);\n\n    if (!ret && (states & BOOTM_STATE_FINDOS))\n        ret = bootm_find_os(cmdtp, flag, argc, argv);\n\n    if (!ret && (states & BOOTM_STATE_FINDOTHER))\n        ret = bootm_find_other(cmdtp, flag, argc, argv);\n\n    /* Load the OS */\n    if (!ret && (states & BOOTM_STATE_LOADOS)) {\n        iflag = bootm_disable_interrupts();\n        ret = bootm_load_os(images, 0);\n\t\t......\n    }\n\n    /* Relocate the ramdisk */\n#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH\n    if (!ret && (states & BOOTM_STATE_RAMDISK)) {\n        ulong rd_len = images->rd_end - images->rd_start;\n\n        ret = boot_ramdisk_high(&images->lmb, images->rd_start,\n            rd_len, &images->initrd_start, &images->initrd_end);\n\t\t......\n    }\n#endif\n#if IMAGE_ENABLE_OF_LIBFDT && defined(CONFIG_LMB)\n    if (!ret && (states & BOOTM_STATE_FDT)) {\n        boot_fdt_add_mem_rsv_regions(&images->lmb, images->ft_addr);\n        ret = boot_relocate_fdt(&images->lmb, &images->ft_addr,\n                    &images->ft_len);\n    }\n#endif\n\t......\n    boot_fn = bootm_os_get_boot_func(images->os.os);\n    ......\n    if (!ret && (states & BOOTM_STATE_OS_PREP)) {\n        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);\n    }\n    if (!ret && (states & BOOTM_STATE_OS_PREP)) {\n        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);\n    }\n\n#ifdef CONFIG_TRACE\n    /* Pretend to run the OS, then run a user command */\n    if (!ret && (states & BOOTM_STATE_OS_FAKE_GO)) {\n        char *cmd_list = env_get(\"fakegocmd\");\n\n        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,\n                images, boot_fn);\n        if (!ret && cmd_list)\n            ret = run_command_list(cmd_list, -1, flag);\n    }\n#endif\n\t......\n    /* Now run the OS! We hope this doesn't return */\n    if (!ret && (states & BOOTM_STATE_OS_GO))\n        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,\n                images, boot_fn);\n\t......\n}\n```\n\n\n\n\n\n\n```mermaid\ngraph LR\n\tdo_bootm_states(do_bootm_states)-->states(states)\n\tstates--BOOTM_STATE_START-->bootm_start(bootm_start)\n\tstates--BOOTM_STATE_FINDOS-->bootm_find_os(bootm_find_os)\n\tstates--BOOTM_STATE_FINDOTHER-->bootm_find_other(bootm_find_other)\n\tstates--BOOTM_STATE_LOADOS-->bootm_load_os(bootm_load_os)\n\tstates--BOOTM_STATE_RAMDISK-->boot_ramdisk_high(boot_ramdisk_high)\n\tstates--BOOTM_STATE_FDT-->boot_relocate_fdt(boot_relocate_fdt)\n\tstates--BOOTM_STATE_OS_PREP-->boot_fn(boot_fn)\n\tstates--BOOTM_STATE_OS_FAKE_GO-->boot_selected_os1(boot_selected_os)\n\tstates--BOOTM_STATE_OS_GO-->boot_selected_os2(boot_selected_os)\n```\n\n\n\n\n\n\n\n\n#### bootm_start\n\n\n\n\n```c\n// common/bootm.c\nstatic int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc,\n               char * const argv[])\n{\n    memset((void *)&images, 0, sizeof(images));\n    images.verify = env_get_yesno(\"verify\");\n\n    boot_start_lmb(&images);\n\n    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, \"bootm_start\");\n    images.state = BOOTM_STATE_START;\n\n    return 0;\n}\n```\n\n\n\n\n\n#### bootm_find_os\n\n\n\n```c\nstatic int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,\n             char * const argv[])\n{\n    const void *os_hdr;\n    bool ep_found = false;\n    int ret;\n\n    /* get kernel image header, start address and length */\n    os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,\n            &images, &images.os.image_start, &images.os.image_len);\n    if (images.os.image_len == 0) {\n        puts(\"ERROR: can't get kernel image!\\n\");\n        return 1;\n    }   \n\n    /* get image parameters */\n    switch (genimg_get_format(os_hdr)) {\n#if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)\n    case IMAGE_FORMAT_LEGACY:\n        images.os.type = image_get_type(os_hdr);\n        images.os.comp = image_get_comp(os_hdr);\n        images.os.os = image_get_os(os_hdr);\n\n        images.os.end = image_get_image_end(os_hdr);\n        images.os.load = image_get_load(os_hdr);\n        images.os.arch = image_get_arch(os_hdr);\n        break;\n#endif\n    ......\n\t} else if (images.legacy_hdr_valid) {\n        images.ep = image_get_ep(&images.legacy_hdr_os_copy);\n    }\n\t......\n    images.os.start = map_to_sysmem(os_hdr);\n\n    return 0;\n}\n```\n\n\n\n\n\n```mermaid\ngraph LR\n\tbootm_find_os(bootm_find_os)-->boot_get_kernel(boot_get_kernel)\n\tboot_get_kernel-->images_os1(images.os)\n\timages_os1-->image_start(image_start)\n\timages_os1-->image_len(image_len)\n\tbootm_find_os--IMAGE_FORMAT_LEGACY-->images_os(images.os)\n\timages_os-->type(type)\n\timages_os-->comp(comp)\n\timages_os-->os(os)\n\timages_os-->start(start)\n\timages_os-->endend(end)\n\timages_os-->load(load)\n\timages_os-->arch(arch)\n```\n\n\n\n##### boot_get_kernel\n\nboot_get_kernel()函数，获取内核映像的头、起始地址、长度；\n\n\n\n\n\n\n```c\n// common/bootm_os.c\nboot_os_fn *bootm_os_get_boot_func(int os)\n{\n#ifdef CONFIG_NEEDS_MANUAL_RELOC\n    static bool relocated;\n\n    if (!relocated) {\n        int i;\n\n        /* relocate boot function table */\n        for (i = 0; i < ARRAY_SIZE(boot_os); i++)\n            if (boot_os[i] != NULL)\n                boot_os[i] += gd->reloc_off;\n\n        relocated = true;\n    }\n#endif\n    return boot_os[os];\n}\n```\n\n\n\n\n\n\n```c\n// common/bootm_os.c\nstatic boot_os_fn *boot_os[] = {\n    [IH_OS_U_BOOT] = do_bootm_standalone,\n#ifdef CONFIG_BOOTM_LINUX\n    [IH_OS_LINUX] = do_bootm_linux,\n#endif\n......\n};\n```\n\n\n\n\nu-boot中支持bootm命令需要打开CONFIG_BOOTM_LINUX和CONFIG_CMD_BOOTM配置，即：\n\n\n```\nCONFIG_BOOTM_LINUX=y\n```\n\n\n\n\n```mermaid\ngraph TB\n\tdo_bootm_states(do_bootm_states)\n\t-->bootm_os_get_boot_func(bootm_os_get_boot_func)\n\t-->boot_os(\"boot_os[os]\")\n\t-->do_bootm_linux(do_bootm_linux)\n```\n\n\n\n\n\n\n#### image\n\n\n\n\nbootm_headers_t结构是用来表示bootm命令启动kernel的一些信息的结构体，包含了指向os、initrd、fdt的映像信息；\n\n\n\n\n```c\n// common/bootm.c\nbootm_headers_t images;     /* pointers to os/initrd/fdt images */\n```\n\n\nbootm命令中，会根据参数以及参数指向的映像来填充bootm_headers_t结构体中的成员；最后再使用这个结构体中的信息填充kernel启动信息，并跳转到kernel执行；\n\n\n\n\n\n\n```c\n// include/image.h\n/*\n * Legacy and FIT format headers used by do_bootm() and do_bootm_<os>()\n * routines.\n */\ntypedef struct bootm_headers {\n    /*\n     * Legacy os image header, if it is a multi component image\n     * then boot_get_ramdisk() and get_fdt() will attempt to get\n     * data from second and third component accordingly.\n     */\n    image_header_t  *legacy_hdr_os;     /* image header pointer */\n    image_header_t  legacy_hdr_os_copy; /* header copy */\n    ulong       legacy_hdr_valid;\n\n#if IMAGE_ENABLE_FIT\n    const char  *fit_uname_cfg; /* configuration node unit name */\n\n    void        *fit_hdr_os;    /* os FIT image header */\n    const char  *fit_uname_os;  /* os subimage node unit name */\n    int     fit_noffset_os; /* os subimage node offset */\n\n    void        *fit_hdr_rd;    /* init ramdisk FIT image header */\n    const char  *fit_uname_rd;  /* init ramdisk subimage node unit name */\n    int     fit_noffset_rd; /* init ramdisk subimage node offset */\n\n    void        *fit_hdr_fdt;   /* FDT blob FIT image header */\n    const char  *fit_uname_fdt; /* FDT blob subimage node unit name */\n    int     fit_noffset_fdt;/* FDT blob subimage node offset */\n\n    void        *fit_hdr_setup; /* x86 setup FIT image header */\n    const char  *fit_uname_setup; /* x86 setup subimage node name */\n    int     fit_noffset_setup;/* x86 setup subimage node offset */\n#endif\n\n#ifndef USE_HOSTCC\n    image_info_t    os;     /* os image info */\n    ulong       ep;     /* entry point of OS */\n\n    ulong       rd_start, rd_end;/* ramdisk start/end */\n\n    char        *ft_addr;   /* flat dev tree address */\n    ulong       ft_len;     /* length of flat device tree */\n\n    ulong       initrd_start;\n    ulong       initrd_end;\n    ulong       cmdline_start;\n    ulong       cmdline_end;\n    bd_t        *kbd;\n#endif\n\n    int     verify;     /* env_get(\"verify\")[0] != 'n' */\n\n#define BOOTM_STATE_START   (0x00000001)\n#define BOOTM_STATE_FINDOS  (0x00000002)\n#define BOOTM_STATE_FINDOTHER   (0x00000004)\n#define BOOTM_STATE_LOADOS  (0x00000008)\n#define BOOTM_STATE_RAMDISK (0x00000010)\n#define BOOTM_STATE_FDT     (0x00000020)\n#define BOOTM_STATE_OS_CMDLINE  (0x00000040)\n#define BOOTM_STATE_OS_BD_T (0x00000080)\n#define BOOTM_STATE_OS_PREP (0x00000100)\n#define BOOTM_STATE_OS_FAKE_GO  (0x00000200)    /* 'Almost' run the OS */\n#define BOOTM_STATE_OS_GO   (0x00000400)\n    int     state;\n\n#ifdef CONFIG_LMB\n    struct lmb  lmb;        /* for memory mgmt */\n#endif\n} bootm_headers_t;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n#### do_bootm_linux\n\n\n\n\n为了能够正常调用do_bootm_linux函数，需要打开CONFIG_CMD_BOOTM配置；\n\n\n```\nCONFIG_CMD_BOOTM=y\n```\n\n\n因为do_bootm_linux函数是平台相关的函数，需要在arm平台下打开对应的CONFIG_CMD_BOOTM配置；\n\n\n```\narch/arm/lib/Makefile:34:obj-$(CONFIG_CMD_BOOTM) += bootm.o\n```\n\n\n\n\n\n\n\n\n```mermaid\ngraph TB\n    do_bootm_linux(do_bootm_linux)-->boot_prep_linux(boot_prep_linux)\n\tdo_bootm_linux-->boot_jump_linux(boot_jump_linux)\n```\n\n\n\n\n\n\n\n\ndo_bootm_linux()函数是bootm实现的主要入口点\n\n\n```c\n// arch/arm/lib/bootm.c\nint do_bootm_linux(int flag, int argc, char * const argv[],\n           bootm_headers_t *images)\n{\n    if (flag & BOOTM_STATE_OS_PREP) {\n        boot_prep_linux(images);\n        return 0;\n    }\n\n    if (flag & (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) {\n        boot_jump_linux(images, flag);\n        return 0;\n    }\n\n    boot_prep_linux(images);\n    boot_jump_linux(images, flag);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### u-boot给Kernel传参\n\n\n嵌入式环境的Linux内核运行需要通过u-boot来加载并启动运行，在内核启动之前，由u-boot来提供Kernel的运行环境，同时将启动需要的参数传递给Kernel；\n\n\n**传参方法**：将要传递的参数，封装成一个结构体，把这个结构体连续存储在内存的一片区域，将内存区域的物理地址传递给内核，内核在启动时从指定的物理地址中读取参数，并通过parse_tags()来解析参数，就完成了给kernel传参；\n\n\nu-boot中定义这个结构体为tag：\n\n\n```c\n// arch/arm/include/asm/setup.h\nstruct tag {\n    struct tag_header hdr;\n    union {\n        struct tag_core     core;\n        struct tag_mem32    mem;\n        struct tag_videotext    videotext;\n        struct tag_ramdisk  ramdisk;\n        struct tag_initrd   initrd;\n        struct tag_serialnr serialnr;\n        struct tag_revision revision;\n        struct tag_videolfb videolfb;\n        struct tag_cmdline  cmdline;\n        struct tag_acorn    acorn;\n        struct tag_memclk   memclk;\n    } u;\n};\n```\n\n\n这个数据结构在u-boot和kernel中都有定义，并且必须保持一致；\n\n\n其中tag_header为tag头，表明tag的类型和大小，类型是用来区别tag之间不同的处理函数；\n\n\n```c\n// arch/arm/include/asm/setup.h\nstruct tag_header {\n    u32 size;\n    u32 tag;\n};\n```\n\n\n这个链表必须以tag_header.tag = ATAG_CORE开始，以tag_header.tag = ATAG_NONE结束；\n\n\n\n\n#### 应用\n\n\n\n\n\n\n\n\n```c\n// arch/arm/lib/bootm.c\nstatic void boot_prep_linux(bootm_headers_t *images)\n{\n    char *commandline = env_get(\"bootargs\");\n\n    if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len) {\n#ifdef CONFIG_OF_LIBFDT\n        debug(\"using: FDT\\n\");\n        if (image_setup_linux(images)) {\n            printf(\"FDT creation failed! hanging...\");\n            hang();\n        }\n#endif\n    } else if (BOOTM_ENABLE_TAGS) {\n        debug(\"using: ATAGS\\n\");\n        setup_start_tag(gd->bd);\n        if (BOOTM_ENABLE_SERIAL_TAG)\n            setup_serial_tag(&params);\n        if (BOOTM_ENABLE_CMDLINE_TAG)\n            setup_commandline_tag(gd->bd, commandline);\n        if (BOOTM_ENABLE_REVISION_TAG)\n            setup_revision_tag(&params);\n        if (BOOTM_ENABLE_MEMORY_TAGS)\n            setup_memory_tags(gd->bd);\n        if (BOOTM_ENABLE_INITRD_TAG) {\n            if (images->initrd_start && images->initrd_end) {\n                setup_initrd_tag(gd->bd, images->initrd_start,\n                         images->initrd_end);\n            } else if (images->rd_start && images->rd_end) {\n                setup_initrd_tag(gd->bd, images->rd_start,\n                         images->rd_end);\n            }\n        }\n        setup_board_tags(&params);\n        setup_end_tag(gd->bd);\n    } else {\n        printf(\"FDT and ATAGS support not compiled in - hanging\\n\");\n        hang();\n    }\n}\n```\n\n\n\n\n","slug":"u-boot引导kernel启动过程","published":1,"updated":"2020-05-06T14:00:50.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv6000odqg1g3wt7gs9","content":"<h2 id=\"u-boot引导kernel启动过程\"><a href=\"#u-boot引导kernel启动过程\" class=\"headerlink\" title=\"u-boot引导kernel启动过程\"></a>u-boot引导kernel启动过程</h2><p>u-boot引导Linux kernel启动的过程；</p>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"bootm命令\"><a href=\"#bootm命令\" class=\"headerlink\" title=\"bootm命令\"></a>bootm命令</h3><p>bootm命令用于启动操作系统映像；bootm命令从映像文件的头部获取信息；包括：映像文件的CPU架构、操作系统类型、映像类型、压缩方式、映像文件在内存中的加载地址、映像文件运行的入口地址、映像文件名等；</p>\n<p>bootm将映像文件加载到指定的地址，解压映像并传递必要的内核启动参数给内核，最后跳转到入口地址进入内核，开始执行内核；</p>\n<p>bootm命令执行有三个步骤：</p>\n<p>解压Linux内核映像并将其加载到RAM中</p>\n<p>将ramdisk映像加载到RAM中</p>\n<p>将控制权交给内核，并向内核传递ramdisk在RAM中的位置和大小等信息</p>\n<p>将映像文件加载到RAM中时，需要确保映像文件的加载地址，不能与内核的位置有重叠；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cmd/bootm.c</span></span><br><span class=\"line\">U_BOOT_CMD(</span><br><span class=\"line\">    bootm,  CONFIG_SYS_MAXARGS, <span class=\"number\">1</span>,  do_bootm,</span><br><span class=\"line\">    <span class=\"string\">\"boot application image from memory\"</span>, bootm_help_text</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    bootm(bootm)-->do_bootm(do_bootm)</pre>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_bootm</span><br><span class=\"line\">　　-&gt;do_bootm_states</span><br><span class=\"line\">　　　　-&gt;bootm_start /bootm_find_os /bootm_find_other</span><br><span class=\"line\">　　　　　　-&gt;bootm_load_os</span><br><span class=\"line\">　　　　　　-&gt;boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class=\"line\">　　　　　　　　([IH_OS_LINUX] = do_bootm_linux,)　　</span><br><span class=\"line\">　　　　　　-&gt;boot_selected_os</span><br><span class=\"line\">　　　　　　　　-&gt;do_bootm_linux</span><br><span class=\"line\">　　　　　　　　　　-&gt;boot_prep_linux</span><br><span class=\"line\">　　　　　　　　　　　　-&gt;image_setup_linux</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;boot_fdt_add_mem_rsv_regions</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;boot_get_cmdline</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;boot_relocate_fdt</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;image_setup_libfdt</span><br><span class=\"line\">　　　　　　　　　　　　-&gt;boot_jump_linux</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;r2 = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)images-&gt;ft_addr;</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;kernel_entry(<span class=\"number\">0</span>, machid, r2);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h4 id=\"do-bootm\"><a href=\"#do-bootm\" class=\"headerlink\" title=\"do_bootm\"></a>do_bootm</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cmd/bootm.c</span></span><br><span class=\"line\"><span class=\"comment\">/*******************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/* bootm - boot application image from image in memory */</span></span><br><span class=\"line\"><span class=\"comment\">/*******************************************************************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_bootm</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* determine if we have a sub command */</span></span><br><span class=\"line\">    argc--; argv++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *endp;</span><br><span class=\"line\"></span><br><span class=\"line\">        simple_strtoul(argv[<span class=\"number\">0</span>], &amp;endp, <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"comment\">/* endp pointing to NULL means that argv[0] was just a</span></span><br><span class=\"line\"><span class=\"comment\">         * valid number, pass it along to the normal bootm processing</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * If endp is ':' or '#' assume a FIT identifier so pass</span></span><br><span class=\"line\"><span class=\"comment\">         * along for normal processing.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * Right now we assume the first arg should never be '-'</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*endp != <span class=\"number\">0</span>) &amp;&amp; (*endp != <span class=\"string\">':'</span>) &amp;&amp; (*endp != <span class=\"string\">'#'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |</span><br><span class=\"line\">        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |</span><br><span class=\"line\">        BOOTM_STATE_LOADOS |</span><br><span class=\"line\">#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH</span><br><span class=\"line\">        BOOTM_STATE_RAMDISK |</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class=\"line\">        BOOTM_STATE_OS_GO, &amp;images, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    do_bootm(do_bootm)-->do_bootm_states(do_bootm_states)\n    do_bootm-->do_bootm_subcommand(do_bootm_subcommand)-->do_bootm_states</pre>\n\n\n\n\n\n\n<p>bootm命令执行的核心操作由do_bootm_states()函数来完成；</p>\n<p>do_bootm_states()函数操作，是由参数states来决定的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/image.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_START   (0x00000001)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOS  (0x00000002)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOTHER   (0x00000004)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_LOADOS  (0x00000008)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_RAMDISK (0x00000010)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FDT     (0x00000020)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_CMDLINE  (0x00000040)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_BD_T (0x00000080)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_PREP (0x00000100)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_FAKE_GO  (0x00000200)    <span class=\"comment\">/* 'Almost' run the OS */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_GO   (0x00000400)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>do_bootm_states()函数的参数images，用来表示bootm命令启动kernel的一些信息，包含了指向os、initrd、fdt的映像信息；是全局变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"keyword\">bootm_headers_t</span> images;     <span class=\"comment\">/* pointers to os/initrd/fdt images */</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h4 id=\"do-bootm-states\"><a href=\"#do-bootm-states\" class=\"headerlink\" title=\"do_bootm_states\"></a>do_bootm_states</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_bootm_states</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> states, <span class=\"keyword\">bootm_headers_t</span> *images, <span class=\"keyword\">int</span> boot_progress)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    boot_os_fn *boot_fn;</span><br><span class=\"line\">    ulong iflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>, need_boot_fn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    images-&gt;state |= states;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class=\"line\">        ret = bootm_start(cmdtp, flag, argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class=\"line\">        ret = bootm_find_os(cmdtp, flag, argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER))</span><br><span class=\"line\">        ret = bootm_find_other(cmdtp, flag, argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Load the OS */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) &#123;</span><br><span class=\"line\">        iflag = bootm_disable_interrupts();</span><br><span class=\"line\">        ret = bootm_load_os(images, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Relocate the ramdisk */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) &#123;</span><br><span class=\"line\">        ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class=\"line\">            rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> IMAGE_ENABLE_OF_LIBFDT &amp;&amp; defined(CONFIG_LMB)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) &#123;</span><br><span class=\"line\">        boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class=\"line\">        ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class=\"line\">                    &amp;images-&gt;ft_len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class=\"line\">        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class=\"line\">        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_TRACE</span></span><br><span class=\"line\">    <span class=\"comment\">/* Pretend to run the OS, then run a user command */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *cmd_list = env_get(<span class=\"string\">\"fakegocmd\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,</span><br><span class=\"line\">                images, boot_fn);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class=\"line\">            ret = run_command_list(cmd_list, <span class=\"number\">-1</span>, flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Now run the OS! We hope this doesn't return */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))</span><br><span class=\"line\">        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span><br><span class=\"line\">                images, boot_fn);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    do_bootm_states(do_bootm_states)-->states(states)\n    states--BOOTM_STATE_START-->bootm_start(bootm_start)\n    states--BOOTM_STATE_FINDOS-->bootm_find_os(bootm_find_os)\n    states--BOOTM_STATE_FINDOTHER-->bootm_find_other(bootm_find_other)\n    states--BOOTM_STATE_LOADOS-->bootm_load_os(bootm_load_os)\n    states--BOOTM_STATE_RAMDISK-->boot_ramdisk_high(boot_ramdisk_high)\n    states--BOOTM_STATE_FDT-->boot_relocate_fdt(boot_relocate_fdt)\n    states--BOOTM_STATE_OS_PREP-->boot_fn(boot_fn)\n    states--BOOTM_STATE_OS_FAKE_GO-->boot_selected_os1(boot_selected_os)\n    states--BOOTM_STATE_OS_GO-->boot_selected_os2(boot_selected_os)</pre>\n\n\n\n\n\n\n\n\n<h4 id=\"bootm-start\"><a href=\"#bootm-start\" class=\"headerlink\" title=\"bootm_start\"></a>bootm_start</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bootm_start</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span> *)&amp;images, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(images));</span><br><span class=\"line\">    images.verify = env_get_yesno(<span class=\"string\">\"verify\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    boot_start_lmb(&amp;images);</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, <span class=\"string\">\"bootm_start\"</span>);</span><br><span class=\"line\">    images.state = BOOTM_STATE_START;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"bootm-find-os\"><a href=\"#bootm-find-os\" class=\"headerlink\" title=\"bootm_find_os\"></a>bootm_find_os</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bootm_find_os</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *os_hdr;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ep_found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* get kernel image header, start address and length */</span></span><br><span class=\"line\">    os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,</span><br><span class=\"line\">            &amp;images, &amp;images.os.image_start, &amp;images.os.image_len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (images.os.image_len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">\"ERROR: can't get kernel image!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* get image parameters */</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (genimg_get_format(os_hdr)) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> IMAGE_FORMAT_LEGACY:</span><br><span class=\"line\">        images.os.type = image_get_type(os_hdr);</span><br><span class=\"line\">        images.os.comp = image_get_comp(os_hdr);</span><br><span class=\"line\">        images.os.os = image_get_os(os_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">        images.os.<span class=\"built_in\">end</span> = image_get_image_end(os_hdr);</span><br><span class=\"line\">        images.os.load = image_get_load(os_hdr);</span><br><span class=\"line\">        images.os.arch = image_get_arch(os_hdr);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (images.legacy_hdr_valid) &#123;</span><br><span class=\"line\">        images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    images.os.start = map_to_sysmem(os_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    bootm_find_os(bootm_find_os)-->boot_get_kernel(boot_get_kernel)\n    boot_get_kernel-->images_os1(images.os)\n    images_os1-->image_start(image_start)\n    images_os1-->image_len(image_len)\n    bootm_find_os--IMAGE_FORMAT_LEGACY-->images_os(images.os)\n    images_os-->type(type)\n    images_os-->comp(comp)\n    images_os-->os(os)\n    images_os-->start(start)\n    images_os-->endend(end)\n    images_os-->load(load)\n    images_os-->arch(arch)</pre>\n\n\n\n<h5 id=\"boot-get-kernel\"><a href=\"#boot-get-kernel\" class=\"headerlink\" title=\"boot_get_kernel\"></a>boot_get_kernel</h5><p>boot_get_kernel()函数，获取内核映像的头、起始地址、长度；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm_os.c</span></span><br><span class=\"line\"><span class=\"function\">boot_os_fn *<span class=\"title\">bootm_os_get_boot_func</span><span class=\"params\">(<span class=\"keyword\">int</span> os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> relocated;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!relocated) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* relocate boot function table */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; ARRAY_SIZE(boot_os); i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boot_os[i] != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                boot_os[i] += gd-&gt;reloc_off;</span><br><span class=\"line\"></span><br><span class=\"line\">        relocated = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> boot_os[os];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm_os.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> boot_os_fn *boot_os[] = &#123;</span><br><span class=\"line\">    [IH_OS_U_BOOT] = do_bootm_standalone,</span><br><span class=\"line\">#ifdef CONFIG_BOOTM_LINUX</span><br><span class=\"line\">    [IH_OS_LINUX] = do_bootm_linux,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>u-boot中支持bootm命令需要打开CONFIG_BOOTM_LINUX和CONFIG_CMD_BOOTM配置，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_BOOTM_LINUX&#x3D;y</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    do_bootm_states(do_bootm_states)\n    -->bootm_os_get_boot_func(bootm_os_get_boot_func)\n    -->boot_os(\"boot_os[os]\")\n    -->do_bootm_linux(do_bootm_linux)</pre>\n\n\n\n\n\n\n<h4 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h4><p>bootm_headers_t结构是用来表示bootm命令启动kernel的一些信息的结构体，包含了指向os、initrd、fdt的映像信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"keyword\">bootm_headers_t</span> images;     <span class=\"comment\">/* pointers to os/initrd/fdt images */</span></span><br></pre></td></tr></table></figure>\n\n\n<p>bootm命令中，会根据参数以及参数指向的映像来填充bootm_headers_t结构体中的成员；最后再使用这个结构体中的信息填充kernel启动信息，并跳转到kernel执行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/image.h</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Legacy and FIT format headers used by do_bootm() and do_bootm_&lt;os&gt;()</span></span><br><span class=\"line\"><span class=\"comment\"> * routines.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bootm_headers</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Legacy os image header, if it is a multi component image</span></span><br><span class=\"line\"><span class=\"comment\">     * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class=\"line\"><span class=\"comment\">     * data from second and third component accordingly.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">image_header_t</span>  *legacy_hdr_os;     <span class=\"comment\">/* image header pointer */</span></span><br><span class=\"line\">    <span class=\"keyword\">image_header_t</span>  legacy_hdr_os_copy; <span class=\"comment\">/* header copy */</span></span><br><span class=\"line\">    ulong       legacy_hdr_valid;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> IMAGE_ENABLE_FIT</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_cfg; <span class=\"comment\">/* configuration node unit name */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_os;    <span class=\"comment\">/* os FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_os;  <span class=\"comment\">/* os subimage node unit name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_os; <span class=\"comment\">/* os subimage node offset */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_rd;    <span class=\"comment\">/* init ramdisk FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_rd;  <span class=\"comment\">/* init ramdisk subimage node unit name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_rd; <span class=\"comment\">/* init ramdisk subimage node offset */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_fdt;   <span class=\"comment\">/* FDT blob FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_fdt; <span class=\"comment\">/* FDT blob subimage node unit name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_fdt;<span class=\"comment\">/* FDT blob subimage node offset */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_setup; <span class=\"comment\">/* x86 setup FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_setup; <span class=\"comment\">/* x86 setup subimage node name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_setup;<span class=\"comment\">/* x86 setup subimage node offset */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> USE_HOSTCC</span></span><br><span class=\"line\">    <span class=\"keyword\">image_info_t</span>    os;     <span class=\"comment\">/* os image info */</span></span><br><span class=\"line\">    ulong       ep;     <span class=\"comment\">/* entry point of OS */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ulong       rd_start, rd_end;<span class=\"comment\">/* ramdisk start/end */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>        *ft_addr;   <span class=\"comment\">/* flat dev tree address */</span></span><br><span class=\"line\">    ulong       ft_len;     <span class=\"comment\">/* length of flat device tree */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ulong       initrd_start;</span><br><span class=\"line\">    ulong       initrd_end;</span><br><span class=\"line\">    ulong       cmdline_start;</span><br><span class=\"line\">    ulong       cmdline_end;</span><br><span class=\"line\">    <span class=\"keyword\">bd_t</span>        *kbd;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     verify;     <span class=\"comment\">/* env_get(\"verify\")[0] != 'n' */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_START   (0x00000001)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOS  (0x00000002)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOTHER   (0x00000004)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_LOADOS  (0x00000008)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_RAMDISK (0x00000010)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FDT     (0x00000020)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_CMDLINE  (0x00000040)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_BD_T (0x00000080)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_PREP (0x00000100)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_FAKE_GO  (0x00000200)    <span class=\"comment\">/* 'Almost' run the OS */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_GO   (0x00000400)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_LMB</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lmb</span>  <span class=\"title\">lmb</span>;</span>        <span class=\"comment\">/* for memory mgmt */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; <span class=\"keyword\">bootm_headers_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"do-bootm-linux\"><a href=\"#do-bootm-linux\" class=\"headerlink\" title=\"do_bootm_linux\"></a>do_bootm_linux</h4><p>为了能够正常调用do_bootm_linux函数，需要打开CONFIG_CMD_BOOTM配置；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_CMD_BOOTM&#x3D;y</span><br></pre></td></tr></table></figure>\n\n\n<p>因为do_bootm_linux函数是平台相关的函数，需要在arm平台下打开对应的CONFIG_CMD_BOOTM配置；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch&#x2F;arm&#x2F;lib&#x2F;Makefile:34:obj-$(CONFIG_CMD_BOOTM) +&#x3D; bootm.o</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    do_bootm_linux(do_bootm_linux)-->boot_prep_linux(boot_prep_linux)\n    do_bootm_linux-->boot_jump_linux(boot_jump_linux)</pre>\n\n\n\n\n\n\n\n\n<p>do_bootm_linux()函数是bootm实现的主要入口点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/lib/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_bootm_linux</span><span class=\"params\">(<span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">bootm_headers_t</span> *images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class=\"line\">        boot_prep_linux(images);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class=\"line\">        boot_jump_linux(images, flag);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    boot_prep_linux(images);</span><br><span class=\"line\">    boot_jump_linux(images, flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h3 id=\"u-boot给Kernel传参\"><a href=\"#u-boot给Kernel传参\" class=\"headerlink\" title=\"u-boot给Kernel传参\"></a>u-boot给Kernel传参</h3><p>嵌入式环境的Linux内核运行需要通过u-boot来加载并启动运行，在内核启动之前，由u-boot来提供Kernel的运行环境，同时将启动需要的参数传递给Kernel；</p>\n<p><strong>传参方法</strong>：将要传递的参数，封装成一个结构体，把这个结构体连续存储在内存的一片区域，将内存区域的物理地址传递给内核，内核在启动时从指定的物理地址中读取参数，并通过parse_tags()来解析参数，就完成了给kernel传参；</p>\n<p>u-boot中定义这个结构体为tag：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/include/asm/setup.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> <span class=\"title\">hdr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_core</span>     <span class=\"title\">core</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_mem32</span>    <span class=\"title\">mem</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videotext</span>    <span class=\"title\">videotext</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_ramdisk</span>  <span class=\"title\">ramdisk</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_initrd</span>   <span class=\"title\">initrd</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_serialnr</span> <span class=\"title\">serialnr</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_revision</span> <span class=\"title\">revision</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videolfb</span> <span class=\"title\">videolfb</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_cmdline</span>  <span class=\"title\">cmdline</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_acorn</span>    <span class=\"title\">acorn</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_memclk</span>   <span class=\"title\">memclk</span>;</span></span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>这个数据结构在u-boot和kernel中都有定义，并且必须保持一致；</p>\n<p>其中tag_header为tag头，表明tag的类型和大小，类型是用来区别tag之间不同的处理函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/include/asm/setup.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> &#123;</span></span><br><span class=\"line\">    u32 <span class=\"built_in\">size</span>;</span><br><span class=\"line\">    u32 tag;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>这个链表必须以tag_header.tag = ATAG_CORE开始，以tag_header.tag = ATAG_NONE结束；</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/lib/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">boot_prep_linux</span><span class=\"params\">(<span class=\"keyword\">bootm_headers_t</span> *images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *commandline = env_get(<span class=\"string\">\"bootargs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_OF_LIBFDT</span></span><br><span class=\"line\">        debug(<span class=\"string\">\"using: FDT\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image_setup_linux(images)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"FDT creation failed! hanging...\"</span>);</span><br><span class=\"line\">            hang();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BOOTM_ENABLE_TAGS) &#123;</span><br><span class=\"line\">        debug(<span class=\"string\">\"using: ATAGS\\n\"</span>);</span><br><span class=\"line\">        setup_start_tag(gd-&gt;bd);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_SERIAL_TAG)</span><br><span class=\"line\">            setup_serial_tag(&amp;params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_CMDLINE_TAG)</span><br><span class=\"line\">            setup_commandline_tag(gd-&gt;bd, commandline);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_REVISION_TAG)</span><br><span class=\"line\">            setup_revision_tag(&amp;params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_MEMORY_TAGS)</span><br><span class=\"line\">            setup_memory_tags(gd-&gt;bd);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_INITRD_TAG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (images-&gt;initrd_start &amp;&amp; images-&gt;initrd_end) &#123;</span><br><span class=\"line\">                setup_initrd_tag(gd-&gt;bd, images-&gt;initrd_start,</span><br><span class=\"line\">                         images-&gt;initrd_end);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (images-&gt;rd_start &amp;&amp; images-&gt;rd_end) &#123;</span><br><span class=\"line\">                setup_initrd_tag(gd-&gt;bd, images-&gt;rd_start,</span><br><span class=\"line\">                         images-&gt;rd_end);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setup_board_tags(&amp;params);</span><br><span class=\"line\">        setup_end_tag(gd-&gt;bd);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"FDT and ATAGS support not compiled in - hanging\\n\"</span>);</span><br><span class=\"line\">        hang();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"u-boot引导kernel启动过程\"><a href=\"#u-boot引导kernel启动过程\" class=\"headerlink\" title=\"u-boot引导kernel启动过程\"></a>u-boot引导kernel启动过程</h2><p>u-boot引导Linux kernel启动的过程；</p>","more":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<h3 id=\"bootm命令\"><a href=\"#bootm命令\" class=\"headerlink\" title=\"bootm命令\"></a>bootm命令</h3><p>bootm命令用于启动操作系统映像；bootm命令从映像文件的头部获取信息；包括：映像文件的CPU架构、操作系统类型、映像类型、压缩方式、映像文件在内存中的加载地址、映像文件运行的入口地址、映像文件名等；</p>\n<p>bootm将映像文件加载到指定的地址，解压映像并传递必要的内核启动参数给内核，最后跳转到入口地址进入内核，开始执行内核；</p>\n<p>bootm命令执行有三个步骤：</p>\n<p>解压Linux内核映像并将其加载到RAM中</p>\n<p>将ramdisk映像加载到RAM中</p>\n<p>将控制权交给内核，并向内核传递ramdisk在RAM中的位置和大小等信息</p>\n<p>将映像文件加载到RAM中时，需要确保映像文件的加载地址，不能与内核的位置有重叠；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cmd/bootm.c</span></span><br><span class=\"line\">U_BOOT_CMD(</span><br><span class=\"line\">    bootm,  CONFIG_SYS_MAXARGS, <span class=\"number\">1</span>,  do_bootm,</span><br><span class=\"line\">    <span class=\"string\">\"boot application image from memory\"</span>, bootm_help_text</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    bootm(bootm)-->do_bootm(do_bootm)</pre>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_bootm</span><br><span class=\"line\">　　-&gt;do_bootm_states</span><br><span class=\"line\">　　　　-&gt;bootm_start /bootm_find_os /bootm_find_other</span><br><span class=\"line\">　　　　　　-&gt;bootm_load_os</span><br><span class=\"line\">　　　　　　-&gt;boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class=\"line\">　　　　　　　　([IH_OS_LINUX] = do_bootm_linux,)　　</span><br><span class=\"line\">　　　　　　-&gt;boot_selected_os</span><br><span class=\"line\">　　　　　　　　-&gt;do_bootm_linux</span><br><span class=\"line\">　　　　　　　　　　-&gt;boot_prep_linux</span><br><span class=\"line\">　　　　　　　　　　　　-&gt;image_setup_linux</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;boot_fdt_add_mem_rsv_regions</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;boot_get_cmdline</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;boot_relocate_fdt</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;image_setup_libfdt</span><br><span class=\"line\">　　　　　　　　　　　　-&gt;boot_jump_linux</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;r2 = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)images-&gt;ft_addr;</span><br><span class=\"line\">　　　　　　　　　　　　　　-&gt;kernel_entry(<span class=\"number\">0</span>, machid, r2);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<h4 id=\"do-bootm\"><a href=\"#do-bootm\" class=\"headerlink\" title=\"do_bootm\"></a>do_bootm</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cmd/bootm.c</span></span><br><span class=\"line\"><span class=\"comment\">/*******************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/* bootm - boot application image from image in memory */</span></span><br><span class=\"line\"><span class=\"comment\">/*******************************************************************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_bootm</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* determine if we have a sub command */</span></span><br><span class=\"line\">    argc--; argv++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *endp;</span><br><span class=\"line\"></span><br><span class=\"line\">        simple_strtoul(argv[<span class=\"number\">0</span>], &amp;endp, <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"comment\">/* endp pointing to NULL means that argv[0] was just a</span></span><br><span class=\"line\"><span class=\"comment\">         * valid number, pass it along to the normal bootm processing</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * If endp is ':' or '#' assume a FIT identifier so pass</span></span><br><span class=\"line\"><span class=\"comment\">         * along for normal processing.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * Right now we assume the first arg should never be '-'</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*endp != <span class=\"number\">0</span>) &amp;&amp; (*endp != <span class=\"string\">':'</span>) &amp;&amp; (*endp != <span class=\"string\">'#'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |</span><br><span class=\"line\">        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |</span><br><span class=\"line\">        BOOTM_STATE_LOADOS |</span><br><span class=\"line\">#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH</span><br><span class=\"line\">        BOOTM_STATE_RAMDISK |</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class=\"line\">        BOOTM_STATE_OS_GO, &amp;images, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    do_bootm(do_bootm)-->do_bootm_states(do_bootm_states)\n    do_bootm-->do_bootm_subcommand(do_bootm_subcommand)-->do_bootm_states</pre>\n\n\n\n\n\n\n<p>bootm命令执行的核心操作由do_bootm_states()函数来完成；</p>\n<p>do_bootm_states()函数操作，是由参数states来决定的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/image.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_START   (0x00000001)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOS  (0x00000002)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOTHER   (0x00000004)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_LOADOS  (0x00000008)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_RAMDISK (0x00000010)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FDT     (0x00000020)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_CMDLINE  (0x00000040)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_BD_T (0x00000080)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_PREP (0x00000100)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_FAKE_GO  (0x00000200)    <span class=\"comment\">/* 'Almost' run the OS */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_GO   (0x00000400)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>do_bootm_states()函数的参数images，用来表示bootm命令启动kernel的一些信息，包含了指向os、initrd、fdt的映像信息；是全局变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"keyword\">bootm_headers_t</span> images;     <span class=\"comment\">/* pointers to os/initrd/fdt images */</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h4 id=\"do-bootm-states\"><a href=\"#do-bootm-states\" class=\"headerlink\" title=\"do_bootm_states\"></a>do_bootm_states</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_bootm_states</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> states, <span class=\"keyword\">bootm_headers_t</span> *images, <span class=\"keyword\">int</span> boot_progress)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    boot_os_fn *boot_fn;</span><br><span class=\"line\">    ulong iflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>, need_boot_fn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    images-&gt;state |= states;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class=\"line\">        ret = bootm_start(cmdtp, flag, argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class=\"line\">        ret = bootm_find_os(cmdtp, flag, argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER))</span><br><span class=\"line\">        ret = bootm_find_other(cmdtp, flag, argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Load the OS */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) &#123;</span><br><span class=\"line\">        iflag = bootm_disable_interrupts();</span><br><span class=\"line\">        ret = bootm_load_os(images, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Relocate the ramdisk */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) &#123;</span><br><span class=\"line\">        ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class=\"line\">            rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> IMAGE_ENABLE_OF_LIBFDT &amp;&amp; defined(CONFIG_LMB)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) &#123;</span><br><span class=\"line\">        boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class=\"line\">        ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class=\"line\">                    &amp;images-&gt;ft_len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class=\"line\">        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class=\"line\">        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_TRACE</span></span><br><span class=\"line\">    <span class=\"comment\">/* Pretend to run the OS, then run a user command */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *cmd_list = env_get(<span class=\"string\">\"fakegocmd\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,</span><br><span class=\"line\">                images, boot_fn);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class=\"line\">            ret = run_command_list(cmd_list, <span class=\"number\">-1</span>, flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Now run the OS! We hope this doesn't return */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))</span><br><span class=\"line\">        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span><br><span class=\"line\">                images, boot_fn);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    do_bootm_states(do_bootm_states)-->states(states)\n    states--BOOTM_STATE_START-->bootm_start(bootm_start)\n    states--BOOTM_STATE_FINDOS-->bootm_find_os(bootm_find_os)\n    states--BOOTM_STATE_FINDOTHER-->bootm_find_other(bootm_find_other)\n    states--BOOTM_STATE_LOADOS-->bootm_load_os(bootm_load_os)\n    states--BOOTM_STATE_RAMDISK-->boot_ramdisk_high(boot_ramdisk_high)\n    states--BOOTM_STATE_FDT-->boot_relocate_fdt(boot_relocate_fdt)\n    states--BOOTM_STATE_OS_PREP-->boot_fn(boot_fn)\n    states--BOOTM_STATE_OS_FAKE_GO-->boot_selected_os1(boot_selected_os)\n    states--BOOTM_STATE_OS_GO-->boot_selected_os2(boot_selected_os)</pre>\n\n\n\n\n\n\n\n\n<h4 id=\"bootm-start\"><a href=\"#bootm-start\" class=\"headerlink\" title=\"bootm_start\"></a>bootm_start</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bootm_start</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span> *)&amp;images, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(images));</span><br><span class=\"line\">    images.verify = env_get_yesno(<span class=\"string\">\"verify\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    boot_start_lmb(&amp;images);</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, <span class=\"string\">\"bootm_start\"</span>);</span><br><span class=\"line\">    images.state = BOOTM_STATE_START;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"bootm-find-os\"><a href=\"#bootm-find-os\" class=\"headerlink\" title=\"bootm_find_os\"></a>bootm_find_os</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bootm_find_os</span><span class=\"params\">(<span class=\"keyword\">cmd_tbl_t</span> *cmdtp, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *os_hdr;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ep_found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* get kernel image header, start address and length */</span></span><br><span class=\"line\">    os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,</span><br><span class=\"line\">            &amp;images, &amp;images.os.image_start, &amp;images.os.image_len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (images.os.image_len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">\"ERROR: can't get kernel image!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* get image parameters */</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (genimg_get_format(os_hdr)) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> IMAGE_FORMAT_LEGACY:</span><br><span class=\"line\">        images.os.type = image_get_type(os_hdr);</span><br><span class=\"line\">        images.os.comp = image_get_comp(os_hdr);</span><br><span class=\"line\">        images.os.os = image_get_os(os_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">        images.os.<span class=\"built_in\">end</span> = image_get_image_end(os_hdr);</span><br><span class=\"line\">        images.os.load = image_get_load(os_hdr);</span><br><span class=\"line\">        images.os.arch = image_get_arch(os_hdr);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (images.legacy_hdr_valid) &#123;</span><br><span class=\"line\">        images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    images.os.start = map_to_sysmem(os_hdr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<pre class=\"mermaid\">graph LR\n    bootm_find_os(bootm_find_os)-->boot_get_kernel(boot_get_kernel)\n    boot_get_kernel-->images_os1(images.os)\n    images_os1-->image_start(image_start)\n    images_os1-->image_len(image_len)\n    bootm_find_os--IMAGE_FORMAT_LEGACY-->images_os(images.os)\n    images_os-->type(type)\n    images_os-->comp(comp)\n    images_os-->os(os)\n    images_os-->start(start)\n    images_os-->endend(end)\n    images_os-->load(load)\n    images_os-->arch(arch)</pre>\n\n\n\n<h5 id=\"boot-get-kernel\"><a href=\"#boot-get-kernel\" class=\"headerlink\" title=\"boot_get_kernel\"></a>boot_get_kernel</h5><p>boot_get_kernel()函数，获取内核映像的头、起始地址、长度；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm_os.c</span></span><br><span class=\"line\"><span class=\"function\">boot_os_fn *<span class=\"title\">bootm_os_get_boot_func</span><span class=\"params\">(<span class=\"keyword\">int</span> os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> relocated;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!relocated) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* relocate boot function table */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; ARRAY_SIZE(boot_os); i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boot_os[i] != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                boot_os[i] += gd-&gt;reloc_off;</span><br><span class=\"line\"></span><br><span class=\"line\">        relocated = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> boot_os[os];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm_os.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> boot_os_fn *boot_os[] = &#123;</span><br><span class=\"line\">    [IH_OS_U_BOOT] = do_bootm_standalone,</span><br><span class=\"line\">#ifdef CONFIG_BOOTM_LINUX</span><br><span class=\"line\">    [IH_OS_LINUX] = do_bootm_linux,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>u-boot中支持bootm命令需要打开CONFIG_BOOTM_LINUX和CONFIG_CMD_BOOTM配置，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_BOOTM_LINUX&#x3D;y</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    do_bootm_states(do_bootm_states)\n    -->bootm_os_get_boot_func(bootm_os_get_boot_func)\n    -->boot_os(\"boot_os[os]\")\n    -->do_bootm_linux(do_bootm_linux)</pre>\n\n\n\n\n\n\n<h4 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h4><p>bootm_headers_t结构是用来表示bootm命令启动kernel的一些信息的结构体，包含了指向os、initrd、fdt的映像信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common/bootm.c</span></span><br><span class=\"line\"><span class=\"keyword\">bootm_headers_t</span> images;     <span class=\"comment\">/* pointers to os/initrd/fdt images */</span></span><br></pre></td></tr></table></figure>\n\n\n<p>bootm命令中，会根据参数以及参数指向的映像来填充bootm_headers_t结构体中的成员；最后再使用这个结构体中的信息填充kernel启动信息，并跳转到kernel执行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/image.h</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Legacy and FIT format headers used by do_bootm() and do_bootm_&lt;os&gt;()</span></span><br><span class=\"line\"><span class=\"comment\"> * routines.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bootm_headers</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Legacy os image header, if it is a multi component image</span></span><br><span class=\"line\"><span class=\"comment\">     * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class=\"line\"><span class=\"comment\">     * data from second and third component accordingly.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">image_header_t</span>  *legacy_hdr_os;     <span class=\"comment\">/* image header pointer */</span></span><br><span class=\"line\">    <span class=\"keyword\">image_header_t</span>  legacy_hdr_os_copy; <span class=\"comment\">/* header copy */</span></span><br><span class=\"line\">    ulong       legacy_hdr_valid;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> IMAGE_ENABLE_FIT</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_cfg; <span class=\"comment\">/* configuration node unit name */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_os;    <span class=\"comment\">/* os FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_os;  <span class=\"comment\">/* os subimage node unit name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_os; <span class=\"comment\">/* os subimage node offset */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_rd;    <span class=\"comment\">/* init ramdisk FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_rd;  <span class=\"comment\">/* init ramdisk subimage node unit name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_rd; <span class=\"comment\">/* init ramdisk subimage node offset */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_fdt;   <span class=\"comment\">/* FDT blob FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_fdt; <span class=\"comment\">/* FDT blob subimage node unit name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_fdt;<span class=\"comment\">/* FDT blob subimage node offset */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>        *fit_hdr_setup; <span class=\"comment\">/* x86 setup FIT image header */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *fit_uname_setup; <span class=\"comment\">/* x86 setup subimage node name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     fit_noffset_setup;<span class=\"comment\">/* x86 setup subimage node offset */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> USE_HOSTCC</span></span><br><span class=\"line\">    <span class=\"keyword\">image_info_t</span>    os;     <span class=\"comment\">/* os image info */</span></span><br><span class=\"line\">    ulong       ep;     <span class=\"comment\">/* entry point of OS */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ulong       rd_start, rd_end;<span class=\"comment\">/* ramdisk start/end */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>        *ft_addr;   <span class=\"comment\">/* flat dev tree address */</span></span><br><span class=\"line\">    ulong       ft_len;     <span class=\"comment\">/* length of flat device tree */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ulong       initrd_start;</span><br><span class=\"line\">    ulong       initrd_end;</span><br><span class=\"line\">    ulong       cmdline_start;</span><br><span class=\"line\">    ulong       cmdline_end;</span><br><span class=\"line\">    <span class=\"keyword\">bd_t</span>        *kbd;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     verify;     <span class=\"comment\">/* env_get(\"verify\")[0] != 'n' */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_START   (0x00000001)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOS  (0x00000002)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FINDOTHER   (0x00000004)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_LOADOS  (0x00000008)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_RAMDISK (0x00000010)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_FDT     (0x00000020)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_CMDLINE  (0x00000040)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_BD_T (0x00000080)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_PREP (0x00000100)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_FAKE_GO  (0x00000200)    <span class=\"comment\">/* 'Almost' run the OS */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BOOTM_STATE_OS_GO   (0x00000400)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>     state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_LMB</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lmb</span>  <span class=\"title\">lmb</span>;</span>        <span class=\"comment\">/* for memory mgmt */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; <span class=\"keyword\">bootm_headers_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"do-bootm-linux\"><a href=\"#do-bootm-linux\" class=\"headerlink\" title=\"do_bootm_linux\"></a>do_bootm_linux</h4><p>为了能够正常调用do_bootm_linux函数，需要打开CONFIG_CMD_BOOTM配置；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_CMD_BOOTM&#x3D;y</span><br></pre></td></tr></table></figure>\n\n\n<p>因为do_bootm_linux函数是平台相关的函数，需要在arm平台下打开对应的CONFIG_CMD_BOOTM配置；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arch&#x2F;arm&#x2F;lib&#x2F;Makefile:34:obj-$(CONFIG_CMD_BOOTM) +&#x3D; bootm.o</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    do_bootm_linux(do_bootm_linux)-->boot_prep_linux(boot_prep_linux)\n    do_bootm_linux-->boot_jump_linux(boot_jump_linux)</pre>\n\n\n\n\n\n\n\n\n<p>do_bootm_linux()函数是bootm实现的主要入口点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/lib/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">do_bootm_linux</span><span class=\"params\">(<span class=\"keyword\">int</span> flag, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> argv[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">bootm_headers_t</span> *images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class=\"line\">        boot_prep_linux(images);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class=\"line\">        boot_jump_linux(images, flag);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    boot_prep_linux(images);</span><br><span class=\"line\">    boot_jump_linux(images, flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h3 id=\"u-boot给Kernel传参\"><a href=\"#u-boot给Kernel传参\" class=\"headerlink\" title=\"u-boot给Kernel传参\"></a>u-boot给Kernel传参</h3><p>嵌入式环境的Linux内核运行需要通过u-boot来加载并启动运行，在内核启动之前，由u-boot来提供Kernel的运行环境，同时将启动需要的参数传递给Kernel；</p>\n<p><strong>传参方法</strong>：将要传递的参数，封装成一个结构体，把这个结构体连续存储在内存的一片区域，将内存区域的物理地址传递给内核，内核在启动时从指定的物理地址中读取参数，并通过parse_tags()来解析参数，就完成了给kernel传参；</p>\n<p>u-boot中定义这个结构体为tag：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/include/asm/setup.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> <span class=\"title\">hdr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_core</span>     <span class=\"title\">core</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_mem32</span>    <span class=\"title\">mem</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videotext</span>    <span class=\"title\">videotext</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_ramdisk</span>  <span class=\"title\">ramdisk</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_initrd</span>   <span class=\"title\">initrd</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_serialnr</span> <span class=\"title\">serialnr</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_revision</span> <span class=\"title\">revision</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_videolfb</span> <span class=\"title\">videolfb</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_cmdline</span>  <span class=\"title\">cmdline</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_acorn</span>    <span class=\"title\">acorn</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_memclk</span>   <span class=\"title\">memclk</span>;</span></span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>这个数据结构在u-boot和kernel中都有定义，并且必须保持一致；</p>\n<p>其中tag_header为tag头，表明tag的类型和大小，类型是用来区别tag之间不同的处理函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/include/asm/setup.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag_header</span> &#123;</span></span><br><span class=\"line\">    u32 <span class=\"built_in\">size</span>;</span><br><span class=\"line\">    u32 tag;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>这个链表必须以tag_header.tag = ATAG_CORE开始，以tag_header.tag = ATAG_NONE结束；</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arch/arm/lib/bootm.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">boot_prep_linux</span><span class=\"params\">(<span class=\"keyword\">bootm_headers_t</span> *images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *commandline = env_get(<span class=\"string\">\"bootargs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_OF_LIBFDT</span></span><br><span class=\"line\">        debug(<span class=\"string\">\"using: FDT\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image_setup_linux(images)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"FDT creation failed! hanging...\"</span>);</span><br><span class=\"line\">            hang();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BOOTM_ENABLE_TAGS) &#123;</span><br><span class=\"line\">        debug(<span class=\"string\">\"using: ATAGS\\n\"</span>);</span><br><span class=\"line\">        setup_start_tag(gd-&gt;bd);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_SERIAL_TAG)</span><br><span class=\"line\">            setup_serial_tag(&amp;params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_CMDLINE_TAG)</span><br><span class=\"line\">            setup_commandline_tag(gd-&gt;bd, commandline);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_REVISION_TAG)</span><br><span class=\"line\">            setup_revision_tag(&amp;params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_MEMORY_TAGS)</span><br><span class=\"line\">            setup_memory_tags(gd-&gt;bd);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BOOTM_ENABLE_INITRD_TAG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (images-&gt;initrd_start &amp;&amp; images-&gt;initrd_end) &#123;</span><br><span class=\"line\">                setup_initrd_tag(gd-&gt;bd, images-&gt;initrd_start,</span><br><span class=\"line\">                         images-&gt;initrd_end);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (images-&gt;rd_start &amp;&amp; images-&gt;rd_end) &#123;</span><br><span class=\"line\">                setup_initrd_tag(gd-&gt;bd, images-&gt;rd_start,</span><br><span class=\"line\">                         images-&gt;rd_end);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setup_board_tags(&amp;params);</span><br><span class=\"line\">        setup_end_tag(gd-&gt;bd);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"FDT and ATAGS support not compiled in - hanging\\n\"</span>);</span><br><span class=\"line\">        hang();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"阶段性自我反思及学习动员----2019.07.07","date":"2019-07-07T14:47:42.000Z","_content":"\n\n\n## 自我反思及学习动员\n\n&emsp;&emsp;Time is flying! 转眼间，工作已经这么多年了，按理说，在职场经过这么多年时间的洗礼，我也应该被洗成职场老手了；然而事实上，老的只是年龄，技术方面一点也不老，甚至还比不过一个刚入职的职场新人。\n\n<!--more-->\n\n![图片发自简书App](http://upload-images.jianshu.io/upload_images/9159706-9206c81a7cc48f8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50)\n\n\n\n### 深刻反思\n\n有上述中的不安全感，究其原因，有如下反思：\n\n1、**缺乏反思**；自己在工作、学习中碰到过不少问题，在解决问题之后没有花费时间和精力去做好总结和记录，致使好多碰到过的问题，再次碰到时还是不知道怎么处理，还得重新去想办法解决，即花费了时间精力，又没有很好的学习提高成效。\n2、**书看的少**；至少是看的还不够多，平时书买了不少，放在书架上都快放不下了，可是真正读完的很少。\n3、**学而不用**；读书的过程，只是粗枝大叶地翻看阅读，很少有更进一步细致分析，也没有过多的去实践应用，导致看书学习到的知识点印象不是很深，只是知道怎么用，而具体的内部细节就不太明白，甚至还有一部分用不到的知识点，前边看完，后来再看还是觉得很新鲜。\n4、**浪费太多时间**；平时总是以工作忙、加班累为借口给自己开脱，浪费大量时间上网、看电影、刷新闻，导致一天天宝贵的时间流逝浪费。\n5、**基础不牢**；非计算机专业科班出身，没有上过操作系统类专业课程，自学Linux内核驱动，总是感觉不得要领，感觉学习内容不够系统，有些知识点都是知其然不知其所以然，所谓基础不牢地动山摇，就是这样。\n\n&emsp;&emsp;程序员的成长过程，可不是一般职业的熬资历就能够实现的，程序员只会越熬越废，必须抓住空闲时间，不断学习，不断提高自己的技术水平，工作中不断去实践检验所学知识点，在学习和实践中脚踏实地，一步一个脚印地成长。\n\n\n### 回炉重造\n\n&emsp;&emsp;到了这个时候，发现自己基础知识不够牢靠，所学对于所求有点供不应求，虽然有点晚，但是也不至于无药可救。引用不知道哪位大神所说的一句话，”努力学习最坏的结果也不过是大器晚成“。所以最狠、最痛苦、也最有成效的解决方法就是--回炉重造。\n\n重造，必须要修正以前不好的学习习惯，纠正自己的学习方法：\n\n1、**学习要用心**；书中的内容是作者总结的杰出成果，并不是占有了书籍就占有了书中的知识点，必须细致认真地去读、去分析、消化、吸收，要高质量地读书。\n2、**边学边实践**；学习的过程中，要伴随着时间，用实践来检验所学知识点，不仅能够加深对知识点的印象，更能对知识点有更好的理解。\n3、**重视基础**；不能因为某些小知识点觉得简单，就不去学不去看，这样会导致眼高手低，看着知识点都知道，实际使用却又不会了，必须耐住性子，不厌其烦地去学习好基础知识。\n4、**多学习总结**；工作、学习中碰到问题，在解决之后，多写问题总结，记录碰到过的大小问题，作为日后查询的资料；学习过程中多写学习总结，针对知识点追根溯源，弄明白知识点的来龙去脉，不仅要知其然，也要知其所以然。\n5、**利用琐碎时间**；工作虽忙，加班虽累，总是可以抽出时间来学习的，比如：午饭后、午休前、晚饭后、睡觉前等可以用来玩手机、刷新闻的所有时间都可以用来学习，要善于利用空闲的时间，积少成多也能看好多书，学习好多知识点。\n\n\n### 写技术总结并发博客\n\n写学习总结、甚至发博客的好处：\n\n1、**可以查漏补缺**；不管写的好不好，都要就要坚持发总结博客，这样有助于发现自己学习的不足，即使写的不好，发出来或许会有博友留言吐槽，或者碰到更好的能指出博客中的错误之处，就更有助于进行查漏补缺，也能起到检验自己所学知识点\n2、**可以激励自己**；在坚持写学习总结并发博客一段时间后，回过头来翻看自己发过的博客，还是很有成就感的。\n3、**养成学习总结的习惯**；当写博客坚持不下去的时候，有心无心翻阅到以前写的博客时，可以让我想起下定决心好好总结写博客时的决心，有助于我继续坚持下去。\n4、**便于保存查询**；以前也会写一些总结笔记，保存在印象笔记的云端，书写方便，查询也方便，但是现在换了大点的公司后，由于信息安全问题，公司禁止携带个人电脑，禁止一切信息外发，印象笔记之类的软件不能使用了，虽然引起了很大的不方便很无奈，不过还好可以上网查看以前写的博客；为了在工作时能够是不是借鉴以前的学习笔记，还是在网上发博客方便，能够随时通过网络查询到。\n5、**打造一份独特的简历**；博客不仅可以作为自己总结的收纳，也能说明自己的技术知识点水平，在职场上还可以作为一份自己独特的名片或者简历；通过写博客讨论技术问题，和志同道合的博友成为朋友，求职面试的时候，一个持续输出高质量博客的网址，很具有说服力。\n\n\n### 学习计划\n\n&emsp;&emsp;现在已经下定决心，重新开始学习，把知识点细致地学一遍，这个过程可能会很慢，但是我希望自己能够坚持下去。就先从细读《Linux设备驱动程序》开始。\n\n&emsp;&emsp;这次为了能够理解并记住更多知识点，我会细致认真地读，在实践中实地操作验证，之后再针对知识点写成总结博客。这些作为总结的读书笔记，可能不会按照书中的章节顺序，但是会尽量将各个知识点写详细，并尽可能多地覆盖书中知识点。写博客的过程中可能会大范围抄书本上的内容，也可能会自己发挥，不过我希望通过多写总结，可以从抄书到自我发挥进行转变。\n\n&emsp;&emsp;最后，如果有博友能够阅读我的博客，并指出博文中的错误，或者不合适的地方，那对我来说将会是莫大的鼓励，我将忠心地表示感谢！\n\n","source":"_posts/阶段性自我反思及学习动员-2019-07-07.md","raw":"---\ntitle: 阶段性自我反思及学习动员----2019.07.07\ndate: 2019-07-07 22:47:42\ntags:\n---\n\n\n\n## 自我反思及学习动员\n\n&emsp;&emsp;Time is flying! 转眼间，工作已经这么多年了，按理说，在职场经过这么多年时间的洗礼，我也应该被洗成职场老手了；然而事实上，老的只是年龄，技术方面一点也不老，甚至还比不过一个刚入职的职场新人。\n\n<!--more-->\n\n![图片发自简书App](http://upload-images.jianshu.io/upload_images/9159706-9206c81a7cc48f8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50)\n\n\n\n### 深刻反思\n\n有上述中的不安全感，究其原因，有如下反思：\n\n1、**缺乏反思**；自己在工作、学习中碰到过不少问题，在解决问题之后没有花费时间和精力去做好总结和记录，致使好多碰到过的问题，再次碰到时还是不知道怎么处理，还得重新去想办法解决，即花费了时间精力，又没有很好的学习提高成效。\n2、**书看的少**；至少是看的还不够多，平时书买了不少，放在书架上都快放不下了，可是真正读完的很少。\n3、**学而不用**；读书的过程，只是粗枝大叶地翻看阅读，很少有更进一步细致分析，也没有过多的去实践应用，导致看书学习到的知识点印象不是很深，只是知道怎么用，而具体的内部细节就不太明白，甚至还有一部分用不到的知识点，前边看完，后来再看还是觉得很新鲜。\n4、**浪费太多时间**；平时总是以工作忙、加班累为借口给自己开脱，浪费大量时间上网、看电影、刷新闻，导致一天天宝贵的时间流逝浪费。\n5、**基础不牢**；非计算机专业科班出身，没有上过操作系统类专业课程，自学Linux内核驱动，总是感觉不得要领，感觉学习内容不够系统，有些知识点都是知其然不知其所以然，所谓基础不牢地动山摇，就是这样。\n\n&emsp;&emsp;程序员的成长过程，可不是一般职业的熬资历就能够实现的，程序员只会越熬越废，必须抓住空闲时间，不断学习，不断提高自己的技术水平，工作中不断去实践检验所学知识点，在学习和实践中脚踏实地，一步一个脚印地成长。\n\n\n### 回炉重造\n\n&emsp;&emsp;到了这个时候，发现自己基础知识不够牢靠，所学对于所求有点供不应求，虽然有点晚，但是也不至于无药可救。引用不知道哪位大神所说的一句话，”努力学习最坏的结果也不过是大器晚成“。所以最狠、最痛苦、也最有成效的解决方法就是--回炉重造。\n\n重造，必须要修正以前不好的学习习惯，纠正自己的学习方法：\n\n1、**学习要用心**；书中的内容是作者总结的杰出成果，并不是占有了书籍就占有了书中的知识点，必须细致认真地去读、去分析、消化、吸收，要高质量地读书。\n2、**边学边实践**；学习的过程中，要伴随着时间，用实践来检验所学知识点，不仅能够加深对知识点的印象，更能对知识点有更好的理解。\n3、**重视基础**；不能因为某些小知识点觉得简单，就不去学不去看，这样会导致眼高手低，看着知识点都知道，实际使用却又不会了，必须耐住性子，不厌其烦地去学习好基础知识。\n4、**多学习总结**；工作、学习中碰到问题，在解决之后，多写问题总结，记录碰到过的大小问题，作为日后查询的资料；学习过程中多写学习总结，针对知识点追根溯源，弄明白知识点的来龙去脉，不仅要知其然，也要知其所以然。\n5、**利用琐碎时间**；工作虽忙，加班虽累，总是可以抽出时间来学习的，比如：午饭后、午休前、晚饭后、睡觉前等可以用来玩手机、刷新闻的所有时间都可以用来学习，要善于利用空闲的时间，积少成多也能看好多书，学习好多知识点。\n\n\n### 写技术总结并发博客\n\n写学习总结、甚至发博客的好处：\n\n1、**可以查漏补缺**；不管写的好不好，都要就要坚持发总结博客，这样有助于发现自己学习的不足，即使写的不好，发出来或许会有博友留言吐槽，或者碰到更好的能指出博客中的错误之处，就更有助于进行查漏补缺，也能起到检验自己所学知识点\n2、**可以激励自己**；在坚持写学习总结并发博客一段时间后，回过头来翻看自己发过的博客，还是很有成就感的。\n3、**养成学习总结的习惯**；当写博客坚持不下去的时候，有心无心翻阅到以前写的博客时，可以让我想起下定决心好好总结写博客时的决心，有助于我继续坚持下去。\n4、**便于保存查询**；以前也会写一些总结笔记，保存在印象笔记的云端，书写方便，查询也方便，但是现在换了大点的公司后，由于信息安全问题，公司禁止携带个人电脑，禁止一切信息外发，印象笔记之类的软件不能使用了，虽然引起了很大的不方便很无奈，不过还好可以上网查看以前写的博客；为了在工作时能够是不是借鉴以前的学习笔记，还是在网上发博客方便，能够随时通过网络查询到。\n5、**打造一份独特的简历**；博客不仅可以作为自己总结的收纳，也能说明自己的技术知识点水平，在职场上还可以作为一份自己独特的名片或者简历；通过写博客讨论技术问题，和志同道合的博友成为朋友，求职面试的时候，一个持续输出高质量博客的网址，很具有说服力。\n\n\n### 学习计划\n\n&emsp;&emsp;现在已经下定决心，重新开始学习，把知识点细致地学一遍，这个过程可能会很慢，但是我希望自己能够坚持下去。就先从细读《Linux设备驱动程序》开始。\n\n&emsp;&emsp;这次为了能够理解并记住更多知识点，我会细致认真地读，在实践中实地操作验证，之后再针对知识点写成总结博客。这些作为总结的读书笔记，可能不会按照书中的章节顺序，但是会尽量将各个知识点写详细，并尽可能多地覆盖书中知识点。写博客的过程中可能会大范围抄书本上的内容，也可能会自己发挥，不过我希望通过多写总结，可以从抄书到自我发挥进行转变。\n\n&emsp;&emsp;最后，如果有博友能够阅读我的博客，并指出博文中的错误，或者不合适的地方，那对我来说将会是莫大的鼓励，我将忠心地表示感谢！\n\n","slug":"阶段性自我反思及学习动员-2019-07-07","published":1,"updated":"2020-05-07T13:54:20.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkv7000qdqg1htlm1fpb","content":"<h2 id=\"自我反思及学习动员\"><a href=\"#自我反思及学习动员\" class=\"headerlink\" title=\"自我反思及学习动员\"></a>自我反思及学习动员</h2><p>&emsp;&emsp;Time is flying! 转眼间，工作已经这么多年了，按理说，在职场经过这么多年时间的洗礼，我也应该被洗成职场老手了；然而事实上，老的只是年龄，技术方面一点也不老，甚至还比不过一个刚入职的职场新人。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/9159706-9206c81a7cc48f8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50\" alt=\"图片发自简书App\"></p>\n<h3 id=\"深刻反思\"><a href=\"#深刻反思\" class=\"headerlink\" title=\"深刻反思\"></a>深刻反思</h3><p>有上述中的不安全感，究其原因，有如下反思：</p>\n<p>1、<strong>缺乏反思</strong>；自己在工作、学习中碰到过不少问题，在解决问题之后没有花费时间和精力去做好总结和记录，致使好多碰到过的问题，再次碰到时还是不知道怎么处理，还得重新去想办法解决，即花费了时间精力，又没有很好的学习提高成效。<br>2、<strong>书看的少</strong>；至少是看的还不够多，平时书买了不少，放在书架上都快放不下了，可是真正读完的很少。<br>3、<strong>学而不用</strong>；读书的过程，只是粗枝大叶地翻看阅读，很少有更进一步细致分析，也没有过多的去实践应用，导致看书学习到的知识点印象不是很深，只是知道怎么用，而具体的内部细节就不太明白，甚至还有一部分用不到的知识点，前边看完，后来再看还是觉得很新鲜。<br>4、<strong>浪费太多时间</strong>；平时总是以工作忙、加班累为借口给自己开脱，浪费大量时间上网、看电影、刷新闻，导致一天天宝贵的时间流逝浪费。<br>5、<strong>基础不牢</strong>；非计算机专业科班出身，没有上过操作系统类专业课程，自学Linux内核驱动，总是感觉不得要领，感觉学习内容不够系统，有些知识点都是知其然不知其所以然，所谓基础不牢地动山摇，就是这样。</p>\n<p>&emsp;&emsp;程序员的成长过程，可不是一般职业的熬资历就能够实现的，程序员只会越熬越废，必须抓住空闲时间，不断学习，不断提高自己的技术水平，工作中不断去实践检验所学知识点，在学习和实践中脚踏实地，一步一个脚印地成长。</p>\n<h3 id=\"回炉重造\"><a href=\"#回炉重造\" class=\"headerlink\" title=\"回炉重造\"></a>回炉重造</h3><p>&emsp;&emsp;到了这个时候，发现自己基础知识不够牢靠，所学对于所求有点供不应求，虽然有点晚，但是也不至于无药可救。引用不知道哪位大神所说的一句话，”努力学习最坏的结果也不过是大器晚成“。所以最狠、最痛苦、也最有成效的解决方法就是–回炉重造。</p>\n<p>重造，必须要修正以前不好的学习习惯，纠正自己的学习方法：</p>\n<p>1、<strong>学习要用心</strong>；书中的内容是作者总结的杰出成果，并不是占有了书籍就占有了书中的知识点，必须细致认真地去读、去分析、消化、吸收，要高质量地读书。<br>2、<strong>边学边实践</strong>；学习的过程中，要伴随着时间，用实践来检验所学知识点，不仅能够加深对知识点的印象，更能对知识点有更好的理解。<br>3、<strong>重视基础</strong>；不能因为某些小知识点觉得简单，就不去学不去看，这样会导致眼高手低，看着知识点都知道，实际使用却又不会了，必须耐住性子，不厌其烦地去学习好基础知识。<br>4、<strong>多学习总结</strong>；工作、学习中碰到问题，在解决之后，多写问题总结，记录碰到过的大小问题，作为日后查询的资料；学习过程中多写学习总结，针对知识点追根溯源，弄明白知识点的来龙去脉，不仅要知其然，也要知其所以然。<br>5、<strong>利用琐碎时间</strong>；工作虽忙，加班虽累，总是可以抽出时间来学习的，比如：午饭后、午休前、晚饭后、睡觉前等可以用来玩手机、刷新闻的所有时间都可以用来学习，要善于利用空闲的时间，积少成多也能看好多书，学习好多知识点。</p>\n<h3 id=\"写技术总结并发博客\"><a href=\"#写技术总结并发博客\" class=\"headerlink\" title=\"写技术总结并发博客\"></a>写技术总结并发博客</h3><p>写学习总结、甚至发博客的好处：</p>\n<p>1、<strong>可以查漏补缺</strong>；不管写的好不好，都要就要坚持发总结博客，这样有助于发现自己学习的不足，即使写的不好，发出来或许会有博友留言吐槽，或者碰到更好的能指出博客中的错误之处，就更有助于进行查漏补缺，也能起到检验自己所学知识点<br>2、<strong>可以激励自己</strong>；在坚持写学习总结并发博客一段时间后，回过头来翻看自己发过的博客，还是很有成就感的。<br>3、<strong>养成学习总结的习惯</strong>；当写博客坚持不下去的时候，有心无心翻阅到以前写的博客时，可以让我想起下定决心好好总结写博客时的决心，有助于我继续坚持下去。<br>4、<strong>便于保存查询</strong>；以前也会写一些总结笔记，保存在印象笔记的云端，书写方便，查询也方便，但是现在换了大点的公司后，由于信息安全问题，公司禁止携带个人电脑，禁止一切信息外发，印象笔记之类的软件不能使用了，虽然引起了很大的不方便很无奈，不过还好可以上网查看以前写的博客；为了在工作时能够是不是借鉴以前的学习笔记，还是在网上发博客方便，能够随时通过网络查询到。<br>5、<strong>打造一份独特的简历</strong>；博客不仅可以作为自己总结的收纳，也能说明自己的技术知识点水平，在职场上还可以作为一份自己独特的名片或者简历；通过写博客讨论技术问题，和志同道合的博友成为朋友，求职面试的时候，一个持续输出高质量博客的网址，很具有说服力。</p>\n<h3 id=\"学习计划\"><a href=\"#学习计划\" class=\"headerlink\" title=\"学习计划\"></a>学习计划</h3><p>&emsp;&emsp;现在已经下定决心，重新开始学习，把知识点细致地学一遍，这个过程可能会很慢，但是我希望自己能够坚持下去。就先从细读《Linux设备驱动程序》开始。</p>\n<p>&emsp;&emsp;这次为了能够理解并记住更多知识点，我会细致认真地读，在实践中实地操作验证，之后再针对知识点写成总结博客。这些作为总结的读书笔记，可能不会按照书中的章节顺序，但是会尽量将各个知识点写详细，并尽可能多地覆盖书中知识点。写博客的过程中可能会大范围抄书本上的内容，也可能会自己发挥，不过我希望通过多写总结，可以从抄书到自我发挥进行转变。</p>\n<p>&emsp;&emsp;最后，如果有博友能够阅读我的博客，并指出博文中的错误，或者不合适的地方，那对我来说将会是莫大的鼓励，我将忠心地表示感谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"自我反思及学习动员\"><a href=\"#自我反思及学习动员\" class=\"headerlink\" title=\"自我反思及学习动员\"></a>自我反思及学习动员</h2><p>&emsp;&emsp;Time is flying! 转眼间，工作已经这么多年了，按理说，在职场经过这么多年时间的洗礼，我也应该被洗成职场老手了；然而事实上，老的只是年龄，技术方面一点也不老，甚至还比不过一个刚入职的职场新人。</p>","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/9159706-9206c81a7cc48f8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50\" alt=\"图片发自简书App\"></p>\n<h3 id=\"深刻反思\"><a href=\"#深刻反思\" class=\"headerlink\" title=\"深刻反思\"></a>深刻反思</h3><p>有上述中的不安全感，究其原因，有如下反思：</p>\n<p>1、<strong>缺乏反思</strong>；自己在工作、学习中碰到过不少问题，在解决问题之后没有花费时间和精力去做好总结和记录，致使好多碰到过的问题，再次碰到时还是不知道怎么处理，还得重新去想办法解决，即花费了时间精力，又没有很好的学习提高成效。<br>2、<strong>书看的少</strong>；至少是看的还不够多，平时书买了不少，放在书架上都快放不下了，可是真正读完的很少。<br>3、<strong>学而不用</strong>；读书的过程，只是粗枝大叶地翻看阅读，很少有更进一步细致分析，也没有过多的去实践应用，导致看书学习到的知识点印象不是很深，只是知道怎么用，而具体的内部细节就不太明白，甚至还有一部分用不到的知识点，前边看完，后来再看还是觉得很新鲜。<br>4、<strong>浪费太多时间</strong>；平时总是以工作忙、加班累为借口给自己开脱，浪费大量时间上网、看电影、刷新闻，导致一天天宝贵的时间流逝浪费。<br>5、<strong>基础不牢</strong>；非计算机专业科班出身，没有上过操作系统类专业课程，自学Linux内核驱动，总是感觉不得要领，感觉学习内容不够系统，有些知识点都是知其然不知其所以然，所谓基础不牢地动山摇，就是这样。</p>\n<p>&emsp;&emsp;程序员的成长过程，可不是一般职业的熬资历就能够实现的，程序员只会越熬越废，必须抓住空闲时间，不断学习，不断提高自己的技术水平，工作中不断去实践检验所学知识点，在学习和实践中脚踏实地，一步一个脚印地成长。</p>\n<h3 id=\"回炉重造\"><a href=\"#回炉重造\" class=\"headerlink\" title=\"回炉重造\"></a>回炉重造</h3><p>&emsp;&emsp;到了这个时候，发现自己基础知识不够牢靠，所学对于所求有点供不应求，虽然有点晚，但是也不至于无药可救。引用不知道哪位大神所说的一句话，”努力学习最坏的结果也不过是大器晚成“。所以最狠、最痛苦、也最有成效的解决方法就是–回炉重造。</p>\n<p>重造，必须要修正以前不好的学习习惯，纠正自己的学习方法：</p>\n<p>1、<strong>学习要用心</strong>；书中的内容是作者总结的杰出成果，并不是占有了书籍就占有了书中的知识点，必须细致认真地去读、去分析、消化、吸收，要高质量地读书。<br>2、<strong>边学边实践</strong>；学习的过程中，要伴随着时间，用实践来检验所学知识点，不仅能够加深对知识点的印象，更能对知识点有更好的理解。<br>3、<strong>重视基础</strong>；不能因为某些小知识点觉得简单，就不去学不去看，这样会导致眼高手低，看着知识点都知道，实际使用却又不会了，必须耐住性子，不厌其烦地去学习好基础知识。<br>4、<strong>多学习总结</strong>；工作、学习中碰到问题，在解决之后，多写问题总结，记录碰到过的大小问题，作为日后查询的资料；学习过程中多写学习总结，针对知识点追根溯源，弄明白知识点的来龙去脉，不仅要知其然，也要知其所以然。<br>5、<strong>利用琐碎时间</strong>；工作虽忙，加班虽累，总是可以抽出时间来学习的，比如：午饭后、午休前、晚饭后、睡觉前等可以用来玩手机、刷新闻的所有时间都可以用来学习，要善于利用空闲的时间，积少成多也能看好多书，学习好多知识点。</p>\n<h3 id=\"写技术总结并发博客\"><a href=\"#写技术总结并发博客\" class=\"headerlink\" title=\"写技术总结并发博客\"></a>写技术总结并发博客</h3><p>写学习总结、甚至发博客的好处：</p>\n<p>1、<strong>可以查漏补缺</strong>；不管写的好不好，都要就要坚持发总结博客，这样有助于发现自己学习的不足，即使写的不好，发出来或许会有博友留言吐槽，或者碰到更好的能指出博客中的错误之处，就更有助于进行查漏补缺，也能起到检验自己所学知识点<br>2、<strong>可以激励自己</strong>；在坚持写学习总结并发博客一段时间后，回过头来翻看自己发过的博客，还是很有成就感的。<br>3、<strong>养成学习总结的习惯</strong>；当写博客坚持不下去的时候，有心无心翻阅到以前写的博客时，可以让我想起下定决心好好总结写博客时的决心，有助于我继续坚持下去。<br>4、<strong>便于保存查询</strong>；以前也会写一些总结笔记，保存在印象笔记的云端，书写方便，查询也方便，但是现在换了大点的公司后，由于信息安全问题，公司禁止携带个人电脑，禁止一切信息外发，印象笔记之类的软件不能使用了，虽然引起了很大的不方便很无奈，不过还好可以上网查看以前写的博客；为了在工作时能够是不是借鉴以前的学习笔记，还是在网上发博客方便，能够随时通过网络查询到。<br>5、<strong>打造一份独特的简历</strong>；博客不仅可以作为自己总结的收纳，也能说明自己的技术知识点水平，在职场上还可以作为一份自己独特的名片或者简历；通过写博客讨论技术问题，和志同道合的博友成为朋友，求职面试的时候，一个持续输出高质量博客的网址，很具有说服力。</p>\n<h3 id=\"学习计划\"><a href=\"#学习计划\" class=\"headerlink\" title=\"学习计划\"></a>学习计划</h3><p>&emsp;&emsp;现在已经下定决心，重新开始学习，把知识点细致地学一遍，这个过程可能会很慢，但是我希望自己能够坚持下去。就先从细读《Linux设备驱动程序》开始。</p>\n<p>&emsp;&emsp;这次为了能够理解并记住更多知识点，我会细致认真地读，在实践中实地操作验证，之后再针对知识点写成总结博客。这些作为总结的读书笔记，可能不会按照书中的章节顺序，但是会尽量将各个知识点写详细，并尽可能多地覆盖书中知识点。写博客的过程中可能会大范围抄书本上的内容，也可能会自己发挥，不过我希望通过多写总结，可以从抄书到自我发挥进行转变。</p>\n<p>&emsp;&emsp;最后，如果有博友能够阅读我的博客，并指出博文中的错误，或者不合适的地方，那对我来说将会是莫大的鼓励，我将忠心地表示感谢！</p>"},{"title":"Linux kernel中的I2C子系统","date":"2020-04-06T06:36:52.000Z","_content":"\n\n\n\n\nLinux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n[TOC]\n\nLinux内核中的I2C驱动代码位于：drivers/i2c目录；\n\n\n\n### 0. 简述\n\n\n\nLinux内核中的I2C驱动代码位于：drivers/i2c目录；\n\nLinux设备模型由bus、device、driver组成；\n\n\n\nI2C驱动中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；\n\n> I2C总线：维护I2C驱动和I2C设备两个链表，管理I2C驱动和I2C设备的匹配、删除等；\n>\n> I2C设备：具体硬件设备的一个抽象；\n>\n> I2C驱动：对应I2C设备的驱动程序；\n>\n> I2C适配器：用于I2C驱动和I2C设备间通信，是SOC上I2C控制器的一个抽象；\n\n\n\nI2C总线上有两个链表，分别是i2c_driver和i2c_client三链表；当任何一个driver或client注册时，I2C总线都会调用match函数，对client.name和driver.id_table.name进行遍历匹配；如果driver.id_table中所有的id都匹配不成功，说明client没有找到对应的driver；如果匹配成功，说明client和driver是配套的，那么I2C总线就会调用自己的probe函数，然后probe函数调用driver中提供的probe函数，driver中的probe函数会对设备进行硬件初始化和后续工作；\n\n\n\ni2c_add_adapter\t// 注册adapter\n\ni2c_add_driver\t\t// 注册driver\n\ni2c_new_device\t\t// 注册client\n\n\n\n### 1. I2C驱动框架\n\n\n\n\n\nLinux的I2C体系结构分为3个部分：\n\n> I2C核心\n>\n> I2C总线驱动\n>\n> I2C设备驱动\n\n\n\n![Linux的I2C子系统框架](Linux-kernel中的I2C子系统/Linux的I2C子系统框架.png)\n\n\n\n#### 1.1 I2C核心\n\n\n\nI2C核心（i2c_core）维护了i2c_bus结构体，提供了：\n\n> I2C总线驱动和设备驱动的注册、注销方法\n>\n> I2C的通信方法（i2c_algorithm）\n>\n> 上层的与具体适配器无关的代码\n>\n> 探测设备、检测设备地址的上层代码\n\n此部分代码由Linux内核提供；\n\n\n\n#### 1.2 I2C总线驱动\n\n\n\nI2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器由CPU控制，或者直接集成在CPU内部；\n\n\n\nI2C总线驱动主要包含：\n\n> I2C适配器数据结构i2c_adapter\n>\n> I2C适配器的控制算法数据结构i2c_algorithm\n>\n> 控制I2C适配器产生通信信号的函数\n\n通过I2C总线驱动代码，可以控制I2C适配器，以主设备方式产生开始位、停止位、读写周期，以及以从设备方式读写、产生ACK等；\n\n此部分代码由具体的芯片厂商提供，如：高通、Samsung等；\n\n\n\n#### 1.3 I2C设备驱动\n\n\n\nI2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在I2C控制器（适配器）上，通过I2C适配器与CPU交换数据；\n\nI2C设备驱动主要包含i2c_client和i2c_driver结构体，实现和用户交互的文件操作集fops、cdev等；\n\n这两个数据结构中的成员函数，需要由驱动开发者根据具体设备去实现；\n\n\n\n### 2. 核心数据结构\n\n\n\nI2C驱动中最核心的4个数据结构：\n\n> struct i2c_client\n>\n> struct i2c_driver\n>\n> struct i2c_adapter\n>\n> struct i2c_algorithm\n\n\n\n#### 2.1 设备层\n\n\n\n##### 2.1.1 I2C设备（i2c_client）\n\n硬件上连接到I2C的SDA、SCL总线上的设备都是I2C设备，每一个I2C设备由一个i2c_client结构体进行描述；i2c_client对应真实的I2C物理设备，是具体硬件设备的抽象；一个i2c_client对象，表示连接到i2c总线的一个设备；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_client {\n    unsigned short flags;       /* div., see below      */\n    unsigned short addr;        /* chip address - NOTE: 7bit    */\n    char name[I2C_NAME_SIZE];\n    struct i2c_adapter *adapter;    /* the adapter we sit on    */\n    struct device dev;      /* the device structure     */\n    int irq;            /* irq issued by device     */\n    struct list_head detected;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n    i2c_slave_cb_t slave_cb;    /* callback for slave mode  */\n#endif\n};\n```\n\n> unsigned short addr：表示7bit的设备芯片地址，地址被保存在低7bits\n>\n> struct i2c_adapter *adapter：表示这个i2c_client从属的i2c_adapter对象，驱动中使用这个指针操作发送\n>\n> struct device dev：表示device信息\n>\n> struct list_head detected：设备链表，将所有的i2c_client组成链表\n\n\n\ni2c_client结构不是驱动开发者创建的，而是通过以下方式自动创建：\n\n> 分配、设置、注册i2c_board_info\n>\n> 获取i2c_adapter，调用i2c_new_device\n>\n> 通过设备树（DeviceTree）创建\n\n\n\n##### 2.1.2 I2C驱动（i2c_driver）\n\n\n\ni2c_driver结构用于管理I2C的驱动和I2C设备的匹配探测，实现与用户层交互的文件操作集fops、cdev等；每一个I2C设备都对应一个I2C驱动，因此，每一个i2c_client结构，都对应一个i2c_driver结构，通过指针相连；编写一个i2c驱动的本质，就是要构造一个i2c_driver对象，并将其注册到内核；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_driver {\n    unsigned int class;\n\n    int (*attach_adapter)(struct i2c_adapter *) __deprecated;\n\n    /* Standard driver model interfaces */\n    int (*probe)(struct i2c_client *, const struct i2c_device_id *); \n    int (*remove)(struct i2c_client *); \n\n    void (*shutdown)(struct i2c_client *); \n    void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol,\n              unsigned int data);\n\n    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);\n\n    struct device_driver driver;\n    const struct i2c_device_id *id_table;\n\n    /* Device detection callback for automatic device creation */\n    int (*detect)(struct i2c_client *, struct i2c_board_info *); \n    const unsigned short *address_list;\n    struct list_head clients;\n};\n```\n\n> probe：探测函数，匹配成功后执行，会将匹配到的i2c_client对象传入，完成申请资源、初始化、提供接口等操作\n>\n> remove：移除函数，设备消失时或驱动模块被卸载时会被调用，和probe操作相反\n>\n> struct device_driver driver：表明是一个设备的驱动类，用于匹配设备树的of_match_table域\n>\n> const struct i2c_device_id *id_table：用于使用平台文件或模块编写设备信息时进行匹配\n>\n> struct list_head clients：用于将所有i2c_driver联系到一起的链表\n\n\n\n```\n#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)\n```\n\n\n\n##### 2.1.3 总线和设备关系\n\n![I2C设备和驱动的关系](Linux-kernel中的I2C子系统/I2C设备和驱动的关系.png)\n\n\n\n#### 2.2 总线层\n\n\n\n##### 2.2.1 I2C适配器（i2c_adapter）\n\n\n\nI2C适配器，即SOC中的I2C控制器，对应struct i2c_adapter结构体；Linux中用i2c_adapter来表示一个I2C控制器，一个i2c_adapter结构体对应的就是SOC上的I2C控制器；所有的设备驱动都需要经过i2c_adapter对象的处理才能和物理设备通信；通过i2c_core层将I2C设备与i2c adapter关联起来，用来完成i2c总线控制器相关的数据通信，此结构体在芯片厂商提供的代码中维护；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_adapter {\n    struct module *owner;\n    unsigned int class;       /* classes to allow probing for */\n    const struct i2c_algorithm *algo; /* the algorithm to access the bus */\n    void *algo_data;\n\n    /* data fields that are valid for all devices   */\n    const struct i2c_lock_operations *lock_ops;\n    struct rt_mutex bus_lock;\n    struct rt_mutex mux_lock;\n\n    int timeout;            /* in jiffies */\n    int retries;\n    struct device dev;      /* the adapter device */\n\n    int nr;\n    char name[48];\n    struct completion dev_released;\n\n    struct mutex userspace_clients_lock;\n    struct list_head userspace_clients;\n\n    struct i2c_bus_recovery_info *bus_recovery_info;\n    const struct i2c_adapter_quirks *quirks;\n};\n```\n\n\n\n```\n#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)\n```\n\n\n\n##### 2.2.2 I2C总线算法（i2c_algorithm）\n\nI2C总线数据通信算法，通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；\n\nstruct i2c_algorithm数据结构，是i2c控制器数据通信需要的控制算法，对应的是I2C的时序；通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；用来描述适配器和设备之间的通信方法，由芯片厂商实现；\n\n最重要的成员是master_xfer()函数，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_algorithm {\n    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,\n               int num);\n    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,\n               unsigned short flags, char read_write,\n               u8 command, int size, union i2c_smbus_data *data);\n\n    /* To determine what the adapter supports */\n    u32 (*functionality) (struct i2c_adapter *);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n    int (*reg_slave)(struct i2c_client *client);\n    int (*unreg_slave)(struct i2c_client *client);\n#endif\n};\n```\n\n> master_xfer：最重要的接口，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；该函数返回成功发送的消息数，错误返回负数；\n\n\n\n\ndevice_driver\n\n```\n// include/linux/device.h\nstruct device_driver {\n    const char      *name;\n    struct bus_type     *bus;\n\n    struct module       *owner;\n    const char      *mod_name;  /* used for built-in modules */\n\n    bool suppress_bind_attrs;   /* disables bind/unbind via sysfs */\n    enum probe_type probe_type;\n\n    const struct of_device_id   *of_match_table;\n    const struct acpi_device_id *acpi_match_table;\n\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n    void (*shutdown) (struct device *dev);\n    int (*suspend) (struct device *dev, pm_message_t state);\n    int (*resume) (struct device *dev);\n    const struct attribute_group **groups;\n\n    const struct dev_pm_ops *pm; \n\n    struct driver_private *p;\n};\n```\n\n\n\n\n\n\n\n##### 2.2.3 I2C总线类型\n\n\nI2C总线对应着/bus/目录下的一个总线；维护I2C设备和I2C驱动两个链表，管理I2C设备和I2C的匹配和删除；是SOC上I2C控制器的抽象；\n\n\n\n```\n// include/linux/device.h\nstruct bus_type {\n    const char      *name;\n    const char      *dev_name;\n    struct device       *dev_root;\n    struct device_attribute *dev_attrs; /* use dev_groups instead */\n    const struct attribute_group **bus_groups;\n    const struct attribute_group **dev_groups;\n    const struct attribute_group **drv_groups;\n\n    int (*match)(struct device *dev, struct device_driver *drv);\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n\n    int (*online)(struct device *dev);\n    int (*offline)(struct device *dev);\n\n    int (*suspend)(struct device *dev, pm_message_t state);\n    int (*resume)(struct device *dev);\n\n    const struct dev_pm_ops *pm; \n\n    const struct iommu_ops *iommu_ops;\n\n    struct subsys_private *p;\n    struct lock_class_key lock_key;\n};\n```\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstruct bus_type i2c_bus_type = {\n    .name       = \"i2c\",\n    .match      = i2c_device_match,\n    .probe      = i2c_device_probe,\n    .remove     = i2c_device_remove,\n    .shutdown   = i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n```\n\n\n\nI2C总线bus_type结构体管理着i2c设备和i2c驱动的匹配、删除操作，i2c会调用i2c_device_match函数对比i2c设备和i2c驱动是否匹配，如果匹配就调用i2c_device_probe函数，进而调用i2c驱动的probe函数；\n\n\n\n#### 2.3 总线层和设备层关系\n\n\n\n在设备层，i2c_client通过adapter指针，指向总线层的i2c_adapter，和总线层存在关系；\n\n在总线层，i2c_adapter通过algo指针，指向i2c_algorithm，进一步调用i2c_algorithm中的算法，如：master_xfer()，进行实际的数据发送和接收；\n\n\n\n总线层\n\nstruct i2c_adapter       I2C适配器（主机CPU的I2C控制器）\n\nstruct i2c_algorithm       I2C算法（I2C的收、发时序控制）\n\n\n\n设备层\n\nstruct i2c_client       I2C（从机）设备信息\n\nstruct i2c_driver       I2C（从机）设备驱动信息\n\n\n\n\n\n![I2C总线层和设备层的关系](Linux-kernel中的I2C子系统/I2C总线层和设备层的关系.png)\n\n\n\n\n\n#### 2.4 数据结构间的关系\n\n\n\n![I2C数据结构间的关系](Linux-kernel中的I2C子系统/I2C数据结构间的关系.png)\n\n\n\n\n\n### 3. 重要的操作函数\n\n\n\n#### 3.1 I2C子系统初始化\n\n\n\n##### 3.1.1 I2C总线初始化\n\n\n\n```\n// drivers/i2c/i2c-core.c\npostcore_initcall(i2c_init);\nmodule_exit(i2c_exit);\n```\n\n\n\n```\n// include/linux/init.h\n#define postcore_initcall(fn)       __define_initcall(fn, 2)\n```\n\n\n\n```\n// include/linux/init.h\n#define __define_initcall(fn, id) \\\n    static initcall_t __initcall_##fn##id __used \\\n    __attribute__((__section__(\".initcall\" #id \".init\"))) = fn;\n```\n\npostcore_initcall(i2c_init)操作，会在编译内核时，将函数指针变量__initcall_i2c_init放到名称为initcall2.init的section中；即将i2c_init()函数的首地址放到名称为initcall2.init的section中；\n\nLinux设备启动时，会在do_basic_setup()函数中，通过driver_init()和do_initcalls()函数，调用到i2c_init()函数，对I2C总线初始化；\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstatic int __init i2c_init(void)\n{\n    ......\n    retval = bus_register(&i2c_bus_type);\n    ......\n    i2c_adapter_compat_class = class_compat_register(\"i2c-adapter\");\n    ......\n    retval = i2c_add_driver(&dummy_driver);\n    ......\n}\n```\n\n\n\n通过bus_register()函数，在系统中注册一个新的总线i2c_bus_type，name: i2c；适配器设备、I2C设备、I2C设备驱动程序都会连接到这条总线上；\n\n```\n// drivers/i2c/i2c-core.c\nstruct bus_type i2c_bus_type = {\n    .name       = \"i2c\",\n    .match      = i2c_device_match,\n    .probe      = i2c_device_probe,\n    .remove     = i2c_device_remove,\n    .shutdown   = i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n```\n\n\n\n通过i2c_add_driver()函数，向I2C总线注册一个空的I2C设备驱动程序；可以不用关心；\n\n```mermaid\ngraph TB\n\ti2c_init1(i2c_init)-->bus_register1(bus_register)\n\tsubgraph i2c_init\n\t\tbus_register1(bus_register)-->\n\t\tclass_compat_register(class_compat_register)-->\n\t\ti2c_add_driver(i2c_add_driver)\n\tend\n```\n\n\n\n注册过程中发生异常错误时，需要使用对应的函数进行反向操作：\n\n```mermaid\ngraph TB\n\tclass_compat_register(class_compat_register)\n\tclass_compat_unregister(class_compat_unregister) \n```\n\n\n\n```mermaid\ngraph TB\n\tbus_register(bus_register) \n\tbus_unregister(bus_unregister)\n```\n\n\n\n##### 3.1.2 I2C总线退出\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstatic void __exit i2c_exit(void)\n{\n    if (IS_ENABLED(CONFIG_ACPI))\n        WARN_ON(acpi_reconfig_notifier_unregister(&i2c_acpi_notifier));\n    if (IS_ENABLED(CONFIG_OF_DYNAMIC))\n        WARN_ON(of_reconfig_notifier_unregister(&i2c_of_notifier));\n    i2c_del_driver(&dummy_driver);\n#ifdef CONFIG_I2C_COMPAT\n    class_compat_unregister(i2c_adapter_compat_class);\n#endif\n    bus_unregister(&i2c_bus_type);\n    tracepoint_synchronize_unregister();\n}\n```\n\n\ni2c_del_driver()函数，用来从I2C总线注销设备驱动程序；和i2c_add_driver()函数功能相反；\n\n```mermaid\ngraph TB\n\ti2c_add_driver(i2c_add_driver) \n\ti2c_del_driver(i2c_del_driver)\n```\n\n\n\n#### \t3.2 适配器驱动\n\n适配器驱动程序是I2C设备驱动程序需要实现的主要驱动程序，需要根据具体的适配器硬件编写；\n\n使用内核提供的框架函数向I2C子系统中添加一个新的适配器；i2c_adapter结构体为描述各种I2C适配器提供了通用的封装，但是i2c_adapter结构体只是所有适配器的共有属性，并不能代表所有类型的适配器；\n\n添加新的适配器的过程：\n\n>分配一个I2C适配器，并初始化一个i2c_adapter结构体，及相应的变量\n>\n>使用i2c_add_adapter()函数向I2C子系统添加适配器结构体i2c_adapter\n\n\n\n##### 3.2.1 添加适配器驱动\n\n```c\n// drivers/i2c/i2c-core.c\nint i2c_add_adapter(struct i2c_adapter *adapter)\n{\n    struct device *dev = &adapter->dev;\n    int id;\n\n    if (dev->of_node) {\n        id = of_alias_get_id(dev->of_node, \"i2c\");\n        if (id >= 0) { \n            adapter->nr = id;\n            return __i2c_add_numbered_adapter(adapter);\n        }\n    }    \n\n    mutex_lock(&core_lock);\n    id = idr_alloc(&i2c_adapter_idr, adapter,\n               __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\n    mutex_unlock(&core_lock);\n    if (WARN(id < 0, \"couldn't get idr\"))\n        return id;\n\n    adapter->nr = id;\n\n    return i2c_register_adapter(adapter);\n}\nEXPORT_SYMBOL(i2c_add_adapter);\n```\n\n通过i2c_register_adapter()函数，向内核注册一个适配器设备adapter；\n\n\n\n```mermaid\ngraph TB\n\ti2c_add_adapter(i2c_add_adapter)\n\t-->i2c_register_adapter(i2c_register_adapter)\n```\n\n\n\n```c\n// drivers/i2c/i2c-core.c\nstatic int i2c_register_adapter(struct i2c_adapter *adap)\n{\n    int res = -EINVAL;\n\t......\n    /* Sanity checks */\n    if (WARN(!adap->name[0], \"i2c adapter has no name\"))\n        goto out_list;\n\n    if (!adap->algo) {\n        pr_err(\"adapter '%s': no algo supplied!\\n\", adap->name);\n        goto out_list;\n    }\n\n    if (!adap->lock_ops)\n        adap->lock_ops = &i2c_adapter_lock_ops;\n\t......\n    /* Set default timeout to 1 second if not already set */\n    if (adap->timeout == 0)\n        adap->timeout = HZ;\n\n    dev_set_name(&adap->dev, \"i2c-%d\", adap->nr);\n    adap->dev.bus = &i2c_bus_type;\n    adap->dev.type = &i2c_adapter_type;\n    res = device_register(&adap->dev);\n\n    pm_runtime_no_callbacks(&adap->dev);\n    pm_suspend_ignore_children(&adap->dev, true);\n    pm_runtime_enable(&adap->dev);\n\n#ifdef CONFIG_I2C_COMPAT\n    res = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,\n                       adap->dev.parent);\n#endif\n\n    i2c_init_recovery(adap);\n\n    /* create pre-declared device nodes */\n    of_i2c_register_devices(adap);\n    i2c_acpi_register_devices(adap);\n    i2c_acpi_install_space_handler(adap);\n\n    if (adap->nr < __i2c_first_dynamic_bus_num)\n        i2c_scan_static_board_info(adap);\n\n    /* Notify drivers */\n    mutex_lock(&core_lock);\n    bus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);\n    mutex_unlock(&core_lock);\n\n    return 0;\n\nout_list:\n    mutex_lock(&core_lock);\n    idr_remove(&i2c_adapter_idr, adap->nr);\n    mutex_unlock(&core_lock);\n    return res;\n}\n```\n\n\n\n##### 3.2.2 注销适配器驱动\n\n```c\n// // drivers/i2c/i2c-core.c\nvoid i2c_del_adapter(struct i2c_adapter *adap)\n{\n    struct i2c_adapter *found;\n    struct i2c_client *client, *next;\n\n    /* First make sure that this adapter was ever added */\n    mutex_lock(&core_lock);\n    found = idr_find(&i2c_adapter_idr, adap->nr);\n    mutex_unlock(&core_lock);\n    if (found != adap) {\n        pr_debug(\"attempting to delete unregistered adapter [%s]\\n\", adap->name);\n        return;\n    }\n\n    i2c_acpi_remove_space_handler(adap);\n    /* Tell drivers about this removal */\n    mutex_lock(&core_lock);\n    bus_for_each_drv(&i2c_bus_type, NULL, adap,\n                   __process_removed_adapter);\n    mutex_unlock(&core_lock);\n\n    /* Remove devices instantiated from sysfs */\n    mutex_lock_nested(&adap->userspace_clients_lock,\n              i2c_adapter_depth(adap));\n    list_for_each_entry_safe(client, next, &adap->userspace_clients,\n                 detected) {\n        list_del(&client->detected);\n        i2c_unregister_device(client);\n    }\n    mutex_unlock(&adap->userspace_clients_lock);\n    device_for_each_child(&adap->dev, NULL, __unregister_client);\n    device_for_each_child(&adap->dev, NULL, __unregister_dummy);\n\n#ifdef CONFIG_I2C_COMPAT\n    class_compat_remove_link(i2c_adapter_compat_class, &adap->dev,\n                 adap->dev.parent);\n#endif\n\n    pm_runtime_disable(&adap->dev);\n\n    init_completion(&adap->dev_released);\n    device_unregister(&adap->dev);\n    wait_for_completion(&adap->dev_released);\n\n    /* free bus id */\n    mutex_lock(&core_lock);\n    idr_remove(&i2c_adapter_idr, adap->nr);\n    mutex_unlock(&core_lock);\n\n    /* Clear the device structure in case this adapter is ever going to be\n       added again */\n    memset(&adap->dev, 0, sizeof(adap->dev));\n}\nEXPORT_SYMBOL(i2c_del_adapter);\n```\n\n\n\n\n\n#### 3.3 注册I2C驱动\n\n注册I2C驱动需要完成的操作：\n\n> 将I2C驱动添加到I2C总线的驱动链表中\n>\n> 遍历I2C总线上的I2C设备链表，根据i2c_device_match函数进行匹配，如果匹配就调用i2c_device_probe函数\n>\n> i2c_device_probe函数会调用I2C驱动的probe函数\n\n\n\n##### 3.3.1 注册I2C驱动\n\n在I2C驱动程序中，通过i2c_add_driver()函数，来注册驱动：\n\n```\n// include/linux/i2c.h\n#define i2c_add_driver(driver) \\\n    i2c_register_driver(THIS_MODULE, driver)\n```\n\n\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\n{\n\t......\n    /* add the driver to the list of i2c drivers in the driver core */\n    driver->driver.owner = owner;\n    driver->driver.bus = &i2c_bus_type;\t\t// 绑定I2C总线 \n    INIT_LIST_HEAD(&driver->clients);\n\n    res = driver_register(&driver->driver);\t\t// 向I2C总线注册驱动\n\t......\n    i2c_for_each_dev(driver, __process_new_driver);\n\n    return 0;\n}\nEXPORT_SYMBOL(i2c_register_driver);\n```\n\n\n在i2c_add_driver()函数中，做了三件事：\n\n> 绑定总线\n>\n> 向总线注册驱动 ---- 重点\n>\n> 遍历总线的设备，调用__process_new_driver\n\n\n\n\n\ndriver_register\n\n```\n// drivers/i2c/i2c-core.c\nint driver_register(struct device_driver *drv)\n{\n    int ret;\n    struct device_driver *other;\n\t......\n    other = driver_find(drv->name, drv->bus);\n\t......\n    ret = bus_add_driver(drv);\n\n    ret = driver_add_groups(drv, drv->groups);\n    if (ret) {\n        bus_remove_driver(drv);\n        return ret;\n    }\n    kobject_uevent(&drv->p->kobj, KOBJ_ADD);\n\n    return ret;\n}\nEXPORT_SYMBOL_GPL(driver_register);\n```\n\n\n\n\ndriver_find()函数，在I2C总线中，找到name对应的I2C device_driver；\n\nbus_add_driver()函数，将驱动添加到总线上；\n\n\n\n```mermaid\ngraph TB\n\ti2c_add_driver(i2c_add_driver)-->\n\ti2c_register_driver(i2c_register_driver)-->\n\tdriver_register(driver_register)-->\n\tbus_add_driver(bus_add_driver)\t\n```\n\n\n\n\n\n\n\n##### 3.3.2 注销I2C驱动\n\n```\n// drivers/i2c/i2c-core.c\nvoid i2c_del_driver(struct i2c_driver *driver)\n{\n    i2c_for_each_dev(driver, __process_removed_driver);\n\n    driver_unregister(&driver->driver);\n    pr_debug(\"driver [%s] unregistered\\n\", driver->driver.name);\n}\nEXPORT_SYMBOL(i2c_del_driver);\n```\n\n\n\n#### 3.4 注册I2C设备\n\n##### 3.4.1 注册I2C设备\n\nI2C通过i2c_new_device()函数，来添加一个I2C设备；\n\n```\n// drivers/i2c/i2c-core.c\nstruct i2c_client *\ni2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)\n{\n    struct i2c_client   *client;\n    int         status;\n\n    client = kzalloc(sizeof *client, GFP_KERNEL);\n\n    client->adapter = adap;\t\t// 指定设备的适配器\n\n    client->dev.platform_data = info->platform_data;\n\n    if (info->archdata)\n        client->dev.archdata = *info->archdata;\n\n    client->flags = info->flags;\n    client->addr = info->addr;\n    client->irq = info->irq;\n\n    strlcpy(client->name, info->type, sizeof(client->name));\n\n    status = i2c_check_addr_validity(client->addr, client->flags);\n\n\t/* Check for address business */\n    status = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));\n\n    client->dev.parent = &client->adapter->dev;\n    client->dev.bus = &i2c_bus_type;\t// 绑定I2C总线\n    client->dev.type = &i2c_client_type;\n    client->dev.of_node = info->of_node;\n    client->dev.fwnode = info->fwnode;\n\n    i2c_dev_set_name(adap, client);\n    status = device_register(&client->dev);\t\t// 向总线注册设备\n\t......\n    return client;\n}\nEXPORT_SYMBOL_GPL(i2c_new_device);\n```\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_board_info {\n    char        type[I2C_NAME_SIZE];\t// 设备名称，用于与驱动匹配\n    unsigned short  flags;\n    unsigned short  addr;\t// 设备地址\n    void        *platform_data;\n    struct dev_archdata *archdata;\n    struct device_node *of_node;\n    struct fwnode_handle *fwnode;\n    int     irq;\n};\n```\n\nstruct i2c_board_info结构体描述了设备的硬件信息；\n\n\n\n```\n// drivers/base/core.c\nint device_register(struct device *dev)\n{   \n    device_initialize(dev);\n    return device_add(dev);\n}\nEXPORT_SYMBOL_GPL(device_register);\n```\n\n\n\n```mermaid\ngraph TB\n\ti2c_new_device(i2c_new_device)-->\n\tdevice_register(device_register)-->\n\tdevice_initialize(device_initialize)\n\tdevice_register-->device_add(device_add)\n```\n\n\n\ndevice_initialize()函数用来初始化I2C设备的device结构体；\n\n```\n// drivers/base/core.c\nvoid device_initialize(struct device *dev)\n{\n    dev->kobj.kset = devices_kset;\n    kobject_init(&dev->kobj, &device_ktype);\n    INIT_LIST_HEAD(&dev->dma_pools);\n    mutex_init(&dev->mutex);\n    lockdep_set_novalidate_class(&dev->mutex);\n    spin_lock_init(&dev->devres_lock);\n    INIT_LIST_HEAD(&dev->devres_head);\n    device_pm_init(dev);\n    set_dev_node(dev, -1);\n#ifdef CONFIG_GENERIC_MSI_IRQ\n    INIT_LIST_HEAD(&dev->msi_list);\n#endif\n}\nEXPORT_SYMBOL_GPL(device_initialize);\n```\n\n\n\n```\nint device_add(struct device *dev)\n{\n    struct device *parent = NULL;\n    struct kobject *kobj;\n    struct class_interface *class_intf;\n    int error = -EINVAL;\n    struct kobject *glue_dir = NULL;\n\n    dev = get_device(dev);\n\n    if (!dev->p) {\n        error = device_private_init(dev);\n        if (error)\n            goto done;\n    }\n\n    if (dev->init_name) {\n        dev_set_name(dev, \"%s\", dev->init_name);\n        dev->init_name = NULL;\n    }\n\n    if (!dev_name(dev) && dev->bus && dev->bus->dev_name)\n        dev_set_name(dev, \"%s%u\", dev->bus->dev_name, dev->id);\n\n    parent = get_device(dev->parent);\n    kobj = get_device_parent(dev, parent);\n\n    if (kobj)\n        dev->kobj.parent = kobj;\n    if (parent && (dev_to_node(dev) == NUMA_NO_NODE))\n        set_dev_node(dev, dev_to_node(parent));\n\n    error = kobject_add(&dev->kobj, dev->kobj.parent, NULL);\n\n    if (platform_notify)\n        platform_notify(dev);\n\n    error = device_create_file(dev, &dev_attr_uevent);\n\n    error = device_add_class_symlinks(dev);\n\n    error = device_add_attrs(dev);\n\n    error = bus_add_device(dev);\n\n    error = dpm_sysfs_add(dev);\n\n    device_pm_add(dev);\n\n    if (MAJOR(dev->devt)) {\n        error = device_create_file(dev, &dev_attr_dev);\n\n        error = device_create_sys_dev_entry(dev);\n\n        devtmpfs_create_node(dev);\n    }\n\n    if (dev->bus)\n        blocking_notifier_call_chain(&dev->bus->p->bus_notifier,\n                         BUS_NOTIFY_ADD_DEVICE, dev);\n\n    kobject_uevent(&dev->kobj, KOBJ_ADD);\n    bus_probe_device(dev);\n    if (parent)\n        klist_add_tail(&dev->p->knode_parent,\n                   &parent->p->klist_children);\n\n    if (dev->class) {\n        mutex_lock(&dev->class->p->mutex);\n        klist_add_tail(&dev->knode_class,\n                   &dev->class->p->klist_devices);\n\n        list_for_each_entry(class_intf,\n                    &dev->class->p->interfaces, node)\n            if (class_intf->add_dev)\n                class_intf->add_dev(dev, class_intf);\n        mutex_unlock(&dev->class->p->mutex);\n    }\n}\nEXPORT_SYMBOL_GPL(device_add);\n```\n\n\n\n\ndevice_addbus_add_devicebus_probe_device\n\n\n\n\n\n##### 3.4.2 注销I2C设备\n\n\n\n```\n// drivers/i2c/i2c-core.c\nvoid i2c_unregister_device(struct i2c_client *client)\n{\n    if (client->dev.of_node)\n        of_node_clear_flag(client->dev.of_node, OF_POPULATED);\n    if (ACPI_COMPANION(&client->dev))\n        acpi_device_clear_enumerated(ACPI_COMPANION(&client->dev));\n    device_unregister(&client->dev);\n}\nEXPORT_SYMBOL_GPL(i2c_unregister_device);\n```\n\n\n\n\n\n```mermaid\ngraph TB\n\ti2c_new_device(i2c_new_device)\n\ti2c_unregister_device(i2c_unregister_device)\n```\n\n\n\n\n\n#### 3.5 适配器和设备通信\n\n\n\nI2C总线通信方式是对特定的I2C适配器使用i2c_transfer()函数，调用i2c_algothrim的master_xfer()方法实现i2c_msg消息的传输；不同的适配器，对应的master_xfer()方法由控制器的硬件决定，由芯片厂商提供；\n\n\n\n##### 3.5.1 i2c_transfer\n\n\n\n\n在I2C设备和I2C驱动匹配之后，驱动程序和设备的通讯，通过i2c_transfer()函数来给设备发送信息；\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n    int ret;\n    if (adap->algo->master_xfer) {\n\t\t......\n        ret = __i2c_transfer(adap, msgs, num);\n\t\t......\n}\nEXPORT_SYMBOL(i2c_transfer);\n```\n\ni2c_transfer()函数是i2c核心提供给设备驱动的发送方法，该函数发送的数据需要被打包成i2c_msg结构，该函数最终会回调i2c_adapter->i2c_algorithm->master_xfer()函数，将i2c_msg对象发送到i2c的物理控制器；\n\n```\n// drivers/i2c/i2c-core.c\nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n    unsigned long orig_jiffies;\n    int ret, try;\n\n    if (adap->quirks && i2c_check_for_quirks(adap, msgs, num))\n        return -EOPNOTSUPP;\n\n    if (static_key_false(&i2c_trace_msg)) {\n        int i;\n        for (i = 0; i < num; i++)\n            if (msgs[i].flags & I2C_M_RD)\n                trace_i2c_read(adap, &msgs[i], i);\n            else\n                trace_i2c_write(adap, &msgs[i], i);\n    }\n\n    orig_jiffies = jiffies;\n    for (ret = 0, try = 0; try <= adap->retries; try++) {\n        ret = adap->algo->master_xfer(adap, msgs, num);\t\t// 发送、接收信息操作\n        if (ret != -EAGAIN)\n            break;\n        if (time_after(jiffies, orig_jiffies + adap->timeout))\n            break;\n    }\n\t......\n}\nEXPORT_SYMBOL(__i2c_transfer);\n```\n\n最终，通过adap->algo->master_xfer()函数，将struct i2c_msg结构体类型的消息，通过适配器的struct i2c_adapter发送给设备，或者从设备中读取信息；\n\n\n\n##### 3.5.2 消息格式\n\n\n\n经过mster_xfer()函数发送、接收的消息类型应该按照struct i2c_msg结构体格式：\n\n```c\n// include/uapi/linux/i2c.h\nstruct i2c_msg {\n    __u16 addr; /* slave address            */\n    __u16 flags;\n#define I2C_M_RD        0x0001  /* read data, from slave to master */\n                    /* I2C_M_RD is guaranteed to be 0x0001! */\n#define I2C_M_TEN       0x0010  /* this is a ten bit chip address */\n#define I2C_M_RECV_LEN      0x0400  /* length will be first received byte */\n#define I2C_M_NO_RD_ACK     0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_IGNORE_NAK    0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_REV_DIR_ADDR  0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_NOSTART       0x4000  /* if I2C_FUNC_NOSTART */\n#define I2C_M_STOP      0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n    __u16 len;      /* msg length               */\n    __u8 *buf;      /* pointer to msg data          */\n};\n```\n\n> I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；\n>\n> I2C读取，即封装的xxx_i2c_read()函数，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；\n>\n> I2C写入，即封装的xxx_i2c_write()函数，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；\n\n注意：以数组格式定义i2c_msg是为了访问连续，因为数组是连续内存存储的；\n\n\n\n##### 3.5.3 消息发送、接收函数\n\n\n\n###### 1）发送函数\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_master_send(const struct i2c_client *client, const char *buf, int count)\n{\n    int ret;\n    struct i2c_adapter *adap = client->adapter;\n    struct i2c_msg msg;\n\n    msg.addr = client->addr;\n    msg.flags = client->flags & I2C_M_TEN;\n    msg.len = count;\n    msg.buf = (char *)buf;\n\n    ret = i2c_transfer(adap, &msg, 1);\n\n    return (ret == 1) ? count : ret;\n}\nEXPORT_SYMBOL(i2c_master_send);\n```\n\nI2C发送消息操作时，仅需要一个i2c_msg；i2c_msg的buf，保存slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；如下：\n\n```c\ni2c_master_send(client, data, len);\n```\n\n\n\n###### 2）接收函数\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_master_recv(const struct i2c_client *client, char *buf, int count)\n{\n    struct i2c_adapter *adap = client->adapter;\n    struct i2c_msg msg;\n    int ret;\n\n    msg.addr = client->addr;\n    msg.flags = client->flags & I2C_M_TEN;\n    msg.flags |= I2C_M_RD;\n    msg.len = count;\n    msg.buf = buf;\n\n    ret = i2c_transfer(adap, &msg, 1);\n\n    return (ret == 1) ? count : ret;\n}\nEXPORT_SYMBOL(i2c_master_recv);\n```\n\nI2C接收消息操作时，需要给从设备发送两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，并使用buf指针指向这个地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；\n\n也可以分两次，先使用i2c_master_send()函数，向slave发出目标寄存器地址，在使用i2c_master_recv()函数，用来接收读取到的数据消息；如下：\n\n```c\n\ti2c_master_send(client, reg, 2); \n\ti2c_master_recv(client, data, len);\n```\n\n\n\n### 4. 添加设备\n\n\n\n在内核中的Documentation/i2c/instantiating-devices文件中，讲述了添加设备的方法；\n\n\n\ni2c_client结构是通过以下方式自动创建：\n\n> 分配、设置、注册i2c_board_info\n>\n> 获取i2c_adapter，调用i2c_new_device\n>\n> 通过设备树（DeviceTree）创建\n\n\n\n#### 4.1 添加设备树\n\n\n\n```\n// Image-fsl-lx2160a-rdb-new.dts\n        i2c@2030000 {\n            compatible = \"fsl,vf610-i2c\";\n            #address-cells = <0x1>;\n            #size-cells = <0x0>;\n            reg = <0x0 0x2030000 0x0 0x10000>;\n            interrupts = <0x0 0x23 0x4>;\n            scl-gpios=<&gpio4 8 0x0>;\n            clock-names = \"i2c\";\n            clocks = <0x2 0x4 0x7>;\n            status = \"okay\";\n            rtc@32 {\n                compatible = \"Micro Crystal,rv8803\";\n                reg = <0x32>;\n            };\n\n            eeprom_mcy@51 {\n                compatible = \"mcy,eeprom_mcy\";\n                reg = <0x51>;\n            };\n        };\n```\n\n\n\n\n\n```\n# ls /sys/bus/i2c/devices/\n2-0032  2-0051  i2c-0   i2c-1   i2c-2   i2c-3 \n# ls /sys/bus/i2c/devices/ -l\ntotal 0\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0032 -> ../../../devices/platform/soc/2030000.i2c/i2c-2/2-0032\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0051 -> ../../../devices/platform/soc/2030000.i2c/i2c-2/2-0051\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-0 -> ../../../devices/platform/soc/2000000.i2c/i2c-0\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-1 -> ../../../devices/platform/soc/2010000.i2c/i2c-1\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-2 -> ../../../devices/platform/soc/2030000.i2c/i2c-2\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-3 -> ../../../devices/platform/soc/2050000.i2c/i2c-3\n\n\n# ls /sys/bus/i2c/devices/2-0051/\nconsumers  modalias   name       of_node    subsystem  suppliers  uevent\n# ls /sys/bus/i2c/devices/2-0051/ -l\ntotal 0\n-r--r--r--    1 root     root          4096 Oct 15 03:27 consumers\n-r--r--r--    1 root     root          4096 Oct 15 03:27 modalias\n-r--r--r--    1 root     root          4096 Oct 15 03:27 name\nlrwxrwxrwx    1 root     root             0 Oct 15 03:27 of_node -> ../../../../../../firmware/devicetree/base/soc/i2c@2030000/eeprom_mcy@51\nlrwxrwxrwx    1 root     root             0 Oct 15 03:27 subsystem -> ../../../../../../bus/i2c\n-r--r--r--    1 root     root          4096 Oct 15 03:27 suppliers\n-rw-r--r--    1 root     root          4096 Oct 15 03:27 uevent\n# cat /sys/bus/i2c/devices/2-0051/name\neeprom_mcy\n```\n\n\n\n\n\n#### 4.2 i2c_new_device添加\n\n\n\n\n\n```c\n#include <linux/module.h>\n#include <linux/i2c.h>\n\nstatic struct i2c_client *client;\n\nstatic struct i2c_board_info eeprom_info = { \n    I2C_BOARD_INFO(\"eeprom_device\", 0x51),\n};\n\nstatic int eeprom_device_init(void)\n{\n    struct i2c_adapter *adap = NULL;\n\n    printk(\"%s: %d\\n\", __func__, __LINE__);\n\n    adap = i2c_get_adapter(2);\n    if (!adap) {\n        printk(\"%s, i2c_get_adapter failed!\\n\", __func__);\n        return -1; \n    }   \n\n    client = i2c_new_device(adap, &eeprom_info);\n    if (!client) {\n        printk(\"%s, i2c_new_device failed!\\n\", __func__);\n        return -2; \n    }   \n\n    i2c_put_adapter(adap);\n\n    return 0;\n}\n\nstatic void eeprom_device_exit(void)\n{\n    printk(\"%s: %d\\n\", __func__, __LINE__);\n\n    i2c_unregister_device(client);\n}\n\nmodule_init(eeprom_device_init);\nmodule_exit(eeprom_device_exit);\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.3 静态注册I2C设备\n\n内核提供了一种静态注册I2C设备的方法，通过i2c_register_board_info()函数实现：\n\n```\n// drivers/i2c/i2c-boardinfo.c\nint i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len)\n{\n    int status;\n\n    if (busnum >= __i2c_first_dynamic_bus_num)\n        __i2c_first_dynamic_bus_num = busnum + 1;\n\n    for (status = 0; len; len--, info++) {\n        struct i2c_devinfo  *devinfo;\n\n        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);\n\n        devinfo->busnum = busnum;\n        devinfo->board_info = *info;\n        list_add_tail(&devinfo->list, &__i2c_board_list);\n    }   \n\t......\n}\n```\n\n在系统初始化过程中，可以通过i2c_register_board_info()函数，将需要的I2C设备添加到\\_\\_i2c_board_list链表；系统在成功加载I2C适配器adapter后，会对这个\\_\\_i2c_board_list链表中所有的设备逐一完成i2c_client的注册；\n\n```\n// drivers/i2c/i2c-core.h\nstruct i2c_devinfo {\n    struct list_head    list;\n    int         busnum;\n    struct i2c_board_info   board_info;\n};\n```\n\n系统初始化时，根据I2C设备配置信息，创建I2C设备（i2c_client），并添加到I2C子系统；\n\n最终是在i2c_scan_static_board_info()函数中，通过调用i2c_new_device()函数来实现添加设备；i2c_scan_static_board_info()函数一般在初始化时工作；\n\n```\n// drivers/i2c/i2c-core.c\nstatic void i2c_scan_static_board_info(struct i2c_adapter *adapter)\n{\n    struct i2c_devinfo  *devinfo;\n\n    list_for_each_entry(devinfo, &__i2c_board_list, list) {\n        if (devinfo->busnum == adapter->nr\n                && !i2c_new_device(adapter,\n                        &devinfo->board_info))\n\t\t......\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n### 5. 添加驱动\n\n以eeprom为例；\n\n\n\n\n\n#### 5.1 I2C设备驱动框架\n\n```c\nstatic int mcy_eeprom_init(void)\n{\n    printk(\"%s\\n\", __func__);\n\n    i2c_add_driver(&mcy_eeprom_driver);\n\n    return 0;\n}\n\nstatic void mcy_eeprom_exit(void)\n{\n    printk(\"%s\\n\", __func__);\n\n    i2c_del_driver(&mcy_eeprom_driver);\n}\n\nmodule_init(mcy_eeprom_init);\nmodule_exit(mcy_eeprom_exit);\n```\n\n\n\n```c\nstruct i2c_driver mcy_eeprom_driver = {\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"mcy_eeprom\",\n        //.of_match_table = mcy_eeprom_table,\n    },\n    .probe = mcy_eeprom_probe,\n    .remove = mcy_eeprom_remove,\n    .id_table = mcy_eeprom_id,\n};\n```\n\n\n\n\n\n\n\n```mermaid\ngraph TB\n\teeprom_init(eeprom_init)-->\n\ti2c_add_driver(i2c_add_driver)-->eeprom_driver(eeprom_driver)\n\teeprom_driver-->driver(driver)\n\teeprom_driver-->probe(probe)\n\teeprom_driver-->remove(remove)\n\teeprom_driver-->id_table(id_table)\n```\n\n\n\n#### 5.2 probe函数\n\n##### 1）注册字符设备\n\n```c\nint mcy_eeprom_probe(struct i2c_client *client, const struct i2c_device_id *id)\n{\n    int ret = -1; \n\n    printk(\"%s\\n\", __func__);\n    \n    eeprom_driver.client = client;\n\n    ret = alloc_chrdev_region(&devnum, 0, 1, \"mcy_eeprom_chrdev\");\n    if (ret) {\n        printk(\"%s, alloc_chrdev_region failed!\\n\", __func__);\n        goto chrdev_err;\n    }   \n    printk(\"%s, alloc_chrdev_region, devnum: %d\\n\", __func__, devnum);\n\n    cdev = cdev_alloc();\n    cdev_init(cdev, &mcy_eeprom_fops);\n    ret = cdev_add(cdev, devnum, 1); \n    if (ret) {\n        printk(\"%s, cdev_add failed!\\n\", __func__);\n        goto cdev_err;\n    }\n        \n    // /sys/class\n    dev_class = class_create(THIS_MODULE, \"mcy_eeprom_class\");\n    if (IS_ERR(dev_class)) {\n        printk(\"%s, dev_class class_create failed\\n\", __func__);\n        goto class_err;\n    }   \n    // /dev\n    device_create(dev_class, NULL, devnum, NULL, \"mcy_eeprom0\");\n\n    printk(\"%s, OK!\\n\", __func__);\n\n    return 0;\n\nclass_err:\n    cdev_del(cdev);\ncdev_err:\n    unregister_chrdev_region(devnum, 1); \nchrdev_err:\n    return -1; \n}\n```\n\n\n\n##### 2）卸载函数\n\n```c\nint mcy_eeprom_remove(struct i2c_client *client)\n{\n    printk(\"%s\\n\", __func__);\n\n    device_destroy(dev_class, devnum);\n    class_destroy(dev_class);\n    cdev_del(cdev);\n    unregister_chrdev_region(devnum, 1);\n    kfree(cdev);\n\n    return 0;\n}\n```\n\n\n\n##### 3）字符设备操作集\n\n```c\nstruct file_operations mcy_eeprom_fops= {\n    .open = eeprom_driver_open,\n    .release = eeprom_driver_release,\n    .read = eeprom_driver_read,\n    .write = eeprom_driver_write,\n};\n```\n\n\n\n#### 5.3 读写函数\n\n\n\nI2C数据的发送和接收，是通过I2C驱动中file_operations的write和read系统调用来实现的；驱动中read和write的封装，是需要封装调用i2c_transfer()函数来完成i2d_msg消息的通信；read和write函数的封装，有两种方法；\n\n\n\n##### 5.3.1 内核函数调用\n\n使用i2c-core.c提供的i2c_master_send()和i2c_master_recv()函数实现I2C信息的发送和接收；\n\n\n\n###### 1）发送\n\n```c\ni2c_master_send(client, data, len);\n```\n\nI2C发送，直接调用i2c_master_send()函数，一次完成I2C数据的发送；\n\ndata：要发送的数据信息数组；其中data最前边的地址存放的是I2C从设备寄存器的地址，如果地址是8bits，就占用data[0]，如果地址是16bits，占用data[0]和data[1]；在地址之后，紧接着存放要发送的数据内容；\n\nlen：要发送的数据长度；包含I2C从设备寄存器地址和数据内容的总数据长度；\n\n```c\nstatic ssize_t eeprom_driver_write(struct file *filp, const char __user *buf, size_t count, loff_t *loff)\n{   \n    eeprom_data_t eeprom_data;\n    unsigned char data[18] = {0};\n    int len = 0;\n    int i = 0;\n    int ret = -1;\n\n    printk(\"%s\\n\", __func__);\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    memcpy(&data[2], eeprom_data.data, eeprom_data.len);\n    data[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8);\n    data[1] = (char)(eeprom_data.reg & 0x000000ff);\n    len = eeprom_data.len + 2;\n\n    for (i = 0; i < len; i++) {\n        printk(\"%s, data[%d]: 0x%2x\\n\", __func__, i, data[i]);\n    }\n#if 1\n    ret = i2c_master_send(eeprom_driver.client, data, len);\n#else\n    \n#endif\n    return 0;\n}\n```\n\n\n\n###### 2）接收\n\n```c\ni2c_master_send(client, reg, reg_len); \ni2c_master_recv(client, data, data_len);\n```\n\nI2C接收不同于发送，需要两步来完成，先使用i2c_master_send()函数向I2C从设备发送要读取的寄存器地址；再使用i2c_master_recv()函数，从I2C从设备指定寄存器地址读取数据；\n\nreg：要读取的从设备寄存器地址数组；如果地址是8bits，reg_len为1；如果地址是16bits，reg_len为2；\n\ndata：要读取的数据信息存放的指针地址；data_len为要读取的寄存器个数；\n\n###### \n\n```c\nstatic ssize_t eeprom_driver_read(struct file *filp, char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    unsigned char reg[2] = {0};\n    int i = 0;\n    int ret = -1; \n\n    printk(\"%s\\n\", __func__);\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1; \n    }\n\n    reg[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8); \n    reg[1] = (char)(eeprom_data.reg & 0x000000ff);\n\n#if 1\n    ret = i2c_master_send(eeprom_driver.client, reg, 2); \n    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);\n#else\n    \n#endif\n\n    for (i = 0; i < eeprom_data.len; i++) {\n        printk(\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\", __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);\n    }   \n\n    ret = copy_to_user(buf, &eeprom_data, count);\n    if (ret < 0) {\n        printk(\"%s, copy_to_user failed, ret: %d\\n\", __func__, ret);\n        return -1; \n    }   \n\n    return 0;\n}\n```\n\n\n\n##### 5.3.2 直接封装\n\n直接通过封装i2c_msg消息，通过i2c_transfer()函数实现I2C信息的发送和接收；\n\n###### 1）发送\n\n```c\nint i2c_send_bytes(const struct i2c_client *client, unsigned short reg, const char *buf, int count)\n{\n    unsigned char *data = NULL;\n    struct i2c_msg msg;\n    int len = 0;\n    int ret = -1;\n\n    data = kmalloc(count + 2, GFP_KERNEL);\n    if (!data) {\n        printk(\"%s, kmalloc failed!\\n\", __func__);\n        return -1;\n    }\n    data[0] = (char)((reg & 0x0000ff00) >> 8);\n    data[1] = (char)(reg & 0x000000ff);\n    memcpy(&data[2], buf, count);\n    len = count + 2;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.addr = client->addr;\n    msg.flags = 0;\n    msg.len = count;\n    msg.buf = data;\n\n    ret = i2c_transfer(client->adapter, &msg, 1);\n\n    if (data) {\n        kfree(data);\n        data = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n```c\nstatic ssize_t eeprom_driver_write(struct file *filp, const char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    ret = i2c_send_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);\n\n    return 0;\n}\n```\n\n\n\n###### 2）接收\n\n```c\nint i2c_recv_bytes(const struct i2c_client *client, unsigned short reg, unsigned char *buf, int count)\n{\n    struct i2c_msg msg[2] = { 0 };\n    unsigned char txbuf[2] = { 0 };\n    int ret = -1;\n\n    txbuf[0] = (char)((reg & 0x0000ff00) >> 8);\n    txbuf[1] = (char)(reg & 0x000000ff);\n\n    memset(&msg, 0, sizeof(msg));\n    msg[0].addr = client->addr;\n    msg[0].flags = 0;\n    msg[0].len = 2;\n    msg[0].buf = txbuf;\n\n    msg[1].addr = client->addr;\n    msg[1].flags = I2C_M_RD;\n    msg[1].len = count;\n    msg[1].buf = buf;\n\n    ret = i2c_transfer(client->adapter, msg, 2);\n\n    return ret;\n}\n```\n\n\n\n```c\nstatic ssize_t eeprom_driver_read(struct file *filp, char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    ret = i2c_recv_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);\n\n    ret = copy_to_user(buf, &eeprom_data, count);\n    if (ret < 0) {\n        printk(\"%s, copy_to_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    return 0;\n}\n```\n\n\n\n### 6. 驱动和设备匹配\n\n设备和驱动的关系\n\n对于一个驱动程序，有两个必不可少的元素，即：设备和驱动，驱动是通过设备名和驱动名建立联系；在i2c_adapter注册时会遍历i2c_board_info结构，会完成驱动和设备的匹配；\n\n\n\n一个驱动程序，可以有多个名字，即一个驱动程序可以支持多个设备，该机制通过由i2c_device_id结构体组成的数组实现；该数组是在驱动中建立；I2C架构会扫描该结构体数组，逐一与设备进行匹配，匹配成功就会调用相应的probe函数；\n\n进入驱动中的probe函数，要先进入总线的probe函数，而前提是设备与驱动的match匹配成功；\n\n\n\nbus_add_driver\n\n```\n// drivers/base/bus.c\nint bus_add_driver(struct device_driver *drv)\n{\n    struct bus_type *bus;\n    struct driver_private *priv;\n    int error = 0; \n\n    bus = bus_get(drv->bus);\n\n    priv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\n    klist_init(&priv->klist_devices, NULL, NULL);\n    priv->driver = drv; \n    drv->p = priv;\n    priv->kobj.kset = bus->p->drivers_kset;\n    error = kobject_init_and_add(&priv->kobj, &driver_ktype, NULL,\n                     \"%s\", drv->name);\n\n    klist_add_tail(&priv->knode_bus, &bus->p->klist_drivers);\n    if (drv->bus->p->drivers_autoprobe) {\n        if (driver_allows_async_probing(drv)) {\n            async_schedule(driver_attach_async, drv);\n        } else {\n            error = driver_attach(drv);\n        }\n    }\n    module_add_driver(drv->owner, drv);\n\n    error = driver_create_file(drv, &driver_attr_uevent);\n\n    error = driver_add_groups(drv, bus->drv_groups);\n\n    if (!drv->suppress_bind_attrs) {\n        error = add_bind_files(drv);\n    }\n\t......\n}\n```\n\n\n\n\n\n\n\n```\n// drivers/base/dd.c\nint driver_attach(struct device_driver *drv)\n{               \n    return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);\n}       \nEXPORT_SYMBOL_GPL(driver_attach);\n```\n\n\n\n\n\n```\n// drivers/base/bus.c\nint bus_for_each_dev(struct bus_type *bus, struct device *start,\n             void *data, int (*fn)(struct device *, void *))\n{\n    struct klist_iter i;\n    struct device *dev;\n    int error = 0;\n\n    if (!bus || !bus->p)\n        return -EINVAL;\n\n    klist_iter_init_node(&bus->p->klist_devices, &i,\n                 (start ? &start->p->knode_bus : NULL));\n    while ((dev = next_device(&i)) && !error)\n        error = fn(dev, data);\n    klist_iter_exit(&i);\n    return error;\n}\nEXPORT_SYMBOL_GPL(bus_for_each_dev);\n```\n\n\n\n\n\n```\n// drivers/base/dd.c\nstatic int __driver_attach(struct device *dev, void *data)\n{\n    struct device_driver *drv = data;\n    int ret;\n\n    ret = driver_match_device(drv, dev);\n\t......\n    if (!dev->driver)\n        driver_probe_device(drv, dev);\n\t......\n}\n```\n\n\n\n\n\n```\n// drivers/base/base.h\nstatic inline int driver_match_device(struct device_driver *drv,\n                      struct device *dev)\n{\n    return drv->bus->match ? drv->bus->match(dev, drv) : 1;\n}\n```\n\n\n\n\n\n```\n// drivers/base/dd.c\nint driver_probe_device(struct device_driver *drv, struct device *dev)\n{\n    int ret = 0;\n\n    if (!device_is_registered(dev))\n        return -ENODEV;\n\n    pr_debug(\"bus: '%s': %s: matched device %s with driver %s\\n\",\n         drv->bus->name, __func__, dev_name(dev), drv->name);\n\n    if (dev->parent)\n        pm_runtime_get_sync(dev->parent);\n\n    pm_runtime_barrier(dev);\n    ret = really_probe(dev, drv);\n    pm_request_idle(dev);\n\n    if (dev->parent)\n        pm_runtime_put(dev->parent);\n\n    return ret;\n}\n```\n\n\n\n\n\n```\n// drivers/base/dd.c\nstatic int really_probe(struct device *dev, struct device_driver *drv)\n{\n\t......\n\tif (dev->bus->probe) {\n        ret = dev->bus->probe(dev);\n    } else if (drv->probe) {\n        ret = drv->probe(dev);\n    }\n    ......\n}\n```\n\n\n\n\n\n```mermaid\ngraph TB\n\tbus_add_driver(bus_add_driver)-->\n\tdriver_attach(driver_attach)--bus_for_each_dev-->\n\t__driver_attach(__driver_attach)-->\n\tdriver_match_device(driver_match_device)-->\n\tbus_match(drv->bus->match)\n\t__driver_attach-->driver_probe_device(driver_probe_device)-->\n\treally_probe(really_probe)-->\n\tbus_probe(dev->bus->probe)\n```\n\n\n\n\n\n\n\n```\n// drivers/i2c/i2c-core.c \nstruct bus_type i2c_bus_type = {\n    .name       = \"i2c\",\n    .match      = i2c_device_match,\n    .probe      = i2c_device_probe,\n    .remove     = i2c_device_remove,\n    .shutdown   = i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n```\n\n\n\n\n\n#### 6.1 match\n\n\n\n```\n// drivers/i2c/i2c-core.c \nstatic int i2c_device_match(struct device *dev, struct device_driver *drv)\n{\n    struct i2c_client   *client = i2c_verify_client(dev);\n    struct i2c_driver   *driver;\n\n    if (!client)\n        return 0;\n\n    /* Attempt an OF style match */\n    if (of_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    driver = to_i2c_driver(drv);\n    /* match on an id table if there is one */\n    if (driver->id_table)\n        return i2c_match_id(driver->id_table, client) != NULL;\n\n    return 0;\n}\n```\n\n\n\n```mermaid\ngraph LR\n\ti2c_device_match(i2c_device_match)\n\ti2c_device_match-->of_driver_match_device(of_driver_match_device)\n\ti2c_device_match-->acpi_driver_match_device(acpi_driver_match_device)\n\ti2c_device_match--id_table-->i2c_match_id(i2c_match_id)\n```\n\n\n\n\n从i2c_device_match()函数的定义可以得出，i2c的match函数，优先选择设备树匹配（of_driver_match_device），如果设备树匹配成功，函数就返回；否则，会进行下一个。。。。。。，最后，如果定义了id_table，就会通过i2c_match_id()函数进行id_table匹配；如果三者全都匹配不成功，才算是匹配失败；\n\n从i2c_device_match函数来看，配置了设备树，就不需要id_table的定义了；但是实际上还是需要id_table的定义的，因为在后边的probe函数中需要判断id_table是否定义，如果定义了才能执行driver->probe函数；\n\n\n\n设备树的匹配过程如下：\n\n```mermaid\ngraph TB\n\tof_driver_match_device(of_driver_match_device)-->\n\tof_match_device(of_match_device)-->\n\tof_match_node(of_match_node)-->\n\t__of_match_node(__of_match_node)-->\n\t__of_device_is_compatible(__of_device_is_compatible)\n\t__of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n\t__of_device_is_compatible--type-->of_compat_cmp\n\t__of_device_is_compatible--name-->of_compat_cmp\n\tof_compat_cmp-->\n\tstrcasecmp(strcasecmp)\n```\n\n\n\n\n__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；\n\n匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；\n\n\n\n#### 6.2 probe\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstatic int i2c_device_probe(struct device *dev)\n{\n    struct i2c_client   *client = i2c_verify_client(dev);\n    struct i2c_driver   *driver;\n    int status;\n    ......\n    driver = to_i2c_driver(dev->driver);\n    if (!driver->probe || !driver->id_table)\n        return -ENODEV;\n\t......\n    status = driver->probe(client, i2c_match_id(driver->id_table, client));\n\t......\n}\n```\n\n\ni2c_device_probe()函数中，如果配置了设备树，i2c总线在match函数中，就不需要id_table的定义了；但是在probe函数中，还是需要id_table的定义的，因为在probe函数中需要判断id_table是否定义，如果定义了才能执行driver->probe函数；\n\n\n\n\n\n#### 6.3 I2C注册匹配过程\n\n\n\n![I2C注册匹配过程](Linux-kernel中的I2C子系统/I2C注册匹配过程.png)\n\n\n\n\n\n\n\n### 7. 实例\n\n以添加eeprom驱动为例讲解I2C驱动在eeprom芯片中的使用；\n\n\n\n#### 7.1 添加设备\n\n##### 1）添加设备树\n\n```\n// arch/arm/boot/dts/vexpress-v2m.dtsi\n\t\t\tv2m_i2c_dvi: i2c@16000 {\n                compatible = \"arm,versatile-i2c\";\n                reg = <0x16000 0x1000>;\n\n                #address-cells = <1>;\n                #size-cells = <0>;\n\n                dvi-transmitter@39 {\n                    compatible = \"sil,sii9022-tpi\", \"sil,sii9022\";\n                    reg = <0x39>;\n                };\n\n                dvi-transmitter@60 {\n                    compatible = \"sil,sii9022-cpi\", \"sil,sii9022\";\n                    reg = <0x60>;\n                };\n\n                eeprom@51 {\n                    compatible = \"mcy,mcy_eeprom\";\n                    reg = <0x51>;\n                };\n            };\n```\n\n\n\n\n\n##### 2）i2c_new_device\n\n```c\n// mcy_eeprom_device.c\n#include <linux/module.h>\n#include <linux/i2c.h>\n\nstatic struct i2c_client *client;\n\nstatic struct i2c_board_info eeprom_info = { \n    I2C_BOARD_INFO(\"eeprom_device\", 0x51),\n};\n\nstatic int eeprom_device_init(void)\n{\n    struct i2c_adapter *adap = NULL;\n\n    adap = i2c_get_adapter(2);\n    if (!adap) {\n        printk(\"%s, i2c_get_adapter failed!\\n\", __func__);\n        return -1; \n    }\n\n    client = i2c_new_device(adap, &eeprom_info);\n    if (!client) {\n        printk(\"%s, i2c_new_device failed!\\n\", __func__);\n        return -2; \n    }   \n\n    i2c_put_adapter(adap);\n\n    return 0;\n}\n\nstatic void eeprom_device_exit(void)\n{\n    i2c_unregister_device(client);\n}\n\nmodule_init(eeprom_device_init);\nmodule_exit(eeprom_device_exit);\n```\n\n\n\n\n\n#### 7.2 添加驱动\n\n##### 实例代码\n\n```c\n// mcy_eeprom_driver.c\n#include <linux/module.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <asm-generic/uaccess.h>\n\ntypedef struct eeprom_data_s {\n    int reg;\n    int len;\n    unsigned char data[16];\n} eeprom_data_t;\n\ntypedef struct eeprom_driver_s {\n    dev_t devnum;\n    struct cdev *cdev;\n    struct class *class;\n    struct device *dev;\n    struct i2c_client *client;\n} eeprom_driver_t;\n\neeprom_data_t eeprom_data;\neeprom_driver_t eeprom_driver;\n\nstatic int eeprom_driver_open(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic int eeprom_driver_release(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic ssize_t eeprom_driver_read(struct file *filp, char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    unsigned char reg[2] = {0};\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    reg[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8);\n    reg[1] = (char)(eeprom_data.reg & 0x000000ff);\n\n    ret = i2c_master_send(eeprom_driver.client, reg, 2);\n    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);\n\n    for (i = 0; i < eeprom_data.len; i++) {\n        printk(\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\", __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);\n    }\n\n    ret = copy_to_user(buf, &eeprom_data, count);\n    if (ret < 0) {\n        printk(\"%s, copy_to_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic ssize_t eeprom_driver_write(struct file *filp, const char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    unsigned char data[18] = {0};\n    int len = 0;\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    memcpy(&data[2], eeprom_data.data, eeprom_data.len);\n    data[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8);\n    data[1] = (char)(eeprom_data.reg & 0x000000ff);\n    len = eeprom_data.len + 2;\n\n    for (i = 0; i < len; i++) {\n        printk(\"%s, data[%d]: 0x%2x\\n\", __func__, i, data[i]);\n    }\n\n    ret = i2c_master_send(eeprom_driver.client, data, len);\n\n    return 0;\n}\n\nstruct file_operations eeprom_driver_fops = {\n    .open = eeprom_driver_open,\n    .release = eeprom_driver_release,\n    .read = eeprom_driver_read,\n    .write = eeprom_driver_write,\n};\n\nint eeprom_driver_probe(struct i2c_client *client, const struct i2c_device_id *id)\n{\n    int major = 0;\n    int ret = -1;\n\n    eeprom_driver.client = client;\n\n    ret = alloc_chrdev_region(&eeprom_driver.devnum, 0, 1, \"eeprom_driver_chrdev\");\n    if (ret < 0) {\n        printk(\"%s, alloc_chrdev_region failed!\\n\", __func__);\n        goto chrdev_err;\n    }\n    major = MAJOR(eeprom_driver.devnum);\n    printk(\"%s, alloc_chrdev_region, devnum: 0x%x, major: %d\\n\", __func__, eeprom_driver.devnum, major);\n\n    eeprom_driver.cdev = cdev_alloc();\n    if (!eeprom_driver.cdev) {\n        printk(\"%s, cdev_alloc failed!\\n\", __func__);\n        goto cdev_alloc_err;\n    }\n    cdev_init(eeprom_driver.cdev, &eeprom_driver_fops);\n    ret = cdev_add(eeprom_driver.cdev, eeprom_driver.devnum, 1);\n    if (ret < 0) {\n        printk(\"%s, cdev_add failed!\\n\", __func__);\n        goto cdev_add_err;\n    }\n\n    // /sys/class\n    eeprom_driver.class = class_create(THIS_MODULE, \"eeprom_driver_class\");\n    if (IS_ERR(eeprom_driver.class)) {\n        printk(\"%s, class_create failed!\\n\", __func__);\n        ret = PTR_ERR(eeprom_driver.class);\n        goto class_create_err;\n    }\n    // /dev\n    eeprom_driver.dev = device_create(eeprom_driver.class, NULL, eeprom_driver.devnum, NULL, \"eeprom_driver\");\n    if (IS_ERR(eeprom_driver.dev)) {\n        printk(\"%s, device_create failed!\\n\", __func__);\n        ret = PTR_ERR(eeprom_driver.dev);\n        goto device_create_err;\n    }\n\n    return 0;\n\ndevice_create_err:\n    class_destroy(eeprom_driver.class);\nclass_create_err:\n    cdev_del(eeprom_driver.cdev);\ncdev_add_err:\n    kfree(eeprom_driver.cdev);\ncdev_alloc_err:\n    unregister_chrdev_region(eeprom_driver.devnum, 1);\nchrdev_err:\n    return -EINVAL;\n}\n\nint eeprom_driver_remove(struct i2c_client *client)\n{\n    device_destroy(eeprom_driver.class, eeprom_driver.devnum);\n    class_destroy(eeprom_driver.class);\n\n    cdev_del(eeprom_driver.cdev);\n\n    kfree(eeprom_driver.cdev);\n    unregister_chrdev_region(eeprom_driver.devnum, 1);\n\n    return 0;\n}\n\nstruct i2c_device_id eeprom_driver_id[] = {\n    {\"mcy_eeprom\", 0},\n    {},\n};\n\nstruct of_device_id eeprom_driver_table[] = {\n    {\n        //.name = \"mcy_eeprom\",\n        .compatible = \"mcy,mcy_eeprom\",\n    },\n    {},\n};\n\nstruct i2c_driver eeprom_i2c_driver= {\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"mcy_eeprom\",\n        //.of_match_table = eeprom_driver_table,\n    },\n    .probe = eeprom_driver_probe,\n    .remove = eeprom_driver_remove,\n    .id_table = eeprom_driver_id,\n};\n\nstatic int eeprom_driver_init(void)\n{\n    i2c_add_driver(&eeprom_i2c_driver);\n\n    return 0;\n}\n\nstatic void eeprom_driver_exit(void)\n{\n    i2c_del_driver(&eeprom_i2c_driver);\n}\n\nmodule_init(eeprom_driver_init);\nmodule_exit(eeprom_driver_exit);\n```\n\n\n\n#### 7.3 应用程序\n\n\n\n```c\n// main.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\ntypedef struct eeprom_s {\n    int reg;\n    int len;\n    unsigned char data[16];\n} eeprom_data_t;\n\nint eeprom_read(int reg, int len)\n{\n    eeprom_data_t eeprom_data;\n    int fd = -1; \n    int i = 0;\n    int ret = -1; \n\n    if (len > 16) {\n        printf(\"%s, len: %d over range!\\n\", __func__, len);\n        return -1; \n    }   \n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    eeprom_data.reg = reg;\n    eeprom_data.len = len;\n    \n    ret = read(fd, &eeprom_data, sizeof(eeprom_data_t));\n    if (ret < 0) {\n        printf(\"%s, read failed, ret: %d\\n\", __func__, ret);\n        return -2; \n    }   \n\n    for (i = 0; i < len; i++) {\n        printf(\"%s, reg[%d]: %d, data: 0x%2x\\n\", __func__, i, reg + i, eeprom_data.data[i]);\n    }   \n\n    return 0;\n}\n\nint eeprom_write(int reg, int len, unsigned char *data)\n{\n    eeprom_data_t eeprom_data;\n    int fd = -1;\n    int i = 0;\n    int ret = -1;\n\n    if (len > 16) {\n        printf(\"%s, len: %d over range!\\n\", __func__, len);\n        return -1;\n    }\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    eeprom_data.reg = reg;\n    eeprom_data.len = len;\n\n    ret = write(fd, &eeprom_data, sizeof(eeprom_data_t));\n    if (ret < 0) {\n        printf(\"%s, read failed, ret: %d\\n\", __func__, ret);\n        return -2;\n    }\n\n    for (i = 0; i < len; i++) {\n        printf(\"%s, reg[%d]: %d, data: 0x%2x\\n\", __func__, i, reg + i, eeprom_data.data[i]);\n    }\n\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    char buf[8] = {0};\n    int count = 0;\n    int reg = 0;\n    int len = 0;\n    int fd = -1;\n    int ret = -1;\n\n    fd = open(\"/dev/eeprom_driver\", O_RDWR | O_NONBLOCK);\n    if (fd < 0) {\n        printf(\"open failed, fd: %d\\n\", fd);\n        return -1;\n    }\n\n    ret = eeprom_write(reg, len, buf);\n    if (ret < 0) {\n        printf(\"eeprom_write failed, ret: %d\\n\", ret);\n        close(fd);\n        return -1;\n    }\n\n    ret = eeprom_read(reg, len);\n    if (ret < 0) {\n        printf(\"eeprom_read failed, ret: %d\\n\", ret);\n        close(fd);\n        return -1;\n    }\n\n    close(fd);\n\n    return 0;\n}\n```\n\n\n\n\n\n#### 7.4 Makefile\n\n\n\n```shell\nifneq ($(KERNELRELEASE),)\n    obj-m := mcy_eeprom_driver.o mcy_eeprom_device.o\nelse\n\n#generate the path\nCURRENT_PATH:=$(shell pwd)\n\n#the absolute path\nLINUX_KERNEL_PATH := /home/xiami/tool/linux-4.9.115\n\nCROSS_COMPILE := arm-linux-gnueabi-\nCC := $(CROSS_COMPILE)gcc\n\n#complie object\nall:\n    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules\nclean:\n    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean\n    -rm main -rf\napp:\n    $(CC) main.c -o main\ninstall:\n    -chmod a+x *.ko\n    -cp *.ko /home/xiami/qemu/nfs_root/mcy -rfp\n    -cp main /home/xiami/qemu/nfs_root/mcy -rfp\n    -chmod a+x /home/xiami/qemu/nfs_root/mcy/* main\nendif\n```\n\n\n\n### 8. 总结\n\n\nI2C总线维护两个链表，一个是I2C驱动链表，一个是I2C设备链表，每当注册一个驱动（或设备），就会将其添加到I2C总线上相对应的I2C驱动链表（或I2C设备链表），然后遍历I2C总线的I2C设备（或I2C驱动）链表的所有设备（或驱动），通过I2C总线的匹配函数判断是否匹配，如果匹配，就调用驱动的probe函数，然后就可以在probe函数中注册字符设备，创建设备节点，实现设备操作集fops等，为应用调用提供接口；\n\n\n\n\n\n参考资料\n\nhttps://blog.csdn.net/shichaog/article/details/41169981\n\n《Linux设备驱动开发详解》\n\n《精通linux设备驱动程序开发》\n\n\n\n\n\n[回到目录](#目录)\n\n\n\n\n\n","source":"_posts/Linux-kernel中的I2C子系统.md","raw":"---\ntitle: Linux kernel中的I2C子系统\ndate: 2020-04-06 14:36:52\ntags: i2c\n---\n\n\n\n\n\nLinux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；\n\n\n\n<!--more-->\n\n\n\n### 目录\n\n[TOC]\n\nLinux内核中的I2C驱动代码位于：drivers/i2c目录；\n\n\n\n### 0. 简述\n\n\n\nLinux内核中的I2C驱动代码位于：drivers/i2c目录；\n\nLinux设备模型由bus、device、driver组成；\n\n\n\nI2C驱动中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；\n\n> I2C总线：维护I2C驱动和I2C设备两个链表，管理I2C驱动和I2C设备的匹配、删除等；\n>\n> I2C设备：具体硬件设备的一个抽象；\n>\n> I2C驱动：对应I2C设备的驱动程序；\n>\n> I2C适配器：用于I2C驱动和I2C设备间通信，是SOC上I2C控制器的一个抽象；\n\n\n\nI2C总线上有两个链表，分别是i2c_driver和i2c_client三链表；当任何一个driver或client注册时，I2C总线都会调用match函数，对client.name和driver.id_table.name进行遍历匹配；如果driver.id_table中所有的id都匹配不成功，说明client没有找到对应的driver；如果匹配成功，说明client和driver是配套的，那么I2C总线就会调用自己的probe函数，然后probe函数调用driver中提供的probe函数，driver中的probe函数会对设备进行硬件初始化和后续工作；\n\n\n\ni2c_add_adapter\t// 注册adapter\n\ni2c_add_driver\t\t// 注册driver\n\ni2c_new_device\t\t// 注册client\n\n\n\n### 1. I2C驱动框架\n\n\n\n\n\nLinux的I2C体系结构分为3个部分：\n\n> I2C核心\n>\n> I2C总线驱动\n>\n> I2C设备驱动\n\n\n\n![Linux的I2C子系统框架](Linux-kernel中的I2C子系统/Linux的I2C子系统框架.png)\n\n\n\n#### 1.1 I2C核心\n\n\n\nI2C核心（i2c_core）维护了i2c_bus结构体，提供了：\n\n> I2C总线驱动和设备驱动的注册、注销方法\n>\n> I2C的通信方法（i2c_algorithm）\n>\n> 上层的与具体适配器无关的代码\n>\n> 探测设备、检测设备地址的上层代码\n\n此部分代码由Linux内核提供；\n\n\n\n#### 1.2 I2C总线驱动\n\n\n\nI2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器由CPU控制，或者直接集成在CPU内部；\n\n\n\nI2C总线驱动主要包含：\n\n> I2C适配器数据结构i2c_adapter\n>\n> I2C适配器的控制算法数据结构i2c_algorithm\n>\n> 控制I2C适配器产生通信信号的函数\n\n通过I2C总线驱动代码，可以控制I2C适配器，以主设备方式产生开始位、停止位、读写周期，以及以从设备方式读写、产生ACK等；\n\n此部分代码由具体的芯片厂商提供，如：高通、Samsung等；\n\n\n\n#### 1.3 I2C设备驱动\n\n\n\nI2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在I2C控制器（适配器）上，通过I2C适配器与CPU交换数据；\n\nI2C设备驱动主要包含i2c_client和i2c_driver结构体，实现和用户交互的文件操作集fops、cdev等；\n\n这两个数据结构中的成员函数，需要由驱动开发者根据具体设备去实现；\n\n\n\n### 2. 核心数据结构\n\n\n\nI2C驱动中最核心的4个数据结构：\n\n> struct i2c_client\n>\n> struct i2c_driver\n>\n> struct i2c_adapter\n>\n> struct i2c_algorithm\n\n\n\n#### 2.1 设备层\n\n\n\n##### 2.1.1 I2C设备（i2c_client）\n\n硬件上连接到I2C的SDA、SCL总线上的设备都是I2C设备，每一个I2C设备由一个i2c_client结构体进行描述；i2c_client对应真实的I2C物理设备，是具体硬件设备的抽象；一个i2c_client对象，表示连接到i2c总线的一个设备；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_client {\n    unsigned short flags;       /* div., see below      */\n    unsigned short addr;        /* chip address - NOTE: 7bit    */\n    char name[I2C_NAME_SIZE];\n    struct i2c_adapter *adapter;    /* the adapter we sit on    */\n    struct device dev;      /* the device structure     */\n    int irq;            /* irq issued by device     */\n    struct list_head detected;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n    i2c_slave_cb_t slave_cb;    /* callback for slave mode  */\n#endif\n};\n```\n\n> unsigned short addr：表示7bit的设备芯片地址，地址被保存在低7bits\n>\n> struct i2c_adapter *adapter：表示这个i2c_client从属的i2c_adapter对象，驱动中使用这个指针操作发送\n>\n> struct device dev：表示device信息\n>\n> struct list_head detected：设备链表，将所有的i2c_client组成链表\n\n\n\ni2c_client结构不是驱动开发者创建的，而是通过以下方式自动创建：\n\n> 分配、设置、注册i2c_board_info\n>\n> 获取i2c_adapter，调用i2c_new_device\n>\n> 通过设备树（DeviceTree）创建\n\n\n\n##### 2.1.2 I2C驱动（i2c_driver）\n\n\n\ni2c_driver结构用于管理I2C的驱动和I2C设备的匹配探测，实现与用户层交互的文件操作集fops、cdev等；每一个I2C设备都对应一个I2C驱动，因此，每一个i2c_client结构，都对应一个i2c_driver结构，通过指针相连；编写一个i2c驱动的本质，就是要构造一个i2c_driver对象，并将其注册到内核；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_driver {\n    unsigned int class;\n\n    int (*attach_adapter)(struct i2c_adapter *) __deprecated;\n\n    /* Standard driver model interfaces */\n    int (*probe)(struct i2c_client *, const struct i2c_device_id *); \n    int (*remove)(struct i2c_client *); \n\n    void (*shutdown)(struct i2c_client *); \n    void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol,\n              unsigned int data);\n\n    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);\n\n    struct device_driver driver;\n    const struct i2c_device_id *id_table;\n\n    /* Device detection callback for automatic device creation */\n    int (*detect)(struct i2c_client *, struct i2c_board_info *); \n    const unsigned short *address_list;\n    struct list_head clients;\n};\n```\n\n> probe：探测函数，匹配成功后执行，会将匹配到的i2c_client对象传入，完成申请资源、初始化、提供接口等操作\n>\n> remove：移除函数，设备消失时或驱动模块被卸载时会被调用，和probe操作相反\n>\n> struct device_driver driver：表明是一个设备的驱动类，用于匹配设备树的of_match_table域\n>\n> const struct i2c_device_id *id_table：用于使用平台文件或模块编写设备信息时进行匹配\n>\n> struct list_head clients：用于将所有i2c_driver联系到一起的链表\n\n\n\n```\n#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)\n```\n\n\n\n##### 2.1.3 总线和设备关系\n\n![I2C设备和驱动的关系](Linux-kernel中的I2C子系统/I2C设备和驱动的关系.png)\n\n\n\n#### 2.2 总线层\n\n\n\n##### 2.2.1 I2C适配器（i2c_adapter）\n\n\n\nI2C适配器，即SOC中的I2C控制器，对应struct i2c_adapter结构体；Linux中用i2c_adapter来表示一个I2C控制器，一个i2c_adapter结构体对应的就是SOC上的I2C控制器；所有的设备驱动都需要经过i2c_adapter对象的处理才能和物理设备通信；通过i2c_core层将I2C设备与i2c adapter关联起来，用来完成i2c总线控制器相关的数据通信，此结构体在芯片厂商提供的代码中维护；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_adapter {\n    struct module *owner;\n    unsigned int class;       /* classes to allow probing for */\n    const struct i2c_algorithm *algo; /* the algorithm to access the bus */\n    void *algo_data;\n\n    /* data fields that are valid for all devices   */\n    const struct i2c_lock_operations *lock_ops;\n    struct rt_mutex bus_lock;\n    struct rt_mutex mux_lock;\n\n    int timeout;            /* in jiffies */\n    int retries;\n    struct device dev;      /* the adapter device */\n\n    int nr;\n    char name[48];\n    struct completion dev_released;\n\n    struct mutex userspace_clients_lock;\n    struct list_head userspace_clients;\n\n    struct i2c_bus_recovery_info *bus_recovery_info;\n    const struct i2c_adapter_quirks *quirks;\n};\n```\n\n\n\n```\n#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)\n```\n\n\n\n##### 2.2.2 I2C总线算法（i2c_algorithm）\n\nI2C总线数据通信算法，通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；\n\nstruct i2c_algorithm数据结构，是i2c控制器数据通信需要的控制算法，对应的是I2C的时序；通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；用来描述适配器和设备之间的通信方法，由芯片厂商实现；\n\n最重要的成员是master_xfer()函数，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_algorithm {\n    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,\n               int num);\n    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,\n               unsigned short flags, char read_write,\n               u8 command, int size, union i2c_smbus_data *data);\n\n    /* To determine what the adapter supports */\n    u32 (*functionality) (struct i2c_adapter *);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n    int (*reg_slave)(struct i2c_client *client);\n    int (*unreg_slave)(struct i2c_client *client);\n#endif\n};\n```\n\n> master_xfer：最重要的接口，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；该函数返回成功发送的消息数，错误返回负数；\n\n\n\n\ndevice_driver\n\n```\n// include/linux/device.h\nstruct device_driver {\n    const char      *name;\n    struct bus_type     *bus;\n\n    struct module       *owner;\n    const char      *mod_name;  /* used for built-in modules */\n\n    bool suppress_bind_attrs;   /* disables bind/unbind via sysfs */\n    enum probe_type probe_type;\n\n    const struct of_device_id   *of_match_table;\n    const struct acpi_device_id *acpi_match_table;\n\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n    void (*shutdown) (struct device *dev);\n    int (*suspend) (struct device *dev, pm_message_t state);\n    int (*resume) (struct device *dev);\n    const struct attribute_group **groups;\n\n    const struct dev_pm_ops *pm; \n\n    struct driver_private *p;\n};\n```\n\n\n\n\n\n\n\n##### 2.2.3 I2C总线类型\n\n\nI2C总线对应着/bus/目录下的一个总线；维护I2C设备和I2C驱动两个链表，管理I2C设备和I2C的匹配和删除；是SOC上I2C控制器的抽象；\n\n\n\n```\n// include/linux/device.h\nstruct bus_type {\n    const char      *name;\n    const char      *dev_name;\n    struct device       *dev_root;\n    struct device_attribute *dev_attrs; /* use dev_groups instead */\n    const struct attribute_group **bus_groups;\n    const struct attribute_group **dev_groups;\n    const struct attribute_group **drv_groups;\n\n    int (*match)(struct device *dev, struct device_driver *drv);\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n\n    int (*online)(struct device *dev);\n    int (*offline)(struct device *dev);\n\n    int (*suspend)(struct device *dev, pm_message_t state);\n    int (*resume)(struct device *dev);\n\n    const struct dev_pm_ops *pm; \n\n    const struct iommu_ops *iommu_ops;\n\n    struct subsys_private *p;\n    struct lock_class_key lock_key;\n};\n```\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstruct bus_type i2c_bus_type = {\n    .name       = \"i2c\",\n    .match      = i2c_device_match,\n    .probe      = i2c_device_probe,\n    .remove     = i2c_device_remove,\n    .shutdown   = i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n```\n\n\n\nI2C总线bus_type结构体管理着i2c设备和i2c驱动的匹配、删除操作，i2c会调用i2c_device_match函数对比i2c设备和i2c驱动是否匹配，如果匹配就调用i2c_device_probe函数，进而调用i2c驱动的probe函数；\n\n\n\n#### 2.3 总线层和设备层关系\n\n\n\n在设备层，i2c_client通过adapter指针，指向总线层的i2c_adapter，和总线层存在关系；\n\n在总线层，i2c_adapter通过algo指针，指向i2c_algorithm，进一步调用i2c_algorithm中的算法，如：master_xfer()，进行实际的数据发送和接收；\n\n\n\n总线层\n\nstruct i2c_adapter       I2C适配器（主机CPU的I2C控制器）\n\nstruct i2c_algorithm       I2C算法（I2C的收、发时序控制）\n\n\n\n设备层\n\nstruct i2c_client       I2C（从机）设备信息\n\nstruct i2c_driver       I2C（从机）设备驱动信息\n\n\n\n\n\n![I2C总线层和设备层的关系](Linux-kernel中的I2C子系统/I2C总线层和设备层的关系.png)\n\n\n\n\n\n#### 2.4 数据结构间的关系\n\n\n\n![I2C数据结构间的关系](Linux-kernel中的I2C子系统/I2C数据结构间的关系.png)\n\n\n\n\n\n### 3. 重要的操作函数\n\n\n\n#### 3.1 I2C子系统初始化\n\n\n\n##### 3.1.1 I2C总线初始化\n\n\n\n```\n// drivers/i2c/i2c-core.c\npostcore_initcall(i2c_init);\nmodule_exit(i2c_exit);\n```\n\n\n\n```\n// include/linux/init.h\n#define postcore_initcall(fn)       __define_initcall(fn, 2)\n```\n\n\n\n```\n// include/linux/init.h\n#define __define_initcall(fn, id) \\\n    static initcall_t __initcall_##fn##id __used \\\n    __attribute__((__section__(\".initcall\" #id \".init\"))) = fn;\n```\n\npostcore_initcall(i2c_init)操作，会在编译内核时，将函数指针变量__initcall_i2c_init放到名称为initcall2.init的section中；即将i2c_init()函数的首地址放到名称为initcall2.init的section中；\n\nLinux设备启动时，会在do_basic_setup()函数中，通过driver_init()和do_initcalls()函数，调用到i2c_init()函数，对I2C总线初始化；\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstatic int __init i2c_init(void)\n{\n    ......\n    retval = bus_register(&i2c_bus_type);\n    ......\n    i2c_adapter_compat_class = class_compat_register(\"i2c-adapter\");\n    ......\n    retval = i2c_add_driver(&dummy_driver);\n    ......\n}\n```\n\n\n\n通过bus_register()函数，在系统中注册一个新的总线i2c_bus_type，name: i2c；适配器设备、I2C设备、I2C设备驱动程序都会连接到这条总线上；\n\n```\n// drivers/i2c/i2c-core.c\nstruct bus_type i2c_bus_type = {\n    .name       = \"i2c\",\n    .match      = i2c_device_match,\n    .probe      = i2c_device_probe,\n    .remove     = i2c_device_remove,\n    .shutdown   = i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n```\n\n\n\n通过i2c_add_driver()函数，向I2C总线注册一个空的I2C设备驱动程序；可以不用关心；\n\n```mermaid\ngraph TB\n\ti2c_init1(i2c_init)-->bus_register1(bus_register)\n\tsubgraph i2c_init\n\t\tbus_register1(bus_register)-->\n\t\tclass_compat_register(class_compat_register)-->\n\t\ti2c_add_driver(i2c_add_driver)\n\tend\n```\n\n\n\n注册过程中发生异常错误时，需要使用对应的函数进行反向操作：\n\n```mermaid\ngraph TB\n\tclass_compat_register(class_compat_register)\n\tclass_compat_unregister(class_compat_unregister) \n```\n\n\n\n```mermaid\ngraph TB\n\tbus_register(bus_register) \n\tbus_unregister(bus_unregister)\n```\n\n\n\n##### 3.1.2 I2C总线退出\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstatic void __exit i2c_exit(void)\n{\n    if (IS_ENABLED(CONFIG_ACPI))\n        WARN_ON(acpi_reconfig_notifier_unregister(&i2c_acpi_notifier));\n    if (IS_ENABLED(CONFIG_OF_DYNAMIC))\n        WARN_ON(of_reconfig_notifier_unregister(&i2c_of_notifier));\n    i2c_del_driver(&dummy_driver);\n#ifdef CONFIG_I2C_COMPAT\n    class_compat_unregister(i2c_adapter_compat_class);\n#endif\n    bus_unregister(&i2c_bus_type);\n    tracepoint_synchronize_unregister();\n}\n```\n\n\ni2c_del_driver()函数，用来从I2C总线注销设备驱动程序；和i2c_add_driver()函数功能相反；\n\n```mermaid\ngraph TB\n\ti2c_add_driver(i2c_add_driver) \n\ti2c_del_driver(i2c_del_driver)\n```\n\n\n\n#### \t3.2 适配器驱动\n\n适配器驱动程序是I2C设备驱动程序需要实现的主要驱动程序，需要根据具体的适配器硬件编写；\n\n使用内核提供的框架函数向I2C子系统中添加一个新的适配器；i2c_adapter结构体为描述各种I2C适配器提供了通用的封装，但是i2c_adapter结构体只是所有适配器的共有属性，并不能代表所有类型的适配器；\n\n添加新的适配器的过程：\n\n>分配一个I2C适配器，并初始化一个i2c_adapter结构体，及相应的变量\n>\n>使用i2c_add_adapter()函数向I2C子系统添加适配器结构体i2c_adapter\n\n\n\n##### 3.2.1 添加适配器驱动\n\n```c\n// drivers/i2c/i2c-core.c\nint i2c_add_adapter(struct i2c_adapter *adapter)\n{\n    struct device *dev = &adapter->dev;\n    int id;\n\n    if (dev->of_node) {\n        id = of_alias_get_id(dev->of_node, \"i2c\");\n        if (id >= 0) { \n            adapter->nr = id;\n            return __i2c_add_numbered_adapter(adapter);\n        }\n    }    \n\n    mutex_lock(&core_lock);\n    id = idr_alloc(&i2c_adapter_idr, adapter,\n               __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\n    mutex_unlock(&core_lock);\n    if (WARN(id < 0, \"couldn't get idr\"))\n        return id;\n\n    adapter->nr = id;\n\n    return i2c_register_adapter(adapter);\n}\nEXPORT_SYMBOL(i2c_add_adapter);\n```\n\n通过i2c_register_adapter()函数，向内核注册一个适配器设备adapter；\n\n\n\n```mermaid\ngraph TB\n\ti2c_add_adapter(i2c_add_adapter)\n\t-->i2c_register_adapter(i2c_register_adapter)\n```\n\n\n\n```c\n// drivers/i2c/i2c-core.c\nstatic int i2c_register_adapter(struct i2c_adapter *adap)\n{\n    int res = -EINVAL;\n\t......\n    /* Sanity checks */\n    if (WARN(!adap->name[0], \"i2c adapter has no name\"))\n        goto out_list;\n\n    if (!adap->algo) {\n        pr_err(\"adapter '%s': no algo supplied!\\n\", adap->name);\n        goto out_list;\n    }\n\n    if (!adap->lock_ops)\n        adap->lock_ops = &i2c_adapter_lock_ops;\n\t......\n    /* Set default timeout to 1 second if not already set */\n    if (adap->timeout == 0)\n        adap->timeout = HZ;\n\n    dev_set_name(&adap->dev, \"i2c-%d\", adap->nr);\n    adap->dev.bus = &i2c_bus_type;\n    adap->dev.type = &i2c_adapter_type;\n    res = device_register(&adap->dev);\n\n    pm_runtime_no_callbacks(&adap->dev);\n    pm_suspend_ignore_children(&adap->dev, true);\n    pm_runtime_enable(&adap->dev);\n\n#ifdef CONFIG_I2C_COMPAT\n    res = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,\n                       adap->dev.parent);\n#endif\n\n    i2c_init_recovery(adap);\n\n    /* create pre-declared device nodes */\n    of_i2c_register_devices(adap);\n    i2c_acpi_register_devices(adap);\n    i2c_acpi_install_space_handler(adap);\n\n    if (adap->nr < __i2c_first_dynamic_bus_num)\n        i2c_scan_static_board_info(adap);\n\n    /* Notify drivers */\n    mutex_lock(&core_lock);\n    bus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);\n    mutex_unlock(&core_lock);\n\n    return 0;\n\nout_list:\n    mutex_lock(&core_lock);\n    idr_remove(&i2c_adapter_idr, adap->nr);\n    mutex_unlock(&core_lock);\n    return res;\n}\n```\n\n\n\n##### 3.2.2 注销适配器驱动\n\n```c\n// // drivers/i2c/i2c-core.c\nvoid i2c_del_adapter(struct i2c_adapter *adap)\n{\n    struct i2c_adapter *found;\n    struct i2c_client *client, *next;\n\n    /* First make sure that this adapter was ever added */\n    mutex_lock(&core_lock);\n    found = idr_find(&i2c_adapter_idr, adap->nr);\n    mutex_unlock(&core_lock);\n    if (found != adap) {\n        pr_debug(\"attempting to delete unregistered adapter [%s]\\n\", adap->name);\n        return;\n    }\n\n    i2c_acpi_remove_space_handler(adap);\n    /* Tell drivers about this removal */\n    mutex_lock(&core_lock);\n    bus_for_each_drv(&i2c_bus_type, NULL, adap,\n                   __process_removed_adapter);\n    mutex_unlock(&core_lock);\n\n    /* Remove devices instantiated from sysfs */\n    mutex_lock_nested(&adap->userspace_clients_lock,\n              i2c_adapter_depth(adap));\n    list_for_each_entry_safe(client, next, &adap->userspace_clients,\n                 detected) {\n        list_del(&client->detected);\n        i2c_unregister_device(client);\n    }\n    mutex_unlock(&adap->userspace_clients_lock);\n    device_for_each_child(&adap->dev, NULL, __unregister_client);\n    device_for_each_child(&adap->dev, NULL, __unregister_dummy);\n\n#ifdef CONFIG_I2C_COMPAT\n    class_compat_remove_link(i2c_adapter_compat_class, &adap->dev,\n                 adap->dev.parent);\n#endif\n\n    pm_runtime_disable(&adap->dev);\n\n    init_completion(&adap->dev_released);\n    device_unregister(&adap->dev);\n    wait_for_completion(&adap->dev_released);\n\n    /* free bus id */\n    mutex_lock(&core_lock);\n    idr_remove(&i2c_adapter_idr, adap->nr);\n    mutex_unlock(&core_lock);\n\n    /* Clear the device structure in case this adapter is ever going to be\n       added again */\n    memset(&adap->dev, 0, sizeof(adap->dev));\n}\nEXPORT_SYMBOL(i2c_del_adapter);\n```\n\n\n\n\n\n#### 3.3 注册I2C驱动\n\n注册I2C驱动需要完成的操作：\n\n> 将I2C驱动添加到I2C总线的驱动链表中\n>\n> 遍历I2C总线上的I2C设备链表，根据i2c_device_match函数进行匹配，如果匹配就调用i2c_device_probe函数\n>\n> i2c_device_probe函数会调用I2C驱动的probe函数\n\n\n\n##### 3.3.1 注册I2C驱动\n\n在I2C驱动程序中，通过i2c_add_driver()函数，来注册驱动：\n\n```\n// include/linux/i2c.h\n#define i2c_add_driver(driver) \\\n    i2c_register_driver(THIS_MODULE, driver)\n```\n\n\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\n{\n\t......\n    /* add the driver to the list of i2c drivers in the driver core */\n    driver->driver.owner = owner;\n    driver->driver.bus = &i2c_bus_type;\t\t// 绑定I2C总线 \n    INIT_LIST_HEAD(&driver->clients);\n\n    res = driver_register(&driver->driver);\t\t// 向I2C总线注册驱动\n\t......\n    i2c_for_each_dev(driver, __process_new_driver);\n\n    return 0;\n}\nEXPORT_SYMBOL(i2c_register_driver);\n```\n\n\n在i2c_add_driver()函数中，做了三件事：\n\n> 绑定总线\n>\n> 向总线注册驱动 ---- 重点\n>\n> 遍历总线的设备，调用__process_new_driver\n\n\n\n\n\ndriver_register\n\n```\n// drivers/i2c/i2c-core.c\nint driver_register(struct device_driver *drv)\n{\n    int ret;\n    struct device_driver *other;\n\t......\n    other = driver_find(drv->name, drv->bus);\n\t......\n    ret = bus_add_driver(drv);\n\n    ret = driver_add_groups(drv, drv->groups);\n    if (ret) {\n        bus_remove_driver(drv);\n        return ret;\n    }\n    kobject_uevent(&drv->p->kobj, KOBJ_ADD);\n\n    return ret;\n}\nEXPORT_SYMBOL_GPL(driver_register);\n```\n\n\n\n\ndriver_find()函数，在I2C总线中，找到name对应的I2C device_driver；\n\nbus_add_driver()函数，将驱动添加到总线上；\n\n\n\n```mermaid\ngraph TB\n\ti2c_add_driver(i2c_add_driver)-->\n\ti2c_register_driver(i2c_register_driver)-->\n\tdriver_register(driver_register)-->\n\tbus_add_driver(bus_add_driver)\t\n```\n\n\n\n\n\n\n\n##### 3.3.2 注销I2C驱动\n\n```\n// drivers/i2c/i2c-core.c\nvoid i2c_del_driver(struct i2c_driver *driver)\n{\n    i2c_for_each_dev(driver, __process_removed_driver);\n\n    driver_unregister(&driver->driver);\n    pr_debug(\"driver [%s] unregistered\\n\", driver->driver.name);\n}\nEXPORT_SYMBOL(i2c_del_driver);\n```\n\n\n\n#### 3.4 注册I2C设备\n\n##### 3.4.1 注册I2C设备\n\nI2C通过i2c_new_device()函数，来添加一个I2C设备；\n\n```\n// drivers/i2c/i2c-core.c\nstruct i2c_client *\ni2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)\n{\n    struct i2c_client   *client;\n    int         status;\n\n    client = kzalloc(sizeof *client, GFP_KERNEL);\n\n    client->adapter = adap;\t\t// 指定设备的适配器\n\n    client->dev.platform_data = info->platform_data;\n\n    if (info->archdata)\n        client->dev.archdata = *info->archdata;\n\n    client->flags = info->flags;\n    client->addr = info->addr;\n    client->irq = info->irq;\n\n    strlcpy(client->name, info->type, sizeof(client->name));\n\n    status = i2c_check_addr_validity(client->addr, client->flags);\n\n\t/* Check for address business */\n    status = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));\n\n    client->dev.parent = &client->adapter->dev;\n    client->dev.bus = &i2c_bus_type;\t// 绑定I2C总线\n    client->dev.type = &i2c_client_type;\n    client->dev.of_node = info->of_node;\n    client->dev.fwnode = info->fwnode;\n\n    i2c_dev_set_name(adap, client);\n    status = device_register(&client->dev);\t\t// 向总线注册设备\n\t......\n    return client;\n}\nEXPORT_SYMBOL_GPL(i2c_new_device);\n```\n\n\n\n```\n// include/linux/i2c.h\nstruct i2c_board_info {\n    char        type[I2C_NAME_SIZE];\t// 设备名称，用于与驱动匹配\n    unsigned short  flags;\n    unsigned short  addr;\t// 设备地址\n    void        *platform_data;\n    struct dev_archdata *archdata;\n    struct device_node *of_node;\n    struct fwnode_handle *fwnode;\n    int     irq;\n};\n```\n\nstruct i2c_board_info结构体描述了设备的硬件信息；\n\n\n\n```\n// drivers/base/core.c\nint device_register(struct device *dev)\n{   \n    device_initialize(dev);\n    return device_add(dev);\n}\nEXPORT_SYMBOL_GPL(device_register);\n```\n\n\n\n```mermaid\ngraph TB\n\ti2c_new_device(i2c_new_device)-->\n\tdevice_register(device_register)-->\n\tdevice_initialize(device_initialize)\n\tdevice_register-->device_add(device_add)\n```\n\n\n\ndevice_initialize()函数用来初始化I2C设备的device结构体；\n\n```\n// drivers/base/core.c\nvoid device_initialize(struct device *dev)\n{\n    dev->kobj.kset = devices_kset;\n    kobject_init(&dev->kobj, &device_ktype);\n    INIT_LIST_HEAD(&dev->dma_pools);\n    mutex_init(&dev->mutex);\n    lockdep_set_novalidate_class(&dev->mutex);\n    spin_lock_init(&dev->devres_lock);\n    INIT_LIST_HEAD(&dev->devres_head);\n    device_pm_init(dev);\n    set_dev_node(dev, -1);\n#ifdef CONFIG_GENERIC_MSI_IRQ\n    INIT_LIST_HEAD(&dev->msi_list);\n#endif\n}\nEXPORT_SYMBOL_GPL(device_initialize);\n```\n\n\n\n```\nint device_add(struct device *dev)\n{\n    struct device *parent = NULL;\n    struct kobject *kobj;\n    struct class_interface *class_intf;\n    int error = -EINVAL;\n    struct kobject *glue_dir = NULL;\n\n    dev = get_device(dev);\n\n    if (!dev->p) {\n        error = device_private_init(dev);\n        if (error)\n            goto done;\n    }\n\n    if (dev->init_name) {\n        dev_set_name(dev, \"%s\", dev->init_name);\n        dev->init_name = NULL;\n    }\n\n    if (!dev_name(dev) && dev->bus && dev->bus->dev_name)\n        dev_set_name(dev, \"%s%u\", dev->bus->dev_name, dev->id);\n\n    parent = get_device(dev->parent);\n    kobj = get_device_parent(dev, parent);\n\n    if (kobj)\n        dev->kobj.parent = kobj;\n    if (parent && (dev_to_node(dev) == NUMA_NO_NODE))\n        set_dev_node(dev, dev_to_node(parent));\n\n    error = kobject_add(&dev->kobj, dev->kobj.parent, NULL);\n\n    if (platform_notify)\n        platform_notify(dev);\n\n    error = device_create_file(dev, &dev_attr_uevent);\n\n    error = device_add_class_symlinks(dev);\n\n    error = device_add_attrs(dev);\n\n    error = bus_add_device(dev);\n\n    error = dpm_sysfs_add(dev);\n\n    device_pm_add(dev);\n\n    if (MAJOR(dev->devt)) {\n        error = device_create_file(dev, &dev_attr_dev);\n\n        error = device_create_sys_dev_entry(dev);\n\n        devtmpfs_create_node(dev);\n    }\n\n    if (dev->bus)\n        blocking_notifier_call_chain(&dev->bus->p->bus_notifier,\n                         BUS_NOTIFY_ADD_DEVICE, dev);\n\n    kobject_uevent(&dev->kobj, KOBJ_ADD);\n    bus_probe_device(dev);\n    if (parent)\n        klist_add_tail(&dev->p->knode_parent,\n                   &parent->p->klist_children);\n\n    if (dev->class) {\n        mutex_lock(&dev->class->p->mutex);\n        klist_add_tail(&dev->knode_class,\n                   &dev->class->p->klist_devices);\n\n        list_for_each_entry(class_intf,\n                    &dev->class->p->interfaces, node)\n            if (class_intf->add_dev)\n                class_intf->add_dev(dev, class_intf);\n        mutex_unlock(&dev->class->p->mutex);\n    }\n}\nEXPORT_SYMBOL_GPL(device_add);\n```\n\n\n\n\ndevice_addbus_add_devicebus_probe_device\n\n\n\n\n\n##### 3.4.2 注销I2C设备\n\n\n\n```\n// drivers/i2c/i2c-core.c\nvoid i2c_unregister_device(struct i2c_client *client)\n{\n    if (client->dev.of_node)\n        of_node_clear_flag(client->dev.of_node, OF_POPULATED);\n    if (ACPI_COMPANION(&client->dev))\n        acpi_device_clear_enumerated(ACPI_COMPANION(&client->dev));\n    device_unregister(&client->dev);\n}\nEXPORT_SYMBOL_GPL(i2c_unregister_device);\n```\n\n\n\n\n\n```mermaid\ngraph TB\n\ti2c_new_device(i2c_new_device)\n\ti2c_unregister_device(i2c_unregister_device)\n```\n\n\n\n\n\n#### 3.5 适配器和设备通信\n\n\n\nI2C总线通信方式是对特定的I2C适配器使用i2c_transfer()函数，调用i2c_algothrim的master_xfer()方法实现i2c_msg消息的传输；不同的适配器，对应的master_xfer()方法由控制器的硬件决定，由芯片厂商提供；\n\n\n\n##### 3.5.1 i2c_transfer\n\n\n\n\n在I2C设备和I2C驱动匹配之后，驱动程序和设备的通讯，通过i2c_transfer()函数来给设备发送信息；\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n    int ret;\n    if (adap->algo->master_xfer) {\n\t\t......\n        ret = __i2c_transfer(adap, msgs, num);\n\t\t......\n}\nEXPORT_SYMBOL(i2c_transfer);\n```\n\ni2c_transfer()函数是i2c核心提供给设备驱动的发送方法，该函数发送的数据需要被打包成i2c_msg结构，该函数最终会回调i2c_adapter->i2c_algorithm->master_xfer()函数，将i2c_msg对象发送到i2c的物理控制器；\n\n```\n// drivers/i2c/i2c-core.c\nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n    unsigned long orig_jiffies;\n    int ret, try;\n\n    if (adap->quirks && i2c_check_for_quirks(adap, msgs, num))\n        return -EOPNOTSUPP;\n\n    if (static_key_false(&i2c_trace_msg)) {\n        int i;\n        for (i = 0; i < num; i++)\n            if (msgs[i].flags & I2C_M_RD)\n                trace_i2c_read(adap, &msgs[i], i);\n            else\n                trace_i2c_write(adap, &msgs[i], i);\n    }\n\n    orig_jiffies = jiffies;\n    for (ret = 0, try = 0; try <= adap->retries; try++) {\n        ret = adap->algo->master_xfer(adap, msgs, num);\t\t// 发送、接收信息操作\n        if (ret != -EAGAIN)\n            break;\n        if (time_after(jiffies, orig_jiffies + adap->timeout))\n            break;\n    }\n\t......\n}\nEXPORT_SYMBOL(__i2c_transfer);\n```\n\n最终，通过adap->algo->master_xfer()函数，将struct i2c_msg结构体类型的消息，通过适配器的struct i2c_adapter发送给设备，或者从设备中读取信息；\n\n\n\n##### 3.5.2 消息格式\n\n\n\n经过mster_xfer()函数发送、接收的消息类型应该按照struct i2c_msg结构体格式：\n\n```c\n// include/uapi/linux/i2c.h\nstruct i2c_msg {\n    __u16 addr; /* slave address            */\n    __u16 flags;\n#define I2C_M_RD        0x0001  /* read data, from slave to master */\n                    /* I2C_M_RD is guaranteed to be 0x0001! */\n#define I2C_M_TEN       0x0010  /* this is a ten bit chip address */\n#define I2C_M_RECV_LEN      0x0400  /* length will be first received byte */\n#define I2C_M_NO_RD_ACK     0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_IGNORE_NAK    0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_REV_DIR_ADDR  0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_NOSTART       0x4000  /* if I2C_FUNC_NOSTART */\n#define I2C_M_STOP      0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */\n    __u16 len;      /* msg length               */\n    __u8 *buf;      /* pointer to msg data          */\n};\n```\n\n> I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；\n>\n> I2C读取，即封装的xxx_i2c_read()函数，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；\n>\n> I2C写入，即封装的xxx_i2c_write()函数，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；\n\n注意：以数组格式定义i2c_msg是为了访问连续，因为数组是连续内存存储的；\n\n\n\n##### 3.5.3 消息发送、接收函数\n\n\n\n###### 1）发送函数\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_master_send(const struct i2c_client *client, const char *buf, int count)\n{\n    int ret;\n    struct i2c_adapter *adap = client->adapter;\n    struct i2c_msg msg;\n\n    msg.addr = client->addr;\n    msg.flags = client->flags & I2C_M_TEN;\n    msg.len = count;\n    msg.buf = (char *)buf;\n\n    ret = i2c_transfer(adap, &msg, 1);\n\n    return (ret == 1) ? count : ret;\n}\nEXPORT_SYMBOL(i2c_master_send);\n```\n\nI2C发送消息操作时，仅需要一个i2c_msg；i2c_msg的buf，保存slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；如下：\n\n```c\ni2c_master_send(client, data, len);\n```\n\n\n\n###### 2）接收函数\n\n```\n// drivers/i2c/i2c-core.c\nint i2c_master_recv(const struct i2c_client *client, char *buf, int count)\n{\n    struct i2c_adapter *adap = client->adapter;\n    struct i2c_msg msg;\n    int ret;\n\n    msg.addr = client->addr;\n    msg.flags = client->flags & I2C_M_TEN;\n    msg.flags |= I2C_M_RD;\n    msg.len = count;\n    msg.buf = buf;\n\n    ret = i2c_transfer(adap, &msg, 1);\n\n    return (ret == 1) ? count : ret;\n}\nEXPORT_SYMBOL(i2c_master_recv);\n```\n\nI2C接收消息操作时，需要给从设备发送两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，并使用buf指针指向这个地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；\n\n也可以分两次，先使用i2c_master_send()函数，向slave发出目标寄存器地址，在使用i2c_master_recv()函数，用来接收读取到的数据消息；如下：\n\n```c\n\ti2c_master_send(client, reg, 2); \n\ti2c_master_recv(client, data, len);\n```\n\n\n\n### 4. 添加设备\n\n\n\n在内核中的Documentation/i2c/instantiating-devices文件中，讲述了添加设备的方法；\n\n\n\ni2c_client结构是通过以下方式自动创建：\n\n> 分配、设置、注册i2c_board_info\n>\n> 获取i2c_adapter，调用i2c_new_device\n>\n> 通过设备树（DeviceTree）创建\n\n\n\n#### 4.1 添加设备树\n\n\n\n```\n// Image-fsl-lx2160a-rdb-new.dts\n        i2c@2030000 {\n            compatible = \"fsl,vf610-i2c\";\n            #address-cells = <0x1>;\n            #size-cells = <0x0>;\n            reg = <0x0 0x2030000 0x0 0x10000>;\n            interrupts = <0x0 0x23 0x4>;\n            scl-gpios=<&gpio4 8 0x0>;\n            clock-names = \"i2c\";\n            clocks = <0x2 0x4 0x7>;\n            status = \"okay\";\n            rtc@32 {\n                compatible = \"Micro Crystal,rv8803\";\n                reg = <0x32>;\n            };\n\n            eeprom_mcy@51 {\n                compatible = \"mcy,eeprom_mcy\";\n                reg = <0x51>;\n            };\n        };\n```\n\n\n\n\n\n```\n# ls /sys/bus/i2c/devices/\n2-0032  2-0051  i2c-0   i2c-1   i2c-2   i2c-3 \n# ls /sys/bus/i2c/devices/ -l\ntotal 0\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0032 -> ../../../devices/platform/soc/2030000.i2c/i2c-2/2-0032\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0051 -> ../../../devices/platform/soc/2030000.i2c/i2c-2/2-0051\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-0 -> ../../../devices/platform/soc/2000000.i2c/i2c-0\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-1 -> ../../../devices/platform/soc/2010000.i2c/i2c-1\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-2 -> ../../../devices/platform/soc/2030000.i2c/i2c-2\nlrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-3 -> ../../../devices/platform/soc/2050000.i2c/i2c-3\n\n\n# ls /sys/bus/i2c/devices/2-0051/\nconsumers  modalias   name       of_node    subsystem  suppliers  uevent\n# ls /sys/bus/i2c/devices/2-0051/ -l\ntotal 0\n-r--r--r--    1 root     root          4096 Oct 15 03:27 consumers\n-r--r--r--    1 root     root          4096 Oct 15 03:27 modalias\n-r--r--r--    1 root     root          4096 Oct 15 03:27 name\nlrwxrwxrwx    1 root     root             0 Oct 15 03:27 of_node -> ../../../../../../firmware/devicetree/base/soc/i2c@2030000/eeprom_mcy@51\nlrwxrwxrwx    1 root     root             0 Oct 15 03:27 subsystem -> ../../../../../../bus/i2c\n-r--r--r--    1 root     root          4096 Oct 15 03:27 suppliers\n-rw-r--r--    1 root     root          4096 Oct 15 03:27 uevent\n# cat /sys/bus/i2c/devices/2-0051/name\neeprom_mcy\n```\n\n\n\n\n\n#### 4.2 i2c_new_device添加\n\n\n\n\n\n```c\n#include <linux/module.h>\n#include <linux/i2c.h>\n\nstatic struct i2c_client *client;\n\nstatic struct i2c_board_info eeprom_info = { \n    I2C_BOARD_INFO(\"eeprom_device\", 0x51),\n};\n\nstatic int eeprom_device_init(void)\n{\n    struct i2c_adapter *adap = NULL;\n\n    printk(\"%s: %d\\n\", __func__, __LINE__);\n\n    adap = i2c_get_adapter(2);\n    if (!adap) {\n        printk(\"%s, i2c_get_adapter failed!\\n\", __func__);\n        return -1; \n    }   \n\n    client = i2c_new_device(adap, &eeprom_info);\n    if (!client) {\n        printk(\"%s, i2c_new_device failed!\\n\", __func__);\n        return -2; \n    }   \n\n    i2c_put_adapter(adap);\n\n    return 0;\n}\n\nstatic void eeprom_device_exit(void)\n{\n    printk(\"%s: %d\\n\", __func__, __LINE__);\n\n    i2c_unregister_device(client);\n}\n\nmodule_init(eeprom_device_init);\nmodule_exit(eeprom_device_exit);\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.3 静态注册I2C设备\n\n内核提供了一种静态注册I2C设备的方法，通过i2c_register_board_info()函数实现：\n\n```\n// drivers/i2c/i2c-boardinfo.c\nint i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len)\n{\n    int status;\n\n    if (busnum >= __i2c_first_dynamic_bus_num)\n        __i2c_first_dynamic_bus_num = busnum + 1;\n\n    for (status = 0; len; len--, info++) {\n        struct i2c_devinfo  *devinfo;\n\n        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);\n\n        devinfo->busnum = busnum;\n        devinfo->board_info = *info;\n        list_add_tail(&devinfo->list, &__i2c_board_list);\n    }   \n\t......\n}\n```\n\n在系统初始化过程中，可以通过i2c_register_board_info()函数，将需要的I2C设备添加到\\_\\_i2c_board_list链表；系统在成功加载I2C适配器adapter后，会对这个\\_\\_i2c_board_list链表中所有的设备逐一完成i2c_client的注册；\n\n```\n// drivers/i2c/i2c-core.h\nstruct i2c_devinfo {\n    struct list_head    list;\n    int         busnum;\n    struct i2c_board_info   board_info;\n};\n```\n\n系统初始化时，根据I2C设备配置信息，创建I2C设备（i2c_client），并添加到I2C子系统；\n\n最终是在i2c_scan_static_board_info()函数中，通过调用i2c_new_device()函数来实现添加设备；i2c_scan_static_board_info()函数一般在初始化时工作；\n\n```\n// drivers/i2c/i2c-core.c\nstatic void i2c_scan_static_board_info(struct i2c_adapter *adapter)\n{\n    struct i2c_devinfo  *devinfo;\n\n    list_for_each_entry(devinfo, &__i2c_board_list, list) {\n        if (devinfo->busnum == adapter->nr\n                && !i2c_new_device(adapter,\n                        &devinfo->board_info))\n\t\t......\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n### 5. 添加驱动\n\n以eeprom为例；\n\n\n\n\n\n#### 5.1 I2C设备驱动框架\n\n```c\nstatic int mcy_eeprom_init(void)\n{\n    printk(\"%s\\n\", __func__);\n\n    i2c_add_driver(&mcy_eeprom_driver);\n\n    return 0;\n}\n\nstatic void mcy_eeprom_exit(void)\n{\n    printk(\"%s\\n\", __func__);\n\n    i2c_del_driver(&mcy_eeprom_driver);\n}\n\nmodule_init(mcy_eeprom_init);\nmodule_exit(mcy_eeprom_exit);\n```\n\n\n\n```c\nstruct i2c_driver mcy_eeprom_driver = {\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"mcy_eeprom\",\n        //.of_match_table = mcy_eeprom_table,\n    },\n    .probe = mcy_eeprom_probe,\n    .remove = mcy_eeprom_remove,\n    .id_table = mcy_eeprom_id,\n};\n```\n\n\n\n\n\n\n\n```mermaid\ngraph TB\n\teeprom_init(eeprom_init)-->\n\ti2c_add_driver(i2c_add_driver)-->eeprom_driver(eeprom_driver)\n\teeprom_driver-->driver(driver)\n\teeprom_driver-->probe(probe)\n\teeprom_driver-->remove(remove)\n\teeprom_driver-->id_table(id_table)\n```\n\n\n\n#### 5.2 probe函数\n\n##### 1）注册字符设备\n\n```c\nint mcy_eeprom_probe(struct i2c_client *client, const struct i2c_device_id *id)\n{\n    int ret = -1; \n\n    printk(\"%s\\n\", __func__);\n    \n    eeprom_driver.client = client;\n\n    ret = alloc_chrdev_region(&devnum, 0, 1, \"mcy_eeprom_chrdev\");\n    if (ret) {\n        printk(\"%s, alloc_chrdev_region failed!\\n\", __func__);\n        goto chrdev_err;\n    }   \n    printk(\"%s, alloc_chrdev_region, devnum: %d\\n\", __func__, devnum);\n\n    cdev = cdev_alloc();\n    cdev_init(cdev, &mcy_eeprom_fops);\n    ret = cdev_add(cdev, devnum, 1); \n    if (ret) {\n        printk(\"%s, cdev_add failed!\\n\", __func__);\n        goto cdev_err;\n    }\n        \n    // /sys/class\n    dev_class = class_create(THIS_MODULE, \"mcy_eeprom_class\");\n    if (IS_ERR(dev_class)) {\n        printk(\"%s, dev_class class_create failed\\n\", __func__);\n        goto class_err;\n    }   \n    // /dev\n    device_create(dev_class, NULL, devnum, NULL, \"mcy_eeprom0\");\n\n    printk(\"%s, OK!\\n\", __func__);\n\n    return 0;\n\nclass_err:\n    cdev_del(cdev);\ncdev_err:\n    unregister_chrdev_region(devnum, 1); \nchrdev_err:\n    return -1; \n}\n```\n\n\n\n##### 2）卸载函数\n\n```c\nint mcy_eeprom_remove(struct i2c_client *client)\n{\n    printk(\"%s\\n\", __func__);\n\n    device_destroy(dev_class, devnum);\n    class_destroy(dev_class);\n    cdev_del(cdev);\n    unregister_chrdev_region(devnum, 1);\n    kfree(cdev);\n\n    return 0;\n}\n```\n\n\n\n##### 3）字符设备操作集\n\n```c\nstruct file_operations mcy_eeprom_fops= {\n    .open = eeprom_driver_open,\n    .release = eeprom_driver_release,\n    .read = eeprom_driver_read,\n    .write = eeprom_driver_write,\n};\n```\n\n\n\n#### 5.3 读写函数\n\n\n\nI2C数据的发送和接收，是通过I2C驱动中file_operations的write和read系统调用来实现的；驱动中read和write的封装，是需要封装调用i2c_transfer()函数来完成i2d_msg消息的通信；read和write函数的封装，有两种方法；\n\n\n\n##### 5.3.1 内核函数调用\n\n使用i2c-core.c提供的i2c_master_send()和i2c_master_recv()函数实现I2C信息的发送和接收；\n\n\n\n###### 1）发送\n\n```c\ni2c_master_send(client, data, len);\n```\n\nI2C发送，直接调用i2c_master_send()函数，一次完成I2C数据的发送；\n\ndata：要发送的数据信息数组；其中data最前边的地址存放的是I2C从设备寄存器的地址，如果地址是8bits，就占用data[0]，如果地址是16bits，占用data[0]和data[1]；在地址之后，紧接着存放要发送的数据内容；\n\nlen：要发送的数据长度；包含I2C从设备寄存器地址和数据内容的总数据长度；\n\n```c\nstatic ssize_t eeprom_driver_write(struct file *filp, const char __user *buf, size_t count, loff_t *loff)\n{   \n    eeprom_data_t eeprom_data;\n    unsigned char data[18] = {0};\n    int len = 0;\n    int i = 0;\n    int ret = -1;\n\n    printk(\"%s\\n\", __func__);\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    memcpy(&data[2], eeprom_data.data, eeprom_data.len);\n    data[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8);\n    data[1] = (char)(eeprom_data.reg & 0x000000ff);\n    len = eeprom_data.len + 2;\n\n    for (i = 0; i < len; i++) {\n        printk(\"%s, data[%d]: 0x%2x\\n\", __func__, i, data[i]);\n    }\n#if 1\n    ret = i2c_master_send(eeprom_driver.client, data, len);\n#else\n    \n#endif\n    return 0;\n}\n```\n\n\n\n###### 2）接收\n\n```c\ni2c_master_send(client, reg, reg_len); \ni2c_master_recv(client, data, data_len);\n```\n\nI2C接收不同于发送，需要两步来完成，先使用i2c_master_send()函数向I2C从设备发送要读取的寄存器地址；再使用i2c_master_recv()函数，从I2C从设备指定寄存器地址读取数据；\n\nreg：要读取的从设备寄存器地址数组；如果地址是8bits，reg_len为1；如果地址是16bits，reg_len为2；\n\ndata：要读取的数据信息存放的指针地址；data_len为要读取的寄存器个数；\n\n###### \n\n```c\nstatic ssize_t eeprom_driver_read(struct file *filp, char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    unsigned char reg[2] = {0};\n    int i = 0;\n    int ret = -1; \n\n    printk(\"%s\\n\", __func__);\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1; \n    }\n\n    reg[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8); \n    reg[1] = (char)(eeprom_data.reg & 0x000000ff);\n\n#if 1\n    ret = i2c_master_send(eeprom_driver.client, reg, 2); \n    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);\n#else\n    \n#endif\n\n    for (i = 0; i < eeprom_data.len; i++) {\n        printk(\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\", __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);\n    }   \n\n    ret = copy_to_user(buf, &eeprom_data, count);\n    if (ret < 0) {\n        printk(\"%s, copy_to_user failed, ret: %d\\n\", __func__, ret);\n        return -1; \n    }   \n\n    return 0;\n}\n```\n\n\n\n##### 5.3.2 直接封装\n\n直接通过封装i2c_msg消息，通过i2c_transfer()函数实现I2C信息的发送和接收；\n\n###### 1）发送\n\n```c\nint i2c_send_bytes(const struct i2c_client *client, unsigned short reg, const char *buf, int count)\n{\n    unsigned char *data = NULL;\n    struct i2c_msg msg;\n    int len = 0;\n    int ret = -1;\n\n    data = kmalloc(count + 2, GFP_KERNEL);\n    if (!data) {\n        printk(\"%s, kmalloc failed!\\n\", __func__);\n        return -1;\n    }\n    data[0] = (char)((reg & 0x0000ff00) >> 8);\n    data[1] = (char)(reg & 0x000000ff);\n    memcpy(&data[2], buf, count);\n    len = count + 2;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.addr = client->addr;\n    msg.flags = 0;\n    msg.len = count;\n    msg.buf = data;\n\n    ret = i2c_transfer(client->adapter, &msg, 1);\n\n    if (data) {\n        kfree(data);\n        data = NULL;\n    }\n\n    return ret;\n}\n```\n\n\n\n```c\nstatic ssize_t eeprom_driver_write(struct file *filp, const char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    ret = i2c_send_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);\n\n    return 0;\n}\n```\n\n\n\n###### 2）接收\n\n```c\nint i2c_recv_bytes(const struct i2c_client *client, unsigned short reg, unsigned char *buf, int count)\n{\n    struct i2c_msg msg[2] = { 0 };\n    unsigned char txbuf[2] = { 0 };\n    int ret = -1;\n\n    txbuf[0] = (char)((reg & 0x0000ff00) >> 8);\n    txbuf[1] = (char)(reg & 0x000000ff);\n\n    memset(&msg, 0, sizeof(msg));\n    msg[0].addr = client->addr;\n    msg[0].flags = 0;\n    msg[0].len = 2;\n    msg[0].buf = txbuf;\n\n    msg[1].addr = client->addr;\n    msg[1].flags = I2C_M_RD;\n    msg[1].len = count;\n    msg[1].buf = buf;\n\n    ret = i2c_transfer(client->adapter, msg, 2);\n\n    return ret;\n}\n```\n\n\n\n```c\nstatic ssize_t eeprom_driver_read(struct file *filp, char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    ret = i2c_recv_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);\n\n    ret = copy_to_user(buf, &eeprom_data, count);\n    if (ret < 0) {\n        printk(\"%s, copy_to_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    return 0;\n}\n```\n\n\n\n### 6. 驱动和设备匹配\n\n设备和驱动的关系\n\n对于一个驱动程序，有两个必不可少的元素，即：设备和驱动，驱动是通过设备名和驱动名建立联系；在i2c_adapter注册时会遍历i2c_board_info结构，会完成驱动和设备的匹配；\n\n\n\n一个驱动程序，可以有多个名字，即一个驱动程序可以支持多个设备，该机制通过由i2c_device_id结构体组成的数组实现；该数组是在驱动中建立；I2C架构会扫描该结构体数组，逐一与设备进行匹配，匹配成功就会调用相应的probe函数；\n\n进入驱动中的probe函数，要先进入总线的probe函数，而前提是设备与驱动的match匹配成功；\n\n\n\nbus_add_driver\n\n```\n// drivers/base/bus.c\nint bus_add_driver(struct device_driver *drv)\n{\n    struct bus_type *bus;\n    struct driver_private *priv;\n    int error = 0; \n\n    bus = bus_get(drv->bus);\n\n    priv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\n    klist_init(&priv->klist_devices, NULL, NULL);\n    priv->driver = drv; \n    drv->p = priv;\n    priv->kobj.kset = bus->p->drivers_kset;\n    error = kobject_init_and_add(&priv->kobj, &driver_ktype, NULL,\n                     \"%s\", drv->name);\n\n    klist_add_tail(&priv->knode_bus, &bus->p->klist_drivers);\n    if (drv->bus->p->drivers_autoprobe) {\n        if (driver_allows_async_probing(drv)) {\n            async_schedule(driver_attach_async, drv);\n        } else {\n            error = driver_attach(drv);\n        }\n    }\n    module_add_driver(drv->owner, drv);\n\n    error = driver_create_file(drv, &driver_attr_uevent);\n\n    error = driver_add_groups(drv, bus->drv_groups);\n\n    if (!drv->suppress_bind_attrs) {\n        error = add_bind_files(drv);\n    }\n\t......\n}\n```\n\n\n\n\n\n\n\n```\n// drivers/base/dd.c\nint driver_attach(struct device_driver *drv)\n{               \n    return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);\n}       \nEXPORT_SYMBOL_GPL(driver_attach);\n```\n\n\n\n\n\n```\n// drivers/base/bus.c\nint bus_for_each_dev(struct bus_type *bus, struct device *start,\n             void *data, int (*fn)(struct device *, void *))\n{\n    struct klist_iter i;\n    struct device *dev;\n    int error = 0;\n\n    if (!bus || !bus->p)\n        return -EINVAL;\n\n    klist_iter_init_node(&bus->p->klist_devices, &i,\n                 (start ? &start->p->knode_bus : NULL));\n    while ((dev = next_device(&i)) && !error)\n        error = fn(dev, data);\n    klist_iter_exit(&i);\n    return error;\n}\nEXPORT_SYMBOL_GPL(bus_for_each_dev);\n```\n\n\n\n\n\n```\n// drivers/base/dd.c\nstatic int __driver_attach(struct device *dev, void *data)\n{\n    struct device_driver *drv = data;\n    int ret;\n\n    ret = driver_match_device(drv, dev);\n\t......\n    if (!dev->driver)\n        driver_probe_device(drv, dev);\n\t......\n}\n```\n\n\n\n\n\n```\n// drivers/base/base.h\nstatic inline int driver_match_device(struct device_driver *drv,\n                      struct device *dev)\n{\n    return drv->bus->match ? drv->bus->match(dev, drv) : 1;\n}\n```\n\n\n\n\n\n```\n// drivers/base/dd.c\nint driver_probe_device(struct device_driver *drv, struct device *dev)\n{\n    int ret = 0;\n\n    if (!device_is_registered(dev))\n        return -ENODEV;\n\n    pr_debug(\"bus: '%s': %s: matched device %s with driver %s\\n\",\n         drv->bus->name, __func__, dev_name(dev), drv->name);\n\n    if (dev->parent)\n        pm_runtime_get_sync(dev->parent);\n\n    pm_runtime_barrier(dev);\n    ret = really_probe(dev, drv);\n    pm_request_idle(dev);\n\n    if (dev->parent)\n        pm_runtime_put(dev->parent);\n\n    return ret;\n}\n```\n\n\n\n\n\n```\n// drivers/base/dd.c\nstatic int really_probe(struct device *dev, struct device_driver *drv)\n{\n\t......\n\tif (dev->bus->probe) {\n        ret = dev->bus->probe(dev);\n    } else if (drv->probe) {\n        ret = drv->probe(dev);\n    }\n    ......\n}\n```\n\n\n\n\n\n```mermaid\ngraph TB\n\tbus_add_driver(bus_add_driver)-->\n\tdriver_attach(driver_attach)--bus_for_each_dev-->\n\t__driver_attach(__driver_attach)-->\n\tdriver_match_device(driver_match_device)-->\n\tbus_match(drv->bus->match)\n\t__driver_attach-->driver_probe_device(driver_probe_device)-->\n\treally_probe(really_probe)-->\n\tbus_probe(dev->bus->probe)\n```\n\n\n\n\n\n\n\n```\n// drivers/i2c/i2c-core.c \nstruct bus_type i2c_bus_type = {\n    .name       = \"i2c\",\n    .match      = i2c_device_match,\n    .probe      = i2c_device_probe,\n    .remove     = i2c_device_remove,\n    .shutdown   = i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n```\n\n\n\n\n\n#### 6.1 match\n\n\n\n```\n// drivers/i2c/i2c-core.c \nstatic int i2c_device_match(struct device *dev, struct device_driver *drv)\n{\n    struct i2c_client   *client = i2c_verify_client(dev);\n    struct i2c_driver   *driver;\n\n    if (!client)\n        return 0;\n\n    /* Attempt an OF style match */\n    if (of_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    driver = to_i2c_driver(drv);\n    /* match on an id table if there is one */\n    if (driver->id_table)\n        return i2c_match_id(driver->id_table, client) != NULL;\n\n    return 0;\n}\n```\n\n\n\n```mermaid\ngraph LR\n\ti2c_device_match(i2c_device_match)\n\ti2c_device_match-->of_driver_match_device(of_driver_match_device)\n\ti2c_device_match-->acpi_driver_match_device(acpi_driver_match_device)\n\ti2c_device_match--id_table-->i2c_match_id(i2c_match_id)\n```\n\n\n\n\n从i2c_device_match()函数的定义可以得出，i2c的match函数，优先选择设备树匹配（of_driver_match_device），如果设备树匹配成功，函数就返回；否则，会进行下一个。。。。。。，最后，如果定义了id_table，就会通过i2c_match_id()函数进行id_table匹配；如果三者全都匹配不成功，才算是匹配失败；\n\n从i2c_device_match函数来看，配置了设备树，就不需要id_table的定义了；但是实际上还是需要id_table的定义的，因为在后边的probe函数中需要判断id_table是否定义，如果定义了才能执行driver->probe函数；\n\n\n\n设备树的匹配过程如下：\n\n```mermaid\ngraph TB\n\tof_driver_match_device(of_driver_match_device)-->\n\tof_match_device(of_match_device)-->\n\tof_match_node(of_match_node)-->\n\t__of_match_node(__of_match_node)-->\n\t__of_device_is_compatible(__of_device_is_compatible)\n\t__of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n\t__of_device_is_compatible--type-->of_compat_cmp\n\t__of_device_is_compatible--name-->of_compat_cmp\n\tof_compat_cmp-->\n\tstrcasecmp(strcasecmp)\n```\n\n\n\n\n__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；\n\n匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；\n\n\n\n#### 6.2 probe\n\n\n\n```\n// drivers/i2c/i2c-core.c\nstatic int i2c_device_probe(struct device *dev)\n{\n    struct i2c_client   *client = i2c_verify_client(dev);\n    struct i2c_driver   *driver;\n    int status;\n    ......\n    driver = to_i2c_driver(dev->driver);\n    if (!driver->probe || !driver->id_table)\n        return -ENODEV;\n\t......\n    status = driver->probe(client, i2c_match_id(driver->id_table, client));\n\t......\n}\n```\n\n\ni2c_device_probe()函数中，如果配置了设备树，i2c总线在match函数中，就不需要id_table的定义了；但是在probe函数中，还是需要id_table的定义的，因为在probe函数中需要判断id_table是否定义，如果定义了才能执行driver->probe函数；\n\n\n\n\n\n#### 6.3 I2C注册匹配过程\n\n\n\n![I2C注册匹配过程](Linux-kernel中的I2C子系统/I2C注册匹配过程.png)\n\n\n\n\n\n\n\n### 7. 实例\n\n以添加eeprom驱动为例讲解I2C驱动在eeprom芯片中的使用；\n\n\n\n#### 7.1 添加设备\n\n##### 1）添加设备树\n\n```\n// arch/arm/boot/dts/vexpress-v2m.dtsi\n\t\t\tv2m_i2c_dvi: i2c@16000 {\n                compatible = \"arm,versatile-i2c\";\n                reg = <0x16000 0x1000>;\n\n                #address-cells = <1>;\n                #size-cells = <0>;\n\n                dvi-transmitter@39 {\n                    compatible = \"sil,sii9022-tpi\", \"sil,sii9022\";\n                    reg = <0x39>;\n                };\n\n                dvi-transmitter@60 {\n                    compatible = \"sil,sii9022-cpi\", \"sil,sii9022\";\n                    reg = <0x60>;\n                };\n\n                eeprom@51 {\n                    compatible = \"mcy,mcy_eeprom\";\n                    reg = <0x51>;\n                };\n            };\n```\n\n\n\n\n\n##### 2）i2c_new_device\n\n```c\n// mcy_eeprom_device.c\n#include <linux/module.h>\n#include <linux/i2c.h>\n\nstatic struct i2c_client *client;\n\nstatic struct i2c_board_info eeprom_info = { \n    I2C_BOARD_INFO(\"eeprom_device\", 0x51),\n};\n\nstatic int eeprom_device_init(void)\n{\n    struct i2c_adapter *adap = NULL;\n\n    adap = i2c_get_adapter(2);\n    if (!adap) {\n        printk(\"%s, i2c_get_adapter failed!\\n\", __func__);\n        return -1; \n    }\n\n    client = i2c_new_device(adap, &eeprom_info);\n    if (!client) {\n        printk(\"%s, i2c_new_device failed!\\n\", __func__);\n        return -2; \n    }   \n\n    i2c_put_adapter(adap);\n\n    return 0;\n}\n\nstatic void eeprom_device_exit(void)\n{\n    i2c_unregister_device(client);\n}\n\nmodule_init(eeprom_device_init);\nmodule_exit(eeprom_device_exit);\n```\n\n\n\n\n\n#### 7.2 添加驱动\n\n##### 实例代码\n\n```c\n// mcy_eeprom_driver.c\n#include <linux/module.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <asm-generic/uaccess.h>\n\ntypedef struct eeprom_data_s {\n    int reg;\n    int len;\n    unsigned char data[16];\n} eeprom_data_t;\n\ntypedef struct eeprom_driver_s {\n    dev_t devnum;\n    struct cdev *cdev;\n    struct class *class;\n    struct device *dev;\n    struct i2c_client *client;\n} eeprom_driver_t;\n\neeprom_data_t eeprom_data;\neeprom_driver_t eeprom_driver;\n\nstatic int eeprom_driver_open(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic int eeprom_driver_release(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic ssize_t eeprom_driver_read(struct file *filp, char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    unsigned char reg[2] = {0};\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    reg[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8);\n    reg[1] = (char)(eeprom_data.reg & 0x000000ff);\n\n    ret = i2c_master_send(eeprom_driver.client, reg, 2);\n    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);\n\n    for (i = 0; i < eeprom_data.len; i++) {\n        printk(\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\", __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);\n    }\n\n    ret = copy_to_user(buf, &eeprom_data, count);\n    if (ret < 0) {\n        printk(\"%s, copy_to_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic ssize_t eeprom_driver_write(struct file *filp, const char __user *buf, size_t count, loff_t *loff)\n{\n    eeprom_data_t eeprom_data;\n    unsigned char data[18] = {0};\n    int len = 0;\n    int i = 0;\n    int ret = -1;\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    ret = copy_from_user(&eeprom_data, buf, count);\n    if (ret < 0) {\n        printk(\"%s, copy_from_user failed, ret: %d\\n\", __func__, ret);\n        return -1;\n    }\n\n    memcpy(&data[2], eeprom_data.data, eeprom_data.len);\n    data[0] = (char)((eeprom_data.reg & 0x0000ff00) >> 8);\n    data[1] = (char)(eeprom_data.reg & 0x000000ff);\n    len = eeprom_data.len + 2;\n\n    for (i = 0; i < len; i++) {\n        printk(\"%s, data[%d]: 0x%2x\\n\", __func__, i, data[i]);\n    }\n\n    ret = i2c_master_send(eeprom_driver.client, data, len);\n\n    return 0;\n}\n\nstruct file_operations eeprom_driver_fops = {\n    .open = eeprom_driver_open,\n    .release = eeprom_driver_release,\n    .read = eeprom_driver_read,\n    .write = eeprom_driver_write,\n};\n\nint eeprom_driver_probe(struct i2c_client *client, const struct i2c_device_id *id)\n{\n    int major = 0;\n    int ret = -1;\n\n    eeprom_driver.client = client;\n\n    ret = alloc_chrdev_region(&eeprom_driver.devnum, 0, 1, \"eeprom_driver_chrdev\");\n    if (ret < 0) {\n        printk(\"%s, alloc_chrdev_region failed!\\n\", __func__);\n        goto chrdev_err;\n    }\n    major = MAJOR(eeprom_driver.devnum);\n    printk(\"%s, alloc_chrdev_region, devnum: 0x%x, major: %d\\n\", __func__, eeprom_driver.devnum, major);\n\n    eeprom_driver.cdev = cdev_alloc();\n    if (!eeprom_driver.cdev) {\n        printk(\"%s, cdev_alloc failed!\\n\", __func__);\n        goto cdev_alloc_err;\n    }\n    cdev_init(eeprom_driver.cdev, &eeprom_driver_fops);\n    ret = cdev_add(eeprom_driver.cdev, eeprom_driver.devnum, 1);\n    if (ret < 0) {\n        printk(\"%s, cdev_add failed!\\n\", __func__);\n        goto cdev_add_err;\n    }\n\n    // /sys/class\n    eeprom_driver.class = class_create(THIS_MODULE, \"eeprom_driver_class\");\n    if (IS_ERR(eeprom_driver.class)) {\n        printk(\"%s, class_create failed!\\n\", __func__);\n        ret = PTR_ERR(eeprom_driver.class);\n        goto class_create_err;\n    }\n    // /dev\n    eeprom_driver.dev = device_create(eeprom_driver.class, NULL, eeprom_driver.devnum, NULL, \"eeprom_driver\");\n    if (IS_ERR(eeprom_driver.dev)) {\n        printk(\"%s, device_create failed!\\n\", __func__);\n        ret = PTR_ERR(eeprom_driver.dev);\n        goto device_create_err;\n    }\n\n    return 0;\n\ndevice_create_err:\n    class_destroy(eeprom_driver.class);\nclass_create_err:\n    cdev_del(eeprom_driver.cdev);\ncdev_add_err:\n    kfree(eeprom_driver.cdev);\ncdev_alloc_err:\n    unregister_chrdev_region(eeprom_driver.devnum, 1);\nchrdev_err:\n    return -EINVAL;\n}\n\nint eeprom_driver_remove(struct i2c_client *client)\n{\n    device_destroy(eeprom_driver.class, eeprom_driver.devnum);\n    class_destroy(eeprom_driver.class);\n\n    cdev_del(eeprom_driver.cdev);\n\n    kfree(eeprom_driver.cdev);\n    unregister_chrdev_region(eeprom_driver.devnum, 1);\n\n    return 0;\n}\n\nstruct i2c_device_id eeprom_driver_id[] = {\n    {\"mcy_eeprom\", 0},\n    {},\n};\n\nstruct of_device_id eeprom_driver_table[] = {\n    {\n        //.name = \"mcy_eeprom\",\n        .compatible = \"mcy,mcy_eeprom\",\n    },\n    {},\n};\n\nstruct i2c_driver eeprom_i2c_driver= {\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"mcy_eeprom\",\n        //.of_match_table = eeprom_driver_table,\n    },\n    .probe = eeprom_driver_probe,\n    .remove = eeprom_driver_remove,\n    .id_table = eeprom_driver_id,\n};\n\nstatic int eeprom_driver_init(void)\n{\n    i2c_add_driver(&eeprom_i2c_driver);\n\n    return 0;\n}\n\nstatic void eeprom_driver_exit(void)\n{\n    i2c_del_driver(&eeprom_i2c_driver);\n}\n\nmodule_init(eeprom_driver_init);\nmodule_exit(eeprom_driver_exit);\n```\n\n\n\n#### 7.3 应用程序\n\n\n\n```c\n// main.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\ntypedef struct eeprom_s {\n    int reg;\n    int len;\n    unsigned char data[16];\n} eeprom_data_t;\n\nint eeprom_read(int reg, int len)\n{\n    eeprom_data_t eeprom_data;\n    int fd = -1; \n    int i = 0;\n    int ret = -1; \n\n    if (len > 16) {\n        printf(\"%s, len: %d over range!\\n\", __func__, len);\n        return -1; \n    }   \n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    eeprom_data.reg = reg;\n    eeprom_data.len = len;\n    \n    ret = read(fd, &eeprom_data, sizeof(eeprom_data_t));\n    if (ret < 0) {\n        printf(\"%s, read failed, ret: %d\\n\", __func__, ret);\n        return -2; \n    }   \n\n    for (i = 0; i < len; i++) {\n        printf(\"%s, reg[%d]: %d, data: 0x%2x\\n\", __func__, i, reg + i, eeprom_data.data[i]);\n    }   \n\n    return 0;\n}\n\nint eeprom_write(int reg, int len, unsigned char *data)\n{\n    eeprom_data_t eeprom_data;\n    int fd = -1;\n    int i = 0;\n    int ret = -1;\n\n    if (len > 16) {\n        printf(\"%s, len: %d over range!\\n\", __func__, len);\n        return -1;\n    }\n\n    memset(&eeprom_data, 0, sizeof(eeprom_data_t));\n    eeprom_data.reg = reg;\n    eeprom_data.len = len;\n\n    ret = write(fd, &eeprom_data, sizeof(eeprom_data_t));\n    if (ret < 0) {\n        printf(\"%s, read failed, ret: %d\\n\", __func__, ret);\n        return -2;\n    }\n\n    for (i = 0; i < len; i++) {\n        printf(\"%s, reg[%d]: %d, data: 0x%2x\\n\", __func__, i, reg + i, eeprom_data.data[i]);\n    }\n\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    char buf[8] = {0};\n    int count = 0;\n    int reg = 0;\n    int len = 0;\n    int fd = -1;\n    int ret = -1;\n\n    fd = open(\"/dev/eeprom_driver\", O_RDWR | O_NONBLOCK);\n    if (fd < 0) {\n        printf(\"open failed, fd: %d\\n\", fd);\n        return -1;\n    }\n\n    ret = eeprom_write(reg, len, buf);\n    if (ret < 0) {\n        printf(\"eeprom_write failed, ret: %d\\n\", ret);\n        close(fd);\n        return -1;\n    }\n\n    ret = eeprom_read(reg, len);\n    if (ret < 0) {\n        printf(\"eeprom_read failed, ret: %d\\n\", ret);\n        close(fd);\n        return -1;\n    }\n\n    close(fd);\n\n    return 0;\n}\n```\n\n\n\n\n\n#### 7.4 Makefile\n\n\n\n```shell\nifneq ($(KERNELRELEASE),)\n    obj-m := mcy_eeprom_driver.o mcy_eeprom_device.o\nelse\n\n#generate the path\nCURRENT_PATH:=$(shell pwd)\n\n#the absolute path\nLINUX_KERNEL_PATH := /home/xiami/tool/linux-4.9.115\n\nCROSS_COMPILE := arm-linux-gnueabi-\nCC := $(CROSS_COMPILE)gcc\n\n#complie object\nall:\n    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules\nclean:\n    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean\n    -rm main -rf\napp:\n    $(CC) main.c -o main\ninstall:\n    -chmod a+x *.ko\n    -cp *.ko /home/xiami/qemu/nfs_root/mcy -rfp\n    -cp main /home/xiami/qemu/nfs_root/mcy -rfp\n    -chmod a+x /home/xiami/qemu/nfs_root/mcy/* main\nendif\n```\n\n\n\n### 8. 总结\n\n\nI2C总线维护两个链表，一个是I2C驱动链表，一个是I2C设备链表，每当注册一个驱动（或设备），就会将其添加到I2C总线上相对应的I2C驱动链表（或I2C设备链表），然后遍历I2C总线的I2C设备（或I2C驱动）链表的所有设备（或驱动），通过I2C总线的匹配函数判断是否匹配，如果匹配，就调用驱动的probe函数，然后就可以在probe函数中注册字符设备，创建设备节点，实现设备操作集fops等，为应用调用提供接口；\n\n\n\n\n\n参考资料\n\nhttps://blog.csdn.net/shichaog/article/details/41169981\n\n《Linux设备驱动开发详解》\n\n《精通linux设备驱动程序开发》\n\n\n\n\n\n[回到目录](#目录)\n\n\n\n\n\n","slug":"Linux-kernel中的I2C子系统","published":1,"updated":"2020-05-06T14:00:50.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckauufkwc0012dqg11pjdaq9f","content":"<p>Linux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；</p>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<p>Linux内核中的I2C驱动代码位于：drivers/i2c目录；</p>\n<h3 id=\"0-简述\"><a href=\"#0-简述\" class=\"headerlink\" title=\"0. 简述\"></a>0. 简述</h3><p>Linux内核中的I2C驱动代码位于：drivers/i2c目录；</p>\n<p>Linux设备模型由bus、device、driver组成；</p>\n<p>I2C驱动中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；</p>\n<blockquote>\n<p>I2C总线：维护I2C驱动和I2C设备两个链表，管理I2C驱动和I2C设备的匹配、删除等；</p>\n<p>I2C设备：具体硬件设备的一个抽象；</p>\n<p>I2C驱动：对应I2C设备的驱动程序；</p>\n<p>I2C适配器：用于I2C驱动和I2C设备间通信，是SOC上I2C控制器的一个抽象；</p>\n</blockquote>\n<p>I2C总线上有两个链表，分别是i2c_driver和i2c_client三链表；当任何一个driver或client注册时，I2C总线都会调用match函数，对client.name和driver.id_table.name进行遍历匹配；如果driver.id_table中所有的id都匹配不成功，说明client没有找到对应的driver；如果匹配成功，说明client和driver是配套的，那么I2C总线就会调用自己的probe函数，然后probe函数调用driver中提供的probe函数，driver中的probe函数会对设备进行硬件初始化和后续工作；</p>\n<p>i2c_add_adapter    // 注册adapter</p>\n<p>i2c_add_driver        // 注册driver</p>\n<p>i2c_new_device        // 注册client</p>\n<h3 id=\"1-I2C驱动框架\"><a href=\"#1-I2C驱动框架\" class=\"headerlink\" title=\"1. I2C驱动框架\"></a>1. I2C驱动框架</h3><p>Linux的I2C体系结构分为3个部分：</p>\n<blockquote>\n<p>I2C核心</p>\n<p>I2C总线驱动</p>\n<p>I2C设备驱动</p>\n</blockquote>\n<p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png\" alt=\"Linux的I2C子系统框架\"></p>\n<h4 id=\"1-1-I2C核心\"><a href=\"#1-1-I2C核心\" class=\"headerlink\" title=\"1.1 I2C核心\"></a>1.1 I2C核心</h4><p>I2C核心（i2c_core）维护了i2c_bus结构体，提供了：</p>\n<blockquote>\n<p>I2C总线驱动和设备驱动的注册、注销方法</p>\n<p>I2C的通信方法（i2c_algorithm）</p>\n<p>上层的与具体适配器无关的代码</p>\n<p>探测设备、检测设备地址的上层代码</p>\n</blockquote>\n<p>此部分代码由Linux内核提供；</p>\n<h4 id=\"1-2-I2C总线驱动\"><a href=\"#1-2-I2C总线驱动\" class=\"headerlink\" title=\"1.2 I2C总线驱动\"></a>1.2 I2C总线驱动</h4><p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器由CPU控制，或者直接集成在CPU内部；</p>\n<p>I2C总线驱动主要包含：</p>\n<blockquote>\n<p>I2C适配器数据结构i2c_adapter</p>\n<p>I2C适配器的控制算法数据结构i2c_algorithm</p>\n<p>控制I2C适配器产生通信信号的函数</p>\n</blockquote>\n<p>通过I2C总线驱动代码，可以控制I2C适配器，以主设备方式产生开始位、停止位、读写周期，以及以从设备方式读写、产生ACK等；</p>\n<p>此部分代码由具体的芯片厂商提供，如：高通、Samsung等；</p>\n<h4 id=\"1-3-I2C设备驱动\"><a href=\"#1-3-I2C设备驱动\" class=\"headerlink\" title=\"1.3 I2C设备驱动\"></a>1.3 I2C设备驱动</h4><p>I2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在I2C控制器（适配器）上，通过I2C适配器与CPU交换数据；</p>\n<p>I2C设备驱动主要包含i2c_client和i2c_driver结构体，实现和用户交互的文件操作集fops、cdev等；</p>\n<p>这两个数据结构中的成员函数，需要由驱动开发者根据具体设备去实现；</p>\n<h3 id=\"2-核心数据结构\"><a href=\"#2-核心数据结构\" class=\"headerlink\" title=\"2. 核心数据结构\"></a>2. 核心数据结构</h3><p>I2C驱动中最核心的4个数据结构：</p>\n<blockquote>\n<p>struct i2c_client</p>\n<p>struct i2c_driver</p>\n<p>struct i2c_adapter</p>\n<p>struct i2c_algorithm</p>\n</blockquote>\n<h4 id=\"2-1-设备层\"><a href=\"#2-1-设备层\" class=\"headerlink\" title=\"2.1 设备层\"></a>2.1 设备层</h4><h5 id=\"2-1-1-I2C设备（i2c-client）\"><a href=\"#2-1-1-I2C设备（i2c-client）\" class=\"headerlink\" title=\"2.1.1 I2C设备（i2c_client）\"></a>2.1.1 I2C设备（i2c_client）</h5><p>硬件上连接到I2C的SDA、SCL总线上的设备都是I2C设备，每一个I2C设备由一个i2c_client结构体进行描述；i2c_client对应真实的I2C物理设备，是具体硬件设备的抽象；一个i2c_client对象，表示连接到i2c总线的一个设备；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_client &#123;</span><br><span class=\"line\">    unsigned short flags;       &#x2F;* div., see below      *&#x2F;</span><br><span class=\"line\">    unsigned short addr;        &#x2F;* chip address - NOTE: 7bit    *&#x2F;</span><br><span class=\"line\">    char name[I2C_NAME_SIZE];</span><br><span class=\"line\">    struct i2c_adapter *adapter;    &#x2F;* the adapter we sit on    *&#x2F;</span><br><span class=\"line\">    struct device dev;      &#x2F;* the device structure     *&#x2F;</span><br><span class=\"line\">    int irq;            &#x2F;* irq issued by device     *&#x2F;</span><br><span class=\"line\">    struct list_head detected;</span><br><span class=\"line\">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class=\"line\">    i2c_slave_cb_t slave_cb;    &#x2F;* callback for slave mode  *&#x2F;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>unsigned short addr：表示7bit的设备芯片地址，地址被保存在低7bits</p>\n<p>struct i2c_adapter *adapter：表示这个i2c_client从属的i2c_adapter对象，驱动中使用这个指针操作发送</p>\n<p>struct device dev：表示device信息</p>\n<p>struct list_head detected：设备链表，将所有的i2c_client组成链表</p>\n</blockquote>\n<p>i2c_client结构不是驱动开发者创建的，而是通过以下方式自动创建：</p>\n<blockquote>\n<p>分配、设置、注册i2c_board_info</p>\n<p>获取i2c_adapter，调用i2c_new_device</p>\n<p>通过设备树（DeviceTree）创建</p>\n</blockquote>\n<h5 id=\"2-1-2-I2C驱动（i2c-driver）\"><a href=\"#2-1-2-I2C驱动（i2c-driver）\" class=\"headerlink\" title=\"2.1.2 I2C驱动（i2c_driver）\"></a>2.1.2 I2C驱动（i2c_driver）</h5><p>i2c_driver结构用于管理I2C的驱动和I2C设备的匹配探测，实现与用户层交互的文件操作集fops、cdev等；每一个I2C设备都对应一个I2C驱动，因此，每一个i2c_client结构，都对应一个i2c_driver结构，通过指针相连；编写一个i2c驱动的本质，就是要构造一个i2c_driver对象，并将其注册到内核；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_driver &#123;</span><br><span class=\"line\">    unsigned int class;</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Standard driver model interfaces *&#x2F;</span><br><span class=\"line\">    int (*probe)(struct i2c_client *, const struct i2c_device_id *); </span><br><span class=\"line\">    int (*remove)(struct i2c_client *); </span><br><span class=\"line\"></span><br><span class=\"line\">    void (*shutdown)(struct i2c_client *); </span><br><span class=\"line\">    void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol,</span><br><span class=\"line\">              unsigned int data);</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    struct device_driver driver;</span><br><span class=\"line\">    const struct i2c_device_id *id_table;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Device detection callback for automatic device creation *&#x2F;</span><br><span class=\"line\">    int (*detect)(struct i2c_client *, struct i2c_board_info *); </span><br><span class=\"line\">    const unsigned short *address_list;</span><br><span class=\"line\">    struct list_head clients;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>probe：探测函数，匹配成功后执行，会将匹配到的i2c_client对象传入，完成申请资源、初始化、提供接口等操作</p>\n<p>remove：移除函数，设备消失时或驱动模块被卸载时会被调用，和probe操作相反</p>\n<p>struct device_driver driver：表明是一个设备的驱动类，用于匹配设备树的of_match_table域</p>\n<p>const struct i2c_device_id *id_table：用于使用平台文件或模块编写设备信息时进行匹配</p>\n<p>struct list_head clients：用于将所有i2c_driver联系到一起的链表</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-1-3-总线和设备关系\"><a href=\"#2-1-3-总线和设备关系\" class=\"headerlink\" title=\"2.1.3 总线和设备关系\"></a>2.1.3 总线和设备关系</h5><p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"I2C设备和驱动的关系\"></p>\n<h4 id=\"2-2-总线层\"><a href=\"#2-2-总线层\" class=\"headerlink\" title=\"2.2 总线层\"></a>2.2 总线层</h4><h5 id=\"2-2-1-I2C适配器（i2c-adapter）\"><a href=\"#2-2-1-I2C适配器（i2c-adapter）\" class=\"headerlink\" title=\"2.2.1 I2C适配器（i2c_adapter）\"></a>2.2.1 I2C适配器（i2c_adapter）</h5><p>I2C适配器，即SOC中的I2C控制器，对应struct i2c_adapter结构体；Linux中用i2c_adapter来表示一个I2C控制器，一个i2c_adapter结构体对应的就是SOC上的I2C控制器；所有的设备驱动都需要经过i2c_adapter对象的处理才能和物理设备通信；通过i2c_core层将I2C设备与i2c adapter关联起来，用来完成i2c总线控制器相关的数据通信，此结构体在芯片厂商提供的代码中维护；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_adapter &#123;</span><br><span class=\"line\">    struct module *owner;</span><br><span class=\"line\">    unsigned int class;       &#x2F;* classes to allow probing for *&#x2F;</span><br><span class=\"line\">    const struct i2c_algorithm *algo; &#x2F;* the algorithm to access the bus *&#x2F;</span><br><span class=\"line\">    void *algo_data;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* data fields that are valid for all devices   *&#x2F;</span><br><span class=\"line\">    const struct i2c_lock_operations *lock_ops;</span><br><span class=\"line\">    struct rt_mutex bus_lock;</span><br><span class=\"line\">    struct rt_mutex mux_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    int timeout;            &#x2F;* in jiffies *&#x2F;</span><br><span class=\"line\">    int retries;</span><br><span class=\"line\">    struct device dev;      &#x2F;* the adapter device *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">    int nr;</span><br><span class=\"line\">    char name[48];</span><br><span class=\"line\">    struct completion dev_released;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct mutex userspace_clients_lock;</span><br><span class=\"line\">    struct list_head userspace_clients;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct i2c_bus_recovery_info *bus_recovery_info;</span><br><span class=\"line\">    const struct i2c_adapter_quirks *quirks;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-2-2-I2C总线算法（i2c-algorithm）\"><a href=\"#2-2-2-I2C总线算法（i2c-algorithm）\" class=\"headerlink\" title=\"2.2.2 I2C总线算法（i2c_algorithm）\"></a>2.2.2 I2C总线算法（i2c_algorithm）</h5><p>I2C总线数据通信算法，通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；</p>\n<p>struct i2c_algorithm数据结构，是i2c控制器数据通信需要的控制算法，对应的是I2C的时序；通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；用来描述适配器和设备之间的通信方法，由芯片厂商实现；</p>\n<p>最重要的成员是master_xfer()函数，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_algorithm &#123;</span><br><span class=\"line\">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class=\"line\">               int num);</span><br><span class=\"line\">    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class=\"line\">               unsigned short flags, char read_write,</span><br><span class=\"line\">               u8 command, int size, union i2c_smbus_data *data);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class=\"line\">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class=\"line\"></span><br><span class=\"line\">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class=\"line\">    int (*reg_slave)(struct i2c_client *client);</span><br><span class=\"line\">    int (*unreg_slave)(struct i2c_client *client);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>master_xfer：最重要的接口，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；该函数返回成功发送的消息数，错误返回负数；</p>\n</blockquote>\n<p>device_driver</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;device.h</span><br><span class=\"line\">struct device_driver &#123;</span><br><span class=\"line\">    const char      *name;</span><br><span class=\"line\">    struct bus_type     *bus;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct module       *owner;</span><br><span class=\"line\">    const char      *mod_name;  &#x2F;* used for built-in modules *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">    bool suppress_bind_attrs;   &#x2F;* disables bind&#x2F;unbind via sysfs *&#x2F;</span><br><span class=\"line\">    enum probe_type probe_type;</span><br><span class=\"line\"></span><br><span class=\"line\">    const struct of_device_id   *of_match_table;</span><br><span class=\"line\">    const struct acpi_device_id *acpi_match_table;</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*probe) (struct device *dev);</span><br><span class=\"line\">    int (*remove) (struct device *dev);</span><br><span class=\"line\">    void (*shutdown) (struct device *dev);</span><br><span class=\"line\">    int (*suspend) (struct device *dev, pm_message_t state);</span><br><span class=\"line\">    int (*resume) (struct device *dev);</span><br><span class=\"line\">    const struct attribute_group **groups;</span><br><span class=\"line\"></span><br><span class=\"line\">    const struct dev_pm_ops *pm; </span><br><span class=\"line\"></span><br><span class=\"line\">    struct driver_private *p;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h5 id=\"2-2-3-I2C总线类型\"><a href=\"#2-2-3-I2C总线类型\" class=\"headerlink\" title=\"2.2.3 I2C总线类型\"></a>2.2.3 I2C总线类型</h5><p>I2C总线对应着/bus/目录下的一个总线；维护I2C设备和I2C驱动两个链表，管理I2C设备和I2C的匹配和删除；是SOC上I2C控制器的抽象；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;device.h</span><br><span class=\"line\">struct bus_type &#123;</span><br><span class=\"line\">    const char      *name;</span><br><span class=\"line\">    const char      *dev_name;</span><br><span class=\"line\">    struct device       *dev_root;</span><br><span class=\"line\">    struct device_attribute *dev_attrs; &#x2F;* use dev_groups instead *&#x2F;</span><br><span class=\"line\">    const struct attribute_group **bus_groups;</span><br><span class=\"line\">    const struct attribute_group **dev_groups;</span><br><span class=\"line\">    const struct attribute_group **drv_groups;</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class=\"line\">    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class=\"line\">    int (*probe)(struct device *dev);</span><br><span class=\"line\">    int (*remove)(struct device *dev);</span><br><span class=\"line\">    void (*shutdown)(struct device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*online)(struct device *dev);</span><br><span class=\"line\">    int (*offline)(struct device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class=\"line\">    int (*resume)(struct device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    const struct dev_pm_ops *pm; </span><br><span class=\"line\"></span><br><span class=\"line\">    const struct iommu_ops *iommu_ops;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct subsys_private *p;</span><br><span class=\"line\">    struct lock_class_key lock_key;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class=\"line\">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class=\"line\">    .match      &#x3D; i2c_device_match,</span><br><span class=\"line\">    .probe      &#x3D; i2c_device_probe,</span><br><span class=\"line\">    .remove     &#x3D; i2c_device_remove,</span><br><span class=\"line\">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>I2C总线bus_type结构体管理着i2c设备和i2c驱动的匹配、删除操作，i2c会调用i2c_device_match函数对比i2c设备和i2c驱动是否匹配，如果匹配就调用i2c_device_probe函数，进而调用i2c驱动的probe函数；</p>\n<h4 id=\"2-3-总线层和设备层关系\"><a href=\"#2-3-总线层和设备层关系\" class=\"headerlink\" title=\"2.3 总线层和设备层关系\"></a>2.3 总线层和设备层关系</h4><p>在设备层，i2c_client通过adapter指针，指向总线层的i2c_adapter，和总线层存在关系；</p>\n<p>在总线层，i2c_adapter通过algo指针，指向i2c_algorithm，进一步调用i2c_algorithm中的算法，如：master_xfer()，进行实际的数据发送和接收；</p>\n<p>总线层</p>\n<p>struct i2c_adapter       I2C适配器（主机CPU的I2C控制器）</p>\n<p>struct i2c_algorithm       I2C算法（I2C的收、发时序控制）</p>\n<p>设备层</p>\n<p>struct i2c_client       I2C（从机）设备信息</p>\n<p>struct i2c_driver       I2C（从机）设备驱动信息</p>\n<p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E6%80%BB%E7%BA%BF%E5%B1%82%E5%92%8C%E8%AE%BE%E5%A4%87%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"I2C总线层和设备层的关系\"></p>\n<h4 id=\"2-4-数据结构间的关系\"><a href=\"#2-4-数据结构间的关系\" class=\"headerlink\" title=\"2.4 数据结构间的关系\"></a>2.4 数据结构间的关系</h4><p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"I2C数据结构间的关系\"></p>\n<h3 id=\"3-重要的操作函数\"><a href=\"#3-重要的操作函数\" class=\"headerlink\" title=\"3. 重要的操作函数\"></a>3. 重要的操作函数</h3><h4 id=\"3-1-I2C子系统初始化\"><a href=\"#3-1-I2C子系统初始化\" class=\"headerlink\" title=\"3.1 I2C子系统初始化\"></a>3.1 I2C子系统初始化</h4><h5 id=\"3-1-1-I2C总线初始化\"><a href=\"#3-1-1-I2C总线初始化\" class=\"headerlink\" title=\"3.1.1 I2C总线初始化\"></a>3.1.1 I2C总线初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">postcore_initcall(i2c_init);</span><br><span class=\"line\">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;init.h</span><br><span class=\"line\">#define postcore_initcall(fn)       __define_initcall(fn, 2)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;init.h</span><br><span class=\"line\">#define __define_initcall(fn, id) \\</span><br><span class=\"line\">    static initcall_t __initcall_##fn##id __used \\</span><br><span class=\"line\">    __attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) &#x3D; fn;</span><br></pre></td></tr></table></figure>\n\n<p>postcore_initcall(i2c_init)操作，会在编译内核时，将函数指针变量__initcall_i2c_init放到名称为initcall2.init的section中；即将i2c_init()函数的首地址放到名称为initcall2.init的section中；</p>\n<p>Linux设备启动时，会在do_basic_setup()函数中，通过driver_init()和do_initcalls()函数，调用到i2c_init()函数，对I2C总线初始化；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static int __init i2c_init(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    retval &#x3D; bus_register(&amp;i2c_bus_type);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    retval &#x3D; i2c_add_driver(&amp;dummy_driver);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过bus_register()函数，在系统中注册一个新的总线i2c_bus_type，name: i2c；适配器设备、I2C设备、I2C设备驱动程序都会连接到这条总线上；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class=\"line\">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class=\"line\">    .match      &#x3D; i2c_device_match,</span><br><span class=\"line\">    .probe      &#x3D; i2c_device_probe,</span><br><span class=\"line\">    .remove     &#x3D; i2c_device_remove,</span><br><span class=\"line\">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过i2c_add_driver()函数，向I2C总线注册一个空的I2C设备驱动程序；可以不用关心；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_init1(i2c_init)-->bus_register1(bus_register)\n    subgraph i2c_init\n        bus_register1(bus_register)-->\n        class_compat_register(class_compat_register)-->\n        i2c_add_driver(i2c_add_driver)\n    end</pre>\n\n\n\n<p>注册过程中发生异常错误时，需要使用对应的函数进行反向操作：</p>\n<pre class=\"mermaid\">graph TB\n    class_compat_register(class_compat_register)\n    class_compat_unregister(class_compat_unregister)</pre>\n\n\n\n<pre class=\"mermaid\">graph TB\n    bus_register(bus_register) \n    bus_unregister(bus_unregister)</pre>\n\n\n\n<h5 id=\"3-1-2-I2C总线退出\"><a href=\"#3-1-2-I2C总线退出\" class=\"headerlink\" title=\"3.1.2 I2C总线退出\"></a>3.1.2 I2C总线退出</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static void __exit i2c_exit(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (IS_ENABLED(CONFIG_ACPI))</span><br><span class=\"line\">        WARN_ON(acpi_reconfig_notifier_unregister(&amp;i2c_acpi_notifier));</span><br><span class=\"line\">    if (IS_ENABLED(CONFIG_OF_DYNAMIC))</span><br><span class=\"line\">        WARN_ON(of_reconfig_notifier_unregister(&amp;i2c_of_notifier));</span><br><span class=\"line\">    i2c_del_driver(&amp;dummy_driver);</span><br><span class=\"line\">#ifdef CONFIG_I2C_COMPAT</span><br><span class=\"line\">    class_compat_unregister(i2c_adapter_compat_class);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    bus_unregister(&amp;i2c_bus_type);</span><br><span class=\"line\">    tracepoint_synchronize_unregister();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>i2c_del_driver()函数，用来从I2C总线注销设备驱动程序；和i2c_add_driver()函数功能相反；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_add_driver(i2c_add_driver) \n    i2c_del_driver(i2c_del_driver)</pre>\n\n\n\n<h4 id=\"3-2-适配器驱动\"><a href=\"#3-2-适配器驱动\" class=\"headerlink\" title=\"3.2 适配器驱动\"></a>3.2 适配器驱动</h4><p>适配器驱动程序是I2C设备驱动程序需要实现的主要驱动程序，需要根据具体的适配器硬件编写；</p>\n<p>使用内核提供的框架函数向I2C子系统中添加一个新的适配器；i2c_adapter结构体为描述各种I2C适配器提供了通用的封装，但是i2c_adapter结构体只是所有适配器的共有属性，并不能代表所有类型的适配器；</p>\n<p>添加新的适配器的过程：</p>\n<blockquote>\n<p>分配一个I2C适配器，并初始化一个i2c_adapter结构体，及相应的变量</p>\n<p>使用i2c_add_adapter()函数向I2C子系统添加适配器结构体i2c_adapter</p>\n</blockquote>\n<h5 id=\"3-2-1-添加适配器驱动\"><a href=\"#3-2-1-添加适配器驱动\" class=\"headerlink\" title=\"3.2.1 添加适配器驱动\"></a>3.2.1 添加适配器驱动</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_add_adapter</span><span class=\"params\">(struct i2c_adapter *adapter)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span> = &amp;<span class=\"title\">adapter</span>-&gt;<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dev-&gt;of_node) &#123;</span><br><span class=\"line\">        id = of_alias_get_id(dev-&gt;of_node, <span class=\"string\">\"i2c\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id &gt;= <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">            adapter-&gt;nr = id;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class=\"line\">               __i2c_first_dynamic_bus_num, <span class=\"number\">0</span>, GFP_KERNEL);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (WARN(id &lt; <span class=\"number\">0</span>, <span class=\"string\">\"couldn't get idr\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    adapter-&gt;nr = id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i2c_register_adapter(adapter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_add_adapter);</span><br></pre></td></tr></table></figure>\n\n<p>通过i2c_register_adapter()函数，向内核注册一个适配器设备adapter；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_add_adapter(i2c_add_adapter)\n    -->i2c_register_adapter(i2c_register_adapter)</pre>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2c_register_adapter</span><span class=\"params\">(struct i2c_adapter *adap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = -EINVAL;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Sanity checks */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (WARN(!adap-&gt;name[<span class=\"number\">0</span>], <span class=\"string\">\"i2c adapter has no name\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap-&gt;algo) &#123;</span><br><span class=\"line\">        pr_err(<span class=\"string\">\"adapter '%s': no algo supplied!\\n\"</span>, adap-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap-&gt;lock_ops)</span><br><span class=\"line\">        adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Set default timeout to 1 second if not already set */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (adap-&gt;timeout == <span class=\"number\">0</span>)</span><br><span class=\"line\">        adap-&gt;timeout = HZ;</span><br><span class=\"line\"></span><br><span class=\"line\">    dev_set_name(&amp;adap-&gt;dev, <span class=\"string\">\"i2c-%d\"</span>, adap-&gt;nr);</span><br><span class=\"line\">    adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class=\"line\">    adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class=\"line\">    res = device_register(&amp;adap-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span><br><span class=\"line\">    pm_suspend_ignore_children(&amp;adap-&gt;dev, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    pm_runtime_enable(&amp;adap-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class=\"line\">    res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class=\"line\">                       adap-&gt;dev.parent);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_init_recovery(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* create pre-declared device nodes */</span></span><br><span class=\"line\">    of_i2c_register_devices(adap);</span><br><span class=\"line\">    i2c_acpi_register_devices(adap);</span><br><span class=\"line\">    i2c_acpi_install_space_handler(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class=\"line\">        i2c_scan_static_board_info(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Notify drivers */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    bus_for_each_drv(&amp;i2c_bus_type, <span class=\"literal\">NULL</span>, adap, __process_new_adapter);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">out_list:</span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-2-2-注销适配器驱动\"><a href=\"#3-2-2-注销适配器驱动\" class=\"headerlink\" title=\"3.2.2 注销适配器驱动\"></a>3.2.2 注销适配器驱动</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// // drivers/i2c/i2c-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">i2c_del_adapter</span><span class=\"params\">(struct i2c_adapter *adap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">found</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>, *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* First make sure that this adapter was ever added */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    found = idr_find(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found != adap) &#123;</span><br><span class=\"line\">        pr_debug(<span class=\"string\">\"attempting to delete unregistered adapter [%s]\\n\"</span>, adap-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_acpi_remove_space_handler(adap);</span><br><span class=\"line\">    <span class=\"comment\">/* Tell drivers about this removal */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    bus_for_each_drv(&amp;i2c_bus_type, <span class=\"literal\">NULL</span>, adap,</span><br><span class=\"line\">                   __process_removed_adapter);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Remove devices instantiated from sysfs */</span></span><br><span class=\"line\">    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class=\"line\">              i2c_adapter_depth(adap));</span><br><span class=\"line\">    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class=\"line\">                 detected) &#123;</span><br><span class=\"line\">        list_del(&amp;client-&gt;detected);</span><br><span class=\"line\">        i2c_unregister_device(client);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class=\"line\">    device_for_each_child(&amp;adap-&gt;dev, <span class=\"literal\">NULL</span>, __unregister_client);</span><br><span class=\"line\">    device_for_each_child(&amp;adap-&gt;dev, <span class=\"literal\">NULL</span>, __unregister_dummy);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class=\"line\">    class_compat_remove_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class=\"line\">                 adap-&gt;dev.parent);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    pm_runtime_disable(&amp;adap-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    init_completion(&amp;adap-&gt;dev_released);</span><br><span class=\"line\">    device_unregister(&amp;adap-&gt;dev);</span><br><span class=\"line\">    wait_for_completion(&amp;adap-&gt;dev_released);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* free bus id */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Clear the device structure in case this adapter is ever going to be</span></span><br><span class=\"line\"><span class=\"comment\">       added again */</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;adap-&gt;dev, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(adap-&gt;dev));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_adapter);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3-3-注册I2C驱动\"><a href=\"#3-3-注册I2C驱动\" class=\"headerlink\" title=\"3.3 注册I2C驱动\"></a>3.3 注册I2C驱动</h4><p>注册I2C驱动需要完成的操作：</p>\n<blockquote>\n<p>将I2C驱动添加到I2C总线的驱动链表中</p>\n<p>遍历I2C总线上的I2C设备链表，根据i2c_device_match函数进行匹配，如果匹配就调用i2c_device_probe函数</p>\n<p>i2c_device_probe函数会调用I2C驱动的probe函数</p>\n</blockquote>\n<h5 id=\"3-3-1-注册I2C驱动\"><a href=\"#3-3-1-注册I2C驱动\" class=\"headerlink\" title=\"3.3.1 注册I2C驱动\"></a>3.3.1 注册I2C驱动</h5><p>在I2C驱动程序中，通过i2c_add_driver()函数，来注册驱动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">#define i2c_add_driver(driver) \\</span><br><span class=\"line\">    i2c_register_driver(THIS_MODULE, driver)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    &#x2F;* add the driver to the list of i2c drivers in the driver core *&#x2F;</span><br><span class=\"line\">    driver-&gt;driver.owner &#x3D; owner;</span><br><span class=\"line\">    driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;\t\t&#x2F;&#x2F; 绑定I2C总线 </span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class=\"line\"></span><br><span class=\"line\">    res &#x3D; driver_register(&amp;driver-&gt;driver);\t\t&#x2F;&#x2F; 向I2C总线注册驱动</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    i2c_for_each_dev(driver, __process_new_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_register_driver);</span><br></pre></td></tr></table></figure>\n\n\n<p>在i2c_add_driver()函数中，做了三件事：</p>\n<blockquote>\n<p>绑定总线</p>\n<p>向总线注册驱动 —- 重点</p>\n<p>遍历总线的设备，调用__process_new_driver</p>\n</blockquote>\n<p>driver_register</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int driver_register(struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    struct device_driver *other;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    other &#x3D; driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    ret &#x3D; bus_add_driver(drv);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; driver_add_groups(drv, drv-&gt;groups);</span><br><span class=\"line\">    if (ret) &#123;</span><br><span class=\"line\">        bus_remove_driver(drv);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class=\"line\"></span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(driver_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>driver_find()函数，在I2C总线中，找到name对应的I2C device_driver；</p>\n<p>bus_add_driver()函数，将驱动添加到总线上；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_add_driver(i2c_add_driver)-->\n    i2c_register_driver(i2c_register_driver)-->\n    driver_register(driver_register)-->\n    bus_add_driver(bus_add_driver)</pre>\n\n\n\n\n\n\n\n<h5 id=\"3-3-2-注销I2C驱动\"><a href=\"#3-3-2-注销I2C驱动\" class=\"headerlink\" title=\"3.3.2 注销I2C驱动\"></a>3.3.2 注销I2C驱动</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">void i2c_del_driver(struct i2c_driver *driver)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    i2c_for_each_dev(driver, __process_removed_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    driver_unregister(&amp;driver-&gt;driver);</span><br><span class=\"line\">    pr_debug(&quot;driver [%s] unregistered\\n&quot;, driver-&gt;driver.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_driver);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-4-注册I2C设备\"><a href=\"#3-4-注册I2C设备\" class=\"headerlink\" title=\"3.4 注册I2C设备\"></a>3.4 注册I2C设备</h4><h5 id=\"3-4-1-注册I2C设备\"><a href=\"#3-4-1-注册I2C设备\" class=\"headerlink\" title=\"3.4.1 注册I2C设备\"></a>3.4.1 注册I2C设备</h5><p>I2C通过i2c_new_device()函数，来添加一个I2C设备；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">struct i2c_client *</span><br><span class=\"line\">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_client   *client;</span><br><span class=\"line\">    int         status;</span><br><span class=\"line\"></span><br><span class=\"line\">    client &#x3D; kzalloc(sizeof *client, GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;adapter &#x3D; adap;\t\t&#x2F;&#x2F; 指定设备的适配器</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;dev.platform_data &#x3D; info-&gt;platform_data;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (info-&gt;archdata)</span><br><span class=\"line\">        client-&gt;dev.archdata &#x3D; *info-&gt;archdata;</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;flags &#x3D; info-&gt;flags;</span><br><span class=\"line\">    client-&gt;addr &#x3D; info-&gt;addr;</span><br><span class=\"line\">    client-&gt;irq &#x3D; info-&gt;irq;</span><br><span class=\"line\"></span><br><span class=\"line\">    strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));</span><br><span class=\"line\"></span><br><span class=\"line\">    status &#x3D; i2c_check_addr_validity(client-&gt;addr, client-&gt;flags);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;* Check for address business *&#x2F;</span><br><span class=\"line\">    status &#x3D; i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;dev.parent &#x3D; &amp;client-&gt;adapter-&gt;dev;</span><br><span class=\"line\">    client-&gt;dev.bus &#x3D; &amp;i2c_bus_type;\t&#x2F;&#x2F; 绑定I2C总线</span><br><span class=\"line\">    client-&gt;dev.type &#x3D; &amp;i2c_client_type;</span><br><span class=\"line\">    client-&gt;dev.of_node &#x3D; info-&gt;of_node;</span><br><span class=\"line\">    client-&gt;dev.fwnode &#x3D; info-&gt;fwnode;</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_dev_set_name(adap, client);</span><br><span class=\"line\">    status &#x3D; device_register(&amp;client-&gt;dev);\t\t&#x2F;&#x2F; 向总线注册设备</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    return client;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_new_device);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_board_info &#123;</span><br><span class=\"line\">    char        type[I2C_NAME_SIZE];\t&#x2F;&#x2F; 设备名称，用于与驱动匹配</span><br><span class=\"line\">    unsigned short  flags;</span><br><span class=\"line\">    unsigned short  addr;\t&#x2F;&#x2F; 设备地址</span><br><span class=\"line\">    void        *platform_data;</span><br><span class=\"line\">    struct dev_archdata *archdata;</span><br><span class=\"line\">    struct device_node *of_node;</span><br><span class=\"line\">    struct fwnode_handle *fwnode;</span><br><span class=\"line\">    int     irq;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>struct i2c_board_info结构体描述了设备的硬件信息；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;core.c</span><br><span class=\"line\">int device_register(struct device *dev)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    device_initialize(dev);</span><br><span class=\"line\">    return device_add(dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>\n\n\n\n<pre class=\"mermaid\">graph TB\n    i2c_new_device(i2c_new_device)-->\n    device_register(device_register)-->\n    device_initialize(device_initialize)\n    device_register-->device_add(device_add)</pre>\n\n\n\n<p>device_initialize()函数用来初始化I2C设备的device结构体；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;core.c</span><br><span class=\"line\">void device_initialize(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dev-&gt;kobj.kset &#x3D; devices_kset;</span><br><span class=\"line\">    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class=\"line\">    mutex_init(&amp;dev-&gt;mutex);</span><br><span class=\"line\">    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class=\"line\">    spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class=\"line\">    device_pm_init(dev);</span><br><span class=\"line\">    set_dev_node(dev, -1);</span><br><span class=\"line\">#ifdef CONFIG_GENERIC_MSI_IRQ</span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_initialize);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int device_add(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct device *parent &#x3D; NULL;</span><br><span class=\"line\">    struct kobject *kobj;</span><br><span class=\"line\">    struct class_interface *class_intf;</span><br><span class=\"line\">    int error &#x3D; -EINVAL;</span><br><span class=\"line\">    struct kobject *glue_dir &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    dev &#x3D; get_device(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!dev-&gt;p) &#123;</span><br><span class=\"line\">        error &#x3D; device_private_init(dev);</span><br><span class=\"line\">        if (error)</span><br><span class=\"line\">            goto done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;init_name) &#123;</span><br><span class=\"line\">        dev_set_name(dev, &quot;%s&quot;, dev-&gt;init_name);</span><br><span class=\"line\">        dev-&gt;init_name &#x3D; NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class=\"line\">        dev_set_name(dev, &quot;%s%u&quot;, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent &#x3D; get_device(dev-&gt;parent);</span><br><span class=\"line\">    kobj &#x3D; get_device_parent(dev, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kobj)</span><br><span class=\"line\">        dev-&gt;kobj.parent &#x3D; kobj;</span><br><span class=\"line\">    if (parent &amp;&amp; (dev_to_node(dev) &#x3D;&#x3D; NUMA_NO_NODE))</span><br><span class=\"line\">        set_dev_node(dev, dev_to_node(parent));</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (platform_notify)</span><br><span class=\"line\">        platform_notify(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; device_add_class_symlinks(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; device_add_attrs(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; bus_add_device(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; dpm_sysfs_add(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    device_pm_add(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MAJOR(dev-&gt;devt)) &#123;</span><br><span class=\"line\">        error &#x3D; device_create_file(dev, &amp;dev_attr_dev);</span><br><span class=\"line\"></span><br><span class=\"line\">        error &#x3D; device_create_sys_dev_entry(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">        devtmpfs_create_node(dev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;bus)</span><br><span class=\"line\">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class=\"line\">                         BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class=\"line\">    bus_probe_device(dev);</span><br><span class=\"line\">    if (parent)</span><br><span class=\"line\">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class=\"line\">                   &amp;parent-&gt;p-&gt;klist_children);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;class) &#123;</span><br><span class=\"line\">        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class=\"line\">        klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class=\"line\">                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class=\"line\"></span><br><span class=\"line\">        list_for_each_entry(class_intf,</span><br><span class=\"line\">                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class=\"line\">            if (class_intf-&gt;add_dev)</span><br><span class=\"line\">                class_intf-&gt;add_dev(dev, class_intf);</span><br><span class=\"line\">        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_add);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>device_addbus_add_devicebus_probe_device</p>\n<h5 id=\"3-4-2-注销I2C设备\"><a href=\"#3-4-2-注销I2C设备\" class=\"headerlink\" title=\"3.4.2 注销I2C设备\"></a>3.4.2 注销I2C设备</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">void i2c_unregister_device(struct i2c_client *client)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (client-&gt;dev.of_node)</span><br><span class=\"line\">        of_node_clear_flag(client-&gt;dev.of_node, OF_POPULATED);</span><br><span class=\"line\">    if (ACPI_COMPANION(&amp;client-&gt;dev))</span><br><span class=\"line\">        acpi_device_clear_enumerated(ACPI_COMPANION(&amp;client-&gt;dev));</span><br><span class=\"line\">    device_unregister(&amp;client-&gt;dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_unregister_device);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    i2c_new_device(i2c_new_device)\n    i2c_unregister_device(i2c_unregister_device)</pre>\n\n\n\n\n\n<h4 id=\"3-5-适配器和设备通信\"><a href=\"#3-5-适配器和设备通信\" class=\"headerlink\" title=\"3.5 适配器和设备通信\"></a>3.5 适配器和设备通信</h4><p>I2C总线通信方式是对特定的I2C适配器使用i2c_transfer()函数，调用i2c_algothrim的master_xfer()方法实现i2c_msg消息的传输；不同的适配器，对应的master_xfer()方法由控制器的硬件决定，由芯片厂商提供；</p>\n<h5 id=\"3-5-1-i2c-transfer\"><a href=\"#3-5-1-i2c-transfer\" class=\"headerlink\" title=\"3.5.1 i2c_transfer\"></a>3.5.1 i2c_transfer</h5><p>在I2C设备和I2C驱动匹配之后，驱动程序和设备的通讯，通过i2c_transfer()函数来给设备发送信息；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    if (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">        ret &#x3D; __i2c_transfer(adap, msgs, num);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>\n\n<p>i2c_transfer()函数是i2c核心提供给设备驱动的发送方法，该函数发送的数据需要被打包成i2c_msg结构，该函数最终会回调i2c_adapter-&gt;i2c_algorithm-&gt;master_xfer()函数，将i2c_msg对象发送到i2c的物理控制器；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned long orig_jiffies;</span><br><span class=\"line\">    int ret, try;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (adap-&gt;quirks &amp;&amp; i2c_check_for_quirks(adap, msgs, num))</span><br><span class=\"line\">        return -EOPNOTSUPP;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (static_key_false(&amp;i2c_trace_msg)) &#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">        for (i &#x3D; 0; i &lt; num; i++)</span><br><span class=\"line\">            if (msgs[i].flags &amp; I2C_M_RD)</span><br><span class=\"line\">                trace_i2c_read(adap, &amp;msgs[i], i);</span><br><span class=\"line\">            else</span><br><span class=\"line\">                trace_i2c_write(adap, &amp;msgs[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    orig_jiffies &#x3D; jiffies;</span><br><span class=\"line\">    for (ret &#x3D; 0, try &#x3D; 0; try &lt;&#x3D; adap-&gt;retries; try++) &#123;</span><br><span class=\"line\">        ret &#x3D; adap-&gt;algo-&gt;master_xfer(adap, msgs, num);\t\t&#x2F;&#x2F; 发送、接收信息操作</span><br><span class=\"line\">        if (ret !&#x3D; -EAGAIN)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        if (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(__i2c_transfer);</span><br></pre></td></tr></table></figure>\n\n<p>最终，通过adap-&gt;algo-&gt;master_xfer()函数，将struct i2c_msg结构体类型的消息，通过适配器的struct i2c_adapter发送给设备，或者从设备中读取信息；</p>\n<h5 id=\"3-5-2-消息格式\"><a href=\"#3-5-2-消息格式\" class=\"headerlink\" title=\"3.5.2 消息格式\"></a>3.5.2 消息格式</h5><p>经过mster_xfer()函数发送、接收的消息类型应该按照struct i2c_msg结构体格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/uapi/linux/i2c.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> &#123;</span></span><br><span class=\"line\">    __u16 addr; <span class=\"comment\">/* slave address            */</span></span><br><span class=\"line\">    __u16 flags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RD        0x0001  <span class=\"comment\">/* read data, from slave to master */</span></span></span><br><span class=\"line\">                    <span class=\"comment\">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_TEN       0x0010  <span class=\"comment\">/* this is a ten bit chip address */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RECV_LEN      0x0400  <span class=\"comment\">/* length will be first received byte */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NO_RD_ACK     0x0800  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_IGNORE_NAK    0x1000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NOSTART       0x4000  <span class=\"comment\">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_STOP      0x8000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\">    __u16 len;      <span class=\"comment\">/* msg length               */</span></span><br><span class=\"line\">    __u8 *buf;      <span class=\"comment\">/* pointer to msg data          */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；</p>\n<p>I2C读取，即封装的xxx_i2c_read()函数，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>\n<p>I2C写入，即封装的xxx_i2c_write()函数，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；</p>\n</blockquote>\n<p>注意：以数组格式定义i2c_msg是为了访问连续，因为数组是连续内存存储的；</p>\n<h5 id=\"3-5-3-消息发送、接收函数\"><a href=\"#3-5-3-消息发送、接收函数\" class=\"headerlink\" title=\"3.5.3 消息发送、接收函数\"></a>3.5.3 消息发送、接收函数</h5><h6 id=\"1）发送函数\"><a href=\"#1）发送函数\" class=\"headerlink\" title=\"1）发送函数\"></a>1）发送函数</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_master_send(const struct i2c_client *client, const char *buf, int count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    struct i2c_adapter *adap &#x3D; client-&gt;adapter;</span><br><span class=\"line\">    struct i2c_msg msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg.addr &#x3D; client-&gt;addr;</span><br><span class=\"line\">    msg.flags &#x3D; client-&gt;flags &amp; I2C_M_TEN;</span><br><span class=\"line\">    msg.len &#x3D; count;</span><br><span class=\"line\">    msg.buf &#x3D; (char *)buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; i2c_transfer(adap, &amp;msg, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (ret &#x3D;&#x3D; 1) ? count : ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_master_send);</span><br></pre></td></tr></table></figure>\n\n<p>I2C发送消息操作时，仅需要一个i2c_msg；i2c_msg的buf，保存slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, data, len);</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2）接收函数\"><a href=\"#2）接收函数\" class=\"headerlink\" title=\"2）接收函数\"></a>2）接收函数</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_master_recv(const struct i2c_client *client, char *buf, int count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_adapter *adap &#x3D; client-&gt;adapter;</span><br><span class=\"line\">    struct i2c_msg msg;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg.addr &#x3D; client-&gt;addr;</span><br><span class=\"line\">    msg.flags &#x3D; client-&gt;flags &amp; I2C_M_TEN;</span><br><span class=\"line\">    msg.flags |&#x3D; I2C_M_RD;</span><br><span class=\"line\">    msg.len &#x3D; count;</span><br><span class=\"line\">    msg.buf &#x3D; buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; i2c_transfer(adap, &amp;msg, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (ret &#x3D;&#x3D; 1) ? count : ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_master_recv);</span><br></pre></td></tr></table></figure>\n\n<p>I2C接收消息操作时，需要给从设备发送两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，并使用buf指针指向这个地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>\n<p>也可以分两次，先使用i2c_master_send()函数，向slave发出目标寄存器地址，在使用i2c_master_recv()函数，用来接收读取到的数据消息；如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, reg, <span class=\"number\">2</span>); </span><br><span class=\"line\">i2c_master_recv(client, data, len);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-添加设备\"><a href=\"#4-添加设备\" class=\"headerlink\" title=\"4. 添加设备\"></a>4. 添加设备</h3><p>在内核中的Documentation/i2c/instantiating-devices文件中，讲述了添加设备的方法；</p>\n<p>i2c_client结构是通过以下方式自动创建：</p>\n<blockquote>\n<p>分配、设置、注册i2c_board_info</p>\n<p>获取i2c_adapter，调用i2c_new_device</p>\n<p>通过设备树（DeviceTree）创建</p>\n</blockquote>\n<h4 id=\"4-1-添加设备树\"><a href=\"#4-1-添加设备树\" class=\"headerlink\" title=\"4.1 添加设备树\"></a>4.1 添加设备树</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Image-fsl-lx2160a-rdb-new.dts</span><br><span class=\"line\">        i2c@2030000 &#123;</span><br><span class=\"line\">            compatible &#x3D; &quot;fsl,vf610-i2c&quot;;</span><br><span class=\"line\">            #address-cells &#x3D; &lt;0x1&gt;;</span><br><span class=\"line\">            #size-cells &#x3D; &lt;0x0&gt;;</span><br><span class=\"line\">            reg &#x3D; &lt;0x0 0x2030000 0x0 0x10000&gt;;</span><br><span class=\"line\">            interrupts &#x3D; &lt;0x0 0x23 0x4&gt;;</span><br><span class=\"line\">            scl-gpios&#x3D;&lt;&amp;gpio4 8 0x0&gt;;</span><br><span class=\"line\">            clock-names &#x3D; &quot;i2c&quot;;</span><br><span class=\"line\">            clocks &#x3D; &lt;0x2 0x4 0x7&gt;;</span><br><span class=\"line\">            status &#x3D; &quot;okay&quot;;</span><br><span class=\"line\">            rtc@32 &#123;</span><br><span class=\"line\">                compatible &#x3D; &quot;Micro Crystal,rv8803&quot;;</span><br><span class=\"line\">                reg &#x3D; &lt;0x32&gt;;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            eeprom_mcy@51 &#123;</span><br><span class=\"line\">                compatible &#x3D; &quot;mcy,eeprom_mcy&quot;;</span><br><span class=\"line\">                reg &#x3D; &lt;0x51&gt;;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;</span><br><span class=\"line\">2-0032  2-0051  i2c-0   i2c-1   i2c-2   i2c-3 </span><br><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F; -l</span><br><span class=\"line\">total 0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0032 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2030000.i2c&#x2F;i2c-2&#x2F;2-0032</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0051 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2030000.i2c&#x2F;i2c-2&#x2F;2-0051</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-0 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2000000.i2c&#x2F;i2c-0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-1 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2010000.i2c&#x2F;i2c-1</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-2 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2030000.i2c&#x2F;i2c-2</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-3 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2050000.i2c&#x2F;i2c-3</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;2-0051&#x2F;</span><br><span class=\"line\">consumers  modalias   name       of_node    subsystem  suppliers  uevent</span><br><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;2-0051&#x2F; -l</span><br><span class=\"line\">total 0</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 consumers</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 modalias</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 name</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:27 of_node -&gt; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;firmware&#x2F;devicetree&#x2F;base&#x2F;soc&#x2F;i2c@2030000&#x2F;eeprom_mcy@51</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:27 subsystem -&gt; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;bus&#x2F;i2c</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 suppliers</span><br><span class=\"line\">-rw-r--r--    1 root     root          4096 Oct 15 03:27 uevent</span><br><span class=\"line\"># cat &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;2-0051&#x2F;name</span><br><span class=\"line\">eeprom_mcy</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"4-2-i2c-new-device添加\"><a href=\"#4-2-i2c-new-device添加\" class=\"headerlink\" title=\"4.2 i2c_new_device添加\"></a>4.2 i2c_new_device添加</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_board_info</span> <span class=\"title\">eeprom_info</span> = &#123;</span> </span><br><span class=\"line\">    I2C_BOARD_INFO(<span class=\"string\">\"eeprom_device\"</span>, <span class=\"number\">0x51</span>),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_device_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s: %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\"></span><br><span class=\"line\">    adap = i2c_get_adapter(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_get_adapter failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    client = i2c_new_device(adap, &amp;eeprom_info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!client) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_new_device failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_put_adapter(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eeprom_device_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s: %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_unregister_device(client);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(eeprom_device_init);</span><br><span class=\"line\">module_exit(eeprom_device_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"4-3-静态注册I2C设备\"><a href=\"#4-3-静态注册I2C设备\" class=\"headerlink\" title=\"4.3 静态注册I2C设备\"></a>4.3 静态注册I2C设备</h4><p>内核提供了一种静态注册I2C设备的方法，通过i2c_register_board_info()函数实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-boardinfo.c</span><br><span class=\"line\">int i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int status;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (busnum &gt;&#x3D; __i2c_first_dynamic_bus_num)</span><br><span class=\"line\">        __i2c_first_dynamic_bus_num &#x3D; busnum + 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (status &#x3D; 0; len; len--, info++) &#123;</span><br><span class=\"line\">        struct i2c_devinfo  *devinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">        devinfo &#x3D; kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">        devinfo-&gt;busnum &#x3D; busnum;</span><br><span class=\"line\">        devinfo-&gt;board_info &#x3D; *info;</span><br><span class=\"line\">        list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在系统初始化过程中，可以通过i2c_register_board_info()函数，将需要的I2C设备添加到__i2c_board_list链表；系统在成功加载I2C适配器adapter后，会对这个__i2c_board_list链表中所有的设备逐一完成i2c_client的注册；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.h</span><br><span class=\"line\">struct i2c_devinfo &#123;</span><br><span class=\"line\">    struct list_head    list;</span><br><span class=\"line\">    int         busnum;</span><br><span class=\"line\">    struct i2c_board_info   board_info;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>系统初始化时，根据I2C设备配置信息，创建I2C设备（i2c_client），并添加到I2C子系统；</p>\n<p>最终是在i2c_scan_static_board_info()函数中，通过调用i2c_new_device()函数来实现添加设备；i2c_scan_static_board_info()函数一般在初始化时工作；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static void i2c_scan_static_board_info(struct i2c_adapter *adapter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_devinfo  *devinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry(devinfo, &amp;__i2c_board_list, list) &#123;</span><br><span class=\"line\">        if (devinfo-&gt;busnum &#x3D;&#x3D; adapter-&gt;nr</span><br><span class=\"line\">                &amp;&amp; !i2c_new_device(adapter,</span><br><span class=\"line\">                        &amp;devinfo-&gt;board_info))</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"5-添加驱动\"><a href=\"#5-添加驱动\" class=\"headerlink\" title=\"5. 添加驱动\"></a>5. 添加驱动</h3><p>以eeprom为例；</p>\n<h4 id=\"5-1-I2C设备驱动框架\"><a href=\"#5-1-I2C设备驱动框架\" class=\"headerlink\" title=\"5.1 I2C设备驱动框架\"></a>5.1 I2C设备驱动框架</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">mcy_eeprom_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_add_driver(&amp;mcy_eeprom_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mcy_eeprom_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_del_driver(&amp;mcy_eeprom_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(mcy_eeprom_init);</span><br><span class=\"line\">module_exit(mcy_eeprom_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> <span class=\"title\">mcy_eeprom_driver</span> = &#123;</span></span><br><span class=\"line\">    .driver = &#123;</span><br><span class=\"line\">        .owner = THIS_MODULE,</span><br><span class=\"line\">        .name = <span class=\"string\">\"mcy_eeprom\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//.of_match_table = mcy_eeprom_table,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    .probe = mcy_eeprom_probe,</span><br><span class=\"line\">    .<span class=\"built_in\">remove</span> = mcy_eeprom_remove,</span><br><span class=\"line\">    .id_table = mcy_eeprom_id,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    eeprom_init(eeprom_init)-->\n    i2c_add_driver(i2c_add_driver)-->eeprom_driver(eeprom_driver)\n    eeprom_driver-->driver(driver)\n    eeprom_driver-->probe(probe)\n    eeprom_driver-->remove(remove)\n    eeprom_driver-->id_table(id_table)</pre>\n\n\n\n<h4 id=\"5-2-probe函数\"><a href=\"#5-2-probe函数\" class=\"headerlink\" title=\"5.2 probe函数\"></a>5.2 probe函数</h4><h5 id=\"1）注册字符设备\"><a href=\"#1）注册字符设备\" class=\"headerlink\" title=\"1）注册字符设备\"></a>1）注册字符设备</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mcy_eeprom_probe</span><span class=\"params\">(struct i2c_client *client, <span class=\"keyword\">const</span> struct i2c_device_id *id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    eeprom_driver.client = client;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = alloc_chrdev_region(&amp;devnum, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">\"mcy_eeprom_chrdev\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, alloc_chrdev_region failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> chrdev_err;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, alloc_chrdev_region, devnum: %d\\n\"</span>, __func__, devnum);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev = cdev_alloc();</span><br><span class=\"line\">    cdev_init(cdev, &amp;mcy_eeprom_fops);</span><br><span class=\"line\">    ret = cdev_add(cdev, devnum, <span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, cdev_add failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> cdev_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// /sys/class</span></span><br><span class=\"line\">    dev_class = class_create(THIS_MODULE, <span class=\"string\">\"mcy_eeprom_class\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(dev_class)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, dev_class class_create failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> class_err;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"comment\">// /dev</span></span><br><span class=\"line\">    device_create(dev_class, <span class=\"literal\">NULL</span>, devnum, <span class=\"literal\">NULL</span>, <span class=\"string\">\"mcy_eeprom0\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, OK!\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">class_err:</span><br><span class=\"line\">    cdev_del(cdev);</span><br><span class=\"line\">cdev_err:</span><br><span class=\"line\">    unregister_chrdev_region(devnum, <span class=\"number\">1</span>); </span><br><span class=\"line\">chrdev_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2）卸载函数\"><a href=\"#2）卸载函数\" class=\"headerlink\" title=\"2）卸载函数\"></a>2）卸载函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mcy_eeprom_remove</span><span class=\"params\">(struct i2c_client *client)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    device_destroy(dev_class, devnum);</span><br><span class=\"line\">    class_destroy(dev_class);</span><br><span class=\"line\">    cdev_del(cdev);</span><br><span class=\"line\">    unregister_chrdev_region(devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\">    kfree(cdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3）字符设备操作集\"><a href=\"#3）字符设备操作集\" class=\"headerlink\" title=\"3）字符设备操作集\"></a>3）字符设备操作集</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">mcy_eeprom_fops</span>= &#123;</span></span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = eeprom_driver_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = eeprom_driver_release,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span> = eeprom_driver_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span> = eeprom_driver_write,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-读写函数\"><a href=\"#5-3-读写函数\" class=\"headerlink\" title=\"5.3 读写函数\"></a>5.3 读写函数</h4><p>I2C数据的发送和接收，是通过I2C驱动中file_operations的write和read系统调用来实现的；驱动中read和write的封装，是需要封装调用i2c_transfer()函数来完成i2d_msg消息的通信；read和write函数的封装，有两种方法；</p>\n<h5 id=\"5-3-1-内核函数调用\"><a href=\"#5-3-1-内核函数调用\" class=\"headerlink\" title=\"5.3.1 内核函数调用\"></a>5.3.1 内核函数调用</h5><p>使用i2c-core.c提供的i2c_master_send()和i2c_master_recv()函数实现I2C信息的发送和接收；</p>\n<h6 id=\"1）发送\"><a href=\"#1）发送\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, data, len);</span><br></pre></td></tr></table></figure>\n\n<p>I2C发送，直接调用i2c_master_send()函数，一次完成I2C数据的发送；</p>\n<p>data：要发送的数据信息数组；其中data最前边的地址存放的是I2C从设备寄存器的地址，如果地址是8bits，就占用data[0]，如果地址是16bits，占用data[0]和data[1]；在地址之后，紧接着存放要发送的数据内容；</p>\n<p>len：要发送的数据长度；包含I2C从设备寄存器地址和数据内容的总数据长度；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_write</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">18</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data[<span class=\"number\">2</span>], eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\">    len = eeprom_data.len + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, data[%d]: 0x%2x\\n\"</span>, __func__, i, data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 1</span></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, data, len);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2）接收\"><a href=\"#2）接收\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, reg, reg_len); </span><br><span class=\"line\">i2c_master_recv(client, data, data_len);</span><br></pre></td></tr></table></figure>\n\n<p>I2C接收不同于发送，需要两步来完成，先使用i2c_master_send()函数向I2C从设备发送要读取的寄存器地址；再使用i2c_master_recv()函数，从I2C从设备指定寄存器地址读取数据；</p>\n<p>reg：要读取的从设备寄存器地址数组；如果地址是8bits，reg_len为1；如果地址是16bits，reg_len为2；</p>\n<p>data：要读取的数据信息存放的指针地址；data_len为要读取的寄存器个数；</p>\n<h6 id><a href=\"#\" class=\"headerlink\" title></a></h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_read</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> reg[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    reg[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>); </span><br><span class=\"line\">    reg[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 1</span></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, reg, <span class=\"number\">2</span>); </span><br><span class=\"line\">    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; eeprom_data.len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\"</span>, __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_to_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"5-3-2-直接封装\"><a href=\"#5-3-2-直接封装\" class=\"headerlink\" title=\"5.3.2 直接封装\"></a>5.3.2 直接封装</h5><p>直接通过封装i2c_msg消息，通过i2c_transfer()函数实现I2C信息的发送和接收；</p>\n<h6 id=\"1）发送-1\"><a href=\"#1）发送-1\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_send_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct i2c_client *client, <span class=\"keyword\">unsigned</span> short reg, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data = kmalloc(count + <span class=\"number\">2</span>, GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, kmalloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data[<span class=\"number\">2</span>], buf, count);</span><br><span class=\"line\">    len = count + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;msg, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(msg));</span><br><span class=\"line\">    msg.addr = client-&gt;addr;</span><br><span class=\"line\">    msg.flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    msg.len = count;</span><br><span class=\"line\">    msg.buf = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_transfer(client-&gt;adapter, &amp;msg, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">        kfree(data);</span><br><span class=\"line\">        data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_write</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_send_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2）接收-1\"><a href=\"#2）接收-1\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_recv_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct i2c_client *client, <span class=\"keyword\">unsigned</span> short reg, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> <span class=\"title\">msg</span>[2] = &#123;</span> <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> txbuf[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    txbuf[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    txbuf[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;msg, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(msg));</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].addr = client-&gt;addr;</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].len = <span class=\"number\">2</span>;</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].buf = txbuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].addr = client-&gt;addr;</span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].flags = I2C_M_RD;</span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].len = count;</span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].buf = buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_transfer(client-&gt;adapter, msg, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_read</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_recv_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_to_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-驱动和设备匹配\"><a href=\"#6-驱动和设备匹配\" class=\"headerlink\" title=\"6. 驱动和设备匹配\"></a>6. 驱动和设备匹配</h3><p>设备和驱动的关系</p>\n<p>对于一个驱动程序，有两个必不可少的元素，即：设备和驱动，驱动是通过设备名和驱动名建立联系；在i2c_adapter注册时会遍历i2c_board_info结构，会完成驱动和设备的匹配；</p>\n<p>一个驱动程序，可以有多个名字，即一个驱动程序可以支持多个设备，该机制通过由i2c_device_id结构体组成的数组实现；该数组是在驱动中建立；I2C架构会扫描该结构体数组，逐一与设备进行匹配，匹配成功就会调用相应的probe函数；</p>\n<p>进入驱动中的probe函数，要先进入总线的probe函数，而前提是设备与驱动的match匹配成功；</p>\n<p>bus_add_driver</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;bus.c</span><br><span class=\"line\">int bus_add_driver(struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct bus_type *bus;</span><br><span class=\"line\">    struct driver_private *priv;</span><br><span class=\"line\">    int error &#x3D; 0; </span><br><span class=\"line\"></span><br><span class=\"line\">    bus &#x3D; bus_get(drv-&gt;bus);</span><br><span class=\"line\"></span><br><span class=\"line\">    priv &#x3D; kzalloc(sizeof(*priv), GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">    klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);</span><br><span class=\"line\">    priv-&gt;driver &#x3D; drv; </span><br><span class=\"line\">    drv-&gt;p &#x3D; priv;</span><br><span class=\"line\">    priv-&gt;kobj.kset &#x3D; bus-&gt;p-&gt;drivers_kset;</span><br><span class=\"line\">    error &#x3D; kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,</span><br><span class=\"line\">                     &quot;%s&quot;, drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class=\"line\">    if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class=\"line\">        if (driver_allows_async_probing(drv)) &#123;</span><br><span class=\"line\">            async_schedule(driver_attach_async, drv);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            error &#x3D; driver_attach(drv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    module_add_driver(drv-&gt;owner, drv);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class=\"line\">        error &#x3D; add_bind_files(drv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">int driver_attach(struct device_driver *drv)</span><br><span class=\"line\">&#123;               </span><br><span class=\"line\">    return bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);</span><br><span class=\"line\">&#125;       </span><br><span class=\"line\">EXPORT_SYMBOL_GPL(driver_attach);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;bus.c</span><br><span class=\"line\">int bus_for_each_dev(struct bus_type *bus, struct device *start,</span><br><span class=\"line\">             void *data, int (*fn)(struct device *, void *))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct klist_iter i;</span><br><span class=\"line\">    struct device *dev;</span><br><span class=\"line\">    int error &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!bus || !bus-&gt;p)</span><br><span class=\"line\">        return -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,</span><br><span class=\"line\">                 (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));</span><br><span class=\"line\">    while ((dev &#x3D; next_device(&amp;i)) &amp;&amp; !error)</span><br><span class=\"line\">        error &#x3D; fn(dev, data);</span><br><span class=\"line\">    klist_iter_exit(&amp;i);</span><br><span class=\"line\">    return error;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_for_each_dev);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">static int __driver_attach(struct device *dev, void *data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct device_driver *drv &#x3D; data;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; driver_match_device(drv, dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    if (!dev-&gt;driver)</span><br><span class=\"line\">        driver_probe_device(drv, dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;base.h</span><br><span class=\"line\">static inline int driver_match_device(struct device_driver *drv,</span><br><span class=\"line\">                      struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">int driver_probe_device(struct device_driver *drv, struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!device_is_registered(dev))</span><br><span class=\"line\">        return -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_debug(&quot;bus: &#39;%s&#39;: %s: matched device %s with driver %s\\n&quot;,</span><br><span class=\"line\">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;parent)</span><br><span class=\"line\">        pm_runtime_get_sync(dev-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    pm_runtime_barrier(dev);</span><br><span class=\"line\">    ret &#x3D; really_probe(dev, drv);</span><br><span class=\"line\">    pm_request_idle(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;parent)</span><br><span class=\"line\">        pm_runtime_put(dev-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">static int really_probe(struct device *dev, struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tif (dev-&gt;bus-&gt;probe) &#123;</span><br><span class=\"line\">        ret &#x3D; dev-&gt;bus-&gt;probe(dev);</span><br><span class=\"line\">    &#125; else if (drv-&gt;probe) &#123;</span><br><span class=\"line\">        ret &#x3D; drv-&gt;probe(dev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    bus_add_driver(bus_add_driver)-->\n    driver_attach(driver_attach)--bus_for_each_dev-->\n    __driver_attach(__driver_attach)-->\n    driver_match_device(driver_match_device)-->\n    bus_match(drv->bus->match)\n    __driver_attach-->driver_probe_device(driver_probe_device)-->\n    really_probe(really_probe)-->\n    bus_probe(dev->bus->probe)</pre>\n\n\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c </span><br><span class=\"line\">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class=\"line\">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class=\"line\">    .match      &#x3D; i2c_device_match,</span><br><span class=\"line\">    .probe      &#x3D; i2c_device_probe,</span><br><span class=\"line\">    .remove     &#x3D; i2c_device_remove,</span><br><span class=\"line\">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"6-1-match\"><a href=\"#6-1-match\" class=\"headerlink\" title=\"6.1 match\"></a>6.1 match</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c </span><br><span class=\"line\">static int i2c_device_match(struct device *dev, struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_client   *client &#x3D; i2c_verify_client(dev);</span><br><span class=\"line\">    struct i2c_driver   *driver;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!client)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Attempt an OF style match *&#x2F;</span><br><span class=\"line\">    if (of_driver_match_device(dev, drv))</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Then ACPI style match *&#x2F;</span><br><span class=\"line\">    if (acpi_driver_match_device(dev, drv))</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    driver &#x3D; to_i2c_driver(drv);</span><br><span class=\"line\">    &#x2F;* match on an id table if there is one *&#x2F;</span><br><span class=\"line\">    if (driver-&gt;id_table)</span><br><span class=\"line\">        return i2c_match_id(driver-&gt;id_table, client) !&#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<pre class=\"mermaid\">graph LR\n    i2c_device_match(i2c_device_match)\n    i2c_device_match-->of_driver_match_device(of_driver_match_device)\n    i2c_device_match-->acpi_driver_match_device(acpi_driver_match_device)\n    i2c_device_match--id_table-->i2c_match_id(i2c_match_id)</pre>\n\n\n\n\n<p>从i2c_device_match()函数的定义可以得出，i2c的match函数，优先选择设备树匹配（of_driver_match_device），如果设备树匹配成功，函数就返回；否则，会进行下一个。。。。。。，最后，如果定义了id_table，就会通过i2c_match_id()函数进行id_table匹配；如果三者全都匹配不成功，才算是匹配失败；</p>\n<p>从i2c_device_match函数来看，配置了设备树，就不需要id_table的定义了；但是实际上还是需要id_table的定义的，因为在后边的probe函数中需要判断id_table是否定义，如果定义了才能执行driver-&gt;probe函数；</p>\n<p>设备树的匹配过程如下：</p>\n<pre class=\"mermaid\">graph TB\n    of_driver_match_device(of_driver_match_device)-->\n    of_match_device(of_match_device)-->\n    of_match_node(of_match_node)-->\n    __of_match_node(__of_match_node)-->\n    __of_device_is_compatible(__of_device_is_compatible)\n    __of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n    __of_device_is_compatible--type-->of_compat_cmp\n    __of_device_is_compatible--name-->of_compat_cmp\n    of_compat_cmp-->\n    strcasecmp(strcasecmp)</pre>\n\n\n\n\n<p>__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；</p>\n<p>匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；</p>\n<h4 id=\"6-2-probe\"><a href=\"#6-2-probe\" class=\"headerlink\" title=\"6.2 probe\"></a>6.2 probe</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static int i2c_device_probe(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_client   *client &#x3D; i2c_verify_client(dev);</span><br><span class=\"line\">    struct i2c_driver   *driver;</span><br><span class=\"line\">    int status;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    driver &#x3D; to_i2c_driver(dev-&gt;driver);</span><br><span class=\"line\">    if (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class=\"line\">        return -ENODEV;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    status &#x3D; driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>i2c_device_probe()函数中，如果配置了设备树，i2c总线在match函数中，就不需要id_table的定义了；但是在probe函数中，还是需要id_table的定义的，因为在probe函数中需要判断id_table是否定义，如果定义了才能执行driver-&gt;probe函数；</p>\n<h4 id=\"6-3-I2C注册匹配过程\"><a href=\"#6-3-I2C注册匹配过程\" class=\"headerlink\" title=\"6.3 I2C注册匹配过程\"></a>6.3 I2C注册匹配过程</h4><p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E6%B3%A8%E5%86%8C%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png\" alt=\"I2C注册匹配过程\"></p>\n<h3 id=\"7-实例\"><a href=\"#7-实例\" class=\"headerlink\" title=\"7. 实例\"></a>7. 实例</h3><p>以添加eeprom驱动为例讲解I2C驱动在eeprom芯片中的使用；</p>\n<h4 id=\"7-1-添加设备\"><a href=\"#7-1-添加设备\" class=\"headerlink\" title=\"7.1 添加设备\"></a>7.1 添加设备</h4><h5 id=\"1）添加设备树\"><a href=\"#1）添加设备树\" class=\"headerlink\" title=\"1）添加设备树\"></a>1）添加设备树</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;vexpress-v2m.dtsi</span><br><span class=\"line\">\t\t\tv2m_i2c_dvi: i2c@16000 &#123;</span><br><span class=\"line\">                compatible &#x3D; &quot;arm,versatile-i2c&quot;;</span><br><span class=\"line\">                reg &#x3D; &lt;0x16000 0x1000&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">                #address-cells &#x3D; &lt;1&gt;;</span><br><span class=\"line\">                #size-cells &#x3D; &lt;0&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">                dvi-transmitter@39 &#123;</span><br><span class=\"line\">                    compatible &#x3D; &quot;sil,sii9022-tpi&quot;, &quot;sil,sii9022&quot;;</span><br><span class=\"line\">                    reg &#x3D; &lt;0x39&gt;;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                dvi-transmitter@60 &#123;</span><br><span class=\"line\">                    compatible &#x3D; &quot;sil,sii9022-cpi&quot;, &quot;sil,sii9022&quot;;</span><br><span class=\"line\">                    reg &#x3D; &lt;0x60&gt;;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                eeprom@51 &#123;</span><br><span class=\"line\">                    compatible &#x3D; &quot;mcy,mcy_eeprom&quot;;</span><br><span class=\"line\">                    reg &#x3D; &lt;0x51&gt;;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"2）i2c-new-device\"><a href=\"#2）i2c-new-device\" class=\"headerlink\" title=\"2）i2c_new_device\"></a>2）i2c_new_device</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mcy_eeprom_device.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_board_info</span> <span class=\"title\">eeprom_info</span> = &#123;</span> </span><br><span class=\"line\">    I2C_BOARD_INFO(<span class=\"string\">\"eeprom_device\"</span>, <span class=\"number\">0x51</span>),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_device_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    adap = i2c_get_adapter(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_get_adapter failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    client = i2c_new_device(adap, &amp;eeprom_info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!client) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_new_device failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_put_adapter(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eeprom_device_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    i2c_unregister_device(client);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(eeprom_device_init);</span><br><span class=\"line\">module_exit(eeprom_device_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"7-2-添加驱动\"><a href=\"#7-2-添加驱动\" class=\"headerlink\" title=\"7.2 添加驱动\"></a>7.2 添加驱动</h4><h5 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mcy_eeprom_driver.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/cdev.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;asm-generic/uaccess.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eeprom_data_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">16</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">eeprom_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eeprom_driver_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span> devnum;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> *<span class=\"title\">cdev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class</span> *<span class=\"title\">class</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">eeprom_driver_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\"><span class=\"keyword\">eeprom_driver_t</span> eeprom_driver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_open</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_release</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_read</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> reg[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    reg[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    reg[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, reg, <span class=\"number\">2</span>);</span><br><span class=\"line\">    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; eeprom_data.len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\"</span>, __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_to_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_write</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">18</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data[<span class=\"number\">2</span>], eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\">    len = eeprom_data.len + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, data[%d]: 0x%2x\\n\"</span>, __func__, i, data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, data, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">eeprom_driver_fops</span> = &#123;</span></span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = eeprom_driver_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = eeprom_driver_release,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span> = eeprom_driver_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span> = eeprom_driver_write,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_probe</span><span class=\"params\">(struct i2c_client *client, <span class=\"keyword\">const</span> struct i2c_device_id *id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    eeprom_driver.client = client;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = alloc_chrdev_region(&amp;eeprom_driver.devnum, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">\"eeprom_driver_chrdev\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, alloc_chrdev_region failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> chrdev_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    major = MAJOR(eeprom_driver.devnum);</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, alloc_chrdev_region, devnum: 0x%x, major: %d\\n\"</span>, __func__, eeprom_driver.devnum, major);</span><br><span class=\"line\"></span><br><span class=\"line\">    eeprom_driver.cdev = cdev_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!eeprom_driver.cdev) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, cdev_alloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> cdev_alloc_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cdev_init(eeprom_driver.cdev, &amp;eeprom_driver_fops);</span><br><span class=\"line\">    ret = cdev_add(eeprom_driver.cdev, eeprom_driver.devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, cdev_add failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> cdev_add_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /sys/class</span></span><br><span class=\"line\">    eeprom_driver<span class=\"class\">.<span class=\"keyword\">class</span> = <span class=\"title\">class_create</span>(<span class=\"title\">THIS_MODULE</span>, \"<span class=\"title\">eeprom_driver_class</span>\");</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(eeprom_driver.class)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, class_create failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        ret = PTR_ERR(eeprom_driver.class);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> class_create_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// /dev</span></span><br><span class=\"line\">    eeprom_driver.dev = device_create(eeprom_driver.class, <span class=\"literal\">NULL</span>, eeprom_driver.devnum, <span class=\"literal\">NULL</span>, <span class=\"string\">\"eeprom_driver\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(eeprom_driver.dev)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, device_create failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        ret = PTR_ERR(eeprom_driver.dev);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> device_create_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">device_create_err:</span><br><span class=\"line\">    class_destroy(eeprom_driver.class);</span><br><span class=\"line\">class_create_err:</span><br><span class=\"line\">    cdev_del(eeprom_driver.cdev);</span><br><span class=\"line\">cdev_add_err:</span><br><span class=\"line\">    kfree(eeprom_driver.cdev);</span><br><span class=\"line\">cdev_alloc_err:</span><br><span class=\"line\">    unregister_chrdev_region(eeprom_driver.devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\">chrdev_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_remove</span><span class=\"params\">(struct i2c_client *client)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_destroy(eeprom_driver.class, eeprom_driver.devnum);</span><br><span class=\"line\">    class_destroy(eeprom_driver.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_del(eeprom_driver.cdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    kfree(eeprom_driver.cdev);</span><br><span class=\"line\">    unregister_chrdev_region(eeprom_driver.devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_device_id</span> <span class=\"title\">eeprom_driver_id</span>[] = &#123;</span></span><br><span class=\"line\">    &#123;<span class=\"string\">\"mcy_eeprom\"</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> <span class=\"title\">eeprom_driver_table</span>[] = &#123;</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//.name = \"mcy_eeprom\",</span></span><br><span class=\"line\">        .compatible = <span class=\"string\">\"mcy,mcy_eeprom\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> <span class=\"title\">eeprom_i2c_driver</span>= &#123;</span></span><br><span class=\"line\">    .driver = &#123;</span><br><span class=\"line\">        .owner = THIS_MODULE,</span><br><span class=\"line\">        .name = <span class=\"string\">\"mcy_eeprom\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//.of_match_table = eeprom_driver_table,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    .probe = eeprom_driver_probe,</span><br><span class=\"line\">    .<span class=\"built_in\">remove</span> = eeprom_driver_remove,</span><br><span class=\"line\">    .id_table = eeprom_driver_id,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    i2c_add_driver(&amp;eeprom_i2c_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eeprom_driver_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    i2c_del_driver(&amp;eeprom_i2c_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(eeprom_driver_init);</span><br><span class=\"line\">module_exit(eeprom_driver_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"7-3-应用程序\"><a href=\"#7-3-应用程序\" class=\"headerlink\" title=\"7.3 应用程序\"></a>7.3 应用程序</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eeprom_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">16</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">eeprom_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_read</span><span class=\"params\">(<span class=\"keyword\">int</span> reg, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">16</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, len: %d over range!\\n\"</span>, __func__, len);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    eeprom_data.reg = reg;</span><br><span class=\"line\">    eeprom_data.len = len;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = <span class=\"built_in\">read</span>(fd, &amp;eeprom_data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, reg[%d]: %d, data: 0x%2x\\n\"</span>, __func__, i, reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_write</span><span class=\"params\">(<span class=\"keyword\">int</span> reg, <span class=\"keyword\">int</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">16</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, len: %d over range!\\n\"</span>, __func__, len);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    eeprom_data.reg = reg;</span><br><span class=\"line\">    eeprom_data.len = len;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">write</span>(fd, &amp;eeprom_data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, reg[%d]: %d, data: 0x%2x\\n\"</span>, __func__, i, reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">8</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/eeprom_driver\"</span>, O_RDWR | O_NONBLOCK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"open failed, fd: %d\\n\"</span>, fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = eeprom_write(reg, len, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"eeprom_write failed, ret: %d\\n\"</span>, ret);</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = eeprom_read(reg, len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"eeprom_read failed, ret: %d\\n\"</span>, ret);</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"7-4-Makefile\"><a href=\"#7-4-Makefile\" class=\"headerlink\" title=\"7.4 Makefile\"></a>7.4 Makefile</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifneq ($(KERNELRELEASE),)</span><br><span class=\"line\">    obj-m := mcy_eeprom_driver.o mcy_eeprom_device.o</span><br><span class=\"line\">else</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">generate the path</span></span><br><span class=\"line\">CURRENT_PATH:=$(shell pwd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">the absolute path</span></span><br><span class=\"line\">LINUX_KERNEL_PATH := /home/xiami/tool/linux-4.9.115</span><br><span class=\"line\"></span><br><span class=\"line\">CROSS_COMPILE := arm-linux-gnueabi-</span><br><span class=\"line\">CC := $(CROSS_COMPILE)gcc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">complie object</span></span><br><span class=\"line\">all:</span><br><span class=\"line\">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class=\"line\">clean:</span><br><span class=\"line\">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</span><br><span class=\"line\">    -rm main -rf</span><br><span class=\"line\">app:</span><br><span class=\"line\">    $(CC) main.c -o main</span><br><span class=\"line\">install:</span><br><span class=\"line\">    -chmod a+x *.ko</span><br><span class=\"line\">    -cp *.ko /home/xiami/qemu/nfs_root/mcy -rfp</span><br><span class=\"line\">    -cp main /home/xiami/qemu/nfs_root/mcy -rfp</span><br><span class=\"line\">    -chmod a+x /home/xiami/qemu/nfs_root/mcy/* main</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>I2C总线维护两个链表，一个是I2C驱动链表，一个是I2C设备链表，每当注册一个驱动（或设备），就会将其添加到I2C总线上相对应的I2C驱动链表（或I2C设备链表），然后遍历I2C总线的I2C设备（或I2C驱动）链表的所有设备（或驱动），通过I2C总线的匹配函数判断是否匹配，如果匹配，就调用驱动的probe函数，然后就可以在probe函数中注册字符设备，创建设备节点，实现设备操作集fops等，为应用调用提供接口；</p>\n<p>参考资料</p>\n<p><a href=\"https://blog.csdn.net/shichaog/article/details/41169981\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/shichaog/article/details/41169981</a></p>\n<p>《Linux设备驱动开发详解》</p>\n<p>《精通linux设备驱动程序开发》</p>\n<p><a href=\"#目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>Linux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；</p>","more":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>[TOC]</p>\n<p>Linux内核中的I2C驱动代码位于：drivers/i2c目录；</p>\n<h3 id=\"0-简述\"><a href=\"#0-简述\" class=\"headerlink\" title=\"0. 简述\"></a>0. 简述</h3><p>Linux内核中的I2C驱动代码位于：drivers/i2c目录；</p>\n<p>Linux设备模型由bus、device、driver组成；</p>\n<p>I2C驱动中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；</p>\n<blockquote>\n<p>I2C总线：维护I2C驱动和I2C设备两个链表，管理I2C驱动和I2C设备的匹配、删除等；</p>\n<p>I2C设备：具体硬件设备的一个抽象；</p>\n<p>I2C驱动：对应I2C设备的驱动程序；</p>\n<p>I2C适配器：用于I2C驱动和I2C设备间通信，是SOC上I2C控制器的一个抽象；</p>\n</blockquote>\n<p>I2C总线上有两个链表，分别是i2c_driver和i2c_client三链表；当任何一个driver或client注册时，I2C总线都会调用match函数，对client.name和driver.id_table.name进行遍历匹配；如果driver.id_table中所有的id都匹配不成功，说明client没有找到对应的driver；如果匹配成功，说明client和driver是配套的，那么I2C总线就会调用自己的probe函数，然后probe函数调用driver中提供的probe函数，driver中的probe函数会对设备进行硬件初始化和后续工作；</p>\n<p>i2c_add_adapter    // 注册adapter</p>\n<p>i2c_add_driver        // 注册driver</p>\n<p>i2c_new_device        // 注册client</p>\n<h3 id=\"1-I2C驱动框架\"><a href=\"#1-I2C驱动框架\" class=\"headerlink\" title=\"1. I2C驱动框架\"></a>1. I2C驱动框架</h3><p>Linux的I2C体系结构分为3个部分：</p>\n<blockquote>\n<p>I2C核心</p>\n<p>I2C总线驱动</p>\n<p>I2C设备驱动</p>\n</blockquote>\n<p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png\" alt=\"Linux的I2C子系统框架\"></p>\n<h4 id=\"1-1-I2C核心\"><a href=\"#1-1-I2C核心\" class=\"headerlink\" title=\"1.1 I2C核心\"></a>1.1 I2C核心</h4><p>I2C核心（i2c_core）维护了i2c_bus结构体，提供了：</p>\n<blockquote>\n<p>I2C总线驱动和设备驱动的注册、注销方法</p>\n<p>I2C的通信方法（i2c_algorithm）</p>\n<p>上层的与具体适配器无关的代码</p>\n<p>探测设备、检测设备地址的上层代码</p>\n</blockquote>\n<p>此部分代码由Linux内核提供；</p>\n<h4 id=\"1-2-I2C总线驱动\"><a href=\"#1-2-I2C总线驱动\" class=\"headerlink\" title=\"1.2 I2C总线驱动\"></a>1.2 I2C总线驱动</h4><p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器由CPU控制，或者直接集成在CPU内部；</p>\n<p>I2C总线驱动主要包含：</p>\n<blockquote>\n<p>I2C适配器数据结构i2c_adapter</p>\n<p>I2C适配器的控制算法数据结构i2c_algorithm</p>\n<p>控制I2C适配器产生通信信号的函数</p>\n</blockquote>\n<p>通过I2C总线驱动代码，可以控制I2C适配器，以主设备方式产生开始位、停止位、读写周期，以及以从设备方式读写、产生ACK等；</p>\n<p>此部分代码由具体的芯片厂商提供，如：高通、Samsung等；</p>\n<h4 id=\"1-3-I2C设备驱动\"><a href=\"#1-3-I2C设备驱动\" class=\"headerlink\" title=\"1.3 I2C设备驱动\"></a>1.3 I2C设备驱动</h4><p>I2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在I2C控制器（适配器）上，通过I2C适配器与CPU交换数据；</p>\n<p>I2C设备驱动主要包含i2c_client和i2c_driver结构体，实现和用户交互的文件操作集fops、cdev等；</p>\n<p>这两个数据结构中的成员函数，需要由驱动开发者根据具体设备去实现；</p>\n<h3 id=\"2-核心数据结构\"><a href=\"#2-核心数据结构\" class=\"headerlink\" title=\"2. 核心数据结构\"></a>2. 核心数据结构</h3><p>I2C驱动中最核心的4个数据结构：</p>\n<blockquote>\n<p>struct i2c_client</p>\n<p>struct i2c_driver</p>\n<p>struct i2c_adapter</p>\n<p>struct i2c_algorithm</p>\n</blockquote>\n<h4 id=\"2-1-设备层\"><a href=\"#2-1-设备层\" class=\"headerlink\" title=\"2.1 设备层\"></a>2.1 设备层</h4><h5 id=\"2-1-1-I2C设备（i2c-client）\"><a href=\"#2-1-1-I2C设备（i2c-client）\" class=\"headerlink\" title=\"2.1.1 I2C设备（i2c_client）\"></a>2.1.1 I2C设备（i2c_client）</h5><p>硬件上连接到I2C的SDA、SCL总线上的设备都是I2C设备，每一个I2C设备由一个i2c_client结构体进行描述；i2c_client对应真实的I2C物理设备，是具体硬件设备的抽象；一个i2c_client对象，表示连接到i2c总线的一个设备；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_client &#123;</span><br><span class=\"line\">    unsigned short flags;       &#x2F;* div., see below      *&#x2F;</span><br><span class=\"line\">    unsigned short addr;        &#x2F;* chip address - NOTE: 7bit    *&#x2F;</span><br><span class=\"line\">    char name[I2C_NAME_SIZE];</span><br><span class=\"line\">    struct i2c_adapter *adapter;    &#x2F;* the adapter we sit on    *&#x2F;</span><br><span class=\"line\">    struct device dev;      &#x2F;* the device structure     *&#x2F;</span><br><span class=\"line\">    int irq;            &#x2F;* irq issued by device     *&#x2F;</span><br><span class=\"line\">    struct list_head detected;</span><br><span class=\"line\">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class=\"line\">    i2c_slave_cb_t slave_cb;    &#x2F;* callback for slave mode  *&#x2F;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>unsigned short addr：表示7bit的设备芯片地址，地址被保存在低7bits</p>\n<p>struct i2c_adapter *adapter：表示这个i2c_client从属的i2c_adapter对象，驱动中使用这个指针操作发送</p>\n<p>struct device dev：表示device信息</p>\n<p>struct list_head detected：设备链表，将所有的i2c_client组成链表</p>\n</blockquote>\n<p>i2c_client结构不是驱动开发者创建的，而是通过以下方式自动创建：</p>\n<blockquote>\n<p>分配、设置、注册i2c_board_info</p>\n<p>获取i2c_adapter，调用i2c_new_device</p>\n<p>通过设备树（DeviceTree）创建</p>\n</blockquote>\n<h5 id=\"2-1-2-I2C驱动（i2c-driver）\"><a href=\"#2-1-2-I2C驱动（i2c-driver）\" class=\"headerlink\" title=\"2.1.2 I2C驱动（i2c_driver）\"></a>2.1.2 I2C驱动（i2c_driver）</h5><p>i2c_driver结构用于管理I2C的驱动和I2C设备的匹配探测，实现与用户层交互的文件操作集fops、cdev等；每一个I2C设备都对应一个I2C驱动，因此，每一个i2c_client结构，都对应一个i2c_driver结构，通过指针相连；编写一个i2c驱动的本质，就是要构造一个i2c_driver对象，并将其注册到内核；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_driver &#123;</span><br><span class=\"line\">    unsigned int class;</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Standard driver model interfaces *&#x2F;</span><br><span class=\"line\">    int (*probe)(struct i2c_client *, const struct i2c_device_id *); </span><br><span class=\"line\">    int (*remove)(struct i2c_client *); </span><br><span class=\"line\"></span><br><span class=\"line\">    void (*shutdown)(struct i2c_client *); </span><br><span class=\"line\">    void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol,</span><br><span class=\"line\">              unsigned int data);</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br><span class=\"line\"></span><br><span class=\"line\">    struct device_driver driver;</span><br><span class=\"line\">    const struct i2c_device_id *id_table;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Device detection callback for automatic device creation *&#x2F;</span><br><span class=\"line\">    int (*detect)(struct i2c_client *, struct i2c_board_info *); </span><br><span class=\"line\">    const unsigned short *address_list;</span><br><span class=\"line\">    struct list_head clients;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>probe：探测函数，匹配成功后执行，会将匹配到的i2c_client对象传入，完成申请资源、初始化、提供接口等操作</p>\n<p>remove：移除函数，设备消失时或驱动模块被卸载时会被调用，和probe操作相反</p>\n<p>struct device_driver driver：表明是一个设备的驱动类，用于匹配设备树的of_match_table域</p>\n<p>const struct i2c_device_id *id_table：用于使用平台文件或模块编写设备信息时进行匹配</p>\n<p>struct list_head clients：用于将所有i2c_driver联系到一起的链表</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-1-3-总线和设备关系\"><a href=\"#2-1-3-总线和设备关系\" class=\"headerlink\" title=\"2.1.3 总线和设备关系\"></a>2.1.3 总线和设备关系</h5><p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"I2C设备和驱动的关系\"></p>\n<h4 id=\"2-2-总线层\"><a href=\"#2-2-总线层\" class=\"headerlink\" title=\"2.2 总线层\"></a>2.2 总线层</h4><h5 id=\"2-2-1-I2C适配器（i2c-adapter）\"><a href=\"#2-2-1-I2C适配器（i2c-adapter）\" class=\"headerlink\" title=\"2.2.1 I2C适配器（i2c_adapter）\"></a>2.2.1 I2C适配器（i2c_adapter）</h5><p>I2C适配器，即SOC中的I2C控制器，对应struct i2c_adapter结构体；Linux中用i2c_adapter来表示一个I2C控制器，一个i2c_adapter结构体对应的就是SOC上的I2C控制器；所有的设备驱动都需要经过i2c_adapter对象的处理才能和物理设备通信；通过i2c_core层将I2C设备与i2c adapter关联起来，用来完成i2c总线控制器相关的数据通信，此结构体在芯片厂商提供的代码中维护；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_adapter &#123;</span><br><span class=\"line\">    struct module *owner;</span><br><span class=\"line\">    unsigned int class;       &#x2F;* classes to allow probing for *&#x2F;</span><br><span class=\"line\">    const struct i2c_algorithm *algo; &#x2F;* the algorithm to access the bus *&#x2F;</span><br><span class=\"line\">    void *algo_data;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* data fields that are valid for all devices   *&#x2F;</span><br><span class=\"line\">    const struct i2c_lock_operations *lock_ops;</span><br><span class=\"line\">    struct rt_mutex bus_lock;</span><br><span class=\"line\">    struct rt_mutex mux_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    int timeout;            &#x2F;* in jiffies *&#x2F;</span><br><span class=\"line\">    int retries;</span><br><span class=\"line\">    struct device dev;      &#x2F;* the adapter device *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">    int nr;</span><br><span class=\"line\">    char name[48];</span><br><span class=\"line\">    struct completion dev_released;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct mutex userspace_clients_lock;</span><br><span class=\"line\">    struct list_head userspace_clients;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct i2c_bus_recovery_info *bus_recovery_info;</span><br><span class=\"line\">    const struct i2c_adapter_quirks *quirks;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-2-2-I2C总线算法（i2c-algorithm）\"><a href=\"#2-2-2-I2C总线算法（i2c-algorithm）\" class=\"headerlink\" title=\"2.2.2 I2C总线算法（i2c_algorithm）\"></a>2.2.2 I2C总线算法（i2c_algorithm）</h5><p>I2C总线数据通信算法，通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；</p>\n<p>struct i2c_algorithm数据结构，是i2c控制器数据通信需要的控制算法，对应的是I2C的时序；通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；用来描述适配器和设备之间的通信方法，由芯片厂商实现；</p>\n<p>最重要的成员是master_xfer()函数，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_algorithm &#123;</span><br><span class=\"line\">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class=\"line\">               int num);</span><br><span class=\"line\">    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class=\"line\">               unsigned short flags, char read_write,</span><br><span class=\"line\">               u8 command, int size, union i2c_smbus_data *data);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class=\"line\">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class=\"line\"></span><br><span class=\"line\">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class=\"line\">    int (*reg_slave)(struct i2c_client *client);</span><br><span class=\"line\">    int (*unreg_slave)(struct i2c_client *client);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>master_xfer：最重要的接口，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；该函数返回成功发送的消息数，错误返回负数；</p>\n</blockquote>\n<p>device_driver</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;device.h</span><br><span class=\"line\">struct device_driver &#123;</span><br><span class=\"line\">    const char      *name;</span><br><span class=\"line\">    struct bus_type     *bus;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct module       *owner;</span><br><span class=\"line\">    const char      *mod_name;  &#x2F;* used for built-in modules *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">    bool suppress_bind_attrs;   &#x2F;* disables bind&#x2F;unbind via sysfs *&#x2F;</span><br><span class=\"line\">    enum probe_type probe_type;</span><br><span class=\"line\"></span><br><span class=\"line\">    const struct of_device_id   *of_match_table;</span><br><span class=\"line\">    const struct acpi_device_id *acpi_match_table;</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*probe) (struct device *dev);</span><br><span class=\"line\">    int (*remove) (struct device *dev);</span><br><span class=\"line\">    void (*shutdown) (struct device *dev);</span><br><span class=\"line\">    int (*suspend) (struct device *dev, pm_message_t state);</span><br><span class=\"line\">    int (*resume) (struct device *dev);</span><br><span class=\"line\">    const struct attribute_group **groups;</span><br><span class=\"line\"></span><br><span class=\"line\">    const struct dev_pm_ops *pm; </span><br><span class=\"line\"></span><br><span class=\"line\">    struct driver_private *p;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h5 id=\"2-2-3-I2C总线类型\"><a href=\"#2-2-3-I2C总线类型\" class=\"headerlink\" title=\"2.2.3 I2C总线类型\"></a>2.2.3 I2C总线类型</h5><p>I2C总线对应着/bus/目录下的一个总线；维护I2C设备和I2C驱动两个链表，管理I2C设备和I2C的匹配和删除；是SOC上I2C控制器的抽象；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;device.h</span><br><span class=\"line\">struct bus_type &#123;</span><br><span class=\"line\">    const char      *name;</span><br><span class=\"line\">    const char      *dev_name;</span><br><span class=\"line\">    struct device       *dev_root;</span><br><span class=\"line\">    struct device_attribute *dev_attrs; &#x2F;* use dev_groups instead *&#x2F;</span><br><span class=\"line\">    const struct attribute_group **bus_groups;</span><br><span class=\"line\">    const struct attribute_group **dev_groups;</span><br><span class=\"line\">    const struct attribute_group **drv_groups;</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class=\"line\">    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class=\"line\">    int (*probe)(struct device *dev);</span><br><span class=\"line\">    int (*remove)(struct device *dev);</span><br><span class=\"line\">    void (*shutdown)(struct device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*online)(struct device *dev);</span><br><span class=\"line\">    int (*offline)(struct device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class=\"line\">    int (*resume)(struct device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    const struct dev_pm_ops *pm; </span><br><span class=\"line\"></span><br><span class=\"line\">    const struct iommu_ops *iommu_ops;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct subsys_private *p;</span><br><span class=\"line\">    struct lock_class_key lock_key;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class=\"line\">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class=\"line\">    .match      &#x3D; i2c_device_match,</span><br><span class=\"line\">    .probe      &#x3D; i2c_device_probe,</span><br><span class=\"line\">    .remove     &#x3D; i2c_device_remove,</span><br><span class=\"line\">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>I2C总线bus_type结构体管理着i2c设备和i2c驱动的匹配、删除操作，i2c会调用i2c_device_match函数对比i2c设备和i2c驱动是否匹配，如果匹配就调用i2c_device_probe函数，进而调用i2c驱动的probe函数；</p>\n<h4 id=\"2-3-总线层和设备层关系\"><a href=\"#2-3-总线层和设备层关系\" class=\"headerlink\" title=\"2.3 总线层和设备层关系\"></a>2.3 总线层和设备层关系</h4><p>在设备层，i2c_client通过adapter指针，指向总线层的i2c_adapter，和总线层存在关系；</p>\n<p>在总线层，i2c_adapter通过algo指针，指向i2c_algorithm，进一步调用i2c_algorithm中的算法，如：master_xfer()，进行实际的数据发送和接收；</p>\n<p>总线层</p>\n<p>struct i2c_adapter       I2C适配器（主机CPU的I2C控制器）</p>\n<p>struct i2c_algorithm       I2C算法（I2C的收、发时序控制）</p>\n<p>设备层</p>\n<p>struct i2c_client       I2C（从机）设备信息</p>\n<p>struct i2c_driver       I2C（从机）设备驱动信息</p>\n<p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E6%80%BB%E7%BA%BF%E5%B1%82%E5%92%8C%E8%AE%BE%E5%A4%87%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"I2C总线层和设备层的关系\"></p>\n<h4 id=\"2-4-数据结构间的关系\"><a href=\"#2-4-数据结构间的关系\" class=\"headerlink\" title=\"2.4 数据结构间的关系\"></a>2.4 数据结构间的关系</h4><p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"I2C数据结构间的关系\"></p>\n<h3 id=\"3-重要的操作函数\"><a href=\"#3-重要的操作函数\" class=\"headerlink\" title=\"3. 重要的操作函数\"></a>3. 重要的操作函数</h3><h4 id=\"3-1-I2C子系统初始化\"><a href=\"#3-1-I2C子系统初始化\" class=\"headerlink\" title=\"3.1 I2C子系统初始化\"></a>3.1 I2C子系统初始化</h4><h5 id=\"3-1-1-I2C总线初始化\"><a href=\"#3-1-1-I2C总线初始化\" class=\"headerlink\" title=\"3.1.1 I2C总线初始化\"></a>3.1.1 I2C总线初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">postcore_initcall(i2c_init);</span><br><span class=\"line\">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;init.h</span><br><span class=\"line\">#define postcore_initcall(fn)       __define_initcall(fn, 2)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;init.h</span><br><span class=\"line\">#define __define_initcall(fn, id) \\</span><br><span class=\"line\">    static initcall_t __initcall_##fn##id __used \\</span><br><span class=\"line\">    __attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) &#x3D; fn;</span><br></pre></td></tr></table></figure>\n\n<p>postcore_initcall(i2c_init)操作，会在编译内核时，将函数指针变量__initcall_i2c_init放到名称为initcall2.init的section中；即将i2c_init()函数的首地址放到名称为initcall2.init的section中；</p>\n<p>Linux设备启动时，会在do_basic_setup()函数中，通过driver_init()和do_initcalls()函数，调用到i2c_init()函数，对I2C总线初始化；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static int __init i2c_init(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    retval &#x3D; bus_register(&amp;i2c_bus_type);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    retval &#x3D; i2c_add_driver(&amp;dummy_driver);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过bus_register()函数，在系统中注册一个新的总线i2c_bus_type，name: i2c；适配器设备、I2C设备、I2C设备驱动程序都会连接到这条总线上；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class=\"line\">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class=\"line\">    .match      &#x3D; i2c_device_match,</span><br><span class=\"line\">    .probe      &#x3D; i2c_device_probe,</span><br><span class=\"line\">    .remove     &#x3D; i2c_device_remove,</span><br><span class=\"line\">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过i2c_add_driver()函数，向I2C总线注册一个空的I2C设备驱动程序；可以不用关心；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_init1(i2c_init)-->bus_register1(bus_register)\n    subgraph i2c_init\n        bus_register1(bus_register)-->\n        class_compat_register(class_compat_register)-->\n        i2c_add_driver(i2c_add_driver)\n    end</pre>\n\n\n\n<p>注册过程中发生异常错误时，需要使用对应的函数进行反向操作：</p>\n<pre class=\"mermaid\">graph TB\n    class_compat_register(class_compat_register)\n    class_compat_unregister(class_compat_unregister)</pre>\n\n\n\n<pre class=\"mermaid\">graph TB\n    bus_register(bus_register) \n    bus_unregister(bus_unregister)</pre>\n\n\n\n<h5 id=\"3-1-2-I2C总线退出\"><a href=\"#3-1-2-I2C总线退出\" class=\"headerlink\" title=\"3.1.2 I2C总线退出\"></a>3.1.2 I2C总线退出</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static void __exit i2c_exit(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (IS_ENABLED(CONFIG_ACPI))</span><br><span class=\"line\">        WARN_ON(acpi_reconfig_notifier_unregister(&amp;i2c_acpi_notifier));</span><br><span class=\"line\">    if (IS_ENABLED(CONFIG_OF_DYNAMIC))</span><br><span class=\"line\">        WARN_ON(of_reconfig_notifier_unregister(&amp;i2c_of_notifier));</span><br><span class=\"line\">    i2c_del_driver(&amp;dummy_driver);</span><br><span class=\"line\">#ifdef CONFIG_I2C_COMPAT</span><br><span class=\"line\">    class_compat_unregister(i2c_adapter_compat_class);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    bus_unregister(&amp;i2c_bus_type);</span><br><span class=\"line\">    tracepoint_synchronize_unregister();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>i2c_del_driver()函数，用来从I2C总线注销设备驱动程序；和i2c_add_driver()函数功能相反；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_add_driver(i2c_add_driver) \n    i2c_del_driver(i2c_del_driver)</pre>\n\n\n\n<h4 id=\"3-2-适配器驱动\"><a href=\"#3-2-适配器驱动\" class=\"headerlink\" title=\"3.2 适配器驱动\"></a>3.2 适配器驱动</h4><p>适配器驱动程序是I2C设备驱动程序需要实现的主要驱动程序，需要根据具体的适配器硬件编写；</p>\n<p>使用内核提供的框架函数向I2C子系统中添加一个新的适配器；i2c_adapter结构体为描述各种I2C适配器提供了通用的封装，但是i2c_adapter结构体只是所有适配器的共有属性，并不能代表所有类型的适配器；</p>\n<p>添加新的适配器的过程：</p>\n<blockquote>\n<p>分配一个I2C适配器，并初始化一个i2c_adapter结构体，及相应的变量</p>\n<p>使用i2c_add_adapter()函数向I2C子系统添加适配器结构体i2c_adapter</p>\n</blockquote>\n<h5 id=\"3-2-1-添加适配器驱动\"><a href=\"#3-2-1-添加适配器驱动\" class=\"headerlink\" title=\"3.2.1 添加适配器驱动\"></a>3.2.1 添加适配器驱动</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_add_adapter</span><span class=\"params\">(struct i2c_adapter *adapter)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span> = &amp;<span class=\"title\">adapter</span>-&gt;<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dev-&gt;of_node) &#123;</span><br><span class=\"line\">        id = of_alias_get_id(dev-&gt;of_node, <span class=\"string\">\"i2c\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id &gt;= <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">            adapter-&gt;nr = id;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class=\"line\">               __i2c_first_dynamic_bus_num, <span class=\"number\">0</span>, GFP_KERNEL);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (WARN(id &lt; <span class=\"number\">0</span>, <span class=\"string\">\"couldn't get idr\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    adapter-&gt;nr = id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i2c_register_adapter(adapter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_add_adapter);</span><br></pre></td></tr></table></figure>\n\n<p>通过i2c_register_adapter()函数，向内核注册一个适配器设备adapter；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_add_adapter(i2c_add_adapter)\n    -->i2c_register_adapter(i2c_register_adapter)</pre>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/i2c/i2c-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">i2c_register_adapter</span><span class=\"params\">(struct i2c_adapter *adap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = -EINVAL;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Sanity checks */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (WARN(!adap-&gt;name[<span class=\"number\">0</span>], <span class=\"string\">\"i2c adapter has no name\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap-&gt;algo) &#123;</span><br><span class=\"line\">        pr_err(<span class=\"string\">\"adapter '%s': no algo supplied!\\n\"</span>, adap-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap-&gt;lock_ops)</span><br><span class=\"line\">        adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/* Set default timeout to 1 second if not already set */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (adap-&gt;timeout == <span class=\"number\">0</span>)</span><br><span class=\"line\">        adap-&gt;timeout = HZ;</span><br><span class=\"line\"></span><br><span class=\"line\">    dev_set_name(&amp;adap-&gt;dev, <span class=\"string\">\"i2c-%d\"</span>, adap-&gt;nr);</span><br><span class=\"line\">    adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class=\"line\">    adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class=\"line\">    res = device_register(&amp;adap-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span><br><span class=\"line\">    pm_suspend_ignore_children(&amp;adap-&gt;dev, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    pm_runtime_enable(&amp;adap-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class=\"line\">    res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class=\"line\">                       adap-&gt;dev.parent);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_init_recovery(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* create pre-declared device nodes */</span></span><br><span class=\"line\">    of_i2c_register_devices(adap);</span><br><span class=\"line\">    i2c_acpi_register_devices(adap);</span><br><span class=\"line\">    i2c_acpi_install_space_handler(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class=\"line\">        i2c_scan_static_board_info(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Notify drivers */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    bus_for_each_drv(&amp;i2c_bus_type, <span class=\"literal\">NULL</span>, adap, __process_new_adapter);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">out_list:</span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-2-2-注销适配器驱动\"><a href=\"#3-2-2-注销适配器驱动\" class=\"headerlink\" title=\"3.2.2 注销适配器驱动\"></a>3.2.2 注销适配器驱动</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// // drivers/i2c/i2c-core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">i2c_del_adapter</span><span class=\"params\">(struct i2c_adapter *adap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">found</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>, *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* First make sure that this adapter was ever added */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    found = idr_find(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found != adap) &#123;</span><br><span class=\"line\">        pr_debug(<span class=\"string\">\"attempting to delete unregistered adapter [%s]\\n\"</span>, adap-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_acpi_remove_space_handler(adap);</span><br><span class=\"line\">    <span class=\"comment\">/* Tell drivers about this removal */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    bus_for_each_drv(&amp;i2c_bus_type, <span class=\"literal\">NULL</span>, adap,</span><br><span class=\"line\">                   __process_removed_adapter);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Remove devices instantiated from sysfs */</span></span><br><span class=\"line\">    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class=\"line\">              i2c_adapter_depth(adap));</span><br><span class=\"line\">    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class=\"line\">                 detected) &#123;</span><br><span class=\"line\">        list_del(&amp;client-&gt;detected);</span><br><span class=\"line\">        i2c_unregister_device(client);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class=\"line\">    device_for_each_child(&amp;adap-&gt;dev, <span class=\"literal\">NULL</span>, __unregister_client);</span><br><span class=\"line\">    device_for_each_child(&amp;adap-&gt;dev, <span class=\"literal\">NULL</span>, __unregister_dummy);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class=\"line\">    class_compat_remove_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class=\"line\">                 adap-&gt;dev.parent);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    pm_runtime_disable(&amp;adap-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    init_completion(&amp;adap-&gt;dev_released);</span><br><span class=\"line\">    device_unregister(&amp;adap-&gt;dev);</span><br><span class=\"line\">    wait_for_completion(&amp;adap-&gt;dev_released);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* free bus id */</span></span><br><span class=\"line\">    mutex_lock(&amp;core_lock);</span><br><span class=\"line\">    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class=\"line\">    mutex_unlock(&amp;core_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Clear the device structure in case this adapter is ever going to be</span></span><br><span class=\"line\"><span class=\"comment\">       added again */</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;adap-&gt;dev, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(adap-&gt;dev));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_adapter);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3-3-注册I2C驱动\"><a href=\"#3-3-注册I2C驱动\" class=\"headerlink\" title=\"3.3 注册I2C驱动\"></a>3.3 注册I2C驱动</h4><p>注册I2C驱动需要完成的操作：</p>\n<blockquote>\n<p>将I2C驱动添加到I2C总线的驱动链表中</p>\n<p>遍历I2C总线上的I2C设备链表，根据i2c_device_match函数进行匹配，如果匹配就调用i2c_device_probe函数</p>\n<p>i2c_device_probe函数会调用I2C驱动的probe函数</p>\n</blockquote>\n<h5 id=\"3-3-1-注册I2C驱动\"><a href=\"#3-3-1-注册I2C驱动\" class=\"headerlink\" title=\"3.3.1 注册I2C驱动\"></a>3.3.1 注册I2C驱动</h5><p>在I2C驱动程序中，通过i2c_add_driver()函数，来注册驱动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">#define i2c_add_driver(driver) \\</span><br><span class=\"line\">    i2c_register_driver(THIS_MODULE, driver)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    &#x2F;* add the driver to the list of i2c drivers in the driver core *&#x2F;</span><br><span class=\"line\">    driver-&gt;driver.owner &#x3D; owner;</span><br><span class=\"line\">    driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;\t\t&#x2F;&#x2F; 绑定I2C总线 </span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class=\"line\"></span><br><span class=\"line\">    res &#x3D; driver_register(&amp;driver-&gt;driver);\t\t&#x2F;&#x2F; 向I2C总线注册驱动</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    i2c_for_each_dev(driver, __process_new_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_register_driver);</span><br></pre></td></tr></table></figure>\n\n\n<p>在i2c_add_driver()函数中，做了三件事：</p>\n<blockquote>\n<p>绑定总线</p>\n<p>向总线注册驱动 —- 重点</p>\n<p>遍历总线的设备，调用__process_new_driver</p>\n</blockquote>\n<p>driver_register</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int driver_register(struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    struct device_driver *other;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    other &#x3D; driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    ret &#x3D; bus_add_driver(drv);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; driver_add_groups(drv, drv-&gt;groups);</span><br><span class=\"line\">    if (ret) &#123;</span><br><span class=\"line\">        bus_remove_driver(drv);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class=\"line\"></span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(driver_register);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>driver_find()函数，在I2C总线中，找到name对应的I2C device_driver；</p>\n<p>bus_add_driver()函数，将驱动添加到总线上；</p>\n<pre class=\"mermaid\">graph TB\n    i2c_add_driver(i2c_add_driver)-->\n    i2c_register_driver(i2c_register_driver)-->\n    driver_register(driver_register)-->\n    bus_add_driver(bus_add_driver)</pre>\n\n\n\n\n\n\n\n<h5 id=\"3-3-2-注销I2C驱动\"><a href=\"#3-3-2-注销I2C驱动\" class=\"headerlink\" title=\"3.3.2 注销I2C驱动\"></a>3.3.2 注销I2C驱动</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">void i2c_del_driver(struct i2c_driver *driver)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    i2c_for_each_dev(driver, __process_removed_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    driver_unregister(&amp;driver-&gt;driver);</span><br><span class=\"line\">    pr_debug(&quot;driver [%s] unregistered\\n&quot;, driver-&gt;driver.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_driver);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-4-注册I2C设备\"><a href=\"#3-4-注册I2C设备\" class=\"headerlink\" title=\"3.4 注册I2C设备\"></a>3.4 注册I2C设备</h4><h5 id=\"3-4-1-注册I2C设备\"><a href=\"#3-4-1-注册I2C设备\" class=\"headerlink\" title=\"3.4.1 注册I2C设备\"></a>3.4.1 注册I2C设备</h5><p>I2C通过i2c_new_device()函数，来添加一个I2C设备；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">struct i2c_client *</span><br><span class=\"line\">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_client   *client;</span><br><span class=\"line\">    int         status;</span><br><span class=\"line\"></span><br><span class=\"line\">    client &#x3D; kzalloc(sizeof *client, GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;adapter &#x3D; adap;\t\t&#x2F;&#x2F; 指定设备的适配器</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;dev.platform_data &#x3D; info-&gt;platform_data;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (info-&gt;archdata)</span><br><span class=\"line\">        client-&gt;dev.archdata &#x3D; *info-&gt;archdata;</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;flags &#x3D; info-&gt;flags;</span><br><span class=\"line\">    client-&gt;addr &#x3D; info-&gt;addr;</span><br><span class=\"line\">    client-&gt;irq &#x3D; info-&gt;irq;</span><br><span class=\"line\"></span><br><span class=\"line\">    strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));</span><br><span class=\"line\"></span><br><span class=\"line\">    status &#x3D; i2c_check_addr_validity(client-&gt;addr, client-&gt;flags);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;* Check for address business *&#x2F;</span><br><span class=\"line\">    status &#x3D; i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));</span><br><span class=\"line\"></span><br><span class=\"line\">    client-&gt;dev.parent &#x3D; &amp;client-&gt;adapter-&gt;dev;</span><br><span class=\"line\">    client-&gt;dev.bus &#x3D; &amp;i2c_bus_type;\t&#x2F;&#x2F; 绑定I2C总线</span><br><span class=\"line\">    client-&gt;dev.type &#x3D; &amp;i2c_client_type;</span><br><span class=\"line\">    client-&gt;dev.of_node &#x3D; info-&gt;of_node;</span><br><span class=\"line\">    client-&gt;dev.fwnode &#x3D; info-&gt;fwnode;</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_dev_set_name(adap, client);</span><br><span class=\"line\">    status &#x3D; device_register(&amp;client-&gt;dev);\t\t&#x2F;&#x2F; 向总线注册设备</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    return client;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_new_device);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; include&#x2F;linux&#x2F;i2c.h</span><br><span class=\"line\">struct i2c_board_info &#123;</span><br><span class=\"line\">    char        type[I2C_NAME_SIZE];\t&#x2F;&#x2F; 设备名称，用于与驱动匹配</span><br><span class=\"line\">    unsigned short  flags;</span><br><span class=\"line\">    unsigned short  addr;\t&#x2F;&#x2F; 设备地址</span><br><span class=\"line\">    void        *platform_data;</span><br><span class=\"line\">    struct dev_archdata *archdata;</span><br><span class=\"line\">    struct device_node *of_node;</span><br><span class=\"line\">    struct fwnode_handle *fwnode;</span><br><span class=\"line\">    int     irq;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>struct i2c_board_info结构体描述了设备的硬件信息；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;core.c</span><br><span class=\"line\">int device_register(struct device *dev)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    device_initialize(dev);</span><br><span class=\"line\">    return device_add(dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>\n\n\n\n<pre class=\"mermaid\">graph TB\n    i2c_new_device(i2c_new_device)-->\n    device_register(device_register)-->\n    device_initialize(device_initialize)\n    device_register-->device_add(device_add)</pre>\n\n\n\n<p>device_initialize()函数用来初始化I2C设备的device结构体；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;core.c</span><br><span class=\"line\">void device_initialize(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dev-&gt;kobj.kset &#x3D; devices_kset;</span><br><span class=\"line\">    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class=\"line\">    mutex_init(&amp;dev-&gt;mutex);</span><br><span class=\"line\">    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class=\"line\">    spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class=\"line\">    device_pm_init(dev);</span><br><span class=\"line\">    set_dev_node(dev, -1);</span><br><span class=\"line\">#ifdef CONFIG_GENERIC_MSI_IRQ</span><br><span class=\"line\">    INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_initialize);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int device_add(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct device *parent &#x3D; NULL;</span><br><span class=\"line\">    struct kobject *kobj;</span><br><span class=\"line\">    struct class_interface *class_intf;</span><br><span class=\"line\">    int error &#x3D; -EINVAL;</span><br><span class=\"line\">    struct kobject *glue_dir &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    dev &#x3D; get_device(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!dev-&gt;p) &#123;</span><br><span class=\"line\">        error &#x3D; device_private_init(dev);</span><br><span class=\"line\">        if (error)</span><br><span class=\"line\">            goto done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;init_name) &#123;</span><br><span class=\"line\">        dev_set_name(dev, &quot;%s&quot;, dev-&gt;init_name);</span><br><span class=\"line\">        dev-&gt;init_name &#x3D; NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class=\"line\">        dev_set_name(dev, &quot;%s%u&quot;, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent &#x3D; get_device(dev-&gt;parent);</span><br><span class=\"line\">    kobj &#x3D; get_device_parent(dev, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kobj)</span><br><span class=\"line\">        dev-&gt;kobj.parent &#x3D; kobj;</span><br><span class=\"line\">    if (parent &amp;&amp; (dev_to_node(dev) &#x3D;&#x3D; NUMA_NO_NODE))</span><br><span class=\"line\">        set_dev_node(dev, dev_to_node(parent));</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (platform_notify)</span><br><span class=\"line\">        platform_notify(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; device_add_class_symlinks(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; device_add_attrs(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; bus_add_device(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; dpm_sysfs_add(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    device_pm_add(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MAJOR(dev-&gt;devt)) &#123;</span><br><span class=\"line\">        error &#x3D; device_create_file(dev, &amp;dev_attr_dev);</span><br><span class=\"line\"></span><br><span class=\"line\">        error &#x3D; device_create_sys_dev_entry(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">        devtmpfs_create_node(dev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;bus)</span><br><span class=\"line\">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class=\"line\">                         BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class=\"line\">    bus_probe_device(dev);</span><br><span class=\"line\">    if (parent)</span><br><span class=\"line\">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class=\"line\">                   &amp;parent-&gt;p-&gt;klist_children);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;class) &#123;</span><br><span class=\"line\">        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class=\"line\">        klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class=\"line\">                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class=\"line\"></span><br><span class=\"line\">        list_for_each_entry(class_intf,</span><br><span class=\"line\">                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class=\"line\">            if (class_intf-&gt;add_dev)</span><br><span class=\"line\">                class_intf-&gt;add_dev(dev, class_intf);</span><br><span class=\"line\">        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(device_add);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>device_addbus_add_devicebus_probe_device</p>\n<h5 id=\"3-4-2-注销I2C设备\"><a href=\"#3-4-2-注销I2C设备\" class=\"headerlink\" title=\"3.4.2 注销I2C设备\"></a>3.4.2 注销I2C设备</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">void i2c_unregister_device(struct i2c_client *client)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (client-&gt;dev.of_node)</span><br><span class=\"line\">        of_node_clear_flag(client-&gt;dev.of_node, OF_POPULATED);</span><br><span class=\"line\">    if (ACPI_COMPANION(&amp;client-&gt;dev))</span><br><span class=\"line\">        acpi_device_clear_enumerated(ACPI_COMPANION(&amp;client-&gt;dev));</span><br><span class=\"line\">    device_unregister(&amp;client-&gt;dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_unregister_device);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    i2c_new_device(i2c_new_device)\n    i2c_unregister_device(i2c_unregister_device)</pre>\n\n\n\n\n\n<h4 id=\"3-5-适配器和设备通信\"><a href=\"#3-5-适配器和设备通信\" class=\"headerlink\" title=\"3.5 适配器和设备通信\"></a>3.5 适配器和设备通信</h4><p>I2C总线通信方式是对特定的I2C适配器使用i2c_transfer()函数，调用i2c_algothrim的master_xfer()方法实现i2c_msg消息的传输；不同的适配器，对应的master_xfer()方法由控制器的硬件决定，由芯片厂商提供；</p>\n<h5 id=\"3-5-1-i2c-transfer\"><a href=\"#3-5-1-i2c-transfer\" class=\"headerlink\" title=\"3.5.1 i2c_transfer\"></a>3.5.1 i2c_transfer</h5><p>在I2C设备和I2C驱动匹配之后，驱动程序和设备的通讯，通过i2c_transfer()函数来给设备发送信息；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    if (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">        ret &#x3D; __i2c_transfer(adap, msgs, num);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>\n\n<p>i2c_transfer()函数是i2c核心提供给设备驱动的发送方法，该函数发送的数据需要被打包成i2c_msg结构，该函数最终会回调i2c_adapter-&gt;i2c_algorithm-&gt;master_xfer()函数，将i2c_msg对象发送到i2c的物理控制器；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned long orig_jiffies;</span><br><span class=\"line\">    int ret, try;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (adap-&gt;quirks &amp;&amp; i2c_check_for_quirks(adap, msgs, num))</span><br><span class=\"line\">        return -EOPNOTSUPP;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (static_key_false(&amp;i2c_trace_msg)) &#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">        for (i &#x3D; 0; i &lt; num; i++)</span><br><span class=\"line\">            if (msgs[i].flags &amp; I2C_M_RD)</span><br><span class=\"line\">                trace_i2c_read(adap, &amp;msgs[i], i);</span><br><span class=\"line\">            else</span><br><span class=\"line\">                trace_i2c_write(adap, &amp;msgs[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    orig_jiffies &#x3D; jiffies;</span><br><span class=\"line\">    for (ret &#x3D; 0, try &#x3D; 0; try &lt;&#x3D; adap-&gt;retries; try++) &#123;</span><br><span class=\"line\">        ret &#x3D; adap-&gt;algo-&gt;master_xfer(adap, msgs, num);\t\t&#x2F;&#x2F; 发送、接收信息操作</span><br><span class=\"line\">        if (ret !&#x3D; -EAGAIN)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        if (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(__i2c_transfer);</span><br></pre></td></tr></table></figure>\n\n<p>最终，通过adap-&gt;algo-&gt;master_xfer()函数，将struct i2c_msg结构体类型的消息，通过适配器的struct i2c_adapter发送给设备，或者从设备中读取信息；</p>\n<h5 id=\"3-5-2-消息格式\"><a href=\"#3-5-2-消息格式\" class=\"headerlink\" title=\"3.5.2 消息格式\"></a>3.5.2 消息格式</h5><p>经过mster_xfer()函数发送、接收的消息类型应该按照struct i2c_msg结构体格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/uapi/linux/i2c.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> &#123;</span></span><br><span class=\"line\">    __u16 addr; <span class=\"comment\">/* slave address            */</span></span><br><span class=\"line\">    __u16 flags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RD        0x0001  <span class=\"comment\">/* read data, from slave to master */</span></span></span><br><span class=\"line\">                    <span class=\"comment\">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_TEN       0x0010  <span class=\"comment\">/* this is a ten bit chip address */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_RECV_LEN      0x0400  <span class=\"comment\">/* length will be first received byte */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NO_RD_ACK     0x0800  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_IGNORE_NAK    0x1000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_NOSTART       0x4000  <span class=\"comment\">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I2C_M_STOP      0x8000  <span class=\"comment\">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class=\"line\">    __u16 len;      <span class=\"comment\">/* msg length               */</span></span><br><span class=\"line\">    __u8 *buf;      <span class=\"comment\">/* pointer to msg data          */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；</p>\n<p>I2C读取，即封装的xxx_i2c_read()函数，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>\n<p>I2C写入，即封装的xxx_i2c_write()函数，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；</p>\n</blockquote>\n<p>注意：以数组格式定义i2c_msg是为了访问连续，因为数组是连续内存存储的；</p>\n<h5 id=\"3-5-3-消息发送、接收函数\"><a href=\"#3-5-3-消息发送、接收函数\" class=\"headerlink\" title=\"3.5.3 消息发送、接收函数\"></a>3.5.3 消息发送、接收函数</h5><h6 id=\"1）发送函数\"><a href=\"#1）发送函数\" class=\"headerlink\" title=\"1）发送函数\"></a>1）发送函数</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_master_send(const struct i2c_client *client, const char *buf, int count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    struct i2c_adapter *adap &#x3D; client-&gt;adapter;</span><br><span class=\"line\">    struct i2c_msg msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg.addr &#x3D; client-&gt;addr;</span><br><span class=\"line\">    msg.flags &#x3D; client-&gt;flags &amp; I2C_M_TEN;</span><br><span class=\"line\">    msg.len &#x3D; count;</span><br><span class=\"line\">    msg.buf &#x3D; (char *)buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; i2c_transfer(adap, &amp;msg, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (ret &#x3D;&#x3D; 1) ? count : ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_master_send);</span><br></pre></td></tr></table></figure>\n\n<p>I2C发送消息操作时，仅需要一个i2c_msg；i2c_msg的buf，保存slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, data, len);</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2）接收函数\"><a href=\"#2）接收函数\" class=\"headerlink\" title=\"2）接收函数\"></a>2）接收函数</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">int i2c_master_recv(const struct i2c_client *client, char *buf, int count)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_adapter *adap &#x3D; client-&gt;adapter;</span><br><span class=\"line\">    struct i2c_msg msg;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg.addr &#x3D; client-&gt;addr;</span><br><span class=\"line\">    msg.flags &#x3D; client-&gt;flags &amp; I2C_M_TEN;</span><br><span class=\"line\">    msg.flags |&#x3D; I2C_M_RD;</span><br><span class=\"line\">    msg.len &#x3D; count;</span><br><span class=\"line\">    msg.buf &#x3D; buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; i2c_transfer(adap, &amp;msg, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (ret &#x3D;&#x3D; 1) ? count : ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_master_recv);</span><br></pre></td></tr></table></figure>\n\n<p>I2C接收消息操作时，需要给从设备发送两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，并使用buf指针指向这个地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>\n<p>也可以分两次，先使用i2c_master_send()函数，向slave发出目标寄存器地址，在使用i2c_master_recv()函数，用来接收读取到的数据消息；如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, reg, <span class=\"number\">2</span>); </span><br><span class=\"line\">i2c_master_recv(client, data, len);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-添加设备\"><a href=\"#4-添加设备\" class=\"headerlink\" title=\"4. 添加设备\"></a>4. 添加设备</h3><p>在内核中的Documentation/i2c/instantiating-devices文件中，讲述了添加设备的方法；</p>\n<p>i2c_client结构是通过以下方式自动创建：</p>\n<blockquote>\n<p>分配、设置、注册i2c_board_info</p>\n<p>获取i2c_adapter，调用i2c_new_device</p>\n<p>通过设备树（DeviceTree）创建</p>\n</blockquote>\n<h4 id=\"4-1-添加设备树\"><a href=\"#4-1-添加设备树\" class=\"headerlink\" title=\"4.1 添加设备树\"></a>4.1 添加设备树</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Image-fsl-lx2160a-rdb-new.dts</span><br><span class=\"line\">        i2c@2030000 &#123;</span><br><span class=\"line\">            compatible &#x3D; &quot;fsl,vf610-i2c&quot;;</span><br><span class=\"line\">            #address-cells &#x3D; &lt;0x1&gt;;</span><br><span class=\"line\">            #size-cells &#x3D; &lt;0x0&gt;;</span><br><span class=\"line\">            reg &#x3D; &lt;0x0 0x2030000 0x0 0x10000&gt;;</span><br><span class=\"line\">            interrupts &#x3D; &lt;0x0 0x23 0x4&gt;;</span><br><span class=\"line\">            scl-gpios&#x3D;&lt;&amp;gpio4 8 0x0&gt;;</span><br><span class=\"line\">            clock-names &#x3D; &quot;i2c&quot;;</span><br><span class=\"line\">            clocks &#x3D; &lt;0x2 0x4 0x7&gt;;</span><br><span class=\"line\">            status &#x3D; &quot;okay&quot;;</span><br><span class=\"line\">            rtc@32 &#123;</span><br><span class=\"line\">                compatible &#x3D; &quot;Micro Crystal,rv8803&quot;;</span><br><span class=\"line\">                reg &#x3D; &lt;0x32&gt;;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            eeprom_mcy@51 &#123;</span><br><span class=\"line\">                compatible &#x3D; &quot;mcy,eeprom_mcy&quot;;</span><br><span class=\"line\">                reg &#x3D; &lt;0x51&gt;;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;</span><br><span class=\"line\">2-0032  2-0051  i2c-0   i2c-1   i2c-2   i2c-3 </span><br><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F; -l</span><br><span class=\"line\">total 0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0032 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2030000.i2c&#x2F;i2c-2&#x2F;2-0032</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0051 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2030000.i2c&#x2F;i2c-2&#x2F;2-0051</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-0 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2000000.i2c&#x2F;i2c-0</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-1 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2010000.i2c&#x2F;i2c-1</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-2 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2030000.i2c&#x2F;i2c-2</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-3 -&gt; ..&#x2F;..&#x2F;..&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;2050000.i2c&#x2F;i2c-3</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;2-0051&#x2F;</span><br><span class=\"line\">consumers  modalias   name       of_node    subsystem  suppliers  uevent</span><br><span class=\"line\"># ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;2-0051&#x2F; -l</span><br><span class=\"line\">total 0</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 consumers</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 modalias</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 name</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:27 of_node -&gt; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;firmware&#x2F;devicetree&#x2F;base&#x2F;soc&#x2F;i2c@2030000&#x2F;eeprom_mcy@51</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             0 Oct 15 03:27 subsystem -&gt; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;bus&#x2F;i2c</span><br><span class=\"line\">-r--r--r--    1 root     root          4096 Oct 15 03:27 suppliers</span><br><span class=\"line\">-rw-r--r--    1 root     root          4096 Oct 15 03:27 uevent</span><br><span class=\"line\"># cat &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;2-0051&#x2F;name</span><br><span class=\"line\">eeprom_mcy</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"4-2-i2c-new-device添加\"><a href=\"#4-2-i2c-new-device添加\" class=\"headerlink\" title=\"4.2 i2c_new_device添加\"></a>4.2 i2c_new_device添加</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_board_info</span> <span class=\"title\">eeprom_info</span> = &#123;</span> </span><br><span class=\"line\">    I2C_BOARD_INFO(<span class=\"string\">\"eeprom_device\"</span>, <span class=\"number\">0x51</span>),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_device_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s: %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\"></span><br><span class=\"line\">    adap = i2c_get_adapter(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_get_adapter failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    client = i2c_new_device(adap, &amp;eeprom_info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!client) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_new_device failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_put_adapter(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eeprom_device_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s: %d\\n\"</span>, __func__, __LINE__);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_unregister_device(client);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(eeprom_device_init);</span><br><span class=\"line\">module_exit(eeprom_device_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"4-3-静态注册I2C设备\"><a href=\"#4-3-静态注册I2C设备\" class=\"headerlink\" title=\"4.3 静态注册I2C设备\"></a>4.3 静态注册I2C设备</h4><p>内核提供了一种静态注册I2C设备的方法，通过i2c_register_board_info()函数实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-boardinfo.c</span><br><span class=\"line\">int i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int status;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (busnum &gt;&#x3D; __i2c_first_dynamic_bus_num)</span><br><span class=\"line\">        __i2c_first_dynamic_bus_num &#x3D; busnum + 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (status &#x3D; 0; len; len--, info++) &#123;</span><br><span class=\"line\">        struct i2c_devinfo  *devinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">        devinfo &#x3D; kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">        devinfo-&gt;busnum &#x3D; busnum;</span><br><span class=\"line\">        devinfo-&gt;board_info &#x3D; *info;</span><br><span class=\"line\">        list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在系统初始化过程中，可以通过i2c_register_board_info()函数，将需要的I2C设备添加到__i2c_board_list链表；系统在成功加载I2C适配器adapter后，会对这个__i2c_board_list链表中所有的设备逐一完成i2c_client的注册；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.h</span><br><span class=\"line\">struct i2c_devinfo &#123;</span><br><span class=\"line\">    struct list_head    list;</span><br><span class=\"line\">    int         busnum;</span><br><span class=\"line\">    struct i2c_board_info   board_info;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>系统初始化时，根据I2C设备配置信息，创建I2C设备（i2c_client），并添加到I2C子系统；</p>\n<p>最终是在i2c_scan_static_board_info()函数中，通过调用i2c_new_device()函数来实现添加设备；i2c_scan_static_board_info()函数一般在初始化时工作；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static void i2c_scan_static_board_info(struct i2c_adapter *adapter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_devinfo  *devinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry(devinfo, &amp;__i2c_board_list, list) &#123;</span><br><span class=\"line\">        if (devinfo-&gt;busnum &#x3D;&#x3D; adapter-&gt;nr</span><br><span class=\"line\">                &amp;&amp; !i2c_new_device(adapter,</span><br><span class=\"line\">                        &amp;devinfo-&gt;board_info))</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"5-添加驱动\"><a href=\"#5-添加驱动\" class=\"headerlink\" title=\"5. 添加驱动\"></a>5. 添加驱动</h3><p>以eeprom为例；</p>\n<h4 id=\"5-1-I2C设备驱动框架\"><a href=\"#5-1-I2C设备驱动框架\" class=\"headerlink\" title=\"5.1 I2C设备驱动框架\"></a>5.1 I2C设备驱动框架</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">mcy_eeprom_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_add_driver(&amp;mcy_eeprom_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mcy_eeprom_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_del_driver(&amp;mcy_eeprom_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(mcy_eeprom_init);</span><br><span class=\"line\">module_exit(mcy_eeprom_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> <span class=\"title\">mcy_eeprom_driver</span> = &#123;</span></span><br><span class=\"line\">    .driver = &#123;</span><br><span class=\"line\">        .owner = THIS_MODULE,</span><br><span class=\"line\">        .name = <span class=\"string\">\"mcy_eeprom\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//.of_match_table = mcy_eeprom_table,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    .probe = mcy_eeprom_probe,</span><br><span class=\"line\">    .<span class=\"built_in\">remove</span> = mcy_eeprom_remove,</span><br><span class=\"line\">    .id_table = mcy_eeprom_id,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    eeprom_init(eeprom_init)-->\n    i2c_add_driver(i2c_add_driver)-->eeprom_driver(eeprom_driver)\n    eeprom_driver-->driver(driver)\n    eeprom_driver-->probe(probe)\n    eeprom_driver-->remove(remove)\n    eeprom_driver-->id_table(id_table)</pre>\n\n\n\n<h4 id=\"5-2-probe函数\"><a href=\"#5-2-probe函数\" class=\"headerlink\" title=\"5.2 probe函数\"></a>5.2 probe函数</h4><h5 id=\"1）注册字符设备\"><a href=\"#1）注册字符设备\" class=\"headerlink\" title=\"1）注册字符设备\"></a>1）注册字符设备</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mcy_eeprom_probe</span><span class=\"params\">(struct i2c_client *client, <span class=\"keyword\">const</span> struct i2c_device_id *id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    eeprom_driver.client = client;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = alloc_chrdev_region(&amp;devnum, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">\"mcy_eeprom_chrdev\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, alloc_chrdev_region failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> chrdev_err;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, alloc_chrdev_region, devnum: %d\\n\"</span>, __func__, devnum);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev = cdev_alloc();</span><br><span class=\"line\">    cdev_init(cdev, &amp;mcy_eeprom_fops);</span><br><span class=\"line\">    ret = cdev_add(cdev, devnum, <span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, cdev_add failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> cdev_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// /sys/class</span></span><br><span class=\"line\">    dev_class = class_create(THIS_MODULE, <span class=\"string\">\"mcy_eeprom_class\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(dev_class)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, dev_class class_create failed\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> class_err;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"comment\">// /dev</span></span><br><span class=\"line\">    device_create(dev_class, <span class=\"literal\">NULL</span>, devnum, <span class=\"literal\">NULL</span>, <span class=\"string\">\"mcy_eeprom0\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, OK!\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">class_err:</span><br><span class=\"line\">    cdev_del(cdev);</span><br><span class=\"line\">cdev_err:</span><br><span class=\"line\">    unregister_chrdev_region(devnum, <span class=\"number\">1</span>); </span><br><span class=\"line\">chrdev_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2）卸载函数\"><a href=\"#2）卸载函数\" class=\"headerlink\" title=\"2）卸载函数\"></a>2）卸载函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mcy_eeprom_remove</span><span class=\"params\">(struct i2c_client *client)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    device_destroy(dev_class, devnum);</span><br><span class=\"line\">    class_destroy(dev_class);</span><br><span class=\"line\">    cdev_del(cdev);</span><br><span class=\"line\">    unregister_chrdev_region(devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\">    kfree(cdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3）字符设备操作集\"><a href=\"#3）字符设备操作集\" class=\"headerlink\" title=\"3）字符设备操作集\"></a>3）字符设备操作集</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">mcy_eeprom_fops</span>= &#123;</span></span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = eeprom_driver_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = eeprom_driver_release,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span> = eeprom_driver_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span> = eeprom_driver_write,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-读写函数\"><a href=\"#5-3-读写函数\" class=\"headerlink\" title=\"5.3 读写函数\"></a>5.3 读写函数</h4><p>I2C数据的发送和接收，是通过I2C驱动中file_operations的write和read系统调用来实现的；驱动中read和write的封装，是需要封装调用i2c_transfer()函数来完成i2d_msg消息的通信；read和write函数的封装，有两种方法；</p>\n<h5 id=\"5-3-1-内核函数调用\"><a href=\"#5-3-1-内核函数调用\" class=\"headerlink\" title=\"5.3.1 内核函数调用\"></a>5.3.1 内核函数调用</h5><p>使用i2c-core.c提供的i2c_master_send()和i2c_master_recv()函数实现I2C信息的发送和接收；</p>\n<h6 id=\"1）发送\"><a href=\"#1）发送\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, data, len);</span><br></pre></td></tr></table></figure>\n\n<p>I2C发送，直接调用i2c_master_send()函数，一次完成I2C数据的发送；</p>\n<p>data：要发送的数据信息数组；其中data最前边的地址存放的是I2C从设备寄存器的地址，如果地址是8bits，就占用data[0]，如果地址是16bits，占用data[0]和data[1]；在地址之后，紧接着存放要发送的数据内容；</p>\n<p>len：要发送的数据长度；包含I2C从设备寄存器地址和数据内容的总数据长度；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_write</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">18</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data[<span class=\"number\">2</span>], eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\">    len = eeprom_data.len + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, data[%d]: 0x%2x\\n\"</span>, __func__, i, data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 1</span></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, data, len);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2）接收\"><a href=\"#2）接收\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i2c_master_send(client, reg, reg_len); </span><br><span class=\"line\">i2c_master_recv(client, data, data_len);</span><br></pre></td></tr></table></figure>\n\n<p>I2C接收不同于发送，需要两步来完成，先使用i2c_master_send()函数向I2C从设备发送要读取的寄存器地址；再使用i2c_master_recv()函数，从I2C从设备指定寄存器地址读取数据；</p>\n<p>reg：要读取的从设备寄存器地址数组；如果地址是8bits，reg_len为1；如果地址是16bits，reg_len为2；</p>\n<p>data：要读取的数据信息存放的指针地址；data_len为要读取的寄存器个数；</p>\n<h6 id><a href=\"#\" class=\"headerlink\" title></a></h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_read</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> reg[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">\"%s\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    reg[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>); </span><br><span class=\"line\">    reg[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 1</span></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, reg, <span class=\"number\">2</span>); </span><br><span class=\"line\">    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; eeprom_data.len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\"</span>, __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_to_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"5-3-2-直接封装\"><a href=\"#5-3-2-直接封装\" class=\"headerlink\" title=\"5.3.2 直接封装\"></a>5.3.2 直接封装</h5><p>直接通过封装i2c_msg消息，通过i2c_transfer()函数实现I2C信息的发送和接收；</p>\n<h6 id=\"1）发送-1\"><a href=\"#1）发送-1\" class=\"headerlink\" title=\"1）发送\"></a>1）发送</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_send_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct i2c_client *client, <span class=\"keyword\">unsigned</span> short reg, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    data = kmalloc(count + <span class=\"number\">2</span>, GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, kmalloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data[<span class=\"number\">2</span>], buf, count);</span><br><span class=\"line\">    len = count + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;msg, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(msg));</span><br><span class=\"line\">    msg.addr = client-&gt;addr;</span><br><span class=\"line\">    msg.flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    msg.len = count;</span><br><span class=\"line\">    msg.buf = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_transfer(client-&gt;adapter, &amp;msg, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">        kfree(data);</span><br><span class=\"line\">        data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_write</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_send_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2）接收-1\"><a href=\"#2）接收-1\" class=\"headerlink\" title=\"2）接收\"></a>2）接收</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i2c_recv_bytes</span><span class=\"params\">(<span class=\"keyword\">const</span> struct i2c_client *client, <span class=\"keyword\">unsigned</span> short reg, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> <span class=\"title\">msg</span>[2] = &#123;</span> <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> txbuf[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    txbuf[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    txbuf[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;msg, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(msg));</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].addr = client-&gt;addr;</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].len = <span class=\"number\">2</span>;</span><br><span class=\"line\">    msg[<span class=\"number\">0</span>].buf = txbuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].addr = client-&gt;addr;</span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].flags = I2C_M_RD;</span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].len = count;</span><br><span class=\"line\">    msg[<span class=\"number\">1</span>].buf = buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_transfer(client-&gt;adapter, msg, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_read</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_recv_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_to_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-驱动和设备匹配\"><a href=\"#6-驱动和设备匹配\" class=\"headerlink\" title=\"6. 驱动和设备匹配\"></a>6. 驱动和设备匹配</h3><p>设备和驱动的关系</p>\n<p>对于一个驱动程序，有两个必不可少的元素，即：设备和驱动，驱动是通过设备名和驱动名建立联系；在i2c_adapter注册时会遍历i2c_board_info结构，会完成驱动和设备的匹配；</p>\n<p>一个驱动程序，可以有多个名字，即一个驱动程序可以支持多个设备，该机制通过由i2c_device_id结构体组成的数组实现；该数组是在驱动中建立；I2C架构会扫描该结构体数组，逐一与设备进行匹配，匹配成功就会调用相应的probe函数；</p>\n<p>进入驱动中的probe函数，要先进入总线的probe函数，而前提是设备与驱动的match匹配成功；</p>\n<p>bus_add_driver</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;bus.c</span><br><span class=\"line\">int bus_add_driver(struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct bus_type *bus;</span><br><span class=\"line\">    struct driver_private *priv;</span><br><span class=\"line\">    int error &#x3D; 0; </span><br><span class=\"line\"></span><br><span class=\"line\">    bus &#x3D; bus_get(drv-&gt;bus);</span><br><span class=\"line\"></span><br><span class=\"line\">    priv &#x3D; kzalloc(sizeof(*priv), GFP_KERNEL);</span><br><span class=\"line\"></span><br><span class=\"line\">    klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);</span><br><span class=\"line\">    priv-&gt;driver &#x3D; drv; </span><br><span class=\"line\">    drv-&gt;p &#x3D; priv;</span><br><span class=\"line\">    priv-&gt;kobj.kset &#x3D; bus-&gt;p-&gt;drivers_kset;</span><br><span class=\"line\">    error &#x3D; kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,</span><br><span class=\"line\">                     &quot;%s&quot;, drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class=\"line\">    if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class=\"line\">        if (driver_allows_async_probing(drv)) &#123;</span><br><span class=\"line\">            async_schedule(driver_attach_async, drv);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            error &#x3D; driver_attach(drv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    module_add_driver(drv-&gt;owner, drv);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class=\"line\"></span><br><span class=\"line\">    error &#x3D; driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class=\"line\">        error &#x3D; add_bind_files(drv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">int driver_attach(struct device_driver *drv)</span><br><span class=\"line\">&#123;               </span><br><span class=\"line\">    return bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);</span><br><span class=\"line\">&#125;       </span><br><span class=\"line\">EXPORT_SYMBOL_GPL(driver_attach);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;bus.c</span><br><span class=\"line\">int bus_for_each_dev(struct bus_type *bus, struct device *start,</span><br><span class=\"line\">             void *data, int (*fn)(struct device *, void *))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct klist_iter i;</span><br><span class=\"line\">    struct device *dev;</span><br><span class=\"line\">    int error &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!bus || !bus-&gt;p)</span><br><span class=\"line\">        return -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,</span><br><span class=\"line\">                 (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));</span><br><span class=\"line\">    while ((dev &#x3D; next_device(&amp;i)) &amp;&amp; !error)</span><br><span class=\"line\">        error &#x3D; fn(dev, data);</span><br><span class=\"line\">    klist_iter_exit(&amp;i);</span><br><span class=\"line\">    return error;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(bus_for_each_dev);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">static int __driver_attach(struct device *dev, void *data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct device_driver *drv &#x3D; data;</span><br><span class=\"line\">    int ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret &#x3D; driver_match_device(drv, dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    if (!dev-&gt;driver)</span><br><span class=\"line\">        driver_probe_device(drv, dev);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;base.h</span><br><span class=\"line\">static inline int driver_match_device(struct device_driver *drv,</span><br><span class=\"line\">                      struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">int driver_probe_device(struct device_driver *drv, struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ret &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!device_is_registered(dev))</span><br><span class=\"line\">        return -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_debug(&quot;bus: &#39;%s&#39;: %s: matched device %s with driver %s\\n&quot;,</span><br><span class=\"line\">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;parent)</span><br><span class=\"line\">        pm_runtime_get_sync(dev-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    pm_runtime_barrier(dev);</span><br><span class=\"line\">    ret &#x3D; really_probe(dev, drv);</span><br><span class=\"line\">    pm_request_idle(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (dev-&gt;parent)</span><br><span class=\"line\">        pm_runtime_put(dev-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;base&#x2F;dd.c</span><br><span class=\"line\">static int really_probe(struct device *dev, struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tif (dev-&gt;bus-&gt;probe) &#123;</span><br><span class=\"line\">        ret &#x3D; dev-&gt;bus-&gt;probe(dev);</span><br><span class=\"line\">    &#125; else if (drv-&gt;probe) &#123;</span><br><span class=\"line\">        ret &#x3D; drv-&gt;probe(dev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<pre class=\"mermaid\">graph TB\n    bus_add_driver(bus_add_driver)-->\n    driver_attach(driver_attach)--bus_for_each_dev-->\n    __driver_attach(__driver_attach)-->\n    driver_match_device(driver_match_device)-->\n    bus_match(drv->bus->match)\n    __driver_attach-->driver_probe_device(driver_probe_device)-->\n    really_probe(really_probe)-->\n    bus_probe(dev->bus->probe)</pre>\n\n\n\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c </span><br><span class=\"line\">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class=\"line\">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class=\"line\">    .match      &#x3D; i2c_device_match,</span><br><span class=\"line\">    .probe      &#x3D; i2c_device_probe,</span><br><span class=\"line\">    .remove     &#x3D; i2c_device_remove,</span><br><span class=\"line\">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"6-1-match\"><a href=\"#6-1-match\" class=\"headerlink\" title=\"6.1 match\"></a>6.1 match</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c </span><br><span class=\"line\">static int i2c_device_match(struct device *dev, struct device_driver *drv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_client   *client &#x3D; i2c_verify_client(dev);</span><br><span class=\"line\">    struct i2c_driver   *driver;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!client)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Attempt an OF style match *&#x2F;</span><br><span class=\"line\">    if (of_driver_match_device(dev, drv))</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* Then ACPI style match *&#x2F;</span><br><span class=\"line\">    if (acpi_driver_match_device(dev, drv))</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    driver &#x3D; to_i2c_driver(drv);</span><br><span class=\"line\">    &#x2F;* match on an id table if there is one *&#x2F;</span><br><span class=\"line\">    if (driver-&gt;id_table)</span><br><span class=\"line\">        return i2c_match_id(driver-&gt;id_table, client) !&#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<pre class=\"mermaid\">graph LR\n    i2c_device_match(i2c_device_match)\n    i2c_device_match-->of_driver_match_device(of_driver_match_device)\n    i2c_device_match-->acpi_driver_match_device(acpi_driver_match_device)\n    i2c_device_match--id_table-->i2c_match_id(i2c_match_id)</pre>\n\n\n\n\n<p>从i2c_device_match()函数的定义可以得出，i2c的match函数，优先选择设备树匹配（of_driver_match_device），如果设备树匹配成功，函数就返回；否则，会进行下一个。。。。。。，最后，如果定义了id_table，就会通过i2c_match_id()函数进行id_table匹配；如果三者全都匹配不成功，才算是匹配失败；</p>\n<p>从i2c_device_match函数来看，配置了设备树，就不需要id_table的定义了；但是实际上还是需要id_table的定义的，因为在后边的probe函数中需要判断id_table是否定义，如果定义了才能执行driver-&gt;probe函数；</p>\n<p>设备树的匹配过程如下：</p>\n<pre class=\"mermaid\">graph TB\n    of_driver_match_device(of_driver_match_device)-->\n    of_match_device(of_match_device)-->\n    of_match_node(of_match_node)-->\n    __of_match_node(__of_match_node)-->\n    __of_device_is_compatible(__of_device_is_compatible)\n    __of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)\n    __of_device_is_compatible--type-->of_compat_cmp\n    __of_device_is_compatible--name-->of_compat_cmp\n    of_compat_cmp-->\n    strcasecmp(strcasecmp)</pre>\n\n\n\n\n<p>__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；</p>\n<p>匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；</p>\n<h4 id=\"6-2-probe\"><a href=\"#6-2-probe\" class=\"headerlink\" title=\"6.2 probe\"></a>6.2 probe</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class=\"line\">static int i2c_device_probe(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct i2c_client   *client &#x3D; i2c_verify_client(dev);</span><br><span class=\"line\">    struct i2c_driver   *driver;</span><br><span class=\"line\">    int status;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    driver &#x3D; to_i2c_driver(dev-&gt;driver);</span><br><span class=\"line\">    if (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class=\"line\">        return -ENODEV;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    status &#x3D; driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>i2c_device_probe()函数中，如果配置了设备树，i2c总线在match函数中，就不需要id_table的定义了；但是在probe函数中，还是需要id_table的定义的，因为在probe函数中需要判断id_table是否定义，如果定义了才能执行driver-&gt;probe函数；</p>\n<h4 id=\"6-3-I2C注册匹配过程\"><a href=\"#6-3-I2C注册匹配过程\" class=\"headerlink\" title=\"6.3 I2C注册匹配过程\"></a>6.3 I2C注册匹配过程</h4><p><img src=\"/2020/04/06/Linux-kernel%E4%B8%AD%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/I2C%E6%B3%A8%E5%86%8C%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png\" alt=\"I2C注册匹配过程\"></p>\n<h3 id=\"7-实例\"><a href=\"#7-实例\" class=\"headerlink\" title=\"7. 实例\"></a>7. 实例</h3><p>以添加eeprom驱动为例讲解I2C驱动在eeprom芯片中的使用；</p>\n<h4 id=\"7-1-添加设备\"><a href=\"#7-1-添加设备\" class=\"headerlink\" title=\"7.1 添加设备\"></a>7.1 添加设备</h4><h5 id=\"1）添加设备树\"><a href=\"#1）添加设备树\" class=\"headerlink\" title=\"1）添加设备树\"></a>1）添加设备树</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;vexpress-v2m.dtsi</span><br><span class=\"line\">\t\t\tv2m_i2c_dvi: i2c@16000 &#123;</span><br><span class=\"line\">                compatible &#x3D; &quot;arm,versatile-i2c&quot;;</span><br><span class=\"line\">                reg &#x3D; &lt;0x16000 0x1000&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">                #address-cells &#x3D; &lt;1&gt;;</span><br><span class=\"line\">                #size-cells &#x3D; &lt;0&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">                dvi-transmitter@39 &#123;</span><br><span class=\"line\">                    compatible &#x3D; &quot;sil,sii9022-tpi&quot;, &quot;sil,sii9022&quot;;</span><br><span class=\"line\">                    reg &#x3D; &lt;0x39&gt;;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                dvi-transmitter@60 &#123;</span><br><span class=\"line\">                    compatible &#x3D; &quot;sil,sii9022-cpi&quot;, &quot;sil,sii9022&quot;;</span><br><span class=\"line\">                    reg &#x3D; &lt;0x60&gt;;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                eeprom@51 &#123;</span><br><span class=\"line\">                    compatible &#x3D; &quot;mcy,mcy_eeprom&quot;;</span><br><span class=\"line\">                    reg &#x3D; &lt;0x51&gt;;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"2）i2c-new-device\"><a href=\"#2）i2c-new-device\" class=\"headerlink\" title=\"2）i2c_new_device\"></a>2）i2c_new_device</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mcy_eeprom_device.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_board_info</span> <span class=\"title\">eeprom_info</span> = &#123;</span> </span><br><span class=\"line\">    I2C_BOARD_INFO(<span class=\"string\">\"eeprom_device\"</span>, <span class=\"number\">0x51</span>),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_device_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adap</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    adap = i2c_get_adapter(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!adap) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_get_adapter failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    client = i2c_new_device(adap, &amp;eeprom_info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!client) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_new_device failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    i2c_put_adapter(adap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eeprom_device_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    i2c_unregister_device(client);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(eeprom_device_init);</span><br><span class=\"line\">module_exit(eeprom_device_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"7-2-添加驱动\"><a href=\"#7-2-添加驱动\" class=\"headerlink\" title=\"7.2 添加驱动\"></a>7.2 添加驱动</h4><h5 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mcy_eeprom_driver.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/cdev.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/i2c.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;asm-generic/uaccess.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eeprom_data_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">16</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">eeprom_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eeprom_driver_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span> devnum;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> *<span class=\"title\">cdev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class</span> *<span class=\"title\">class</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">eeprom_driver_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\"><span class=\"keyword\">eeprom_driver_t</span> eeprom_driver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_open</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_release</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_read</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> reg[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    reg[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    reg[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, reg, <span class=\"number\">2</span>);</span><br><span class=\"line\">    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; eeprom_data.len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\\n\"</span>, __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_to_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">eeprom_driver_write</span><span class=\"params\">(struct file *filp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *loff)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">18</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, copy_from_user failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;data[<span class=\"number\">2</span>], eeprom_data.data, eeprom_data.len);</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = (<span class=\"keyword\">char</span>)((eeprom_data.reg &amp; <span class=\"number\">0x0000ff00</span>) &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>)(eeprom_data.reg &amp; <span class=\"number\">0x000000ff</span>);</span><br><span class=\"line\">    len = eeprom_data.len + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, data[%d]: 0x%2x\\n\"</span>, __func__, i, data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = i2c_master_send(eeprom_driver.client, data, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">eeprom_driver_fops</span> = &#123;</span></span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = eeprom_driver_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span> = eeprom_driver_release,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span> = eeprom_driver_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span> = eeprom_driver_write,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_probe</span><span class=\"params\">(struct i2c_client *client, <span class=\"keyword\">const</span> struct i2c_device_id *id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    eeprom_driver.client = client;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = alloc_chrdev_region(&amp;eeprom_driver.devnum, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">\"eeprom_driver_chrdev\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, alloc_chrdev_region failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> chrdev_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    major = MAJOR(eeprom_driver.devnum);</span><br><span class=\"line\">    printk(<span class=\"string\">\"%s, alloc_chrdev_region, devnum: 0x%x, major: %d\\n\"</span>, __func__, eeprom_driver.devnum, major);</span><br><span class=\"line\"></span><br><span class=\"line\">    eeprom_driver.cdev = cdev_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!eeprom_driver.cdev) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, cdev_alloc failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> cdev_alloc_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cdev_init(eeprom_driver.cdev, &amp;eeprom_driver_fops);</span><br><span class=\"line\">    ret = cdev_add(eeprom_driver.cdev, eeprom_driver.devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, cdev_add failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> cdev_add_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /sys/class</span></span><br><span class=\"line\">    eeprom_driver<span class=\"class\">.<span class=\"keyword\">class</span> = <span class=\"title\">class_create</span>(<span class=\"title\">THIS_MODULE</span>, \"<span class=\"title\">eeprom_driver_class</span>\");</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(eeprom_driver.class)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, class_create failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        ret = PTR_ERR(eeprom_driver.class);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> class_create_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// /dev</span></span><br><span class=\"line\">    eeprom_driver.dev = device_create(eeprom_driver.class, <span class=\"literal\">NULL</span>, eeprom_driver.devnum, <span class=\"literal\">NULL</span>, <span class=\"string\">\"eeprom_driver\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(eeprom_driver.dev)) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%s, device_create failed!\\n\"</span>, __func__);</span><br><span class=\"line\">        ret = PTR_ERR(eeprom_driver.dev);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> device_create_err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">device_create_err:</span><br><span class=\"line\">    class_destroy(eeprom_driver.class);</span><br><span class=\"line\">class_create_err:</span><br><span class=\"line\">    cdev_del(eeprom_driver.cdev);</span><br><span class=\"line\">cdev_add_err:</span><br><span class=\"line\">    kfree(eeprom_driver.cdev);</span><br><span class=\"line\">cdev_alloc_err:</span><br><span class=\"line\">    unregister_chrdev_region(eeprom_driver.devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\">chrdev_err:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_remove</span><span class=\"params\">(struct i2c_client *client)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    device_destroy(eeprom_driver.class, eeprom_driver.devnum);</span><br><span class=\"line\">    class_destroy(eeprom_driver.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_del(eeprom_driver.cdev);</span><br><span class=\"line\"></span><br><span class=\"line\">    kfree(eeprom_driver.cdev);</span><br><span class=\"line\">    unregister_chrdev_region(eeprom_driver.devnum, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_device_id</span> <span class=\"title\">eeprom_driver_id</span>[] = &#123;</span></span><br><span class=\"line\">    &#123;<span class=\"string\">\"mcy_eeprom\"</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">of_device_id</span> <span class=\"title\">eeprom_driver_table</span>[] = &#123;</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//.name = \"mcy_eeprom\",</span></span><br><span class=\"line\">        .compatible = <span class=\"string\">\"mcy,mcy_eeprom\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> <span class=\"title\">eeprom_i2c_driver</span>= &#123;</span></span><br><span class=\"line\">    .driver = &#123;</span><br><span class=\"line\">        .owner = THIS_MODULE,</span><br><span class=\"line\">        .name = <span class=\"string\">\"mcy_eeprom\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//.of_match_table = eeprom_driver_table,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    .probe = eeprom_driver_probe,</span><br><span class=\"line\">    .<span class=\"built_in\">remove</span> = eeprom_driver_remove,</span><br><span class=\"line\">    .id_table = eeprom_driver_id,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">eeprom_driver_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    i2c_add_driver(&amp;eeprom_i2c_driver);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eeprom_driver_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    i2c_del_driver(&amp;eeprom_i2c_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(eeprom_driver_init);</span><br><span class=\"line\">module_exit(eeprom_driver_exit);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"7-3-应用程序\"><a href=\"#7-3-应用程序\" class=\"headerlink\" title=\"7.3 应用程序\"></a>7.3 应用程序</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eeprom_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> data[<span class=\"number\">16</span>];</span><br><span class=\"line\">&#125; <span class=\"keyword\">eeprom_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_read</span><span class=\"params\">(<span class=\"keyword\">int</span> reg, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">16</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, len: %d over range!\\n\"</span>, __func__, len);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    eeprom_data.reg = reg;</span><br><span class=\"line\">    eeprom_data.len = len;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = <span class=\"built_in\">read</span>(fd, &amp;eeprom_data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, reg[%d]: %d, data: 0x%2x\\n\"</span>, __func__, i, reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">eeprom_write</span><span class=\"params\">(<span class=\"keyword\">int</span> reg, <span class=\"keyword\">int</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">eeprom_data_t</span> eeprom_data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">16</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, len: %d over range!\\n\"</span>, __func__, len);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;eeprom_data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    eeprom_data.reg = reg;</span><br><span class=\"line\">    eeprom_data.len = len;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">write</span>(fd, &amp;eeprom_data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">eeprom_data_t</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, read failed, ret: %d\\n\"</span>, __func__, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, reg[%d]: %d, data: 0x%2x\\n\"</span>, __func__, i, reg + i, eeprom_data.data[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">8</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/eeprom_driver\"</span>, O_RDWR | O_NONBLOCK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"open failed, fd: %d\\n\"</span>, fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = eeprom_write(reg, len, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"eeprom_write failed, ret: %d\\n\"</span>, ret);</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = eeprom_read(reg, len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"eeprom_read failed, ret: %d\\n\"</span>, ret);</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"7-4-Makefile\"><a href=\"#7-4-Makefile\" class=\"headerlink\" title=\"7.4 Makefile\"></a>7.4 Makefile</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifneq ($(KERNELRELEASE),)</span><br><span class=\"line\">    obj-m := mcy_eeprom_driver.o mcy_eeprom_device.o</span><br><span class=\"line\">else</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">generate the path</span></span><br><span class=\"line\">CURRENT_PATH:=$(shell pwd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">the absolute path</span></span><br><span class=\"line\">LINUX_KERNEL_PATH := /home/xiami/tool/linux-4.9.115</span><br><span class=\"line\"></span><br><span class=\"line\">CROSS_COMPILE := arm-linux-gnueabi-</span><br><span class=\"line\">CC := $(CROSS_COMPILE)gcc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">complie object</span></span><br><span class=\"line\">all:</span><br><span class=\"line\">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class=\"line\">clean:</span><br><span class=\"line\">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</span><br><span class=\"line\">    -rm main -rf</span><br><span class=\"line\">app:</span><br><span class=\"line\">    $(CC) main.c -o main</span><br><span class=\"line\">install:</span><br><span class=\"line\">    -chmod a+x *.ko</span><br><span class=\"line\">    -cp *.ko /home/xiami/qemu/nfs_root/mcy -rfp</span><br><span class=\"line\">    -cp main /home/xiami/qemu/nfs_root/mcy -rfp</span><br><span class=\"line\">    -chmod a+x /home/xiami/qemu/nfs_root/mcy/* main</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>I2C总线维护两个链表，一个是I2C驱动链表，一个是I2C设备链表，每当注册一个驱动（或设备），就会将其添加到I2C总线上相对应的I2C驱动链表（或I2C设备链表），然后遍历I2C总线的I2C设备（或I2C驱动）链表的所有设备（或驱动），通过I2C总线的匹配函数判断是否匹配，如果匹配，就调用驱动的probe函数，然后就可以在probe函数中注册字符设备，创建设备节点，实现设备操作集fops等，为应用调用提供接口；</p>\n<p>参考资料</p>\n<p><a href=\"https://blog.csdn.net/shichaog/article/details/41169981\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/shichaog/article/details/41169981</a></p>\n<p>《Linux设备驱动开发详解》</p>\n<p>《精通linux设备驱动程序开发》</p>\n<p><a href=\"#目录\">回到目录</a></p>"},{"title":"busybox加载inittab过程分析","date":"2020-05-31T12:06:09.000Z","_content":"\n\n\n\n\n### busybox加载inittab过程分析\n\n\n\n##### 环境\n\nlinux-4.9.115\n\nbusybox-1.31.1\n\n\n\n<!--more-->\n\n\n\n#### 简介\n\n\n\nbusybox工具通过init_main()函数对inittab文件进行分析执行；\n\n\n\ninit_main()函数通过parse_inittab()函数分析inittab文件，将文件中的每一行配置用new_init_action()函数；\n\n\n\n```mermaid\ngraph TB\n\tinit_main(init_main)-->parse_inittab(parse_inittab)--inittab-->new_init_action(new_init_action)\n```\n\n\n\n\n\n\n\n在parse_inittab()函数中\n\n\n\n如果不支持ENABLE_FEATURE_USE_INITTAB，或者支持ENABLE_FEATURE_USE_INITTAB时，未找到inittab文件；busybox使用默认的脚本操作：\n\n```c\n// init/init.c\n    if (parser == NULL)\n    {    \n        /* No inittab file - set up some default behavior */\n        /* Sysinit */\n        new_init_action(SYSINIT, INIT_SCRIPT, \"\"); \n        /* Askfirst shell on tty1-4 */\n        new_init_action(ASKFIRST, bb_default_login_shell, \"\"); \n//TODO: VC_1 instead of \"\"? \"\" is console -> ctty problems -> angry users\n        new_init_action(ASKFIRST, bb_default_login_shell, VC_2);\n        new_init_action(ASKFIRST, bb_default_login_shell, VC_3);\n        new_init_action(ASKFIRST, bb_default_login_shell, VC_4);\n        /* Reboot on Ctrl-Alt-Del */\n        new_init_action(CTRLALTDEL, \"reboot\", \"\"); \n        /* Umount all filesystems on halt/reboot */\n        new_init_action(SHUTDOWN, \"umount -a -r\", \"\"); \n        /* Swapoff on halt/reboot */\n        new_init_action(SHUTDOWN, \"swapoff -a\", \"\"); \n        /* Restart init when a QUIT is received */\n        new_init_action(RESTART, \"init\", \"\"); \n        return;\n    }\n```\n\n\n\n```c\n// init/init.c\n#define SYSINIT     0x01\n#define WAIT        0x02\n#define ONCE        0x04\n#define RESPAWN     0x08\n#define ASKFIRST    0x10\n#define CTRLALTDEL  0x20\n#define SHUTDOWN    0x40\n#define RESTART     0x80\n```\n\n\n\n在没有inittab配置文件时，busybox会默认加载初始化脚本/etc/init.d/rcS；\n\n```c\n// init/init.c\n/* Default sysinit script. */\n#ifndef INIT_SCRIPT\n# define INIT_SCRIPT  \"/etc/init.d/rcS\"\n#endif\n```\n\n\n\n\n\n\n\n\n\n如果支持ENABLE_FEATURE_USE_INITTAB；busybox会解析inittab配置文件，根据inittab中的配置进行初始化；\n\n先在config_open2()函数中，申请一个struct parser_t结构体的内存空间，并初始化结构体成员fp，指向已经打开的inittab文件；\n\n\n\n```c\n// init/init.c\n#if ENABLE_FEATURE_USE_INITTAB\n    char *token[4];\n    parser_t *parser = config_open2(\"/etc/inittab\", fopen_for_read);\n#endif\n```\n\n\n\n```c\n// include/libbb.h\ntypedef struct parser_t {\n    FILE *fp; \n    char *data;\n    char *line, *nline;\n    size_t line_alloc, nline_alloc;\n    int lineno;\n} parser_t;\n```\n\n\n\nbusybox解析inittab文件的操作如下：\n\n```c\n// init/init.c\n#if ENABLE_FEATURE_USE_INITTAB\n    /* optional_tty:ignored_runlevel:action:command\n     * Delims are not to be collapsed and need exactly 4 tokens\n     */\n    while (config_read(parser, token, 4, 0, \"#:\",\n                PARSE_NORMAL & ~(PARSE_TRIM | PARSE_COLLAPSE))) {\n        /* order must correspond to SYSINIT..RESTART constants */\n        static const char actions[] ALIGN1 =\n            \"sysinit\\0\"\"wait\\0\"\"once\\0\"\"respawn\\0\"\"askfirst\\0\"\n            \"ctrlaltdel\\0\"\"shutdown\\0\"\"restart\\0\";\n        int action;\n        char *tty = token[0];\n\n        if (!token[3]) /* less than 4 tokens */\n            goto bad_entry;\n        action = index_in_strings(actions, token[2]);\n        if (action < 0 || !token[3][0]) /* token[3]: command */\n            goto bad_entry;\n        /* turn .*TTY -> /dev/TTY */\n        if (tty[0]) {\n            tty = concat_path_file(\"/dev/\", skip_dev_pfx(tty));\n        }\n        new_init_action(1 << action, token[3], tty);\n        if (tty[0])\n            free(tty);\n        continue;\n bad_entry:\n        message(L_LOG | L_CONSOLE, \"Bad inittab entry at line %d\",\n                parser->lineno);\n    }\n    config_close(parser);\n#endif\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/busybox加载inittab过程分析.md","raw":"---\ntitle: busybox加载inittab过程分析\ndate: 2020-05-31 20:06:09\ntags: busybox\n---\n\n\n\n\n\n### busybox加载inittab过程分析\n\n\n\n##### 环境\n\nlinux-4.9.115\n\nbusybox-1.31.1\n\n\n\n<!--more-->\n\n\n\n#### 简介\n\n\n\nbusybox工具通过init_main()函数对inittab文件进行分析执行；\n\n\n\ninit_main()函数通过parse_inittab()函数分析inittab文件，将文件中的每一行配置用new_init_action()函数；\n\n\n\n```mermaid\ngraph TB\n\tinit_main(init_main)-->parse_inittab(parse_inittab)--inittab-->new_init_action(new_init_action)\n```\n\n\n\n\n\n\n\n在parse_inittab()函数中\n\n\n\n如果不支持ENABLE_FEATURE_USE_INITTAB，或者支持ENABLE_FEATURE_USE_INITTAB时，未找到inittab文件；busybox使用默认的脚本操作：\n\n```c\n// init/init.c\n    if (parser == NULL)\n    {    \n        /* No inittab file - set up some default behavior */\n        /* Sysinit */\n        new_init_action(SYSINIT, INIT_SCRIPT, \"\"); \n        /* Askfirst shell on tty1-4 */\n        new_init_action(ASKFIRST, bb_default_login_shell, \"\"); \n//TODO: VC_1 instead of \"\"? \"\" is console -> ctty problems -> angry users\n        new_init_action(ASKFIRST, bb_default_login_shell, VC_2);\n        new_init_action(ASKFIRST, bb_default_login_shell, VC_3);\n        new_init_action(ASKFIRST, bb_default_login_shell, VC_4);\n        /* Reboot on Ctrl-Alt-Del */\n        new_init_action(CTRLALTDEL, \"reboot\", \"\"); \n        /* Umount all filesystems on halt/reboot */\n        new_init_action(SHUTDOWN, \"umount -a -r\", \"\"); \n        /* Swapoff on halt/reboot */\n        new_init_action(SHUTDOWN, \"swapoff -a\", \"\"); \n        /* Restart init when a QUIT is received */\n        new_init_action(RESTART, \"init\", \"\"); \n        return;\n    }\n```\n\n\n\n```c\n// init/init.c\n#define SYSINIT     0x01\n#define WAIT        0x02\n#define ONCE        0x04\n#define RESPAWN     0x08\n#define ASKFIRST    0x10\n#define CTRLALTDEL  0x20\n#define SHUTDOWN    0x40\n#define RESTART     0x80\n```\n\n\n\n在没有inittab配置文件时，busybox会默认加载初始化脚本/etc/init.d/rcS；\n\n```c\n// init/init.c\n/* Default sysinit script. */\n#ifndef INIT_SCRIPT\n# define INIT_SCRIPT  \"/etc/init.d/rcS\"\n#endif\n```\n\n\n\n\n\n\n\n\n\n如果支持ENABLE_FEATURE_USE_INITTAB；busybox会解析inittab配置文件，根据inittab中的配置进行初始化；\n\n先在config_open2()函数中，申请一个struct parser_t结构体的内存空间，并初始化结构体成员fp，指向已经打开的inittab文件；\n\n\n\n```c\n// init/init.c\n#if ENABLE_FEATURE_USE_INITTAB\n    char *token[4];\n    parser_t *parser = config_open2(\"/etc/inittab\", fopen_for_read);\n#endif\n```\n\n\n\n```c\n// include/libbb.h\ntypedef struct parser_t {\n    FILE *fp; \n    char *data;\n    char *line, *nline;\n    size_t line_alloc, nline_alloc;\n    int lineno;\n} parser_t;\n```\n\n\n\nbusybox解析inittab文件的操作如下：\n\n```c\n// init/init.c\n#if ENABLE_FEATURE_USE_INITTAB\n    /* optional_tty:ignored_runlevel:action:command\n     * Delims are not to be collapsed and need exactly 4 tokens\n     */\n    while (config_read(parser, token, 4, 0, \"#:\",\n                PARSE_NORMAL & ~(PARSE_TRIM | PARSE_COLLAPSE))) {\n        /* order must correspond to SYSINIT..RESTART constants */\n        static const char actions[] ALIGN1 =\n            \"sysinit\\0\"\"wait\\0\"\"once\\0\"\"respawn\\0\"\"askfirst\\0\"\n            \"ctrlaltdel\\0\"\"shutdown\\0\"\"restart\\0\";\n        int action;\n        char *tty = token[0];\n\n        if (!token[3]) /* less than 4 tokens */\n            goto bad_entry;\n        action = index_in_strings(actions, token[2]);\n        if (action < 0 || !token[3][0]) /* token[3]: command */\n            goto bad_entry;\n        /* turn .*TTY -> /dev/TTY */\n        if (tty[0]) {\n            tty = concat_path_file(\"/dev/\", skip_dev_pfx(tty));\n        }\n        new_init_action(1 << action, token[3], tty);\n        if (tty[0])\n            free(tty);\n        continue;\n bad_entry:\n        message(L_LOG | L_CONSOLE, \"Bad inittab entry at line %d\",\n                parser->lineno);\n    }\n    config_close(parser);\n#endif\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"busybox加载inittab过程分析","published":1,"updated":"2020-05-31T12:09:46.777Z","_id":"ckav0s7fb0000xag174588apg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"busybox加载inittab过程分析\"><a href=\"#busybox加载inittab过程分析\" class=\"headerlink\" title=\"busybox加载inittab过程分析\"></a>busybox加载inittab过程分析</h3><h5 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h5><p>linux-4.9.115</p>\n<p>busybox-1.31.1</p>\n<a id=\"more\"></a>\n\n\n\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>busybox工具通过init_main()函数对inittab文件进行分析执行；</p>\n<p>init_main()函数通过parse_inittab()函数分析inittab文件，将文件中的每一行配置用new_init_action()函数；</p>\n<pre class=\"mermaid\">graph TB\n    init_main(init_main)-->parse_inittab(parse_inittab)--inittab-->new_init_action(new_init_action)</pre>\n\n\n\n\n\n\n\n<p>在parse_inittab()函数中</p>\n<p>如果不支持ENABLE_FEATURE_USE_INITTAB，或者支持ENABLE_FEATURE_USE_INITTAB时，未找到inittab文件；busybox使用默认的脚本操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;    </span><br><span class=\"line\">        <span class=\"comment\">/* No inittab file - set up some default behavior */</span></span><br><span class=\"line\">        <span class=\"comment\">/* Sysinit */</span></span><br><span class=\"line\">        new_init_action(SYSINIT, INIT_SCRIPT, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Askfirst shell on tty1-4 */</span></span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\"><span class=\"comment\">//<span class=\"doctag\">TODO:</span> VC_1 instead of \"\"? \"\" is console -&gt; ctty problems -&gt; angry users</span></span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, VC_2);</span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, VC_3);</span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, VC_4);</span><br><span class=\"line\">        <span class=\"comment\">/* Reboot on Ctrl-Alt-Del */</span></span><br><span class=\"line\">        new_init_action(CTRLALTDEL, <span class=\"string\">\"reboot\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Umount all filesystems on halt/reboot */</span></span><br><span class=\"line\">        new_init_action(SHUTDOWN, <span class=\"string\">\"umount -a -r\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Swapoff on halt/reboot */</span></span><br><span class=\"line\">        new_init_action(SHUTDOWN, <span class=\"string\">\"swapoff -a\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Restart init when a QUIT is received */</span></span><br><span class=\"line\">        new_init_action(RESTART, <span class=\"string\">\"init\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SYSINIT     0x01</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WAIT        0x02</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ONCE        0x04</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESPAWN     0x08</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ASKFIRST    0x10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CTRLALTDEL  0x20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHUTDOWN    0x40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESTART     0x80</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在没有inittab配置文件时，busybox会默认加载初始化脚本/etc/init.d/rcS；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"comment\">/* Default sysinit script. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> INIT_SCRIPT</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> INIT_SCRIPT  <span class=\"meta-string\">\"/etc/init.d/rcS\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<p>如果支持ENABLE_FEATURE_USE_INITTAB；busybox会解析inittab配置文件，根据inittab中的配置进行初始化；</p>\n<p>先在config_open2()函数中，申请一个struct parser_t结构体的内存空间，并初始化结构体成员fp，指向已经打开的inittab文件；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *token[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">parser_t</span> *parser = config_open2(<span class=\"string\">\"/etc/inittab\"</span>, fopen_for_read);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/libbb.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">parser_t</span> &#123;</span></span><br><span class=\"line\">    FILE *fp; </span><br><span class=\"line\">    <span class=\"keyword\">char</span> *data;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *<span class=\"built_in\">line</span>, *nline;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> line_alloc, nline_alloc;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lineno;</span><br><span class=\"line\">&#125; <span class=\"keyword\">parser_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>busybox解析inittab文件的操作如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class=\"line\">    <span class=\"comment\">/* optional_tty:ignored_runlevel:action:command</span></span><br><span class=\"line\"><span class=\"comment\">     * Delims are not to be collapsed and need exactly 4 tokens</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (config_read(parser, token, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"string\">\"#:\"</span>,</span><br><span class=\"line\">                PARSE_NORMAL &amp; ~(PARSE_TRIM | PARSE_COLLAPSE))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* order must correspond to SYSINIT..RESTART constants */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> actions[] ALIGN1 =</span><br><span class=\"line\">            <span class=\"string\">\"sysinit\\0\"</span><span class=\"string\">\"wait\\0\"</span><span class=\"string\">\"once\\0\"</span><span class=\"string\">\"respawn\\0\"</span><span class=\"string\">\"askfirst\\0\"</span></span><br><span class=\"line\">            <span class=\"string\">\"ctrlaltdel\\0\"</span><span class=\"string\">\"shutdown\\0\"</span><span class=\"string\">\"restart\\0\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> action;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *tty = token[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!token[<span class=\"number\">3</span>]) <span class=\"comment\">/* less than 4 tokens */</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> bad_entry;</span><br><span class=\"line\">        action = index_in_strings(actions, token[<span class=\"number\">2</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action &lt; <span class=\"number\">0</span> || !token[<span class=\"number\">3</span>][<span class=\"number\">0</span>]) <span class=\"comment\">/* token[3]: command */</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> bad_entry;</span><br><span class=\"line\">        <span class=\"comment\">/* turn .*TTY -&gt; /dev/TTY */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            tty = concat_path_file(<span class=\"string\">\"/dev/\"</span>, skip_dev_pfx(tty));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        new_init_action(<span class=\"number\">1</span> &lt;&lt; action, token[<span class=\"number\">3</span>], tty);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty[<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tty);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> bad_entry:</span><br><span class=\"line\">        message(L_LOG | L_CONSOLE, <span class=\"string\">\"Bad inittab entry at line %d\"</span>,</span><br><span class=\"line\">                parser-&gt;lineno);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    config_close(parser);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h3 id=\"busybox加载inittab过程分析\"><a href=\"#busybox加载inittab过程分析\" class=\"headerlink\" title=\"busybox加载inittab过程分析\"></a>busybox加载inittab过程分析</h3><h5 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h5><p>linux-4.9.115</p>\n<p>busybox-1.31.1</p>","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>busybox工具通过init_main()函数对inittab文件进行分析执行；</p>\n<p>init_main()函数通过parse_inittab()函数分析inittab文件，将文件中的每一行配置用new_init_action()函数；</p>\n<pre class=\"mermaid\">graph TB\n    init_main(init_main)-->parse_inittab(parse_inittab)--inittab-->new_init_action(new_init_action)</pre>\n\n\n\n\n\n\n\n<p>在parse_inittab()函数中</p>\n<p>如果不支持ENABLE_FEATURE_USE_INITTAB，或者支持ENABLE_FEATURE_USE_INITTAB时，未找到inittab文件；busybox使用默认的脚本操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parser == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;    </span><br><span class=\"line\">        <span class=\"comment\">/* No inittab file - set up some default behavior */</span></span><br><span class=\"line\">        <span class=\"comment\">/* Sysinit */</span></span><br><span class=\"line\">        new_init_action(SYSINIT, INIT_SCRIPT, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Askfirst shell on tty1-4 */</span></span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\"><span class=\"comment\">//<span class=\"doctag\">TODO:</span> VC_1 instead of \"\"? \"\" is console -&gt; ctty problems -&gt; angry users</span></span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, VC_2);</span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, VC_3);</span><br><span class=\"line\">        new_init_action(ASKFIRST, bb_default_login_shell, VC_4);</span><br><span class=\"line\">        <span class=\"comment\">/* Reboot on Ctrl-Alt-Del */</span></span><br><span class=\"line\">        new_init_action(CTRLALTDEL, <span class=\"string\">\"reboot\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Umount all filesystems on halt/reboot */</span></span><br><span class=\"line\">        new_init_action(SHUTDOWN, <span class=\"string\">\"umount -a -r\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Swapoff on halt/reboot */</span></span><br><span class=\"line\">        new_init_action(SHUTDOWN, <span class=\"string\">\"swapoff -a\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"comment\">/* Restart init when a QUIT is received */</span></span><br><span class=\"line\">        new_init_action(RESTART, <span class=\"string\">\"init\"</span>, <span class=\"string\">\"\"</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SYSINIT     0x01</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WAIT        0x02</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ONCE        0x04</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESPAWN     0x08</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ASKFIRST    0x10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CTRLALTDEL  0x20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHUTDOWN    0x40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESTART     0x80</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在没有inittab配置文件时，busybox会默认加载初始化脚本/etc/init.d/rcS；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"comment\">/* Default sysinit script. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> INIT_SCRIPT</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> INIT_SCRIPT  <span class=\"meta-string\">\"/etc/init.d/rcS\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<p>如果支持ENABLE_FEATURE_USE_INITTAB；busybox会解析inittab配置文件，根据inittab中的配置进行初始化；</p>\n<p>先在config_open2()函数中，申请一个struct parser_t结构体的内存空间，并初始化结构体成员fp，指向已经打开的inittab文件；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *token[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">parser_t</span> *parser = config_open2(<span class=\"string\">\"/etc/inittab\"</span>, fopen_for_read);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/libbb.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">parser_t</span> &#123;</span></span><br><span class=\"line\">    FILE *fp; </span><br><span class=\"line\">    <span class=\"keyword\">char</span> *data;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *<span class=\"built_in\">line</span>, *nline;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> line_alloc, nline_alloc;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lineno;</span><br><span class=\"line\">&#125; <span class=\"keyword\">parser_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>busybox解析inittab文件的操作如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init/init.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class=\"line\">    <span class=\"comment\">/* optional_tty:ignored_runlevel:action:command</span></span><br><span class=\"line\"><span class=\"comment\">     * Delims are not to be collapsed and need exactly 4 tokens</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (config_read(parser, token, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"string\">\"#:\"</span>,</span><br><span class=\"line\">                PARSE_NORMAL &amp; ~(PARSE_TRIM | PARSE_COLLAPSE))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* order must correspond to SYSINIT..RESTART constants */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> actions[] ALIGN1 =</span><br><span class=\"line\">            <span class=\"string\">\"sysinit\\0\"</span><span class=\"string\">\"wait\\0\"</span><span class=\"string\">\"once\\0\"</span><span class=\"string\">\"respawn\\0\"</span><span class=\"string\">\"askfirst\\0\"</span></span><br><span class=\"line\">            <span class=\"string\">\"ctrlaltdel\\0\"</span><span class=\"string\">\"shutdown\\0\"</span><span class=\"string\">\"restart\\0\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> action;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *tty = token[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!token[<span class=\"number\">3</span>]) <span class=\"comment\">/* less than 4 tokens */</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> bad_entry;</span><br><span class=\"line\">        action = index_in_strings(actions, token[<span class=\"number\">2</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action &lt; <span class=\"number\">0</span> || !token[<span class=\"number\">3</span>][<span class=\"number\">0</span>]) <span class=\"comment\">/* token[3]: command */</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> bad_entry;</span><br><span class=\"line\">        <span class=\"comment\">/* turn .*TTY -&gt; /dev/TTY */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            tty = concat_path_file(<span class=\"string\">\"/dev/\"</span>, skip_dev_pfx(tty));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        new_init_action(<span class=\"number\">1</span> &lt;&lt; action, token[<span class=\"number\">3</span>], tty);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty[<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tty);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> bad_entry:</span><br><span class=\"line\">        message(L_LOG | L_CONSOLE, <span class=\"string\">\"Bad inittab entry at line %d\"</span>,</span><br><span class=\"line\">                parser-&gt;lineno);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    config_close(parser);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>"},{"title":"u-boot中的tftp命令解析","date":"2020-06-27T03:54:24.000Z","_content":"\n\n\nu-boot中的tftp命令，采用UDP协议，tftp服务器使用UDP 69号端口，传送的数据包最大为512字节，双方采用超时重传机制；\n\n\n\n<!--more-->\n\n\n\n#### tftp命令\n\n命令：\n\n```c\ntftp Address FileName\n    Address: 用来保存文件的地址\n    FileName: 传送的文件名\n```\n\n\n\n应用举例：\n\n```\n=> setenv serverip 192.168.1.100\n=> setenv ipaddr 192.168.1.110\n```\n\ntftp下载：\n\n```\n=> tftp 0xa0000000 kernel.bin\n```\n\ntftp上传：\n\n```\n=> tftp 0xa0000000 kernel.bin 0x10000000\n```\n\n\n\nu-boot中的bootcmd命令：\n\n```\n=> print bootcmd\nbootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;      setenv bootargs 'root=/dev/mmcblk0 rw       init=/linuxrc       ip=192.168.1.110 console=ttyAMA0';      bootm 0x60003000 - 0x60500000;\n```\n\ntftp下载过程：\n\n```\nsmc911x: MAC **:**:**:**:**:**\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC **:**:**:**:**:**\nUsing smc911x-0 device\nTFTP from server 192.168.1.100; our IP address is 192.168.1.110\nFilename 'uImage'.\nLoad address: 0x60003000\nLoading: #################################################################\n\t #################################################################\n\t #################################################################\n\t #############################################\n\t 7.6 MiB/s\ndone\nBytes transferred = 3512664 (359958 hex)\n\nsmc911x: MAC **:**:**:**:**:**\nsmc911x: MAC **:**:**:**:**:**\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC **:**:**:**:**:**\nUsing smc911x-0 device\nTFTP from server 192.168.1.100; our IP address is 192.168.1.110\nFilename 'vexpress-v2p-ca9.dtb'.\nLoad address: 0x60500000\nLoading: ##\n\t 4.7 MiB/s\ndone\nBytes transferred = 14772 (39b4 hex)\n```\n\n\n\n#### tftp参数\n\ntftp需要的参数：\n\n| 参数             |\n| ---------------- |\n| tftp_remote_ip   |\n| net_ip           |\n| net_netmask      |\n| net_gateway      |\n| tftp_filename    |\n| tftp_state       |\n| tftp_block_size  |\n| timeout_ms       |\n| time_count_max   |\n| tftp_handler     |\n| tftp_remote_port |\n| tftp_our_port    |\n\n\n\n在tftp下载时，会先设置好这些tftp参数，然后开始向tftp服务器发送请求命令；\n\n\n\n#### tftp客户端状态\n\n通过tftp_state变量来描述：\n\n| 状态            | 说明             |\n| --------------- | ---------------- |\n| STATE_SEND_RRQ  | 发出读取请求     |\n| STATE_DATA      | 正在接收数据     |\n| STATE_TOO_LARGE | 文件太大         |\n| STATE_BAD_MAGIC | Magic错误        |\n| STATE_OACK      | 收到OACK应答     |\n| STATE_RECV_WRQ  | 同STATE_DATA     |\n| STATE_SEND_WRQ  | 同STATE_SEND_RRQ |\n\n\n\n#### tftp数据包类型\n\n| 类型       | 说明                                              |\n| ---------- | ------------------------------------------------- |\n| TFTP_RRQ   | 请求读取文件                                      |\n| TFTP_WRQ   | 请求写文件                                        |\n| TFTP_DATA  | 数据包                                            |\n| TFTP_ACK   | 确认应答包                                        |\n| TFTP_ERROR | 错误信息包                                        |\n| TFTP_OACK  | 服务器超时未收到客户端的ACK时，主动发送一个OACK包 |\n\n\n\n#### tftp主要的函数\n\ntftp功能实现代码位于net/tftp.c\n\n```c\nstatic void tftp_send(void)\n```\n\n根据tftp_state变量的值，发送不同的tftp数据包；\n\n```c\nstatic inline int store_block(int block, uchar *src, unsigned int len)\n```\n\n根据load_addr地址，将src开始，长度为len的block个数据块写入flash或内存中；\n\n```c\nstatic void tftp_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n              unsigned src, unsigned len)\n```\n\n处理收到的tftp数据包的函数；\n\n```c\nstatic void tftp_timeout_handler(void)\n```\n\n超时处理函数；\n\n```c\nvoid tftp_start(enum proto_t protocol)\n```\n\n初始化各个tftp参数，并发送tftp读请求；\n\n\n\n\n\n#### tftp下载流程\n\n1. 首先，由客户端初始化各tftp参数，并发出读写请求；\n\n2. 服务器收到请求并同意，打开连接，发送第一个数据包；\n\n3. 客户端收到数据包后发回确认，服务器在发送下一个数据包前必须确认收到客户端对上一个数据包的确认；\n\n4. 如果数据包在传输过程中丢失，服务器不会收到客户端的确认，服务器在超时后重新传输最后一个未被确认的数据包；\n\n5. 发送的数据包为512字节，如果数据包小于512字节，则表示该数据包是最后一个；如果传输的数据是512字节的整数倍，最后会再发送一个空数据包；\n\n\n\n![tftp流程](u-boot的tftp命令解析/tftp流程.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/u-boot的tftp命令解析.md","raw":"---\ntitle: u-boot中的tftp命令解析\ndate: 2020-06-27 11:54:24\ntags:\n---\n\n\n\nu-boot中的tftp命令，采用UDP协议，tftp服务器使用UDP 69号端口，传送的数据包最大为512字节，双方采用超时重传机制；\n\n\n\n<!--more-->\n\n\n\n#### tftp命令\n\n命令：\n\n```c\ntftp Address FileName\n    Address: 用来保存文件的地址\n    FileName: 传送的文件名\n```\n\n\n\n应用举例：\n\n```\n=> setenv serverip 192.168.1.100\n=> setenv ipaddr 192.168.1.110\n```\n\ntftp下载：\n\n```\n=> tftp 0xa0000000 kernel.bin\n```\n\ntftp上传：\n\n```\n=> tftp 0xa0000000 kernel.bin 0x10000000\n```\n\n\n\nu-boot中的bootcmd命令：\n\n```\n=> print bootcmd\nbootcmd=tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;      setenv bootargs 'root=/dev/mmcblk0 rw       init=/linuxrc       ip=192.168.1.110 console=ttyAMA0';      bootm 0x60003000 - 0x60500000;\n```\n\ntftp下载过程：\n\n```\nsmc911x: MAC **:**:**:**:**:**\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC **:**:**:**:**:**\nUsing smc911x-0 device\nTFTP from server 192.168.1.100; our IP address is 192.168.1.110\nFilename 'uImage'.\nLoad address: 0x60003000\nLoading: #################################################################\n\t #################################################################\n\t #################################################################\n\t #############################################\n\t 7.6 MiB/s\ndone\nBytes transferred = 3512664 (359958 hex)\n\nsmc911x: MAC **:**:**:**:**:**\nsmc911x: MAC **:**:**:**:**:**\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC **:**:**:**:**:**\nUsing smc911x-0 device\nTFTP from server 192.168.1.100; our IP address is 192.168.1.110\nFilename 'vexpress-v2p-ca9.dtb'.\nLoad address: 0x60500000\nLoading: ##\n\t 4.7 MiB/s\ndone\nBytes transferred = 14772 (39b4 hex)\n```\n\n\n\n#### tftp参数\n\ntftp需要的参数：\n\n| 参数             |\n| ---------------- |\n| tftp_remote_ip   |\n| net_ip           |\n| net_netmask      |\n| net_gateway      |\n| tftp_filename    |\n| tftp_state       |\n| tftp_block_size  |\n| timeout_ms       |\n| time_count_max   |\n| tftp_handler     |\n| tftp_remote_port |\n| tftp_our_port    |\n\n\n\n在tftp下载时，会先设置好这些tftp参数，然后开始向tftp服务器发送请求命令；\n\n\n\n#### tftp客户端状态\n\n通过tftp_state变量来描述：\n\n| 状态            | 说明             |\n| --------------- | ---------------- |\n| STATE_SEND_RRQ  | 发出读取请求     |\n| STATE_DATA      | 正在接收数据     |\n| STATE_TOO_LARGE | 文件太大         |\n| STATE_BAD_MAGIC | Magic错误        |\n| STATE_OACK      | 收到OACK应答     |\n| STATE_RECV_WRQ  | 同STATE_DATA     |\n| STATE_SEND_WRQ  | 同STATE_SEND_RRQ |\n\n\n\n#### tftp数据包类型\n\n| 类型       | 说明                                              |\n| ---------- | ------------------------------------------------- |\n| TFTP_RRQ   | 请求读取文件                                      |\n| TFTP_WRQ   | 请求写文件                                        |\n| TFTP_DATA  | 数据包                                            |\n| TFTP_ACK   | 确认应答包                                        |\n| TFTP_ERROR | 错误信息包                                        |\n| TFTP_OACK  | 服务器超时未收到客户端的ACK时，主动发送一个OACK包 |\n\n\n\n#### tftp主要的函数\n\ntftp功能实现代码位于net/tftp.c\n\n```c\nstatic void tftp_send(void)\n```\n\n根据tftp_state变量的值，发送不同的tftp数据包；\n\n```c\nstatic inline int store_block(int block, uchar *src, unsigned int len)\n```\n\n根据load_addr地址，将src开始，长度为len的block个数据块写入flash或内存中；\n\n```c\nstatic void tftp_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n              unsigned src, unsigned len)\n```\n\n处理收到的tftp数据包的函数；\n\n```c\nstatic void tftp_timeout_handler(void)\n```\n\n超时处理函数；\n\n```c\nvoid tftp_start(enum proto_t protocol)\n```\n\n初始化各个tftp参数，并发送tftp读请求；\n\n\n\n\n\n#### tftp下载流程\n\n1. 首先，由客户端初始化各tftp参数，并发出读写请求；\n\n2. 服务器收到请求并同意，打开连接，发送第一个数据包；\n\n3. 客户端收到数据包后发回确认，服务器在发送下一个数据包前必须确认收到客户端对上一个数据包的确认；\n\n4. 如果数据包在传输过程中丢失，服务器不会收到客户端的确认，服务器在超时后重新传输最后一个未被确认的数据包；\n\n5. 发送的数据包为512字节，如果数据包小于512字节，则表示该数据包是最后一个；如果传输的数据是512字节的整数倍，最后会再发送一个空数据包；\n\n\n\n![tftp流程](u-boot的tftp命令解析/tftp流程.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"u-boot的tftp命令解析","published":1,"updated":"2020-06-27T05:42:35.052Z","_id":"ckbx7tt8f0000k8g1fyw03twi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>u-boot中的tftp命令，采用UDP协议，tftp服务器使用UDP 69号端口，传送的数据包最大为512字节，双方采用超时重传机制；</p>\n<a id=\"more\"></a>\n\n\n\n<h4 id=\"tftp命令\"><a href=\"#tftp命令\" class=\"headerlink\" title=\"tftp命令\"></a>tftp命令</h4><p>命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tftp Address FileName</span><br><span class=\"line\">    Address: 用来保存文件的地址</span><br><span class=\"line\">    FileName: 传送的文件名</span><br></pre></td></tr></table></figure>\n\n\n\n<p>应用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; setenv serverip 192.168.1.100</span><br><span class=\"line\">&#x3D;&gt; setenv ipaddr 192.168.1.110</span><br></pre></td></tr></table></figure>\n\n<p>tftp下载：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; tftp 0xa0000000 kernel.bin</span><br></pre></td></tr></table></figure>\n\n<p>tftp上传：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; tftp 0xa0000000 kernel.bin 0x10000000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>u-boot中的bootcmd命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; print bootcmd</span><br><span class=\"line\">bootcmd&#x3D;tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;      setenv bootargs &#39;root&#x3D;&#x2F;dev&#x2F;mmcblk0 rw       init&#x3D;&#x2F;linuxrc       ip&#x3D;192.168.1.110 console&#x3D;ttyAMA0&#39;;      bootm 0x60003000 - 0x60500000;</span><br></pre></td></tr></table></figure>\n\n<p>tftp下载过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.100; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;uImage&#39;.</span><br><span class=\"line\">Load address: 0x60003000</span><br><span class=\"line\">Loading: #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #############################################</span><br><span class=\"line\">\t 7.6 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 3512664 (359958 hex)</span><br><span class=\"line\"></span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.100; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;vexpress-v2p-ca9.dtb&#39;.</span><br><span class=\"line\">Load address: 0x60500000</span><br><span class=\"line\">Loading: ##</span><br><span class=\"line\">\t 4.7 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 14772 (39b4 hex)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"tftp参数\"><a href=\"#tftp参数\" class=\"headerlink\" title=\"tftp参数\"></a>tftp参数</h4><p>tftp需要的参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tftp_remote_ip</td>\n</tr>\n<tr>\n<td>net_ip</td>\n</tr>\n<tr>\n<td>net_netmask</td>\n</tr>\n<tr>\n<td>net_gateway</td>\n</tr>\n<tr>\n<td>tftp_filename</td>\n</tr>\n<tr>\n<td>tftp_state</td>\n</tr>\n<tr>\n<td>tftp_block_size</td>\n</tr>\n<tr>\n<td>timeout_ms</td>\n</tr>\n<tr>\n<td>time_count_max</td>\n</tr>\n<tr>\n<td>tftp_handler</td>\n</tr>\n<tr>\n<td>tftp_remote_port</td>\n</tr>\n<tr>\n<td>tftp_our_port</td>\n</tr>\n</tbody></table>\n<p>在tftp下载时，会先设置好这些tftp参数，然后开始向tftp服务器发送请求命令；</p>\n<h4 id=\"tftp客户端状态\"><a href=\"#tftp客户端状态\" class=\"headerlink\" title=\"tftp客户端状态\"></a>tftp客户端状态</h4><p>通过tftp_state变量来描述：</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>STATE_SEND_RRQ</td>\n<td>发出读取请求</td>\n</tr>\n<tr>\n<td>STATE_DATA</td>\n<td>正在接收数据</td>\n</tr>\n<tr>\n<td>STATE_TOO_LARGE</td>\n<td>文件太大</td>\n</tr>\n<tr>\n<td>STATE_BAD_MAGIC</td>\n<td>Magic错误</td>\n</tr>\n<tr>\n<td>STATE_OACK</td>\n<td>收到OACK应答</td>\n</tr>\n<tr>\n<td>STATE_RECV_WRQ</td>\n<td>同STATE_DATA</td>\n</tr>\n<tr>\n<td>STATE_SEND_WRQ</td>\n<td>同STATE_SEND_RRQ</td>\n</tr>\n</tbody></table>\n<h4 id=\"tftp数据包类型\"><a href=\"#tftp数据包类型\" class=\"headerlink\" title=\"tftp数据包类型\"></a>tftp数据包类型</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TFTP_RRQ</td>\n<td>请求读取文件</td>\n</tr>\n<tr>\n<td>TFTP_WRQ</td>\n<td>请求写文件</td>\n</tr>\n<tr>\n<td>TFTP_DATA</td>\n<td>数据包</td>\n</tr>\n<tr>\n<td>TFTP_ACK</td>\n<td>确认应答包</td>\n</tr>\n<tr>\n<td>TFTP_ERROR</td>\n<td>错误信息包</td>\n</tr>\n<tr>\n<td>TFTP_OACK</td>\n<td>服务器超时未收到客户端的ACK时，主动发送一个OACK包</td>\n</tr>\n</tbody></table>\n<h4 id=\"tftp主要的函数\"><a href=\"#tftp主要的函数\" class=\"headerlink\" title=\"tftp主要的函数\"></a>tftp主要的函数</h4><p>tftp功能实现代码位于net/tftp.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tftp_send</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>根据tftp_state变量的值，发送不同的tftp数据包；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">store_block</span><span class=\"params\">(<span class=\"keyword\">int</span> block, uchar *src, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>根据load_addr地址，将src开始，长度为len的block个数据块写入flash或内存中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tftp_handler</span><span class=\"params\">(uchar *pkt, <span class=\"keyword\">unsigned</span> dest, struct in_addr sip,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">              <span class=\"keyword\">unsigned</span> src, <span class=\"keyword\">unsigned</span> len)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>处理收到的tftp数据包的函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tftp_timeout_handler</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>超时处理函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tftp_start</span><span class=\"params\">(<span class=\"keyword\">enum</span> <span class=\"keyword\">proto_t</span> protocol)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>初始化各个tftp参数，并发送tftp读请求；</p>\n<h4 id=\"tftp下载流程\"><a href=\"#tftp下载流程\" class=\"headerlink\" title=\"tftp下载流程\"></a>tftp下载流程</h4><ol>\n<li><p>首先，由客户端初始化各tftp参数，并发出读写请求；</p>\n</li>\n<li><p>服务器收到请求并同意，打开连接，发送第一个数据包；</p>\n</li>\n<li><p>客户端收到数据包后发回确认，服务器在发送下一个数据包前必须确认收到客户端对上一个数据包的确认；</p>\n</li>\n<li><p>如果数据包在传输过程中丢失，服务器不会收到客户端的确认，服务器在超时后重新传输最后一个未被确认的数据包；</p>\n</li>\n<li><p>发送的数据包为512字节，如果数据包小于512字节，则表示该数据包是最后一个；如果传输的数据是512字节的整数倍，最后会再发送一个空数据包；</p>\n</li>\n</ol>\n<p><img src=\"/2020/06/27/u-boot%E7%9A%84tftp%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/tftp%E6%B5%81%E7%A8%8B.jpg\" alt=\"tftp流程\"></p>\n","site":{"data":{}},"excerpt":"<p>u-boot中的tftp命令，采用UDP协议，tftp服务器使用UDP 69号端口，传送的数据包最大为512字节，双方采用超时重传机制；</p>","more":"<h4 id=\"tftp命令\"><a href=\"#tftp命令\" class=\"headerlink\" title=\"tftp命令\"></a>tftp命令</h4><p>命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tftp Address FileName</span><br><span class=\"line\">    Address: 用来保存文件的地址</span><br><span class=\"line\">    FileName: 传送的文件名</span><br></pre></td></tr></table></figure>\n\n\n\n<p>应用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; setenv serverip 192.168.1.100</span><br><span class=\"line\">&#x3D;&gt; setenv ipaddr 192.168.1.110</span><br></pre></td></tr></table></figure>\n\n<p>tftp下载：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; tftp 0xa0000000 kernel.bin</span><br></pre></td></tr></table></figure>\n\n<p>tftp上传：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; tftp 0xa0000000 kernel.bin 0x10000000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>u-boot中的bootcmd命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&gt; print bootcmd</span><br><span class=\"line\">bootcmd&#x3D;tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb;      setenv bootargs &#39;root&#x3D;&#x2F;dev&#x2F;mmcblk0 rw       init&#x3D;&#x2F;linuxrc       ip&#x3D;192.168.1.110 console&#x3D;ttyAMA0&#39;;      bootm 0x60003000 - 0x60500000;</span><br></pre></td></tr></table></figure>\n\n<p>tftp下载过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.100; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;uImage&#39;.</span><br><span class=\"line\">Load address: 0x60003000</span><br><span class=\"line\">Loading: #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #################################################################</span><br><span class=\"line\">\t #############################################</span><br><span class=\"line\">\t 7.6 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 3512664 (359958 hex)</span><br><span class=\"line\"></span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">smc911x: detected LAN9118 controller</span><br><span class=\"line\">smc911x: phy initialized</span><br><span class=\"line\">smc911x: MAC **:**:**:**:**:**</span><br><span class=\"line\">Using smc911x-0 device</span><br><span class=\"line\">TFTP from server 192.168.1.100; our IP address is 192.168.1.110</span><br><span class=\"line\">Filename &#39;vexpress-v2p-ca9.dtb&#39;.</span><br><span class=\"line\">Load address: 0x60500000</span><br><span class=\"line\">Loading: ##</span><br><span class=\"line\">\t 4.7 MiB&#x2F;s</span><br><span class=\"line\">done</span><br><span class=\"line\">Bytes transferred &#x3D; 14772 (39b4 hex)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"tftp参数\"><a href=\"#tftp参数\" class=\"headerlink\" title=\"tftp参数\"></a>tftp参数</h4><p>tftp需要的参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tftp_remote_ip</td>\n</tr>\n<tr>\n<td>net_ip</td>\n</tr>\n<tr>\n<td>net_netmask</td>\n</tr>\n<tr>\n<td>net_gateway</td>\n</tr>\n<tr>\n<td>tftp_filename</td>\n</tr>\n<tr>\n<td>tftp_state</td>\n</tr>\n<tr>\n<td>tftp_block_size</td>\n</tr>\n<tr>\n<td>timeout_ms</td>\n</tr>\n<tr>\n<td>time_count_max</td>\n</tr>\n<tr>\n<td>tftp_handler</td>\n</tr>\n<tr>\n<td>tftp_remote_port</td>\n</tr>\n<tr>\n<td>tftp_our_port</td>\n</tr>\n</tbody></table>\n<p>在tftp下载时，会先设置好这些tftp参数，然后开始向tftp服务器发送请求命令；</p>\n<h4 id=\"tftp客户端状态\"><a href=\"#tftp客户端状态\" class=\"headerlink\" title=\"tftp客户端状态\"></a>tftp客户端状态</h4><p>通过tftp_state变量来描述：</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>STATE_SEND_RRQ</td>\n<td>发出读取请求</td>\n</tr>\n<tr>\n<td>STATE_DATA</td>\n<td>正在接收数据</td>\n</tr>\n<tr>\n<td>STATE_TOO_LARGE</td>\n<td>文件太大</td>\n</tr>\n<tr>\n<td>STATE_BAD_MAGIC</td>\n<td>Magic错误</td>\n</tr>\n<tr>\n<td>STATE_OACK</td>\n<td>收到OACK应答</td>\n</tr>\n<tr>\n<td>STATE_RECV_WRQ</td>\n<td>同STATE_DATA</td>\n</tr>\n<tr>\n<td>STATE_SEND_WRQ</td>\n<td>同STATE_SEND_RRQ</td>\n</tr>\n</tbody></table>\n<h4 id=\"tftp数据包类型\"><a href=\"#tftp数据包类型\" class=\"headerlink\" title=\"tftp数据包类型\"></a>tftp数据包类型</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TFTP_RRQ</td>\n<td>请求读取文件</td>\n</tr>\n<tr>\n<td>TFTP_WRQ</td>\n<td>请求写文件</td>\n</tr>\n<tr>\n<td>TFTP_DATA</td>\n<td>数据包</td>\n</tr>\n<tr>\n<td>TFTP_ACK</td>\n<td>确认应答包</td>\n</tr>\n<tr>\n<td>TFTP_ERROR</td>\n<td>错误信息包</td>\n</tr>\n<tr>\n<td>TFTP_OACK</td>\n<td>服务器超时未收到客户端的ACK时，主动发送一个OACK包</td>\n</tr>\n</tbody></table>\n<h4 id=\"tftp主要的函数\"><a href=\"#tftp主要的函数\" class=\"headerlink\" title=\"tftp主要的函数\"></a>tftp主要的函数</h4><p>tftp功能实现代码位于net/tftp.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tftp_send</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>根据tftp_state变量的值，发送不同的tftp数据包；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">store_block</span><span class=\"params\">(<span class=\"keyword\">int</span> block, uchar *src, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>根据load_addr地址，将src开始，长度为len的block个数据块写入flash或内存中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tftp_handler</span><span class=\"params\">(uchar *pkt, <span class=\"keyword\">unsigned</span> dest, struct in_addr sip,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">              <span class=\"keyword\">unsigned</span> src, <span class=\"keyword\">unsigned</span> len)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>处理收到的tftp数据包的函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tftp_timeout_handler</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>超时处理函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tftp_start</span><span class=\"params\">(<span class=\"keyword\">enum</span> <span class=\"keyword\">proto_t</span> protocol)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>初始化各个tftp参数，并发送tftp读请求；</p>\n<h4 id=\"tftp下载流程\"><a href=\"#tftp下载流程\" class=\"headerlink\" title=\"tftp下载流程\"></a>tftp下载流程</h4><ol>\n<li><p>首先，由客户端初始化各tftp参数，并发出读写请求；</p>\n</li>\n<li><p>服务器收到请求并同意，打开连接，发送第一个数据包；</p>\n</li>\n<li><p>客户端收到数据包后发回确认，服务器在发送下一个数据包前必须确认收到客户端对上一个数据包的确认；</p>\n</li>\n<li><p>如果数据包在传输过程中丢失，服务器不会收到客户端的确认，服务器在超时后重新传输最后一个未被确认的数据包；</p>\n</li>\n<li><p>发送的数据包为512字节，如果数据包小于512字节，则表示该数据包是最后一个；如果传输的数据是512字节的整数倍，最后会再发送一个空数据包；</p>\n</li>\n</ol>\n<p><img src=\"/2020/06/27/u-boot%E7%9A%84tftp%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/tftp%E6%B5%81%E7%A8%8B.jpg\" alt=\"tftp流程\"></p>"},{"title":"linux-kernel中的tty驱动","date":"2020-08-02T09:54:21.000Z","_content":"\n\n\nTTY 是 Teletypewriter的缩写（Teleprinter、TeletypewriterTele-Type，缩写为 TTY），中文电传打字机简称电传，是远距离打印交换的编写形式；\n\n\n在linux中tty表示各种终端，通常是和硬件相对应，tty用来指任何的串口设备，如：输入设备键盘鼠标、输出设备显示器、虚拟的pty等；\n\n<!--more-->\n\n\n\n\n### 0. 简介\n\n\n\ntty驱动、uart驱动存在密切联系，tty设备包括uart，uart设备的工作依赖于tty设备，uart是tty的上层，内核中有完整的tty驱动，uart设备可以使用tty驱动进行封装；而内核中也有完整的uart驱动，两者相互独立又密切相关；本文主要讲解tty驱动相关的内容，以控制台驱动为例讲述tty驱动的应用，关于uart驱动方面内容，请参考下一文uart驱动；\n\n\n\n\ntty驱动程序的核心在标准字符设备驱动层之下；\n\n\nlinux内核中的tty层次结构，包含：tty核心、tty线路规程、tty驱动；\n\n\n1. tty核心(tty_core)：整个tty设备的抽象，对用户提供统一的接口，用户空间通过设备文件与tty_core交互；tty_core根据用户空间操作类型，选择将数据交给line discipline和tty_driver；\n\n\n2. tty线路规程(line discipline)：对传输数据的格式化，把从用户或硬件接收的数据格式化，这种格式化使用协议完成转换，如：蓝牙；处理之后，将数据交给tty_driver；\n\n\n3. tty驱动(tty_driver)：tty设备对应的驱动，将字符转换成硬件可以理解的字符，将其传给硬件设备；并从硬件接收数据；\n\n![tty层次关系](linux-kernel中的tty驱动/tty层次关系.jpg)\n\n\ntty核心和线路规程由内核提供，驱动工程师只需要完成tty驱动部分代码就可以使用tty了；\n\n\n多数时候tty核心和tty驱动之间的数据传输会经历tty线路规程的转换，但是tty驱动和tty核心之间也可以直接传输数据；tty核心根据操作类型选择和线路规程和tty驱动交互；如：设置硬件的ioctl直接交给tty_driver处理；而read/write操作交给线路规程处理；\n\n\n1) 发送数据流程：tty核心从用户空间获取到将要发送给tty设备的数据，tty核心将数据传递给tty线路规程驱动，然后数据被传递到tty驱动，tty驱动将数据转换为可以发送给硬件的格式；\n\n\n2) 接收数据流程：tty硬件将接收到的数据上交给tty驱动，进入tty线路规程驱动，再进入tty核心，被传递给用户空间；\n\n\ntty驱动程序有三种类型：控制台、串口和pty；控制台和pty驱动程序已经在内核中稳定使用，使用tty核心与用户和系统交互的新驱动都可以看做是串口驱动程序；\n\n\ntty驱动代码位于drivers/tty目录；\n\n\n\n\n### 1. tty核心\n\n\ntty核心是所有tty类型驱动的顶层架构，向应用层提供了统一的接口；用户态的open、close、read、write系统调用首先到达tty核心；\n\n\ntty核心在tty_io.c文件中由内核实现，定义了tty设备需要的核心数据结构，和一些需要操作；\n\n\n\n\n#### 1.1 tty重要数据结构\n\n\n\n\n**1) tty_driver**\n\n\ntty驱动程序的主要数据结构是struct tty_driver，规定了tty驱动程序和高层之间的编程接口，用来向tty核心注册和注销驱动程序；操作包含在头文件<linux/tty_driver.h>中；\n\n\n```c\n// linux/tty_driver.h\nstruct tty_driver {\n    int magic;      /* magic number for this structure */\n    struct kref kref;   /* Reference management */\n    struct cdev **cdevs;\n    struct module   *owner;\n    const char  *driver_name;\n    const char  *name;\n    int name_base;  /* offset of printed name */\n    int major;      /* major device number */\n    int minor_start;    /* start of minor device number */\n    unsigned int    num;    /* number of devices allocated */\n    short   type;       /* type of tty driver */\n    short   subtype;    /* subtype of tty driver */\n    struct ktermios init_termios; /* Initial termios */\n    unsigned long   flags;      /* tty driver flags */\n    struct proc_dir_entry *proc_entry; /* /proc fs entry */\n    struct tty_driver *other; /* only used for the PTY driver */\n\n    /*\n     * Pointer to the tty data structures\n     */\n    struct tty_struct **ttys;\n    struct tty_port **ports;\n    struct ktermios **termios;\n    void *driver_state;\n\n    /*\n     * Driver methods\n     */\n    const struct tty_operations *ops;\n    struct list_head tty_drivers;\n};\n```\n\n\n\n\ntty设备的所有操作都包含在tty_driver结构体中，内核提供alloc_tty_driver()函数来分配tty_driver结构体，参数是该驱动支持的tty设备的数量；\n\n\n```c\n\t// 分配tty驱动程序\n\tstruct tty_driver *normal;\n\tnormal = alloc_tty_driver(nr);\n```\n\n\nalloc_tty_driver()函数的实现如下：\n\n\n```c\nstatic inline struct tty_driver *alloc_tty_driver(unsigned int lines)\n{\n    struct tty_driver *ret = tty_alloc_driver(lines, 0);\n    if (IS_ERR(ret))\n        return NULL;\n    return ret;\n}\n\n#define tty_alloc_driver(lines, flags) \\\n        __tty_alloc_driver(lines, THIS_MODULE, flags)\n\n// tty_io.c\nstruct tty_driver *__tty_alloc_driver(unsigned int lines, struct module *owner,\n         unsigned long flags)\n{\n\tstruct tty_driver *driver;\n\n\tdriver = kzalloc(sizeof(struct tty_driver), GFP_KERNEL);\n    if (!driver)\n        return ERR_PTR(-ENOMEM);\n    ......\n}\n```\n\n\n申请成功后，alloc_tty_driver()函数将申请到的tty_driver结构体作为返回值返回，之后，需要对tty_driver进行初始化，再通过调用tty_register_driver()来注册进内核；\n\n\n\n\n**2) tty_operations**\n\n\ntty_operations结构中包含所有的回调函数，被tty驱动程序设置，并被tty核心调用；\n\n\n```c\n// linux/tty_driver.h\nstruct tty_operations {\n    struct tty_struct * (*lookup)(struct tty_driver *driver,\n            struct inode *inode, int idx);\n    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);\n    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n    int  (*open)(struct tty_struct * tty, struct file * filp);\n    void (*close)(struct tty_struct * tty, struct file * filp);\n    void (*shutdown)(struct tty_struct *tty);\n    void (*cleanup)(struct tty_struct *tty);\n    int  (*write)(struct tty_struct * tty,\n              const unsigned char *buf, int count);\n    int  (*put_char)(struct tty_struct *tty, unsigned char ch);\n    void (*flush_chars)(struct tty_struct *tty);\n    int  (*write_room)(struct tty_struct *tty);\n    int  (*chars_in_buffer)(struct tty_struct *tty);\n    int  (*ioctl)(struct tty_struct *tty,\n            unsigned int cmd, unsigned long arg);\n    long (*compat_ioctl)(struct tty_struct *tty,\n                 unsigned int cmd, unsigned long arg);\n    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);\n    void (*throttle)(struct tty_struct * tty);\n    void (*unthrottle)(struct tty_struct * tty);\n    void (*stop)(struct tty_struct *tty);\n    void (*start)(struct tty_struct *tty);\n    void (*hangup)(struct tty_struct *tty);\n    int (*break_ctl)(struct tty_struct *tty, int state);\n    void (*flush_buffer)(struct tty_struct *tty);\n    void (*set_ldisc)(struct tty_struct *tty);\n    void (*wait_until_sent)(struct tty_struct *tty, int timeout);\n    void (*send_xchar)(struct tty_struct *tty, char ch);\n    int (*tiocmget)(struct tty_struct *tty);\n    int (*tiocmset)(struct tty_struct *tty,\n            unsigned int set, unsigned int clear);\n    int (*resize)(struct tty_struct *tty, struct winsize *ws);\n    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);\n\t......\n};\n```\n\n\n\n\n**3) tty_struct**\n\n\ntty核心使用tty_struct结构保存当前特定tty端口的状态；除了个别成员外基本上所有成员都只能被tty核心使用；\n\n\n```c\n// linux/tty_driver.h\nstruct tty_struct {\n    int magic;\n    struct kref kref;\n    struct device *dev;\n    struct tty_driver *driver;\n    const struct tty_operations *ops;\n    int index;\n\n    /* Protects ldisc changes: Lock tty not pty */\n    struct ld_semaphore ldisc_sem;\n    struct tty_ldisc *ldisc;\n\n    /* Termios values are protected by the termios rwsem */\n    struct ktermios termios, termios_locked;\n    struct termiox *termiox;    /* May be NULL for unsupported */\n    char name[64];\n\n    struct tty_struct *link;\n    struct fasync_struct *fasync;\n    int alt_speed;      /* For magic substitution of 38400 bps */\n    wait_queue_head_t write_wait;\n    wait_queue_head_t read_wait;\n\n#define N_TTY_BUF_SIZE 4096\n    unsigned char *write_buf;\n    int write_cnt;\n    /* If the tty has a pending do_SAK, queue it here - akpm */\n    struct work_struct SAK_work;\n    struct tty_port *port;\n};\n```\n\n\n\n\ntty端口的状态都包含在tty_struct结构体中，内核提供alloc_tty_struct()函数来分配tty_struct结构体，并对成员进行初始化操作，参数是该驱动的tty_driver和设备的索引号；该函数在tty核心中实现并调用，不需要在tty驱动中明确调用；\n\n\n```c\n\t// 分配tty驱动程序\n\tstruct tty_struct *tty;\n\ttty = alloc_tty_struct(driver, idx);\n```\n\n\n\n\n#### 1.2 tty的注册和卸载\n\n\n\n\n**1) 注册**\n\n\ntty驱动的注册，由tty_register_driver()函数完成，用于将串口驱动tty_driver注册到内核；注册时会分配主设备号和次设备号，主设备号对应驱动程序，告知内核需要使用哪个驱动程序驱动该设备，次设备号对应具体的设备；\n\n\ntty_register_driver()函数用来向内核注册tty设备，根据tty_driver的所有次设备号，创建不同的sysfs文件；会使用fs/char_dev.c中提供的字符设备接口注册字符设备；使用fs/proc/proc_tty.c中的函数创建/proc/tty文件；在使用tty_register_driver()函数注册tty驱动之前，需要先对申请到的tty_driver结构体成员进行初始化；tty_register_driver()函数的参数是已经初始化过的tty_driver结构体指针；\n\n\n```c\n// drivers/tty/tty_io.c\nint tty_register_driver(struct tty_driver *driver)\n{\n\talloc_chrdev_region();\n    register_chrdev_region();\n    tty_cdev_add();\n    list_add(&driver->tty_drivers, &tty_drivers);\n    // 注册所控制的设备\n    if (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV)) {\n        for (i = 0; i < driver->num; i++) {\n            d = tty_register_device(driver, i, NULL);\n            if (IS_ERR(d)) {\n                error = PTR_ERR(d);\n                goto err_unreg_devs;\n            }\n        }\n    }\n}\n```\n\n\n在tty_cdev_add()函数中，将字符设备操作集指定为tty_fops，之后将tty_driver添加到tty_driver结构体中的tty_drivers链表中，可以通过设备号找到对应的driver；最后通过tty_register_device()函数注册tty驱动所控制的硬件设备；\n\n\n\n\n**2) 卸载**\n\n\ntty驱动的卸载，由tty_unregister_driver()函数完成，用于注销已注册的tty_driver；\n\n\n```c\n// drivers/tty/tty_io.c\nint tty_unregister_driver(struct tty_driver *driver)\n{\n    unregister_chrdev_region(MKDEV(driver->major, driver->minor_start),\n                driver->num);\n\tlist_del(&driver->tty_drivers);\n}\n```\n\n\n\n\n从注册过程中可以得知，tty设备所有的操作都包含在tty_fops结构体中；\n\n\n```c\n// drivers/tty/tty_io.c\nstatic const struct file_operations tty_fops = {\n    .llseek     = no_llseek,\n    .read       = tty_read,\n    .write      = tty_write,\n    .poll       = tty_poll,\n    .unlocked_ioctl = tty_ioctl,\n    .compat_ioctl   = tty_compat_ioctl,\n    .open       = tty_open,\n    .release    = tty_release,\n    .fasync     = tty_fasync,\n};\n```\n\n\n\n\n特定的tty设备驱动的主要工作是填充tty_driver结构体中的成员；\n\n\n\n\n#### 1.3 tty的打开和关闭\n\n\ntty设备的打开和关闭操作，在tty_io.c中实现通过tty_open和tty_release函数实现；tty_open和tty_release函数保持对tty打开的设备计数；\n\n\n**1) open**\n\n\n用户态使用open函数打开设备节点时，对应tty_fops结构体中的tty_open函数被调用；tty驱动程序一定要设置open成员操作，否则用户态调用open时，将返回-ENODEV；\n\n\n```c\nstatic int tty_open(struct inode *inode, struct file *filp)\n{\n    struct tty_struct *tty;\n    struct tty_driver *driver = NULL;\n    int index;\n    dev_t device = inode->i_rdev;\n\n    nonseekable_open(inode, filp);\n\nretry_open:\n    retval = tty_alloc_file(filp);\n    if (retval)\n        return -ENOMEM;\n\n    tty = tty_open_current_tty(device, filp);\n    if (!tty) {\n        mutex_lock(&tty_mutex);\n        driver = tty_lookup_driver(device, filp, &noctty, &index);\n\n        /* check whether we're reopening an existing tty */\n        tty = tty_driver_lookup_tty(driver, inode, index);\n\n        if (tty) {\n            mutex_unlock(&tty_mutex);\n            retval = tty_lock_interruptible(tty);\n\n            /* safe to drop the kref from tty_driver_lookup_tty() */\n            tty_kref_put(tty);\n            retval = tty_reopen(tty);\n\n        } else { /* Returns with the tty_lock held for now */\n            tty = tty_init_dev(driver, index);\n            mutex_unlock(&tty_mutex);\n        }\n\n        tty_driver_kref_put(driver);\n    }\n\n    tty_add_file(tty, filp);\n\t......\n    if (tty->ops->open)\n        retval = tty->ops->open(tty, filp);\n    else\n        retval = -ENODEV;\n    filp->f_flags = saved_flags;\n\t......\n}\n```\n\n\n\n\ntty_alloc_file()函数\n\n\n每一个打开的tty都有一个私有数据tty_file_private结构，在tty_alloc_file()函数中用private_data指针指向该结构；\n\n\n```c\nint tty_alloc_file(struct file *file)\n{\n    struct tty_file_private *priv;\n\n    priv = kmalloc(sizeof(*priv), GFP_KERNEL);\n    if (!priv)\n        return -ENOMEM;\n\n    file->private_data = priv;\n\n    return 0;\n}\n```\n\n\n\n\n```c\n// linux/tty.h\n/* Each of a tty's open files has private_data pointing to tty_file_private */\nstruct tty_file_private {\n    struct tty_struct *tty;\n    struct file *file;\n    struct list_head list;\n};\n```\n\n\n\n\ntty_lookup_driver()函数查找tty_driver链表，找到注册时添加的tty_driver，然后调用tty_driver的ops->open函数打开具体的tty设备；\n\n\n```c\n\tstruct tty_driver *driver = NULL;\n\tdriver = tty_lookup_driver(device, filp, &noctty, &index);\n```\n\n\n\n\n```c\nstatic struct tty_driver *tty_lookup_driver(dev_t device, struct file *filp,\n        int *noctty, int *index)\n{\n\t......\n    default:\n        driver = get_tty_driver(device, index);\n        if (!driver)\n            return ERR_PTR(-ENODEV);\n        break;\n    }\n    return driver;\n}    \n```\n\n\n\n\n```c\nstatic struct tty_driver *get_tty_driver(dev_t device, int *index)\n{\n    struct tty_driver *p;\n\n    list_for_each_entry(p, &tty_drivers, tty_drivers) {\n        dev_t base = MKDEV(p->major, p->minor_start);\n        if (device < base || device >= base + p->num)\n            continue;\n        *index = device - base;\n        return tty_driver_kref_get(p);\n    }\n    return NULL;\n}\n```\n\n\n\n\ntty_reopen()\n\n\n\n\ntty_init_dev()\n\n\n\n\n**2) release**\n\n\ntty_release()函数通过tty->ops->close操作来关闭tty设备；\n\n\n```c\nint tty_release(struct inode *inode, struct file *filp)\n{\n    struct tty_struct *tty = file_tty(filp);\n    struct tty_struct *o_tty = NULL;\n    long    timeout = 0;\n\t......\n    if (tty->ops->close)\n        tty->ops->close(tty, filp);\n\n    tty_del_file(filp);\n\n    /*\n     * Ask the line discipline code to release its structures\n     */\n    tty_ldisc_release(tty);\n\n    /* Wait for pending work before tty destruction commmences */\n    tty_flush_works(tty);\n\t......\n}\n```\n\n\n\n\n#### 1.4 tty的读写\n\n\n\n\n**1) write**\n\n\n在用户态调用write系统调用函数将数据发送给硬件时，内核将数据和大小发送给tty驱动程序的write操作；\n\n\n由于tty硬件速度和缓冲区大小等原因，当write时写操作程序处理的数据不能同时发送出去，write函数将返回发送给硬件的字符数；用户态可以通过write系统条用函数的返回值，判断是否写入了所有的数据；\n\n\ntty设备文件的写操作通过tty_fops结构体中的tty_write函数实现；\n\n\n```c\nstatic ssize_t tty_write(struct file *file, const char __user *buf,\n                        size_t count, loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n    ssize_t ret;\n\n    if (tty_paranoia_check(tty, file_inode(file), \"tty_write\"))\n        return -EIO;\n    if (!tty || !tty->ops->write ||\n        (test_bit(TTY_IO_ERROR, &tty->flags)))\n            return -EIO;\n    /* Short term debug to catch buggy drivers */\n    if (tty->ops->write_room == NULL)\n        printk(KERN_ERR \"tty driver %s lacks a write_room method.\\n\",\n            tty->driver->name);\n    ld = tty_ldisc_ref_wait(tty);\n    if (!ld->ops->write)\n        ret = -EIO;\n    else\n        ret = do_tty_write(ld->ops->write, tty, file, buf, count);\n    tty_ldisc_deref(ld);\n    return ret;\n}\n```\n\n\ntty_write()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，在do_tty_write(ld->ops->write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld->ops->write函数，进行具体的写入操作；\n\n\n```c\nstatic inline ssize_t do_tty_write(\n    ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t),\n    struct tty_struct *tty,\n    struct file *file,\n    const char __user *buf,\n    size_t count)\n{\n    chunk = 2048;\n    if (test_bit(TTY_NO_WRITE_SPLIT, &tty->flags))\n        chunk = 65536;\n\n    for (;;) {\n        if (copy_from_user(tty->write_buf, buf, size))\n            break;\n        ret = write(tty, file, tty->write_buf, size);\n    }\n}\n```\n\n\n在调用do_tty_write()函数前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&ld->tty->ldisc_sem锁；\n\n\n```c\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\nldsem_up_read(&ld->tty->ldisc_sem);\n```\n\n\n在do_tty_write()函数中，默认一次写入数据大小为2048字节，如果设置了TTY_NO_WRITE_SPLIT，可以一次写入65536字节数据；\n\n\ntty->write_buf，是写操作的临时缓冲区，存放通过copy_from_user从用户空间获取的数据；\n\n\ntty->write_cnt，是临时缓冲区的大小；\n\n\n\n\ntty_write通过ld->ops->write操作来完成数据的写入操作；\n\n\n\n\n**2) read**\n\n\ntty设备文件的写操作通过tty_fops结构体中的tty_read函数实现；\n\n\n```c\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\n            loff_t *ppos)\n{\n    int i;\n    struct inode *inode = file_inode(file);\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    if (tty_paranoia_check(tty, inode, \"tty_read\"))\n        return -EIO;\n    if (!tty || (test_bit(TTY_IO_ERROR, &tty->flags)))\n        return -EIO;\n\n    /* We want to wait for the line discipline to sort out in this\n       situation */\n    ld = tty_ldisc_ref_wait(tty);\n    if (ld->ops->read)\n        i = ld->ops->read(tty, file, buf, count);\n    else\n        i = -EIO;\n    tty_ldisc_deref(ld);\n\n    if (i > 0)\n        tty_update_time(&inode->i_atime);\n\n    return i;\n}\n```\n\n\ntty_read()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，使用tty_ldisc_ops结构中的ld->ops->read函数，进行具体的读取操作；\n\n\nld->ops->read(tty, file, buf, count)\n\n\n在读取操作前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&ld->tty->ldisc_sem锁；\n\n\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\n\n\nldsem_up_read(&ld->tty->ldisc_sem);\n\n\n\n\ntty_read通过ld->ops->read操作来完成数据的读取操作；\n\n\n\n\n#### 1.5 tty线路设置\n\n\n用户态要改变线路设置，或者获取当前的线路设置时，只需要调用多个termios用户空间库函数，或者对tty设备节点调用ioctl操作；在tty核心会把这两种操作转换为tty驱动程序的回调函数或ioctl操作；大部分temios用户空间函数会被库函数转换成对tty设备节点的ioctl调用；tty的ioctl调用会被tty核心转换成一系列的set_termios调用；所有的线路设置都封装在termios结构中；\n\n\n```c\n// uapi/asm-generic/termbits.h\nstruct ktermios {\n    tcflag_t c_iflag;       /* input mode flags */\n    tcflag_t c_oflag;       /* output mode flags */\n    tcflag_t c_cflag;       /* control mode flags */\n    tcflag_t c_lflag;       /* local mode flags */\n    cc_t c_line;            /* line discipline */\n    cc_t c_cc[NCCS];        /* control characters */\n    speed_t c_ispeed;       /* input speed */\n    speed_t c_ospeed;       /* output speed */\n};\n```\n\n\nktermios结构体用来提供一个线路设置集合，给tty设备提供一个特定的端口，用来设置波特率、数据大小、数据流控设置等；如果驱动中未初始化使用，驱动中会使用tty_std_termios结构体变量；\n\n\n```c\n// tty_io.c\nstruct ktermios tty_std_termios = { /* for the benefit of tty drivers  */\n    .c_iflag = ICRNL | IXON,\n    .c_oflag = OPOST | ONLCR,\n    .c_cflag = B38400 | CS8 | CREAD | HUPCL,\n    .c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |\n           ECHOCTL | ECHOKE | IEXTEN,\n    .c_cc = INIT_C_CC,\n    .c_ispeed = 38400,\n    .c_ospeed = 38400\n};\n```\n\n\n最终在内核空间tty驱动中会转换为对tty设备节点的ioctl调用；\n\n\n```c\nlong tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    ......\n    if (tty->ops->ioctl) {\n        retval = tty->ops->ioctl(tty, cmd, arg);\n        if (retval != -ENOIOCTLCMD)\n            return retval;\n    }\n    ld = tty_ldisc_ref_wait(tty);\n    retval = -EINVAL;\n    if (ld->ops->ioctl) {\n        retval = ld->ops->ioctl(tty, file, cmd, arg);\n        if (retval == -ENOIOCTLCMD)\n            retval = -ENOTTY;\n    }\n    tty_ldisc_deref(ld);\n    return retval;\n}\n```\n\n\n\n### 2. tty线路规程\n\n\ntty线路规程在tty_ldisc.c文件中由内核实现；不同的tty类型设备，具有不同的线路规程；tty线路规程由内核实现，不需要驱动工程师开发；\n\n\n在上文tty_read和tty_write函数中可以看出，最后调用了线路规程的read和write操作；\n\n\n内核用tty_ldisc_ops表示设备的线路规程信息；\n\n\n```c\n// linux/tty_ldisc.h\nstruct tty_ldisc_ops {\n    int magic;\n    char    *name;\n    int num;\n    int flags;\n\n    /*\n     * The following routines are called from above.\n     */\n    int (*open)(struct tty_struct *);\n    void    (*close)(struct tty_struct *);\n    void    (*flush_buffer)(struct tty_struct *tty);\n    ssize_t (*chars_in_buffer)(struct tty_struct *tty);\n    ssize_t (*read)(struct tty_struct *tty, struct file *file,\n            unsigned char __user *buf, size_t nr);\n    ssize_t (*write)(struct tty_struct *tty, struct file *file,\n             const unsigned char *buf, size_t nr);\n    int (*ioctl)(struct tty_struct *tty, struct file *file,\n             unsigned int cmd, unsigned long arg);\n    long    (*compat_ioctl)(struct tty_struct *tty, struct file *file,\n                unsigned int cmd, unsigned long arg);\n    void    (*set_termios)(struct tty_struct *tty, struct ktermios *old);\n    unsigned int (*poll)(struct tty_struct *, struct file *,\n                 struct poll_table_struct *);\n    int (*hangup)(struct tty_struct *tty);\n\n    /*\n     * The following routines are called from below.\n     */\n    void    (*receive_buf)(struct tty_struct *, const unsigned char *cp,\n                   char *fp, int count);\n    void    (*write_wakeup)(struct tty_struct *);\n    void    (*dcd_change)(struct tty_struct *, unsigned int);\n    void    (*fasync)(struct tty_struct *tty, int on);\n    int (*receive_buf2)(struct tty_struct *, const unsigned char *cp,\n                char *fp, int count);\n\n    struct  module *owner;\n\n    int refcount;\n};\n```\n\n\ntty_ldisc_ops结构体中不仅有功上层调用的函数指针成员，如：open、read、write等，还有供下层往上层调用的函数指针成员，如：receive_buf、receive_buf2、write_wakeup等；\n\n\n内核中有一个tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]；NR_LDISCS的值是30，系统在初始化或者安装驱动模块时通过tty_register_ldisc()函数将有关的tty_ldisc_ops结构体注册登记到tty_ldiscs[NR_LDISCS]指针数组中；\n\n\n```c\n// uapi/linux/tty.h\n#define NR_LDISCS       30\n// tty_ldisc.c\nstatic struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];\n```\n\n\n\n\n控制终端在内核启动时进行初始化，并给显示提供驱动服务，本节以控制终端为例进行说明，控制台对应的tty_ldisc_ops的是tty_ldiscs指针数组中序号为N_TTY的tty_ldisc_N_TTY结构，其中包含了该线路规程的大部分操作；\n\n\n```c\n// n_tty.c\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n    .magic           = TTY_LDISC_MAGIC,\n    .name            = \"n_tty\",\n    .open            = n_tty_open,\n    .close           = n_tty_close,\n    .flush_buffer    = n_tty_flush_buffer,\n    .chars_in_buffer = n_tty_chars_in_buffer,\n    .read            = n_tty_read,\n    .write           = n_tty_write,\n    .ioctl           = n_tty_ioctl,\n    .set_termios     = n_tty_set_termios,\n    .poll            = n_tty_poll,\n    .receive_buf     = n_tty_receive_buf,\n    .write_wakeup    = n_tty_write_wakeup,\n    .fasync      = n_tty_fasync,\n    .receive_buf2    = n_tty_receive_buf2,\n};\n```\n\n\n\n\n#### 2.1 注册和卸载\n\n\n\n\n**1) 注册**\n\n\ntty_register_ldisc()函数用来向内核注册一个新的线路规程，要注册的线路规程，将以索引的形式添加到tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中；\n\n\n一个串口可以对应多个已被注册的线路规程，最后调用到哪个线路规程，需要用户在打开串口后使用ioctl()选择；\n\n\n```c\n// tty_ldisc.c\nint tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc)\n{\n    unsigned long flags;\n    int ret = 0;\n\n    if (disc < N_TTY || disc >= NR_LDISCS)\n        return -EINVAL;\n\n    raw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n    tty_ldiscs[disc] = new_ldisc;\n    new_ldisc->num = disc;\n    new_ldisc->refcount = 0;\n    raw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n    return ret;\n}\nEXPORT_SYMBOL(tty_register_ldisc);\n```\n\n\n\n\n在内核启动中kernel_start()函数中，通过console_init()函数初始化控制终端，之后显示屏或者串口打印信息才能够正常打印出来；console_init()函数是通过tty_ldisc_begin()来注册默认的线路规程tty_ldisc_N_TTY的；\n\n\n```c\nvoid __init console_init(void)\n{\n    initcall_t *call;\n\n    /* Setup the default TTY line discipline. */\n    tty_ldisc_begin();\n\n    call = __con_initcall_start;\n    while (call < __con_initcall_end) {\n        (*call)();\n        call++;\n    }\n}\n```\n\n\ntty_ldisc_begin()函数用来设置默认的tty线路规程，通过tty_register_ldisc()注册tty_ldisc_ops结构的tty_ldisc_N_TTY；\n\n\n```c\n// uapi/linux/tty.h\n#define N_TTY       0\n\n// tty_ldisc.c\nvoid tty_ldisc_begin(void)\n{\n    /* Setup the default TTY line discipline. */\n    (void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);\n}\n```\n\n\n\n\n**2) 卸载**\n\n\ntty_unregister_ldisc()函数从内核注销一个线路规程；根据索引将要卸载的线路规程，在tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中指向NULL；\n\n\n```c\n// tty_ldisc.c\nint tty_unregister_ldisc(int disc)\n{\n    unsigned long flags;\n    int ret = 0;\n\n    if (disc < N_TTY || disc >= NR_LDISCS)\n        return -EINVAL;\n\n    raw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n    if (tty_ldiscs[disc]->refcount)\n        ret = -EBUSY;\n    else\n        tty_ldiscs[disc] = NULL;\n    raw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n    return ret;\n}\nEXPORT_SYMBOL(tty_unregister_ldisc);\n```\n\n\n\n\n#### 2.2 打开和关闭\n\n\n\n**1) open**\n\n在tty核心的打开操作中会调用打开线路规程，该操作主要是申请一些资源，并对一些线路规程的数据进行初始化；申请n_tty_data结构体，read_buf成员作为读取缓冲区；\n\n```c\n// n_tty.c\nstatic int n_tty_open(struct tty_struct *tty)\n{\n    struct n_tty_data *ldata;\n\n    /* Currently a malloc failure here can panic */\n    ldata = vzalloc(sizeof(*ldata));\n    if (!ldata)\n        return -ENOMEM;\n\n    ldata->overrun_time = jiffies;\n    mutex_init(&ldata->atomic_read_lock);\n    mutex_init(&ldata->output_lock);\n\n    tty->disc_data = ldata;\n    tty->closing = 0; \n    /* indicate buffer work may resume */\n    clear_bit(TTY_LDISC_HALTED, &tty->flags);\n    n_tty_set_termios(tty, NULL);\n    tty_unthrottle(tty);\n    return 0;\n}\n```\n\nn_tty_data结构体中的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；\n\n```c\n// n_tty.c\nstruct n_tty_data {\n    /* producer-published */\n    size_t read_head;\n    \n    /* shared by producer and consumer */\n    char read_buf[N_TTY_BUF_SIZE];\n    \n    /* consumer-published */\n    size_t read_tail;\n}\n```\n\n```c\ntty->read_buf[]\t// 环形缓冲区；\ntty->read_tail\t// 指向缓冲区当前可以读取的第一个字符；\ntty->read_head\t// 指向缓冲区当前可以写入的第一个地址；\n```\n\ntty_unthrottle()函数，打开缓冲区阀门，使缓冲区能够接收到硬件发送过来的数据；\n\n\n\n**2) close**\n\n同样线路规程的关闭操作中，主要是释放申请的变量资源；\n\n```c\nstatic void n_tty_close(struct tty_struct *tty)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n\n    if (tty->link)\n        n_tty_packet_mode_flush(tty);\n\n    vfree(ldata);\n    tty->disc_data = NULL;\n}\n```\n\n\n\n\n#### 2.3 写入和读取\n\n\n\n\n从上文tty核心中的读写函数可以看出，tty_read和tty_write函数内部调用的是线路规程的read和write操作；\n\n\n**1) write**\n\n\n```c\n// tty_io.c\nstatic ssize_t tty_write(struct file *file, const char __user *buf,\n                        size_t count, loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    ld = tty_ldisc_ref_wait(tty);\n    if (!ld->ops->write)\n        ret = -EIO;\n    else\n        ret = do_tty_write(ld->ops->write, tty, file, buf, count);\n    tty_ldisc_deref(ld);\n\t......\n}\n```\n\n\n在tty_write()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，在do_tty_write(ld->ops->write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld->ops->write函数完成tty的write操作；\n\n\ntty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&ld->tty->ldisc_sem锁；\n\n\n```c\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\nldsem_up_read(&ld->tty->ldisc_sem);\n```\n\n\n\n\n在默认的终端设备中，ld->ops->write对应的是tty_ldisc_N_TTY结构中的n_tty_write()函数；\n\n\n```c\n// n_tty.c\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n               const unsigned char *buf, size_t nr)\n{\n    const unsigned char *b = buf;\n    int c;\n\t......\n    struct n_tty_data *ldata = tty->disc_data;\n\n    while (nr > 0) {\n        mutex_lock(&ldata->output_lock);\n        c = tty->ops->write(tty, b, nr);\n        mutex_unlock(&ldata->output_lock);\n        if (c < 0) {\n            retval = c;\n            goto break_out;\n        }\n        if (!c)\n            break;\n        b += c;\n        nr -= c;\n    }\n\t......\n}\n```\n\n\nn_tty_write()函数中通过tty->ops->write(tty, b, nr)将数据写入控制终端；\n\n\n以串口uart驱动为例；tty->ops->write，是tty_struct结构体中tty_operations中的write函数uart_write；而tty_operations结构体是在uart_register_driver()时，对tty_driver结构体初始化时，使用tty_set_operations()函数设置的；\n\n\n```c\n// serial_core.c\nint uart_register_driver(struct uart_driver *drv)\n{\n    struct tty_driver *normal;\n    normal = alloc_tty_driver(drv->nr);\n    if (!normal)\n        goto out_kfree;\n    ......\n    tty_set_operations(normal, &uart_ops);\n    ......\n}\n```\n\n\ntty_set_operations()函数就是将tty_operations结构体赋值给tty_driver结构体中的ops指针；\n\n\n```c\n// tty_io.c\nvoid tty_set_operations(struct tty_driver *driver,\n            const struct tty_operations *op)\n{\n    driver->ops = op;\n};\n```\n\n\n至于uart_write()函数的实现，在下一文uart驱动中进行说明，此处略过；\n\n\n\n\n**2) read**\n\n\n```c\n// tty_io.c\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\n            loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    /* We want to wait for the line discipline to sort out in this\n       situation */\n    ld = tty_ldisc_ref_wait(tty);\n    if (ld->ops->read)\n        i = ld->ops->read(tty, file, buf, count);\n    else\n        i = -EIO;\n    tty_ldisc_deref(ld);\n\t......\n}\n```\n\n\n在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld->ops->read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；\n\n\n```c\nld->ops->read(tty, file, buf, count)\n```\n\n\n\n\n```c\n// n_tty.c\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n    .name            = \"n_tty\",\n    .read            = n_tty_read,\n    .write           = n_tty_write,\n};\n```\n\n\n在控制台中，ld->ops->read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，n_tty_read()函数的详细，请参考下一文；\n\n\n在n_tty_read()函数中进行一些校验和读取进程的休眠和唤醒操作，最终通过canon_copy_from_read_buf()函数或canon_copy_from_read_buf()函数，将数据从缓冲区中读取到用户空间；\n\n\n```c\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n             unsigned char __user *buf, size_t nr)\n{\n    \t......\n        if (ldata->icanon && !L_EXTPROC(tty)) {\n            retval = canon_copy_from_read_buf(tty, &b, &nr);\n            if (retval)\n                break;\n        } else {\n            int uncopied;\n\n            uncopied = copy_from_read_buf(tty, &b, &nr);\n            uncopied += copy_from_read_buf(tty, &b, &nr);\n            if (uncopied) {\n                retval = -EFAULT;\n                break;\n            }\n        }\n    \t......\n}\n```\n\n\n\n\n### 3. tty驱动\n\n\n具体的tty设备的驱动程序，由驱动开发者来实现；本文以创建一个小型tty驱动程序为例，能够加载、卸载，并对其进行读写操作；\n\n\n终端设备驱动都围绕tty_driver结构开始；终端设备驱动应包含：\n\n\n1. 终端设备驱动模块加载函数和卸载函数，完成注册和注销tty_driver，初始化和释放终端设备对应的tty_driver结构体成员及硬件资源；\n\n2. 实现tty_operations结构体中的成员函数，主要实现open()、close()、read()、write()、tiocmget()、tiocmset()函数等；\n\n\n\n\n#### 3.1 模块加载和卸载\n\n\ntty驱动的模块加载函数中通常需要分配和初始化tty_driver结构体，并申请必要的硬件资源；\n\n\n```c\nstatic int tiny_init(void)\n{\n    struct tty_driver *tiny_tty_driver;\n    unsigned int i;\n\n    tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);\n    if (!tiny_tty_driver)\n        return -ENOMEM;\n\n    tiny_tty_driver->driver_name = \"tiny_tty\";\n    tiny_tty_driver->name        = \"ttty\";\n    tiny_tty_driver->major       = TINY_MAJOR;\n    tiny_tty_driver->minor_start = TINY_MINOR;\n    tiny_tty_driver->type        = TTY_DRIVER_TYPE_SERIAL;\n    tiny_tty_driver->subtype     = SERIAL_TYPE_NORMAL;\n    tiny_tty_driver->init_termios    = tty_std_termios;\n    tiny_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n    tiny_tty_driver->init_termios.c_ispeed = 9600;\n    tiny_tty_driver->flags       = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\n    tty_set_operations(tiny_tty_driver, &tty_serial_ops);\n\n    retval = tty_register_driver(tiny_tty_driver);\n\tif (retval) {\n        put_tty_driver(tiny_tty_driver);\n\t\treturn retval;        \n    }\n    \n    for (i = 0; i < TINY_TTY_MINORS; i++) {\n        tty_register_device(tiny_tty_driver, i, NULL);\n    }\n    ......\n}\n```\n\n\n\n\n``` c\nstatic struct tty_operations tiny_serial_ops = {\n    .open = tiny_open,\n    .close = tiny_close,\n    .write = tiny_write,\n    .write_room = tiny_write_room,\n    .set_termios = tiny_set_termios,\n};\n```\n\n\n\n\n\n\n\n\ntty驱动的模块卸载函数，完成加载函数相反的工作；\n\n\n```c\nvoid tiny_exit(void)\n{\n    struct tty_driver *tiny_tty_driver = get_tty_driver();\n    unsigned int i;\n    \n    for (i = 0; i < TINY_TTY_MINORS; i++) {\n        tty_unregister_device(tiny_tty_driver, i);\n    }\n    \n    tty_unregister_driver(tiny_tty_driver);\n}\n```\n\n\n\n\n#### 3.2 模块的打开和关闭\n\n\n\n\n**1) open**\n\n\n在用户态使用open()系统调用函数操作tty驱动创建的设备节点时，tty核心tty_driver的file_operations结构体中的open()成员函数被调用；用户在执行open()函数后，可以得到一个表示该文件的句柄，用来表示该文件；\n\n\n```c\nstatic int tiny_open(struct tty_struct *tty, struct file *filp)\n{\n \tstruct tiny_serial *tiny;\n    struct timer_list *timer;\n    \n    tty->driver_data = NULL;\n    index = tty->index;\n    tiny = tiny_table[index];\n    if (tiny == NULL) {\n        tiny = kmalloc(sizeof(*tiny), GFP_KERNEL);\n        if (!tiny) {\n            return -ENOMEM;\n        }\n        init_MUTEX(&tiny->sem);\n        tiny->open_count = 0;\n        tiny->timer = NULL;\n        \n        tiny_table[index] = tiny;\n    }\n    down(&tiny->sem);\n    \n    tty->driver_data = tiny;\n    tiny->tty = tty;\n    ......    \n}\n```\n\n\ntty->driver_data保存了tiny_serial结构，该结构包含tiny模块所需要的一些成员，保存在tty_struct结构体的driver_data指针，以后在tiny模块中别的函数也可以很方便地使用；\n\n\n```c\nstruct tiny_serial {\n    struct tty_struct *tty;\t// 指向该设备的tty指针\n    int open_count;\t// 该端口被打开的次数\n    struct semaphore sem;\t// 锁，可以锁住该结构\n    struct timer_list *timer;\n};\n```\n\n\n为了能使多个进程读写数据，tty驱动程序的open和close函数可能会被多次调用，因此需要使用open_count在open和close时进行计数；当端口第一次被打开时，可以对所需要的任何硬件初始化及分配所需要的内存，当端口最后一次被关闭时，可以关闭所有硬件，并清理掉所有分配的内存；\n\n\n```c\n\ttiny->open_count++;\n\tif (tiny->open_count == 1) {\n        // 该端口第一次打开\n        // 对所需要的任何硬件初始化及分配所需要的内存\n    }\n```\n\n\n\n\n**2) close**\n\n\n在open()时生成的文件句柄，在用户态使用close()系统调用操作该文件句柄时，tty_driver驱动中file_operations结构体中的close()成员函数被调用，此时设备将被关闭；和open()函数对应，close()函数可能多次调用，在close()中需要open_count进行计数；\n\n\n```c\nstatic void tiny_close(struct tty_struct *tty, struct file *filp)\n{\n    struct tiny_serial *tiny;\n    \n    tiny = tty->driver_data;\n    if (!tiny) {\n        return;        \n    }\n    down(&tiny->sem);\n    if (!tiny->open_count) {\n        goto exit;\n    }\n    tiny->open_count--;\n    if (tiny->open_count <= 0) {\n        // 最后一个用户已经关闭端口\n        // 关闭所有硬件，并清理掉所有分配的内存\n        \n        del_timer(tiny->timer);\n    }\nexit:\n    up(&tiny->sem);\n\treturn;\n}\n```\n\n\n\n\n#### 3.3 数据的发送和接收\n\n\n\n\n**1) write**\n\n\n在用户态使用write()系统调用发送数据给终端设备时，通过write-->tty核心-->tty线路规程调用-->tty驱动，最终通过tty驱动程序中file_operations结构体中的write()成员函数来完成发送；\n\n\n有时由于tty硬件速度或缓存大小的原因，write()函数被调用时，写操作程序所处理的数据不能同时都发送出去，write()函数将返回发送给硬件的字符数；用户空间可以检查write()函数返回值判断是否写入了所有数据；\n\n\ntiny驱动并没有链接真正的硬件，只是在内核调试日志中记录需要写入的数据；\n\n\n```c\nstatic int tiny_write(struct tty_struct *tty,\n                    const unsigned char *buf, int count)\n{\n    struct tiny_serial *tiny;\n    int i;\n    \n    tiny = tty->driver_data;\n    if (!tiny) {\n        return -ENODEV;        \n    }\n    \n    down(&tiny->sem);\n    if (!tiny->open_count) {\n        goto exit;\n    }\n    \n    for (i = 0; i < count; i++) {\n        printk(\"%02x \", buf[i]);\n    }\n    printk(\"\\n\");\nexit:\n    up(&tiny->sem);\n    \n    return i;\n}\n```\n\n\ntty子系统将数据传送到tty设备之外时可以使用write()函数；\n\n\n\n**2) read**\n\n\n\n\ntty_driver结构中没有提供read()函数，因为发送数据是用户主动发起的，而接收数据则是用户态读取一片缓冲区中已放好的数据；在tty核心中提供了缓冲逻辑，tty驱动中并不是必须实现自身的缓冲逻辑；\n\n\n\n\n#### 3.4 串口驱动举例\n\n\ntty类型的驱动，以串口驱动为例，在serial_core.c文件中实现；\n\n\n参考下一文----uart驱动；\n\n\n\n\n### 4. 总结\n\n\n![tty读写过程中的函数调用流程](linux-kernel中的tty驱动/tty读写过程中的函数调用流程-1598176659467.png)\n\n\n\n\n\n\n### 5. 参考资料\n\n\n\n\n《Linux内核情景分析》----控制态驱动\n\n\n《Linux设备驱动程序》\n\n\n\n\n\n笔记计划：\n\n1. tty驱动-->控制台驱动\n\n\n2. uart驱动-->8250驱动\n\n\n3. 键盘驱动-->PS/2键盘\t-->usb键盘\n4. usb转串口驱动\n\n\n\n[回到目录](#目录)","source":"_posts/linux-kernel中的tty驱动.md","raw":"---\ntitle: linux-kernel中的tty驱动\ndate: 2020-08-02 17:54:21\ntags: tty\n---\n\n\n\nTTY 是 Teletypewriter的缩写（Teleprinter、TeletypewriterTele-Type，缩写为 TTY），中文电传打字机简称电传，是远距离打印交换的编写形式；\n\n\n在linux中tty表示各种终端，通常是和硬件相对应，tty用来指任何的串口设备，如：输入设备键盘鼠标、输出设备显示器、虚拟的pty等；\n\n<!--more-->\n\n\n\n\n### 0. 简介\n\n\n\ntty驱动、uart驱动存在密切联系，tty设备包括uart，uart设备的工作依赖于tty设备，uart是tty的上层，内核中有完整的tty驱动，uart设备可以使用tty驱动进行封装；而内核中也有完整的uart驱动，两者相互独立又密切相关；本文主要讲解tty驱动相关的内容，以控制台驱动为例讲述tty驱动的应用，关于uart驱动方面内容，请参考下一文uart驱动；\n\n\n\n\ntty驱动程序的核心在标准字符设备驱动层之下；\n\n\nlinux内核中的tty层次结构，包含：tty核心、tty线路规程、tty驱动；\n\n\n1. tty核心(tty_core)：整个tty设备的抽象，对用户提供统一的接口，用户空间通过设备文件与tty_core交互；tty_core根据用户空间操作类型，选择将数据交给line discipline和tty_driver；\n\n\n2. tty线路规程(line discipline)：对传输数据的格式化，把从用户或硬件接收的数据格式化，这种格式化使用协议完成转换，如：蓝牙；处理之后，将数据交给tty_driver；\n\n\n3. tty驱动(tty_driver)：tty设备对应的驱动，将字符转换成硬件可以理解的字符，将其传给硬件设备；并从硬件接收数据；\n\n![tty层次关系](linux-kernel中的tty驱动/tty层次关系.jpg)\n\n\ntty核心和线路规程由内核提供，驱动工程师只需要完成tty驱动部分代码就可以使用tty了；\n\n\n多数时候tty核心和tty驱动之间的数据传输会经历tty线路规程的转换，但是tty驱动和tty核心之间也可以直接传输数据；tty核心根据操作类型选择和线路规程和tty驱动交互；如：设置硬件的ioctl直接交给tty_driver处理；而read/write操作交给线路规程处理；\n\n\n1) 发送数据流程：tty核心从用户空间获取到将要发送给tty设备的数据，tty核心将数据传递给tty线路规程驱动，然后数据被传递到tty驱动，tty驱动将数据转换为可以发送给硬件的格式；\n\n\n2) 接收数据流程：tty硬件将接收到的数据上交给tty驱动，进入tty线路规程驱动，再进入tty核心，被传递给用户空间；\n\n\ntty驱动程序有三种类型：控制台、串口和pty；控制台和pty驱动程序已经在内核中稳定使用，使用tty核心与用户和系统交互的新驱动都可以看做是串口驱动程序；\n\n\ntty驱动代码位于drivers/tty目录；\n\n\n\n\n### 1. tty核心\n\n\ntty核心是所有tty类型驱动的顶层架构，向应用层提供了统一的接口；用户态的open、close、read、write系统调用首先到达tty核心；\n\n\ntty核心在tty_io.c文件中由内核实现，定义了tty设备需要的核心数据结构，和一些需要操作；\n\n\n\n\n#### 1.1 tty重要数据结构\n\n\n\n\n**1) tty_driver**\n\n\ntty驱动程序的主要数据结构是struct tty_driver，规定了tty驱动程序和高层之间的编程接口，用来向tty核心注册和注销驱动程序；操作包含在头文件<linux/tty_driver.h>中；\n\n\n```c\n// linux/tty_driver.h\nstruct tty_driver {\n    int magic;      /* magic number for this structure */\n    struct kref kref;   /* Reference management */\n    struct cdev **cdevs;\n    struct module   *owner;\n    const char  *driver_name;\n    const char  *name;\n    int name_base;  /* offset of printed name */\n    int major;      /* major device number */\n    int minor_start;    /* start of minor device number */\n    unsigned int    num;    /* number of devices allocated */\n    short   type;       /* type of tty driver */\n    short   subtype;    /* subtype of tty driver */\n    struct ktermios init_termios; /* Initial termios */\n    unsigned long   flags;      /* tty driver flags */\n    struct proc_dir_entry *proc_entry; /* /proc fs entry */\n    struct tty_driver *other; /* only used for the PTY driver */\n\n    /*\n     * Pointer to the tty data structures\n     */\n    struct tty_struct **ttys;\n    struct tty_port **ports;\n    struct ktermios **termios;\n    void *driver_state;\n\n    /*\n     * Driver methods\n     */\n    const struct tty_operations *ops;\n    struct list_head tty_drivers;\n};\n```\n\n\n\n\ntty设备的所有操作都包含在tty_driver结构体中，内核提供alloc_tty_driver()函数来分配tty_driver结构体，参数是该驱动支持的tty设备的数量；\n\n\n```c\n\t// 分配tty驱动程序\n\tstruct tty_driver *normal;\n\tnormal = alloc_tty_driver(nr);\n```\n\n\nalloc_tty_driver()函数的实现如下：\n\n\n```c\nstatic inline struct tty_driver *alloc_tty_driver(unsigned int lines)\n{\n    struct tty_driver *ret = tty_alloc_driver(lines, 0);\n    if (IS_ERR(ret))\n        return NULL;\n    return ret;\n}\n\n#define tty_alloc_driver(lines, flags) \\\n        __tty_alloc_driver(lines, THIS_MODULE, flags)\n\n// tty_io.c\nstruct tty_driver *__tty_alloc_driver(unsigned int lines, struct module *owner,\n         unsigned long flags)\n{\n\tstruct tty_driver *driver;\n\n\tdriver = kzalloc(sizeof(struct tty_driver), GFP_KERNEL);\n    if (!driver)\n        return ERR_PTR(-ENOMEM);\n    ......\n}\n```\n\n\n申请成功后，alloc_tty_driver()函数将申请到的tty_driver结构体作为返回值返回，之后，需要对tty_driver进行初始化，再通过调用tty_register_driver()来注册进内核；\n\n\n\n\n**2) tty_operations**\n\n\ntty_operations结构中包含所有的回调函数，被tty驱动程序设置，并被tty核心调用；\n\n\n```c\n// linux/tty_driver.h\nstruct tty_operations {\n    struct tty_struct * (*lookup)(struct tty_driver *driver,\n            struct inode *inode, int idx);\n    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);\n    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n    int  (*open)(struct tty_struct * tty, struct file * filp);\n    void (*close)(struct tty_struct * tty, struct file * filp);\n    void (*shutdown)(struct tty_struct *tty);\n    void (*cleanup)(struct tty_struct *tty);\n    int  (*write)(struct tty_struct * tty,\n              const unsigned char *buf, int count);\n    int  (*put_char)(struct tty_struct *tty, unsigned char ch);\n    void (*flush_chars)(struct tty_struct *tty);\n    int  (*write_room)(struct tty_struct *tty);\n    int  (*chars_in_buffer)(struct tty_struct *tty);\n    int  (*ioctl)(struct tty_struct *tty,\n            unsigned int cmd, unsigned long arg);\n    long (*compat_ioctl)(struct tty_struct *tty,\n                 unsigned int cmd, unsigned long arg);\n    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);\n    void (*throttle)(struct tty_struct * tty);\n    void (*unthrottle)(struct tty_struct * tty);\n    void (*stop)(struct tty_struct *tty);\n    void (*start)(struct tty_struct *tty);\n    void (*hangup)(struct tty_struct *tty);\n    int (*break_ctl)(struct tty_struct *tty, int state);\n    void (*flush_buffer)(struct tty_struct *tty);\n    void (*set_ldisc)(struct tty_struct *tty);\n    void (*wait_until_sent)(struct tty_struct *tty, int timeout);\n    void (*send_xchar)(struct tty_struct *tty, char ch);\n    int (*tiocmget)(struct tty_struct *tty);\n    int (*tiocmset)(struct tty_struct *tty,\n            unsigned int set, unsigned int clear);\n    int (*resize)(struct tty_struct *tty, struct winsize *ws);\n    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);\n\t......\n};\n```\n\n\n\n\n**3) tty_struct**\n\n\ntty核心使用tty_struct结构保存当前特定tty端口的状态；除了个别成员外基本上所有成员都只能被tty核心使用；\n\n\n```c\n// linux/tty_driver.h\nstruct tty_struct {\n    int magic;\n    struct kref kref;\n    struct device *dev;\n    struct tty_driver *driver;\n    const struct tty_operations *ops;\n    int index;\n\n    /* Protects ldisc changes: Lock tty not pty */\n    struct ld_semaphore ldisc_sem;\n    struct tty_ldisc *ldisc;\n\n    /* Termios values are protected by the termios rwsem */\n    struct ktermios termios, termios_locked;\n    struct termiox *termiox;    /* May be NULL for unsupported */\n    char name[64];\n\n    struct tty_struct *link;\n    struct fasync_struct *fasync;\n    int alt_speed;      /* For magic substitution of 38400 bps */\n    wait_queue_head_t write_wait;\n    wait_queue_head_t read_wait;\n\n#define N_TTY_BUF_SIZE 4096\n    unsigned char *write_buf;\n    int write_cnt;\n    /* If the tty has a pending do_SAK, queue it here - akpm */\n    struct work_struct SAK_work;\n    struct tty_port *port;\n};\n```\n\n\n\n\ntty端口的状态都包含在tty_struct结构体中，内核提供alloc_tty_struct()函数来分配tty_struct结构体，并对成员进行初始化操作，参数是该驱动的tty_driver和设备的索引号；该函数在tty核心中实现并调用，不需要在tty驱动中明确调用；\n\n\n```c\n\t// 分配tty驱动程序\n\tstruct tty_struct *tty;\n\ttty = alloc_tty_struct(driver, idx);\n```\n\n\n\n\n#### 1.2 tty的注册和卸载\n\n\n\n\n**1) 注册**\n\n\ntty驱动的注册，由tty_register_driver()函数完成，用于将串口驱动tty_driver注册到内核；注册时会分配主设备号和次设备号，主设备号对应驱动程序，告知内核需要使用哪个驱动程序驱动该设备，次设备号对应具体的设备；\n\n\ntty_register_driver()函数用来向内核注册tty设备，根据tty_driver的所有次设备号，创建不同的sysfs文件；会使用fs/char_dev.c中提供的字符设备接口注册字符设备；使用fs/proc/proc_tty.c中的函数创建/proc/tty文件；在使用tty_register_driver()函数注册tty驱动之前，需要先对申请到的tty_driver结构体成员进行初始化；tty_register_driver()函数的参数是已经初始化过的tty_driver结构体指针；\n\n\n```c\n// drivers/tty/tty_io.c\nint tty_register_driver(struct tty_driver *driver)\n{\n\talloc_chrdev_region();\n    register_chrdev_region();\n    tty_cdev_add();\n    list_add(&driver->tty_drivers, &tty_drivers);\n    // 注册所控制的设备\n    if (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV)) {\n        for (i = 0; i < driver->num; i++) {\n            d = tty_register_device(driver, i, NULL);\n            if (IS_ERR(d)) {\n                error = PTR_ERR(d);\n                goto err_unreg_devs;\n            }\n        }\n    }\n}\n```\n\n\n在tty_cdev_add()函数中，将字符设备操作集指定为tty_fops，之后将tty_driver添加到tty_driver结构体中的tty_drivers链表中，可以通过设备号找到对应的driver；最后通过tty_register_device()函数注册tty驱动所控制的硬件设备；\n\n\n\n\n**2) 卸载**\n\n\ntty驱动的卸载，由tty_unregister_driver()函数完成，用于注销已注册的tty_driver；\n\n\n```c\n// drivers/tty/tty_io.c\nint tty_unregister_driver(struct tty_driver *driver)\n{\n    unregister_chrdev_region(MKDEV(driver->major, driver->minor_start),\n                driver->num);\n\tlist_del(&driver->tty_drivers);\n}\n```\n\n\n\n\n从注册过程中可以得知，tty设备所有的操作都包含在tty_fops结构体中；\n\n\n```c\n// drivers/tty/tty_io.c\nstatic const struct file_operations tty_fops = {\n    .llseek     = no_llseek,\n    .read       = tty_read,\n    .write      = tty_write,\n    .poll       = tty_poll,\n    .unlocked_ioctl = tty_ioctl,\n    .compat_ioctl   = tty_compat_ioctl,\n    .open       = tty_open,\n    .release    = tty_release,\n    .fasync     = tty_fasync,\n};\n```\n\n\n\n\n特定的tty设备驱动的主要工作是填充tty_driver结构体中的成员；\n\n\n\n\n#### 1.3 tty的打开和关闭\n\n\ntty设备的打开和关闭操作，在tty_io.c中实现通过tty_open和tty_release函数实现；tty_open和tty_release函数保持对tty打开的设备计数；\n\n\n**1) open**\n\n\n用户态使用open函数打开设备节点时，对应tty_fops结构体中的tty_open函数被调用；tty驱动程序一定要设置open成员操作，否则用户态调用open时，将返回-ENODEV；\n\n\n```c\nstatic int tty_open(struct inode *inode, struct file *filp)\n{\n    struct tty_struct *tty;\n    struct tty_driver *driver = NULL;\n    int index;\n    dev_t device = inode->i_rdev;\n\n    nonseekable_open(inode, filp);\n\nretry_open:\n    retval = tty_alloc_file(filp);\n    if (retval)\n        return -ENOMEM;\n\n    tty = tty_open_current_tty(device, filp);\n    if (!tty) {\n        mutex_lock(&tty_mutex);\n        driver = tty_lookup_driver(device, filp, &noctty, &index);\n\n        /* check whether we're reopening an existing tty */\n        tty = tty_driver_lookup_tty(driver, inode, index);\n\n        if (tty) {\n            mutex_unlock(&tty_mutex);\n            retval = tty_lock_interruptible(tty);\n\n            /* safe to drop the kref from tty_driver_lookup_tty() */\n            tty_kref_put(tty);\n            retval = tty_reopen(tty);\n\n        } else { /* Returns with the tty_lock held for now */\n            tty = tty_init_dev(driver, index);\n            mutex_unlock(&tty_mutex);\n        }\n\n        tty_driver_kref_put(driver);\n    }\n\n    tty_add_file(tty, filp);\n\t......\n    if (tty->ops->open)\n        retval = tty->ops->open(tty, filp);\n    else\n        retval = -ENODEV;\n    filp->f_flags = saved_flags;\n\t......\n}\n```\n\n\n\n\ntty_alloc_file()函数\n\n\n每一个打开的tty都有一个私有数据tty_file_private结构，在tty_alloc_file()函数中用private_data指针指向该结构；\n\n\n```c\nint tty_alloc_file(struct file *file)\n{\n    struct tty_file_private *priv;\n\n    priv = kmalloc(sizeof(*priv), GFP_KERNEL);\n    if (!priv)\n        return -ENOMEM;\n\n    file->private_data = priv;\n\n    return 0;\n}\n```\n\n\n\n\n```c\n// linux/tty.h\n/* Each of a tty's open files has private_data pointing to tty_file_private */\nstruct tty_file_private {\n    struct tty_struct *tty;\n    struct file *file;\n    struct list_head list;\n};\n```\n\n\n\n\ntty_lookup_driver()函数查找tty_driver链表，找到注册时添加的tty_driver，然后调用tty_driver的ops->open函数打开具体的tty设备；\n\n\n```c\n\tstruct tty_driver *driver = NULL;\n\tdriver = tty_lookup_driver(device, filp, &noctty, &index);\n```\n\n\n\n\n```c\nstatic struct tty_driver *tty_lookup_driver(dev_t device, struct file *filp,\n        int *noctty, int *index)\n{\n\t......\n    default:\n        driver = get_tty_driver(device, index);\n        if (!driver)\n            return ERR_PTR(-ENODEV);\n        break;\n    }\n    return driver;\n}    \n```\n\n\n\n\n```c\nstatic struct tty_driver *get_tty_driver(dev_t device, int *index)\n{\n    struct tty_driver *p;\n\n    list_for_each_entry(p, &tty_drivers, tty_drivers) {\n        dev_t base = MKDEV(p->major, p->minor_start);\n        if (device < base || device >= base + p->num)\n            continue;\n        *index = device - base;\n        return tty_driver_kref_get(p);\n    }\n    return NULL;\n}\n```\n\n\n\n\ntty_reopen()\n\n\n\n\ntty_init_dev()\n\n\n\n\n**2) release**\n\n\ntty_release()函数通过tty->ops->close操作来关闭tty设备；\n\n\n```c\nint tty_release(struct inode *inode, struct file *filp)\n{\n    struct tty_struct *tty = file_tty(filp);\n    struct tty_struct *o_tty = NULL;\n    long    timeout = 0;\n\t......\n    if (tty->ops->close)\n        tty->ops->close(tty, filp);\n\n    tty_del_file(filp);\n\n    /*\n     * Ask the line discipline code to release its structures\n     */\n    tty_ldisc_release(tty);\n\n    /* Wait for pending work before tty destruction commmences */\n    tty_flush_works(tty);\n\t......\n}\n```\n\n\n\n\n#### 1.4 tty的读写\n\n\n\n\n**1) write**\n\n\n在用户态调用write系统调用函数将数据发送给硬件时，内核将数据和大小发送给tty驱动程序的write操作；\n\n\n由于tty硬件速度和缓冲区大小等原因，当write时写操作程序处理的数据不能同时发送出去，write函数将返回发送给硬件的字符数；用户态可以通过write系统条用函数的返回值，判断是否写入了所有的数据；\n\n\ntty设备文件的写操作通过tty_fops结构体中的tty_write函数实现；\n\n\n```c\nstatic ssize_t tty_write(struct file *file, const char __user *buf,\n                        size_t count, loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n    ssize_t ret;\n\n    if (tty_paranoia_check(tty, file_inode(file), \"tty_write\"))\n        return -EIO;\n    if (!tty || !tty->ops->write ||\n        (test_bit(TTY_IO_ERROR, &tty->flags)))\n            return -EIO;\n    /* Short term debug to catch buggy drivers */\n    if (tty->ops->write_room == NULL)\n        printk(KERN_ERR \"tty driver %s lacks a write_room method.\\n\",\n            tty->driver->name);\n    ld = tty_ldisc_ref_wait(tty);\n    if (!ld->ops->write)\n        ret = -EIO;\n    else\n        ret = do_tty_write(ld->ops->write, tty, file, buf, count);\n    tty_ldisc_deref(ld);\n    return ret;\n}\n```\n\n\ntty_write()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，在do_tty_write(ld->ops->write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld->ops->write函数，进行具体的写入操作；\n\n\n```c\nstatic inline ssize_t do_tty_write(\n    ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t),\n    struct tty_struct *tty,\n    struct file *file,\n    const char __user *buf,\n    size_t count)\n{\n    chunk = 2048;\n    if (test_bit(TTY_NO_WRITE_SPLIT, &tty->flags))\n        chunk = 65536;\n\n    for (;;) {\n        if (copy_from_user(tty->write_buf, buf, size))\n            break;\n        ret = write(tty, file, tty->write_buf, size);\n    }\n}\n```\n\n\n在调用do_tty_write()函数前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&ld->tty->ldisc_sem锁；\n\n\n```c\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\nldsem_up_read(&ld->tty->ldisc_sem);\n```\n\n\n在do_tty_write()函数中，默认一次写入数据大小为2048字节，如果设置了TTY_NO_WRITE_SPLIT，可以一次写入65536字节数据；\n\n\ntty->write_buf，是写操作的临时缓冲区，存放通过copy_from_user从用户空间获取的数据；\n\n\ntty->write_cnt，是临时缓冲区的大小；\n\n\n\n\ntty_write通过ld->ops->write操作来完成数据的写入操作；\n\n\n\n\n**2) read**\n\n\ntty设备文件的写操作通过tty_fops结构体中的tty_read函数实现；\n\n\n```c\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\n            loff_t *ppos)\n{\n    int i;\n    struct inode *inode = file_inode(file);\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    if (tty_paranoia_check(tty, inode, \"tty_read\"))\n        return -EIO;\n    if (!tty || (test_bit(TTY_IO_ERROR, &tty->flags)))\n        return -EIO;\n\n    /* We want to wait for the line discipline to sort out in this\n       situation */\n    ld = tty_ldisc_ref_wait(tty);\n    if (ld->ops->read)\n        i = ld->ops->read(tty, file, buf, count);\n    else\n        i = -EIO;\n    tty_ldisc_deref(ld);\n\n    if (i > 0)\n        tty_update_time(&inode->i_atime);\n\n    return i;\n}\n```\n\n\ntty_read()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，使用tty_ldisc_ops结构中的ld->ops->read函数，进行具体的读取操作；\n\n\nld->ops->read(tty, file, buf, count)\n\n\n在读取操作前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&ld->tty->ldisc_sem锁；\n\n\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\n\n\nldsem_up_read(&ld->tty->ldisc_sem);\n\n\n\n\ntty_read通过ld->ops->read操作来完成数据的读取操作；\n\n\n\n\n#### 1.5 tty线路设置\n\n\n用户态要改变线路设置，或者获取当前的线路设置时，只需要调用多个termios用户空间库函数，或者对tty设备节点调用ioctl操作；在tty核心会把这两种操作转换为tty驱动程序的回调函数或ioctl操作；大部分temios用户空间函数会被库函数转换成对tty设备节点的ioctl调用；tty的ioctl调用会被tty核心转换成一系列的set_termios调用；所有的线路设置都封装在termios结构中；\n\n\n```c\n// uapi/asm-generic/termbits.h\nstruct ktermios {\n    tcflag_t c_iflag;       /* input mode flags */\n    tcflag_t c_oflag;       /* output mode flags */\n    tcflag_t c_cflag;       /* control mode flags */\n    tcflag_t c_lflag;       /* local mode flags */\n    cc_t c_line;            /* line discipline */\n    cc_t c_cc[NCCS];        /* control characters */\n    speed_t c_ispeed;       /* input speed */\n    speed_t c_ospeed;       /* output speed */\n};\n```\n\n\nktermios结构体用来提供一个线路设置集合，给tty设备提供一个特定的端口，用来设置波特率、数据大小、数据流控设置等；如果驱动中未初始化使用，驱动中会使用tty_std_termios结构体变量；\n\n\n```c\n// tty_io.c\nstruct ktermios tty_std_termios = { /* for the benefit of tty drivers  */\n    .c_iflag = ICRNL | IXON,\n    .c_oflag = OPOST | ONLCR,\n    .c_cflag = B38400 | CS8 | CREAD | HUPCL,\n    .c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |\n           ECHOCTL | ECHOKE | IEXTEN,\n    .c_cc = INIT_C_CC,\n    .c_ispeed = 38400,\n    .c_ospeed = 38400\n};\n```\n\n\n最终在内核空间tty驱动中会转换为对tty设备节点的ioctl调用；\n\n\n```c\nlong tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    ......\n    if (tty->ops->ioctl) {\n        retval = tty->ops->ioctl(tty, cmd, arg);\n        if (retval != -ENOIOCTLCMD)\n            return retval;\n    }\n    ld = tty_ldisc_ref_wait(tty);\n    retval = -EINVAL;\n    if (ld->ops->ioctl) {\n        retval = ld->ops->ioctl(tty, file, cmd, arg);\n        if (retval == -ENOIOCTLCMD)\n            retval = -ENOTTY;\n    }\n    tty_ldisc_deref(ld);\n    return retval;\n}\n```\n\n\n\n### 2. tty线路规程\n\n\ntty线路规程在tty_ldisc.c文件中由内核实现；不同的tty类型设备，具有不同的线路规程；tty线路规程由内核实现，不需要驱动工程师开发；\n\n\n在上文tty_read和tty_write函数中可以看出，最后调用了线路规程的read和write操作；\n\n\n内核用tty_ldisc_ops表示设备的线路规程信息；\n\n\n```c\n// linux/tty_ldisc.h\nstruct tty_ldisc_ops {\n    int magic;\n    char    *name;\n    int num;\n    int flags;\n\n    /*\n     * The following routines are called from above.\n     */\n    int (*open)(struct tty_struct *);\n    void    (*close)(struct tty_struct *);\n    void    (*flush_buffer)(struct tty_struct *tty);\n    ssize_t (*chars_in_buffer)(struct tty_struct *tty);\n    ssize_t (*read)(struct tty_struct *tty, struct file *file,\n            unsigned char __user *buf, size_t nr);\n    ssize_t (*write)(struct tty_struct *tty, struct file *file,\n             const unsigned char *buf, size_t nr);\n    int (*ioctl)(struct tty_struct *tty, struct file *file,\n             unsigned int cmd, unsigned long arg);\n    long    (*compat_ioctl)(struct tty_struct *tty, struct file *file,\n                unsigned int cmd, unsigned long arg);\n    void    (*set_termios)(struct tty_struct *tty, struct ktermios *old);\n    unsigned int (*poll)(struct tty_struct *, struct file *,\n                 struct poll_table_struct *);\n    int (*hangup)(struct tty_struct *tty);\n\n    /*\n     * The following routines are called from below.\n     */\n    void    (*receive_buf)(struct tty_struct *, const unsigned char *cp,\n                   char *fp, int count);\n    void    (*write_wakeup)(struct tty_struct *);\n    void    (*dcd_change)(struct tty_struct *, unsigned int);\n    void    (*fasync)(struct tty_struct *tty, int on);\n    int (*receive_buf2)(struct tty_struct *, const unsigned char *cp,\n                char *fp, int count);\n\n    struct  module *owner;\n\n    int refcount;\n};\n```\n\n\ntty_ldisc_ops结构体中不仅有功上层调用的函数指针成员，如：open、read、write等，还有供下层往上层调用的函数指针成员，如：receive_buf、receive_buf2、write_wakeup等；\n\n\n内核中有一个tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]；NR_LDISCS的值是30，系统在初始化或者安装驱动模块时通过tty_register_ldisc()函数将有关的tty_ldisc_ops结构体注册登记到tty_ldiscs[NR_LDISCS]指针数组中；\n\n\n```c\n// uapi/linux/tty.h\n#define NR_LDISCS       30\n// tty_ldisc.c\nstatic struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];\n```\n\n\n\n\n控制终端在内核启动时进行初始化，并给显示提供驱动服务，本节以控制终端为例进行说明，控制台对应的tty_ldisc_ops的是tty_ldiscs指针数组中序号为N_TTY的tty_ldisc_N_TTY结构，其中包含了该线路规程的大部分操作；\n\n\n```c\n// n_tty.c\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n    .magic           = TTY_LDISC_MAGIC,\n    .name            = \"n_tty\",\n    .open            = n_tty_open,\n    .close           = n_tty_close,\n    .flush_buffer    = n_tty_flush_buffer,\n    .chars_in_buffer = n_tty_chars_in_buffer,\n    .read            = n_tty_read,\n    .write           = n_tty_write,\n    .ioctl           = n_tty_ioctl,\n    .set_termios     = n_tty_set_termios,\n    .poll            = n_tty_poll,\n    .receive_buf     = n_tty_receive_buf,\n    .write_wakeup    = n_tty_write_wakeup,\n    .fasync      = n_tty_fasync,\n    .receive_buf2    = n_tty_receive_buf2,\n};\n```\n\n\n\n\n#### 2.1 注册和卸载\n\n\n\n\n**1) 注册**\n\n\ntty_register_ldisc()函数用来向内核注册一个新的线路规程，要注册的线路规程，将以索引的形式添加到tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中；\n\n\n一个串口可以对应多个已被注册的线路规程，最后调用到哪个线路规程，需要用户在打开串口后使用ioctl()选择；\n\n\n```c\n// tty_ldisc.c\nint tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc)\n{\n    unsigned long flags;\n    int ret = 0;\n\n    if (disc < N_TTY || disc >= NR_LDISCS)\n        return -EINVAL;\n\n    raw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n    tty_ldiscs[disc] = new_ldisc;\n    new_ldisc->num = disc;\n    new_ldisc->refcount = 0;\n    raw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n    return ret;\n}\nEXPORT_SYMBOL(tty_register_ldisc);\n```\n\n\n\n\n在内核启动中kernel_start()函数中，通过console_init()函数初始化控制终端，之后显示屏或者串口打印信息才能够正常打印出来；console_init()函数是通过tty_ldisc_begin()来注册默认的线路规程tty_ldisc_N_TTY的；\n\n\n```c\nvoid __init console_init(void)\n{\n    initcall_t *call;\n\n    /* Setup the default TTY line discipline. */\n    tty_ldisc_begin();\n\n    call = __con_initcall_start;\n    while (call < __con_initcall_end) {\n        (*call)();\n        call++;\n    }\n}\n```\n\n\ntty_ldisc_begin()函数用来设置默认的tty线路规程，通过tty_register_ldisc()注册tty_ldisc_ops结构的tty_ldisc_N_TTY；\n\n\n```c\n// uapi/linux/tty.h\n#define N_TTY       0\n\n// tty_ldisc.c\nvoid tty_ldisc_begin(void)\n{\n    /* Setup the default TTY line discipline. */\n    (void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);\n}\n```\n\n\n\n\n**2) 卸载**\n\n\ntty_unregister_ldisc()函数从内核注销一个线路规程；根据索引将要卸载的线路规程，在tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中指向NULL；\n\n\n```c\n// tty_ldisc.c\nint tty_unregister_ldisc(int disc)\n{\n    unsigned long flags;\n    int ret = 0;\n\n    if (disc < N_TTY || disc >= NR_LDISCS)\n        return -EINVAL;\n\n    raw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n    if (tty_ldiscs[disc]->refcount)\n        ret = -EBUSY;\n    else\n        tty_ldiscs[disc] = NULL;\n    raw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n    return ret;\n}\nEXPORT_SYMBOL(tty_unregister_ldisc);\n```\n\n\n\n\n#### 2.2 打开和关闭\n\n\n\n**1) open**\n\n在tty核心的打开操作中会调用打开线路规程，该操作主要是申请一些资源，并对一些线路规程的数据进行初始化；申请n_tty_data结构体，read_buf成员作为读取缓冲区；\n\n```c\n// n_tty.c\nstatic int n_tty_open(struct tty_struct *tty)\n{\n    struct n_tty_data *ldata;\n\n    /* Currently a malloc failure here can panic */\n    ldata = vzalloc(sizeof(*ldata));\n    if (!ldata)\n        return -ENOMEM;\n\n    ldata->overrun_time = jiffies;\n    mutex_init(&ldata->atomic_read_lock);\n    mutex_init(&ldata->output_lock);\n\n    tty->disc_data = ldata;\n    tty->closing = 0; \n    /* indicate buffer work may resume */\n    clear_bit(TTY_LDISC_HALTED, &tty->flags);\n    n_tty_set_termios(tty, NULL);\n    tty_unthrottle(tty);\n    return 0;\n}\n```\n\nn_tty_data结构体中的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；\n\n```c\n// n_tty.c\nstruct n_tty_data {\n    /* producer-published */\n    size_t read_head;\n    \n    /* shared by producer and consumer */\n    char read_buf[N_TTY_BUF_SIZE];\n    \n    /* consumer-published */\n    size_t read_tail;\n}\n```\n\n```c\ntty->read_buf[]\t// 环形缓冲区；\ntty->read_tail\t// 指向缓冲区当前可以读取的第一个字符；\ntty->read_head\t// 指向缓冲区当前可以写入的第一个地址；\n```\n\ntty_unthrottle()函数，打开缓冲区阀门，使缓冲区能够接收到硬件发送过来的数据；\n\n\n\n**2) close**\n\n同样线路规程的关闭操作中，主要是释放申请的变量资源；\n\n```c\nstatic void n_tty_close(struct tty_struct *tty)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n\n    if (tty->link)\n        n_tty_packet_mode_flush(tty);\n\n    vfree(ldata);\n    tty->disc_data = NULL;\n}\n```\n\n\n\n\n#### 2.3 写入和读取\n\n\n\n\n从上文tty核心中的读写函数可以看出，tty_read和tty_write函数内部调用的是线路规程的read和write操作；\n\n\n**1) write**\n\n\n```c\n// tty_io.c\nstatic ssize_t tty_write(struct file *file, const char __user *buf,\n                        size_t count, loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    ld = tty_ldisc_ref_wait(tty);\n    if (!ld->ops->write)\n        ret = -EIO;\n    else\n        ret = do_tty_write(ld->ops->write, tty, file, buf, count);\n    tty_ldisc_deref(ld);\n\t......\n}\n```\n\n\n在tty_write()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，在do_tty_write(ld->ops->write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld->ops->write函数完成tty的write操作；\n\n\ntty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&ld->tty->ldisc_sem锁；\n\n\n```c\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\nldsem_up_read(&ld->tty->ldisc_sem);\n```\n\n\n\n\n在默认的终端设备中，ld->ops->write对应的是tty_ldisc_N_TTY结构中的n_tty_write()函数；\n\n\n```c\n// n_tty.c\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n               const unsigned char *buf, size_t nr)\n{\n    const unsigned char *b = buf;\n    int c;\n\t......\n    struct n_tty_data *ldata = tty->disc_data;\n\n    while (nr > 0) {\n        mutex_lock(&ldata->output_lock);\n        c = tty->ops->write(tty, b, nr);\n        mutex_unlock(&ldata->output_lock);\n        if (c < 0) {\n            retval = c;\n            goto break_out;\n        }\n        if (!c)\n            break;\n        b += c;\n        nr -= c;\n    }\n\t......\n}\n```\n\n\nn_tty_write()函数中通过tty->ops->write(tty, b, nr)将数据写入控制终端；\n\n\n以串口uart驱动为例；tty->ops->write，是tty_struct结构体中tty_operations中的write函数uart_write；而tty_operations结构体是在uart_register_driver()时，对tty_driver结构体初始化时，使用tty_set_operations()函数设置的；\n\n\n```c\n// serial_core.c\nint uart_register_driver(struct uart_driver *drv)\n{\n    struct tty_driver *normal;\n    normal = alloc_tty_driver(drv->nr);\n    if (!normal)\n        goto out_kfree;\n    ......\n    tty_set_operations(normal, &uart_ops);\n    ......\n}\n```\n\n\ntty_set_operations()函数就是将tty_operations结构体赋值给tty_driver结构体中的ops指针；\n\n\n```c\n// tty_io.c\nvoid tty_set_operations(struct tty_driver *driver,\n            const struct tty_operations *op)\n{\n    driver->ops = op;\n};\n```\n\n\n至于uart_write()函数的实现，在下一文uart驱动中进行说明，此处略过；\n\n\n\n\n**2) read**\n\n\n```c\n// tty_io.c\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\n            loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    /* We want to wait for the line discipline to sort out in this\n       situation */\n    ld = tty_ldisc_ref_wait(tty);\n    if (ld->ops->read)\n        i = ld->ops->read(tty, file, buf, count);\n    else\n        i = -EIO;\n    tty_ldisc_deref(ld);\n\t......\n}\n```\n\n\n在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld->ops->read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；\n\n\n```c\nld->ops->read(tty, file, buf, count)\n```\n\n\n\n\n```c\n// n_tty.c\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n    .name            = \"n_tty\",\n    .read            = n_tty_read,\n    .write           = n_tty_write,\n};\n```\n\n\n在控制台中，ld->ops->read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，n_tty_read()函数的详细，请参考下一文；\n\n\n在n_tty_read()函数中进行一些校验和读取进程的休眠和唤醒操作，最终通过canon_copy_from_read_buf()函数或canon_copy_from_read_buf()函数，将数据从缓冲区中读取到用户空间；\n\n\n```c\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n             unsigned char __user *buf, size_t nr)\n{\n    \t......\n        if (ldata->icanon && !L_EXTPROC(tty)) {\n            retval = canon_copy_from_read_buf(tty, &b, &nr);\n            if (retval)\n                break;\n        } else {\n            int uncopied;\n\n            uncopied = copy_from_read_buf(tty, &b, &nr);\n            uncopied += copy_from_read_buf(tty, &b, &nr);\n            if (uncopied) {\n                retval = -EFAULT;\n                break;\n            }\n        }\n    \t......\n}\n```\n\n\n\n\n### 3. tty驱动\n\n\n具体的tty设备的驱动程序，由驱动开发者来实现；本文以创建一个小型tty驱动程序为例，能够加载、卸载，并对其进行读写操作；\n\n\n终端设备驱动都围绕tty_driver结构开始；终端设备驱动应包含：\n\n\n1. 终端设备驱动模块加载函数和卸载函数，完成注册和注销tty_driver，初始化和释放终端设备对应的tty_driver结构体成员及硬件资源；\n\n2. 实现tty_operations结构体中的成员函数，主要实现open()、close()、read()、write()、tiocmget()、tiocmset()函数等；\n\n\n\n\n#### 3.1 模块加载和卸载\n\n\ntty驱动的模块加载函数中通常需要分配和初始化tty_driver结构体，并申请必要的硬件资源；\n\n\n```c\nstatic int tiny_init(void)\n{\n    struct tty_driver *tiny_tty_driver;\n    unsigned int i;\n\n    tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);\n    if (!tiny_tty_driver)\n        return -ENOMEM;\n\n    tiny_tty_driver->driver_name = \"tiny_tty\";\n    tiny_tty_driver->name        = \"ttty\";\n    tiny_tty_driver->major       = TINY_MAJOR;\n    tiny_tty_driver->minor_start = TINY_MINOR;\n    tiny_tty_driver->type        = TTY_DRIVER_TYPE_SERIAL;\n    tiny_tty_driver->subtype     = SERIAL_TYPE_NORMAL;\n    tiny_tty_driver->init_termios    = tty_std_termios;\n    tiny_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n    tiny_tty_driver->init_termios.c_ispeed = 9600;\n    tiny_tty_driver->flags       = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\n    tty_set_operations(tiny_tty_driver, &tty_serial_ops);\n\n    retval = tty_register_driver(tiny_tty_driver);\n\tif (retval) {\n        put_tty_driver(tiny_tty_driver);\n\t\treturn retval;        \n    }\n    \n    for (i = 0; i < TINY_TTY_MINORS; i++) {\n        tty_register_device(tiny_tty_driver, i, NULL);\n    }\n    ......\n}\n```\n\n\n\n\n``` c\nstatic struct tty_operations tiny_serial_ops = {\n    .open = tiny_open,\n    .close = tiny_close,\n    .write = tiny_write,\n    .write_room = tiny_write_room,\n    .set_termios = tiny_set_termios,\n};\n```\n\n\n\n\n\n\n\n\ntty驱动的模块卸载函数，完成加载函数相反的工作；\n\n\n```c\nvoid tiny_exit(void)\n{\n    struct tty_driver *tiny_tty_driver = get_tty_driver();\n    unsigned int i;\n    \n    for (i = 0; i < TINY_TTY_MINORS; i++) {\n        tty_unregister_device(tiny_tty_driver, i);\n    }\n    \n    tty_unregister_driver(tiny_tty_driver);\n}\n```\n\n\n\n\n#### 3.2 模块的打开和关闭\n\n\n\n\n**1) open**\n\n\n在用户态使用open()系统调用函数操作tty驱动创建的设备节点时，tty核心tty_driver的file_operations结构体中的open()成员函数被调用；用户在执行open()函数后，可以得到一个表示该文件的句柄，用来表示该文件；\n\n\n```c\nstatic int tiny_open(struct tty_struct *tty, struct file *filp)\n{\n \tstruct tiny_serial *tiny;\n    struct timer_list *timer;\n    \n    tty->driver_data = NULL;\n    index = tty->index;\n    tiny = tiny_table[index];\n    if (tiny == NULL) {\n        tiny = kmalloc(sizeof(*tiny), GFP_KERNEL);\n        if (!tiny) {\n            return -ENOMEM;\n        }\n        init_MUTEX(&tiny->sem);\n        tiny->open_count = 0;\n        tiny->timer = NULL;\n        \n        tiny_table[index] = tiny;\n    }\n    down(&tiny->sem);\n    \n    tty->driver_data = tiny;\n    tiny->tty = tty;\n    ......    \n}\n```\n\n\ntty->driver_data保存了tiny_serial结构，该结构包含tiny模块所需要的一些成员，保存在tty_struct结构体的driver_data指针，以后在tiny模块中别的函数也可以很方便地使用；\n\n\n```c\nstruct tiny_serial {\n    struct tty_struct *tty;\t// 指向该设备的tty指针\n    int open_count;\t// 该端口被打开的次数\n    struct semaphore sem;\t// 锁，可以锁住该结构\n    struct timer_list *timer;\n};\n```\n\n\n为了能使多个进程读写数据，tty驱动程序的open和close函数可能会被多次调用，因此需要使用open_count在open和close时进行计数；当端口第一次被打开时，可以对所需要的任何硬件初始化及分配所需要的内存，当端口最后一次被关闭时，可以关闭所有硬件，并清理掉所有分配的内存；\n\n\n```c\n\ttiny->open_count++;\n\tif (tiny->open_count == 1) {\n        // 该端口第一次打开\n        // 对所需要的任何硬件初始化及分配所需要的内存\n    }\n```\n\n\n\n\n**2) close**\n\n\n在open()时生成的文件句柄，在用户态使用close()系统调用操作该文件句柄时，tty_driver驱动中file_operations结构体中的close()成员函数被调用，此时设备将被关闭；和open()函数对应，close()函数可能多次调用，在close()中需要open_count进行计数；\n\n\n```c\nstatic void tiny_close(struct tty_struct *tty, struct file *filp)\n{\n    struct tiny_serial *tiny;\n    \n    tiny = tty->driver_data;\n    if (!tiny) {\n        return;        \n    }\n    down(&tiny->sem);\n    if (!tiny->open_count) {\n        goto exit;\n    }\n    tiny->open_count--;\n    if (tiny->open_count <= 0) {\n        // 最后一个用户已经关闭端口\n        // 关闭所有硬件，并清理掉所有分配的内存\n        \n        del_timer(tiny->timer);\n    }\nexit:\n    up(&tiny->sem);\n\treturn;\n}\n```\n\n\n\n\n#### 3.3 数据的发送和接收\n\n\n\n\n**1) write**\n\n\n在用户态使用write()系统调用发送数据给终端设备时，通过write-->tty核心-->tty线路规程调用-->tty驱动，最终通过tty驱动程序中file_operations结构体中的write()成员函数来完成发送；\n\n\n有时由于tty硬件速度或缓存大小的原因，write()函数被调用时，写操作程序所处理的数据不能同时都发送出去，write()函数将返回发送给硬件的字符数；用户空间可以检查write()函数返回值判断是否写入了所有数据；\n\n\ntiny驱动并没有链接真正的硬件，只是在内核调试日志中记录需要写入的数据；\n\n\n```c\nstatic int tiny_write(struct tty_struct *tty,\n                    const unsigned char *buf, int count)\n{\n    struct tiny_serial *tiny;\n    int i;\n    \n    tiny = tty->driver_data;\n    if (!tiny) {\n        return -ENODEV;        \n    }\n    \n    down(&tiny->sem);\n    if (!tiny->open_count) {\n        goto exit;\n    }\n    \n    for (i = 0; i < count; i++) {\n        printk(\"%02x \", buf[i]);\n    }\n    printk(\"\\n\");\nexit:\n    up(&tiny->sem);\n    \n    return i;\n}\n```\n\n\ntty子系统将数据传送到tty设备之外时可以使用write()函数；\n\n\n\n**2) read**\n\n\n\n\ntty_driver结构中没有提供read()函数，因为发送数据是用户主动发起的，而接收数据则是用户态读取一片缓冲区中已放好的数据；在tty核心中提供了缓冲逻辑，tty驱动中并不是必须实现自身的缓冲逻辑；\n\n\n\n\n#### 3.4 串口驱动举例\n\n\ntty类型的驱动，以串口驱动为例，在serial_core.c文件中实现；\n\n\n参考下一文----uart驱动；\n\n\n\n\n### 4. 总结\n\n\n![tty读写过程中的函数调用流程](linux-kernel中的tty驱动/tty读写过程中的函数调用流程-1598176659467.png)\n\n\n\n\n\n\n### 5. 参考资料\n\n\n\n\n《Linux内核情景分析》----控制态驱动\n\n\n《Linux设备驱动程序》\n\n\n\n\n\n笔记计划：\n\n1. tty驱动-->控制台驱动\n\n\n2. uart驱动-->8250驱动\n\n\n3. 键盘驱动-->PS/2键盘\t-->usb键盘\n4. usb转串口驱动\n\n\n\n[回到目录](#目录)","slug":"linux-kernel中的tty驱动","published":1,"updated":"2020-08-23T10:01:33.406Z","_id":"cke6x5hyv000097g1etjuedbu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>TTY 是 Teletypewriter的缩写（Teleprinter、TeletypewriterTele-Type，缩写为 TTY），中文电传打字机简称电传，是远距离打印交换的编写形式；</p>\n<p>在linux中tty表示各种终端，通常是和硬件相对应，tty用来指任何的串口设备，如：输入设备键盘鼠标、输出设备显示器、虚拟的pty等；</p>\n<a id=\"more\"></a>\n\n\n\n\n<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>tty驱动、uart驱动存在密切联系，tty设备包括uart，uart设备的工作依赖于tty设备，uart是tty的上层，内核中有完整的tty驱动，uart设备可以使用tty驱动进行封装；而内核中也有完整的uart驱动，两者相互独立又密切相关；本文主要讲解tty驱动相关的内容，以控制台驱动为例讲述tty驱动的应用，关于uart驱动方面内容，请参考下一文uart驱动；</p>\n<p>tty驱动程序的核心在标准字符设备驱动层之下；</p>\n<p>linux内核中的tty层次结构，包含：tty核心、tty线路规程、tty驱动；</p>\n<ol>\n<li>tty核心(tty_core)：整个tty设备的抽象，对用户提供统一的接口，用户空间通过设备文件与tty_core交互；tty_core根据用户空间操作类型，选择将数据交给line discipline和tty_driver；</li>\n</ol>\n<ol start=\"2\">\n<li>tty线路规程(line discipline)：对传输数据的格式化，把从用户或硬件接收的数据格式化，这种格式化使用协议完成转换，如：蓝牙；处理之后，将数据交给tty_driver；</li>\n</ol>\n<ol start=\"3\">\n<li>tty驱动(tty_driver)：tty设备对应的驱动，将字符转换成硬件可以理解的字符，将其传给硬件设备；并从硬件接收数据；</li>\n</ol>\n<p><img src=\"/2020/08/02/linux-kernel%E4%B8%AD%E7%9A%84tty%E9%A9%B1%E5%8A%A8/tty%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.jpg\" alt=\"tty层次关系\"></p>\n<p>tty核心和线路规程由内核提供，驱动工程师只需要完成tty驱动部分代码就可以使用tty了；</p>\n<p>多数时候tty核心和tty驱动之间的数据传输会经历tty线路规程的转换，但是tty驱动和tty核心之间也可以直接传输数据；tty核心根据操作类型选择和线路规程和tty驱动交互；如：设置硬件的ioctl直接交给tty_driver处理；而read/write操作交给线路规程处理；</p>\n<p>1) 发送数据流程：tty核心从用户空间获取到将要发送给tty设备的数据，tty核心将数据传递给tty线路规程驱动，然后数据被传递到tty驱动，tty驱动将数据转换为可以发送给硬件的格式；</p>\n<p>2) 接收数据流程：tty硬件将接收到的数据上交给tty驱动，进入tty线路规程驱动，再进入tty核心，被传递给用户空间；</p>\n<p>tty驱动程序有三种类型：控制台、串口和pty；控制台和pty驱动程序已经在内核中稳定使用，使用tty核心与用户和系统交互的新驱动都可以看做是串口驱动程序；</p>\n<p>tty驱动代码位于drivers/tty目录；</p>\n<h3 id=\"1-tty核心\"><a href=\"#1-tty核心\" class=\"headerlink\" title=\"1. tty核心\"></a>1. tty核心</h3><p>tty核心是所有tty类型驱动的顶层架构，向应用层提供了统一的接口；用户态的open、close、read、write系统调用首先到达tty核心；</p>\n<p>tty核心在tty_io.c文件中由内核实现，定义了tty设备需要的核心数据结构，和一些需要操作；</p>\n<h4 id=\"1-1-tty重要数据结构\"><a href=\"#1-1-tty重要数据结构\" class=\"headerlink\" title=\"1.1 tty重要数据结构\"></a>1.1 tty重要数据结构</h4><p><strong>1) tty_driver</strong></p>\n<p>tty驱动程序的主要数据结构是struct tty_driver，规定了tty驱动程序和高层之间的编程接口，用来向tty核心注册和注销驱动程序；操作包含在头文件&lt;linux/tty_driver.h&gt;中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_driver.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> magic;      <span class=\"comment\">/* magic number for this structure */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kref</span> <span class=\"title\">kref</span>;</span>   <span class=\"comment\">/* Reference management */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> **<span class=\"title\">cdevs</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span>   *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *driver_name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> name_base;  <span class=\"comment\">/* offset of printed name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> major;      <span class=\"comment\">/* major device number */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> minor_start;    <span class=\"comment\">/* start of minor device number */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>    num;    <span class=\"comment\">/* number of devices allocated */</span></span><br><span class=\"line\">    short   type;       <span class=\"comment\">/* type of tty driver */</span></span><br><span class=\"line\">    short   subtype;    <span class=\"comment\">/* subtype of tty driver */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">init_termios</span>;</span> <span class=\"comment\">/* Initial termios */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>   flags;      <span class=\"comment\">/* tty driver flags */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc_dir_entry</span> *<span class=\"title\">proc_entry</span>;</span> <span class=\"comment\">/* /proc fs entry */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">other</span>;</span> <span class=\"comment\">/* only used for the PTY driver */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Pointer to the tty data structures</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> **<span class=\"title\">ttys</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> **<span class=\"title\">ports</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> **<span class=\"title\">termios</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *driver_state;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Driver methods</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">tty_drivers</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty设备的所有操作都包含在tty_driver结构体中，内核提供alloc_tty_driver()函数来分配tty_driver结构体，参数是该驱动支持的tty设备的数量；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配tty驱动程序</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">normal</span>;</span></span><br><span class=\"line\">normal = alloc_tty_driver(nr);</span><br></pre></td></tr></table></figure>\n\n\n<p>alloc_tty_driver()函数的实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> struct tty_driver *<span class=\"title\">alloc_tty_driver</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lines)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">ret</span> = <span class=\"title\">tty_alloc_driver</span>(<span class=\"title\">lines</span>, 0);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(ret))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> tty_alloc_driver(lines, flags) \\</span></span><br><span class=\"line\">        __tty_alloc_driver(lines, THIS_MODULE, flags)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *__<span class=\"title\">tty_alloc_driver</span>(<span class=\"title\">unsigned</span> <span class=\"title\">int</span> <span class=\"title\">lines</span>, <span class=\"title\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>,</span></span><br><span class=\"line\"><span class=\"class\">         <span class=\"title\">unsigned</span> <span class=\"title\">long</span> <span class=\"title\">flags</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdriver = kzalloc(<span class=\"keyword\">sizeof</span>(struct tty_driver), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!driver)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERR_PTR(-ENOMEM);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>申请成功后，alloc_tty_driver()函数将申请到的tty_driver结构体作为返回值返回，之后，需要对tty_driver进行初始化，再通过调用tty_register_driver()来注册进内核；</p>\n<p><strong>2) tty_operations</strong></p>\n<p>tty_operations结构中包含所有的回调函数，被tty驱动程序设置，并被tty核心调用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_driver.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> * (*<span class=\"title\">lookup</span>)(<span class=\"title\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>,</span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"title\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">inode</span>, <span class=\"title\">int</span> <span class=\"title\">idx</span>);</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">remove</span>)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*<span class=\"built_in\">open</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">close</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*<span class=\"built_in\">write</span>)(struct tty_struct * tty,</span><br><span class=\"line\">              <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*put_char)(struct tty_struct *tty, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> ch);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class=\"line\">                 <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">stop</span>)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*start)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*break_ctl)(struct tty_struct *tty, <span class=\"keyword\">int</span> state);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class=\"keyword\">int</span> timeout);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*send_xchar)(struct tty_struct *tty, <span class=\"keyword\">char</span> ch);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">set</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">clear</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><strong>3) tty_struct</strong></p>\n<p>tty核心使用tty_struct结构保存当前特定tty端口的状态；除了个别成员外基本上所有成员都只能被tty核心使用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_driver.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> magic;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kref</span> <span class=\"title\">kref</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ld_semaphore</span> <span class=\"title\">ldisc_sem</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ldisc</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Termios values are protected by the termios rwsem */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">termios</span>, <span class=\"title\">termios_locked</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">termiox</span> *<span class=\"title\">termiox</span>;</span>    <span class=\"comment\">/* May be NULL for unsupported */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fasync_struct</span> *<span class=\"title\">fasync</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> alt_speed;      <span class=\"comment\">/* For magic substitution of 38400 bps */</span></span><br><span class=\"line\">    <span class=\"keyword\">wait_queue_head_t</span> write_wait;</span><br><span class=\"line\">    <span class=\"keyword\">wait_queue_head_t</span> read_wait;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *write_buf;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> write_cnt;</span><br><span class=\"line\">    <span class=\"comment\">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">work_struct</span> <span class=\"title\">SAK_work</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> *<span class=\"title\">port</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty端口的状态都包含在tty_struct结构体中，内核提供alloc_tty_struct()函数来分配tty_struct结构体，并对成员进行初始化操作，参数是该驱动的tty_driver和设备的索引号；该函数在tty核心中实现并调用，不需要在tty驱动中明确调用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配tty驱动程序</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">tty = alloc_tty_struct(driver, idx);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"1-2-tty的注册和卸载\"><a href=\"#1-2-tty的注册和卸载\" class=\"headerlink\" title=\"1.2 tty的注册和卸载\"></a>1.2 tty的注册和卸载</h4><p><strong>1) 注册</strong></p>\n<p>tty驱动的注册，由tty_register_driver()函数完成，用于将串口驱动tty_driver注册到内核；注册时会分配主设备号和次设备号，主设备号对应驱动程序，告知内核需要使用哪个驱动程序驱动该设备，次设备号对应具体的设备；</p>\n<p>tty_register_driver()函数用来向内核注册tty设备，根据tty_driver的所有次设备号，创建不同的sysfs文件；会使用fs/char_dev.c中提供的字符设备接口注册字符设备；使用fs/proc/proc_tty.c中的函数创建/proc/tty文件；在使用tty_register_driver()函数注册tty驱动之前，需要先对申请到的tty_driver结构体成员进行初始化；tty_register_driver()函数的参数是已经初始化过的tty_driver结构体指针；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_register_driver</span><span class=\"params\">(struct tty_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\talloc_chrdev_region();</span><br><span class=\"line\">    register_chrdev_region();</span><br><span class=\"line\">    tty_cdev_add();</span><br><span class=\"line\">    list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);</span><br><span class=\"line\">    <span class=\"comment\">// 注册所控制的设备</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; driver-&gt;num; i++) &#123;</span><br><span class=\"line\">            d = tty_register_device(driver, i, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (IS_ERR(d)) &#123;</span><br><span class=\"line\">                error = PTR_ERR(d);</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> err_unreg_devs;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty_cdev_add()函数中，将字符设备操作集指定为tty_fops，之后将tty_driver添加到tty_driver结构体中的tty_drivers链表中，可以通过设备号找到对应的driver；最后通过tty_register_device()函数注册tty驱动所控制的硬件设备；</p>\n<p><strong>2) 卸载</strong></p>\n<p>tty驱动的卸载，由tty_unregister_driver()函数完成，用于注销已注册的tty_driver；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_unregister_driver</span><span class=\"params\">(struct tty_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    unregister_chrdev_region(MKDEV(driver-&gt;major, driver-&gt;minor_start),</span><br><span class=\"line\">                driver-&gt;num);</span><br><span class=\"line\">\tlist_del(&amp;driver-&gt;tty_drivers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>从注册过程中可以得知，tty设备所有的操作都包含在tty_fops结构体中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">tty_fops</span> = &#123;</span></span><br><span class=\"line\">    .llseek     = no_llseek,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>       = tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>      = tty_write,</span><br><span class=\"line\">    .poll       = tty_poll,</span><br><span class=\"line\">    .unlocked_ioctl = tty_ioctl,</span><br><span class=\"line\">    .compat_ioctl   = tty_compat_ioctl,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span>       = tty_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span>    = tty_release,</span><br><span class=\"line\">    .fasync     = tty_fasync,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>特定的tty设备驱动的主要工作是填充tty_driver结构体中的成员；</p>\n<h4 id=\"1-3-tty的打开和关闭\"><a href=\"#1-3-tty的打开和关闭\" class=\"headerlink\" title=\"1.3 tty的打开和关闭\"></a>1.3 tty的打开和关闭</h4><p>tty设备的打开和关闭操作，在tty_io.c中实现通过tty_open和tty_release函数实现；tty_open和tty_release函数保持对tty打开的设备计数；</p>\n<p><strong>1) open</strong></p>\n<p>用户态使用open函数打开设备节点时，对应tty_fops结构体中的tty_open函数被调用；tty驱动程序一定要设置open成员操作，否则用户态调用open时，将返回-ENODEV；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tty_open</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span> device = inode-&gt;i_rdev;</span><br><span class=\"line\"></span><br><span class=\"line\">    nonseekable_open(inode, filp);</span><br><span class=\"line\"></span><br><span class=\"line\">retry_open:</span><br><span class=\"line\">    retval = tty_alloc_file(filp);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    tty = tty_open_current_tty(device, filp);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tty) &#123;</span><br><span class=\"line\">        mutex_lock(&amp;tty_mutex);</span><br><span class=\"line\">        driver = tty_lookup_driver(device, filp, &amp;noctty, &amp;index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* check whether we're reopening an existing tty */</span></span><br><span class=\"line\">        tty = tty_driver_lookup_tty(driver, inode, index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty) &#123;</span><br><span class=\"line\">            mutex_unlock(&amp;tty_mutex);</span><br><span class=\"line\">            retval = tty_lock_interruptible(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* safe to drop the kref from tty_driver_lookup_tty() */</span></span><br><span class=\"line\">            tty_kref_put(tty);</span><br><span class=\"line\">            retval = tty_reopen(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* Returns with the tty_lock held for now */</span></span><br><span class=\"line\">            tty = tty_init_dev(driver, index);</span><br><span class=\"line\">            mutex_unlock(&amp;tty_mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tty_driver_kref_put(driver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tty_add_file(tty, filp);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;<span class=\"built_in\">open</span>)</span><br><span class=\"line\">        retval = tty-&gt;ops-&gt;<span class=\"built_in\">open</span>(tty, filp);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        retval = -ENODEV;</span><br><span class=\"line\">    filp-&gt;f_flags = saved_flags;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty_alloc_file()函数</p>\n<p>每一个打开的tty都有一个私有数据tty_file_private结构，在tty_alloc_file()函数中用private_data指针指向该结构；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_alloc_file</span><span class=\"params\">(struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_file_private</span> *<span class=\"title\">priv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priv = kmalloc(<span class=\"keyword\">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!priv)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    file-&gt;private_data = priv;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty.h</span></span><br><span class=\"line\"><span class=\"comment\">/* Each of a tty's open files has private_data pointing to tty_file_private */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_file_private</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> *<span class=\"title\">file</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty_lookup_driver()函数查找tty_driver链表，找到注册时添加的tty_driver，然后调用tty_driver的ops-&gt;open函数打开具体的tty设备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">driver = tty_lookup_driver(device, filp, &amp;noctty, &amp;index);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct tty_driver *<span class=\"title\">tty_lookup_driver</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> device, struct file *filp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> *noctty, <span class=\"keyword\">int</span> *index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        driver = get_tty_driver(device, index);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!driver)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ERR_PTR(-ENODEV);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct tty_driver *<span class=\"title\">get_tty_driver</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> device, <span class=\"keyword\">int</span> *index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry(p, &amp;tty_drivers, tty_drivers) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">dev_t</span> base = MKDEV(p-&gt;major, p-&gt;minor_start);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (device &lt; base || device &gt;= base + p-&gt;num)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        *index = device - base;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tty_driver_kref_get(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty_reopen()</p>\n<p>tty_init_dev()</p>\n<p><strong>2) release</strong></p>\n<p>tty_release()函数通过tty-&gt;ops-&gt;close操作来关闭tty设备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_release</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">filp</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">o_tty</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span>    timeout = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;<span class=\"built_in\">close</span>)</span><br><span class=\"line\">        tty-&gt;ops-&gt;<span class=\"built_in\">close</span>(tty, filp);</span><br><span class=\"line\"></span><br><span class=\"line\">    tty_del_file(filp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Ask the line discipline code to release its structures</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    tty_ldisc_release(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Wait for pending work before tty destruction commmences */</span></span><br><span class=\"line\">    tty_flush_works(tty);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"1-4-tty的读写\"><a href=\"#1-4-tty的读写\" class=\"headerlink\" title=\"1.4 tty的读写\"></a>1.4 tty的读写</h4><p><strong>1) write</strong></p>\n<p>在用户态调用write系统调用函数将数据发送给硬件时，内核将数据和大小发送给tty驱动程序的write操作；</p>\n<p>由于tty硬件速度和缓冲区大小等原因，当write时写操作程序处理的数据不能同时发送出去，write函数将返回发送给硬件的字符数；用户态可以通过write系统条用函数的返回值，判断是否写入了所有的数据；</p>\n<p>tty设备文件的写操作通过tty_fops结构体中的tty_write函数实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_write</span><span class=\"params\">(struct file *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty_paranoia_check(tty, file_inode(file), <span class=\"string\">\"tty_write\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tty || !tty-&gt;ops-&gt;<span class=\"built_in\">write</span> ||</span><br><span class=\"line\">        (test_bit(TTY_IO_ERROR, &amp;tty-&gt;flags)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">    <span class=\"comment\">/* Short term debug to catch buggy drivers */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;write_room == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        printk(KERN_ERR <span class=\"string\">\"tty driver %s lacks a write_room method.\\n\"</span>,</span><br><span class=\"line\">            tty-&gt;driver-&gt;name);</span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ld-&gt;ops-&gt;<span class=\"built_in\">write</span>)</span><br><span class=\"line\">        ret = -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = do_tty_write(ld-&gt;ops-&gt;<span class=\"built_in\">write</span>, tty, file, buf, count);</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_write()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，在do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;write函数，进行具体的写入操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">do_tty_write</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">ssize_t</span> (*<span class=\"built_in\">write</span>)(struct tty_struct *, struct file *, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *, <span class=\"keyword\">size_t</span>),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    chunk = <span class=\"number\">2048</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class=\"line\">        chunk = <span class=\"number\">65536</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy_from_user(tty-&gt;write_buf, buf, <span class=\"built_in\">size</span>))</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ret = <span class=\"built_in\">write</span>(tty, file, tty-&gt;write_buf, <span class=\"built_in\">size</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在调用do_tty_write()函数前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&amp;ld-&gt;tty-&gt;ldisc_sem锁；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldsem_down_read(&amp;tty-&gt;ldisc_sem, MAX_SCHEDULE_TIMEOUT);</span><br><span class=\"line\">ldsem_up_read(&amp;ld-&gt;tty-&gt;ldisc_sem);</span><br></pre></td></tr></table></figure>\n\n\n<p>在do_tty_write()函数中，默认一次写入数据大小为2048字节，如果设置了TTY_NO_WRITE_SPLIT，可以一次写入65536字节数据；</p>\n<p>tty-&gt;write_buf，是写操作的临时缓冲区，存放通过copy_from_user从用户空间获取的数据；</p>\n<p>tty-&gt;write_cnt，是临时缓冲区的大小；</p>\n<p>tty_write通过ld-&gt;ops-&gt;write操作来完成数据的写入操作；</p>\n<p><strong>2) read</strong></p>\n<p>tty设备文件的写操作通过tty_fops结构体中的tty_read函数实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">inode</span> = <span class=\"title\">file_inode</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty_paranoia_check(tty, inode, <span class=\"string\">\"tty_read\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tty || (test_bit(TTY_IO_ERROR, &amp;tty-&gt;flags)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We want to wait for the line discipline to sort out in this</span></span><br><span class=\"line\"><span class=\"comment\">       situation */</span></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;<span class=\"built_in\">read</span>)</span><br><span class=\"line\">        i = ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        i = -EIO;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        tty_update_time(&amp;inode-&gt;i_atime);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_read()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;read函数，进行具体的读取操作；</p>\n<p>ld-&gt;ops-&gt;read(tty, file, buf, count)</p>\n<p>在读取操作前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&amp;ld-&gt;tty-&gt;ldisc_sem锁；</p>\n<p>ldsem_down_read(&amp;tty-&gt;ldisc_sem, MAX_SCHEDULE_TIMEOUT);</p>\n<p>ldsem_up_read(&amp;ld-&gt;tty-&gt;ldisc_sem);</p>\n<p>tty_read通过ld-&gt;ops-&gt;read操作来完成数据的读取操作；</p>\n<h4 id=\"1-5-tty线路设置\"><a href=\"#1-5-tty线路设置\" class=\"headerlink\" title=\"1.5 tty线路设置\"></a>1.5 tty线路设置</h4><p>用户态要改变线路设置，或者获取当前的线路设置时，只需要调用多个termios用户空间库函数，或者对tty设备节点调用ioctl操作；在tty核心会把这两种操作转换为tty驱动程序的回调函数或ioctl操作；大部分temios用户空间函数会被库函数转换成对tty设备节点的ioctl调用；tty的ioctl调用会被tty核心转换成一系列的set_termios调用；所有的线路设置都封装在termios结构中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uapi/asm-generic/termbits.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_iflag;       <span class=\"comment\">/* input mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_oflag;       <span class=\"comment\">/* output mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_cflag;       <span class=\"comment\">/* control mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_lflag;       <span class=\"comment\">/* local mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">cc_t</span> c_line;            <span class=\"comment\">/* line discipline */</span></span><br><span class=\"line\">    <span class=\"keyword\">cc_t</span> c_cc[NCCS];        <span class=\"comment\">/* control characters */</span></span><br><span class=\"line\">    <span class=\"keyword\">speed_t</span> c_ispeed;       <span class=\"comment\">/* input speed */</span></span><br><span class=\"line\">    <span class=\"keyword\">speed_t</span> c_ospeed;       <span class=\"comment\">/* output speed */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>ktermios结构体用来提供一个线路设置集合，给tty设备提供一个特定的端口，用来设置波特率、数据大小、数据流控设置等；如果驱动中未初始化使用，驱动中会使用tty_std_termios结构体变量；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">tty_std_termios</span> = &#123;</span> <span class=\"comment\">/* for the benefit of tty drivers  */</span></span><br><span class=\"line\">    .c_iflag = ICRNL | IXON,</span><br><span class=\"line\">    .c_oflag = OPOST | ONLCR,</span><br><span class=\"line\">    .c_cflag = B38400 | CS8 | CREAD | HUPCL,</span><br><span class=\"line\">    .c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |</span><br><span class=\"line\">           ECHOCTL | ECHOKE | IEXTEN,</span><br><span class=\"line\">    .c_cc = INIT_C_CC,</span><br><span class=\"line\">    .c_ispeed = <span class=\"number\">38400</span>,</span><br><span class=\"line\">    .c_ospeed = <span class=\"number\">38400</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>最终在内核空间tty驱动中会转换为对tty设备节点的ioctl调用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">tty_ioctl</span><span class=\"params\">(struct file *file, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;ioctl) &#123;</span><br><span class=\"line\">        retval = tty-&gt;ops-&gt;ioctl(tty, cmd, arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retval != -ENOIOCTLCMD)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    retval = -EINVAL;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;ioctl) &#123;</span><br><span class=\"line\">        retval = ld-&gt;ops-&gt;ioctl(tty, file, cmd, arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retval == -ENOIOCTLCMD)</span><br><span class=\"line\">            retval = -ENOTTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-tty线路规程\"><a href=\"#2-tty线路规程\" class=\"headerlink\" title=\"2. tty线路规程\"></a>2. tty线路规程</h3><p>tty线路规程在tty_ldisc.c文件中由内核实现；不同的tty类型设备，具有不同的线路规程；tty线路规程由内核实现，不需要驱动工程师开发；</p>\n<p>在上文tty_read和tty_write函数中可以看出，最后调用了线路规程的read和write操作；</p>\n<p>内核用tty_ldisc_ops表示设备的线路规程信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_ldisc.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> magic;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    *name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * The following routines are called from above.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">open</span>)(struct tty_struct *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*<span class=\"built_in\">close</span>)(struct tty_struct *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*flush_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*<span class=\"built_in\">read</span>)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> nr);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*<span class=\"built_in\">write</span>)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">             <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> nr);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*ioctl)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">             <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">long</span>    (*compat_ioctl)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*set_termios)(struct tty_struct *tty, struct ktermios *old);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*poll)</span><span class=\"params\">(struct tty_struct *, struct file *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 struct poll_table_struct *)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*hangup)(struct tty_struct *tty);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * The following routines are called from below.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*receive_buf)(struct tty_struct *, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *cp,</span><br><span class=\"line\">                   <span class=\"keyword\">char</span> *fp, <span class=\"keyword\">int</span> count);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*write_wakeup)(struct tty_struct *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*dcd_change)(struct tty_struct *, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*fasync)(struct tty_struct *tty, <span class=\"keyword\">int</span> on);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*receive_buf2)(struct tty_struct *, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *cp,</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *fp, <span class=\"keyword\">int</span> count);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_ldisc_ops结构体中不仅有功上层调用的函数指针成员，如：open、read、write等，还有供下层往上层调用的函数指针成员，如：receive_buf、receive_buf2、write_wakeup等；</p>\n<p>内核中有一个tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]；NR_LDISCS的值是30，系统在初始化或者安装驱动模块时通过tty_register_ldisc()函数将有关的tty_ldisc_ops结构体注册登记到tty_ldiscs[NR_LDISCS]指针数组中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uapi/linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NR_LDISCS       30</span></span><br><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> *<span class=\"title\">tty_ldiscs</span>[<span class=\"title\">NR_LDISCS</span>];</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>控制终端在内核启动时进行初始化，并给显示提供驱动服务，本节以控制终端为例进行说明，控制台对应的tty_ldisc_ops的是tty_ldiscs指针数组中序号为N_TTY的tty_ldisc_N_TTY结构，其中包含了该线路规程的大部分操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> <span class=\"title\">tty_ldisc_N_TTY</span> = &#123;</span></span><br><span class=\"line\">    .magic           = TTY_LDISC_MAGIC,</span><br><span class=\"line\">    .name            = <span class=\"string\">\"n_tty\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span>            = n_tty_open,</span><br><span class=\"line\">    .<span class=\"built_in\">close</span>           = n_tty_close,</span><br><span class=\"line\">    .flush_buffer    = n_tty_flush_buffer,</span><br><span class=\"line\">    .chars_in_buffer = n_tty_chars_in_buffer,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>            = n_tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>           = n_tty_write,</span><br><span class=\"line\">    .ioctl           = n_tty_ioctl,</span><br><span class=\"line\">    .set_termios     = n_tty_set_termios,</span><br><span class=\"line\">    .poll            = n_tty_poll,</span><br><span class=\"line\">    .receive_buf     = n_tty_receive_buf,</span><br><span class=\"line\">    .write_wakeup    = n_tty_write_wakeup,</span><br><span class=\"line\">    .fasync      = n_tty_fasync,</span><br><span class=\"line\">    .receive_buf2    = n_tty_receive_buf2,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-1-注册和卸载\"><a href=\"#2-1-注册和卸载\" class=\"headerlink\" title=\"2.1 注册和卸载\"></a>2.1 注册和卸载</h4><p><strong>1) 注册</strong></p>\n<p>tty_register_ldisc()函数用来向内核注册一个新的线路规程，要注册的线路规程，将以索引的形式添加到tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中；</p>\n<p>一个串口可以对应多个已被注册的线路规程，最后调用到哪个线路规程，需要用户在打开串口后使用ioctl()选择；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_register_ldisc</span><span class=\"params\">(<span class=\"keyword\">int</span> disc, struct tty_ldisc_ops *new_ldisc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disc &lt; N_TTY || disc &gt;= NR_LDISCS)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    raw_spin_lock_irqsave(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\">    tty_ldiscs[disc] = new_ldisc;</span><br><span class=\"line\">    new_ldisc-&gt;num = disc;</span><br><span class=\"line\">    new_ldisc-&gt;refcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    raw_spin_unlock_irqrestore(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(tty_register_ldisc);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>在内核启动中kernel_start()函数中，通过console_init()函数初始化控制终端，之后显示屏或者串口打印信息才能够正常打印出来；console_init()函数是通过tty_ldisc_begin()来注册默认的线路规程tty_ldisc_N_TTY的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">console_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">initcall_t</span> *call;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Setup the default TTY line discipline. */</span></span><br><span class=\"line\">    tty_ldisc_begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    call = __con_initcall_start;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class=\"line\">        (*call)();</span><br><span class=\"line\">        call++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_ldisc_begin()函数用来设置默认的tty线路规程，通过tty_register_ldisc()注册tty_ldisc_ops结构的tty_ldisc_N_TTY；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uapi/linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY       0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tty_ldisc_begin</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Setup the default TTY line discipline. */</span></span><br><span class=\"line\">    (<span class=\"keyword\">void</span>) tty_register_ldisc(N_TTY, &amp;tty_ldisc_N_TTY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><strong>2) 卸载</strong></p>\n<p>tty_unregister_ldisc()函数从内核注销一个线路规程；根据索引将要卸载的线路规程，在tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中指向NULL；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_unregister_ldisc</span><span class=\"params\">(<span class=\"keyword\">int</span> disc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disc &lt; N_TTY || disc &gt;= NR_LDISCS)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    raw_spin_lock_irqsave(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty_ldiscs[disc]-&gt;refcount)</span><br><span class=\"line\">        ret = -EBUSY;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        tty_ldiscs[disc] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    raw_spin_unlock_irqrestore(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(tty_unregister_ldisc);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-2-打开和关闭\"><a href=\"#2-2-打开和关闭\" class=\"headerlink\" title=\"2.2 打开和关闭\"></a>2.2 打开和关闭</h4><p><strong>1) open</strong></p>\n<p>在tty核心的打开操作中会调用打开线路规程，该操作主要是申请一些资源，并对一些线路规程的数据进行初始化；申请n_tty_data结构体，read_buf成员作为读取缓冲区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">n_tty_open</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Currently a malloc failure here can panic */</span></span><br><span class=\"line\">    ldata = vzalloc(<span class=\"keyword\">sizeof</span>(*ldata));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ldata)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    ldata-&gt;overrun_time = jiffies;</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;atomic_read_lock);</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    tty-&gt;disc_data = ldata;</span><br><span class=\"line\">    tty-&gt;closing = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"comment\">/* indicate buffer work may resume */</span></span><br><span class=\"line\">    clear_bit(TTY_LDISC_HALTED, &amp;tty-&gt;flags);</span><br><span class=\"line\">    n_tty_set_termios(tty, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    tty_unthrottle(tty);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>n_tty_data结构体中的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* producer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* shared by producer and consumer */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> read_buf[N_TTY_BUF_SIZE];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* consumer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tty-&gt;read_buf[]\t<span class=\"comment\">// 环形缓冲区；</span></span><br><span class=\"line\">tty-&gt;read_tail\t<span class=\"comment\">// 指向缓冲区当前可以读取的第一个字符；</span></span><br><span class=\"line\">tty-&gt;read_head\t<span class=\"comment\">// 指向缓冲区当前可以写入的第一个地址；</span></span><br></pre></td></tr></table></figure>\n\n<p>tty_unthrottle()函数，打开缓冲区阀门，使缓冲区能够接收到硬件发送过来的数据；</p>\n<p><strong>2) close</strong></p>\n<p>同样线路规程的关闭操作中，主要是释放申请的变量资源；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">n_tty_close</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;link)</span><br><span class=\"line\">        n_tty_packet_mode_flush(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">    vfree(ldata);</span><br><span class=\"line\">    tty-&gt;disc_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-3-写入和读取\"><a href=\"#2-3-写入和读取\" class=\"headerlink\" title=\"2.3 写入和读取\"></a>2.3 写入和读取</h4><p>从上文tty核心中的读写函数可以看出，tty_read和tty_write函数内部调用的是线路规程的read和write操作；</p>\n<p><strong>1) write</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_write</span><span class=\"params\">(struct file *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ld-&gt;ops-&gt;<span class=\"built_in\">write</span>)</span><br><span class=\"line\">        ret = -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = do_tty_write(ld-&gt;ops-&gt;<span class=\"built_in\">write</span>, tty, file, buf, count);</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty_write()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，在do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;write函数完成tty的write操作；</p>\n<p>tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&amp;ld-&gt;tty-&gt;ldisc_sem锁；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldsem_down_read(&amp;tty-&gt;ldisc_sem, MAX_SCHEDULE_TIMEOUT);</span><br><span class=\"line\">ldsem_up_read(&amp;ld-&gt;tty-&gt;ldisc_sem);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>在默认的终端设备中，ld-&gt;ops-&gt;write对应的是tty_ldisc_N_TTY结构中的n_tty_write()函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">n_tty_write</span><span class=\"params\">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *b = buf;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (nr &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mutex_lock(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\">        c = tty-&gt;ops-&gt;<span class=\"built_in\">write</span>(tty, b, nr);</span><br><span class=\"line\">        mutex_unlock(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            retval = c;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> break_out;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!c)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        b += c;</span><br><span class=\"line\">        nr -= c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>n_tty_write()函数中通过tty-&gt;ops-&gt;write(tty, b, nr)将数据写入控制终端；</p>\n<p>以串口uart驱动为例；tty-&gt;ops-&gt;write，是tty_struct结构体中tty_operations中的write函数uart_write；而tty_operations结构体是在uart_register_driver()时，对tty_driver结构体初始化时，使用tty_set_operations()函数设置的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// serial_core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uart_register_driver</span><span class=\"params\">(struct uart_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">normal</span>;</span></span><br><span class=\"line\">    normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!normal)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_kfree;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    tty_set_operations(normal, &amp;uart_ops);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_set_operations()函数就是将tty_operations结构体赋值给tty_driver结构体中的ops指针；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tty_set_operations</span><span class=\"params\">(struct tty_driver *driver,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">const</span> struct tty_operations *op)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    driver-&gt;ops = op;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>至于uart_write()函数的实现，在下一文uart驱动中进行说明，此处略过；</p>\n<p><strong>2) read</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We want to wait for the line discipline to sort out in this</span></span><br><span class=\"line\"><span class=\"comment\">       situation */</span></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;<span class=\"built_in\">read</span>)</span><br><span class=\"line\">        i = ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        i = -EIO;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> <span class=\"title\">tty_ldisc_N_TTY</span> = &#123;</span></span><br><span class=\"line\">    .name            = <span class=\"string\">\"n_tty\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>            = n_tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>           = n_tty_write,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>在控制台中，ld-&gt;ops-&gt;read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，n_tty_read()函数的详细，请参考下一文；</p>\n<p>在n_tty_read()函数中进行一些校验和读取进程的休眠和唤醒操作，最终通过canon_copy_from_read_buf()函数或canon_copy_from_read_buf()函数，将数据从缓冲区中读取到用户空间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">n_tty_read</span><span class=\"params\">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    \t......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) &#123;</span><br><span class=\"line\">            retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> uncopied;</span><br><span class=\"line\"></span><br><span class=\"line\">            uncopied = copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">            uncopied += copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (uncopied) &#123;</span><br><span class=\"line\">                retval = -EFAULT;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"3-tty驱动\"><a href=\"#3-tty驱动\" class=\"headerlink\" title=\"3. tty驱动\"></a>3. tty驱动</h3><p>具体的tty设备的驱动程序，由驱动开发者来实现；本文以创建一个小型tty驱动程序为例，能够加载、卸载，并对其进行读写操作；</p>\n<p>终端设备驱动都围绕tty_driver结构开始；终端设备驱动应包含：</p>\n<ol>\n<li><p>终端设备驱动模块加载函数和卸载函数，完成注册和注销tty_driver，初始化和释放终端设备对应的tty_driver结构体成员及硬件资源；</p>\n</li>\n<li><p>实现tty_operations结构体中的成员函数，主要实现open()、close()、read()、write()、tiocmget()、tiocmset()函数等；</p>\n</li>\n</ol>\n<h4 id=\"3-1-模块加载和卸载\"><a href=\"#3-1-模块加载和卸载\" class=\"headerlink\" title=\"3.1 模块加载和卸载\"></a>3.1 模块加载和卸载</h4><p>tty驱动的模块加载函数中通常需要分配和初始化tty_driver结构体，并申请必要的硬件资源；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tiny_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">tiny_tty_driver</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny_tty_driver)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    tiny_tty_driver-&gt;driver_name = <span class=\"string\">\"tiny_tty\"</span>;</span><br><span class=\"line\">    tiny_tty_driver-&gt;name        = <span class=\"string\">\"ttty\"</span>;</span><br><span class=\"line\">    tiny_tty_driver-&gt;major       = TINY_MAJOR;</span><br><span class=\"line\">    tiny_tty_driver-&gt;minor_start = TINY_MINOR;</span><br><span class=\"line\">    tiny_tty_driver-&gt;type        = TTY_DRIVER_TYPE_SERIAL;</span><br><span class=\"line\">    tiny_tty_driver-&gt;subtype     = SERIAL_TYPE_NORMAL;</span><br><span class=\"line\">    tiny_tty_driver-&gt;init_termios    = tty_std_termios;</span><br><span class=\"line\">    tiny_tty_driver-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class=\"line\">    tiny_tty_driver-&gt;init_termios.c_ispeed = <span class=\"number\">9600</span>;</span><br><span class=\"line\">    tiny_tty_driver-&gt;flags       = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class=\"line\">    tty_set_operations(tiny_tty_driver, &amp;tty_serial_ops);</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = tty_register_driver(tiny_tty_driver);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (retval) &#123;</span><br><span class=\"line\">        put_tty_driver(tiny_tty_driver);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> retval;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; TINY_TTY_MINORS; i++) &#123;</span><br><span class=\"line\">        tty_register_device(tiny_tty_driver, i, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> <span class=\"title\">tiny_serial_ops</span> = &#123;</span></span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = tiny_open,</span><br><span class=\"line\">    .<span class=\"built_in\">close</span> = tiny_close,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span> = tiny_write,</span><br><span class=\"line\">    .write_room = tiny_write_room,</span><br><span class=\"line\">    .set_termios = tiny_set_termios,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<p>tty驱动的模块卸载函数，完成加载函数相反的工作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tiny_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">tiny_tty_driver</span> = <span class=\"title\">get_tty_driver</span>();</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; TINY_TTY_MINORS; i++) &#123;</span><br><span class=\"line\">        tty_unregister_device(tiny_tty_driver, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tty_unregister_driver(tiny_tty_driver);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-2-模块的打开和关闭\"><a href=\"#3-2-模块的打开和关闭\" class=\"headerlink\" title=\"3.2 模块的打开和关闭\"></a>3.2 模块的打开和关闭</h4><p><strong>1) open</strong></p>\n<p>在用户态使用open()系统调用函数操作tty驱动创建的设备节点时，tty核心tty_driver的file_operations结构体中的open()成员函数被调用；用户在执行open()函数后，可以得到一个表示该文件的句柄，用来表示该文件；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tiny_open</span><span class=\"params\">(struct tty_struct *tty, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> \t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> *<span class=\"title\">tiny</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_list</span> *<span class=\"title\">timer</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    tty-&gt;driver_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    index = tty-&gt;index;</span><br><span class=\"line\">    tiny = tiny_table[index];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tiny == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        tiny = kmalloc(<span class=\"keyword\">sizeof</span>(*tiny), GFP_KERNEL);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tiny) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        init_MUTEX(&amp;tiny-&gt;sem);</span><br><span class=\"line\">        tiny-&gt;open_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tiny-&gt;timer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        tiny_table[index] = tiny;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    down(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    </span><br><span class=\"line\">    tty-&gt;driver_data = tiny;</span><br><span class=\"line\">    tiny-&gt;tty = tty;</span><br><span class=\"line\">    ......    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty-&gt;driver_data保存了tiny_serial结构，该结构包含tiny模块所需要的一些成员，保存在tty_struct结构体的driver_data指针，以后在tiny模块中别的函数也可以很方便地使用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span>\t<span class=\"comment\">// 指向该设备的tty指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> open_count;\t<span class=\"comment\">// 该端口被打开的次数</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semaphore</span> <span class=\"title\">sem</span>;</span>\t<span class=\"comment\">// 锁，可以锁住该结构</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_list</span> *<span class=\"title\">timer</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>为了能使多个进程读写数据，tty驱动程序的open和close函数可能会被多次调用，因此需要使用open_count在open和close时进行计数；当端口第一次被打开时，可以对所需要的任何硬件初始化及分配所需要的内存，当端口最后一次被关闭时，可以关闭所有硬件，并清理掉所有分配的内存；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tiny-&gt;open_count++;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tiny-&gt;open_count == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 该端口第一次打开</span></span><br><span class=\"line\">       <span class=\"comment\">// 对所需要的任何硬件初始化及分配所需要的内存</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><strong>2) close</strong></p>\n<p>在open()时生成的文件句柄，在用户态使用close()系统调用操作该文件句柄时，tty_driver驱动中file_operations结构体中的close()成员函数被调用，此时设备将被关闭；和open()函数对应，close()函数可能多次调用，在close()中需要open_count进行计数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tiny_close</span><span class=\"params\">(struct tty_struct *tty, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> *<span class=\"title\">tiny</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    tiny = tty-&gt;driver_data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    down(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny-&gt;open_count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tiny-&gt;open_count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tiny-&gt;open_count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个用户已经关闭端口</span></span><br><span class=\"line\">        <span class=\"comment\">// 关闭所有硬件，并清理掉所有分配的内存</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        del_timer(tiny-&gt;timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">    up(&amp;tiny-&gt;sem);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-3-数据的发送和接收\"><a href=\"#3-3-数据的发送和接收\" class=\"headerlink\" title=\"3.3 数据的发送和接收\"></a>3.3 数据的发送和接收</h4><p><strong>1) write</strong></p>\n<p>在用户态使用write()系统调用发送数据给终端设备时，通过write–&gt;tty核心–&gt;tty线路规程调用–&gt;tty驱动，最终通过tty驱动程序中file_operations结构体中的write()成员函数来完成发送；</p>\n<p>有时由于tty硬件速度或缓存大小的原因，write()函数被调用时，写操作程序所处理的数据不能同时都发送出去，write()函数将返回发送给硬件的字符数；用户空间可以检查write()函数返回值判断是否写入了所有数据；</p>\n<p>tiny驱动并没有链接真正的硬件，只是在内核调试日志中记录需要写入的数据；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tiny_write</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> *<span class=\"title\">tiny</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tiny = tty-&gt;driver_data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENODEV;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    down(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny-&gt;open_count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%02x \"</span>, buf[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printk(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">    up(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty子系统将数据传送到tty设备之外时可以使用write()函数；</p>\n<p><strong>2) read</strong></p>\n<p>tty_driver结构中没有提供read()函数，因为发送数据是用户主动发起的，而接收数据则是用户态读取一片缓冲区中已放好的数据；在tty核心中提供了缓冲逻辑，tty驱动中并不是必须实现自身的缓冲逻辑；</p>\n<h4 id=\"3-4-串口驱动举例\"><a href=\"#3-4-串口驱动举例\" class=\"headerlink\" title=\"3.4 串口驱动举例\"></a>3.4 串口驱动举例</h4><p>tty类型的驱动，以串口驱动为例，在serial_core.c文件中实现；</p>\n<p>参考下一文—-uart驱动；</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p><img src=\"/2020/08/02/linux-kernel%E4%B8%AD%E7%9A%84tty%E9%A9%B1%E5%8A%A8/tty%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B-1598176659467.png\" alt=\"tty读写过程中的函数调用流程\"></p>\n<h3 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5. 参考资料\"></a>5. 参考资料</h3><p>《Linux内核情景分析》—-控制态驱动</p>\n<p>《Linux设备驱动程序》</p>\n<p>笔记计划：</p>\n<ol>\n<li>tty驱动–&gt;控制台驱动</li>\n</ol>\n<ol start=\"2\">\n<li>uart驱动–&gt;8250驱动</li>\n</ol>\n<ol start=\"3\">\n<li>键盘驱动–&gt;PS/2键盘    –&gt;usb键盘</li>\n<li>usb转串口驱动</li>\n</ol>\n<p><a href=\"#目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>TTY 是 Teletypewriter的缩写（Teleprinter、TeletypewriterTele-Type，缩写为 TTY），中文电传打字机简称电传，是远距离打印交换的编写形式；</p>\n<p>在linux中tty表示各种终端，通常是和硬件相对应，tty用来指任何的串口设备，如：输入设备键盘鼠标、输出设备显示器、虚拟的pty等；</p>","more":"<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>tty驱动、uart驱动存在密切联系，tty设备包括uart，uart设备的工作依赖于tty设备，uart是tty的上层，内核中有完整的tty驱动，uart设备可以使用tty驱动进行封装；而内核中也有完整的uart驱动，两者相互独立又密切相关；本文主要讲解tty驱动相关的内容，以控制台驱动为例讲述tty驱动的应用，关于uart驱动方面内容，请参考下一文uart驱动；</p>\n<p>tty驱动程序的核心在标准字符设备驱动层之下；</p>\n<p>linux内核中的tty层次结构，包含：tty核心、tty线路规程、tty驱动；</p>\n<ol>\n<li>tty核心(tty_core)：整个tty设备的抽象，对用户提供统一的接口，用户空间通过设备文件与tty_core交互；tty_core根据用户空间操作类型，选择将数据交给line discipline和tty_driver；</li>\n</ol>\n<ol start=\"2\">\n<li>tty线路规程(line discipline)：对传输数据的格式化，把从用户或硬件接收的数据格式化，这种格式化使用协议完成转换，如：蓝牙；处理之后，将数据交给tty_driver；</li>\n</ol>\n<ol start=\"3\">\n<li>tty驱动(tty_driver)：tty设备对应的驱动，将字符转换成硬件可以理解的字符，将其传给硬件设备；并从硬件接收数据；</li>\n</ol>\n<p><img src=\"/2020/08/02/linux-kernel%E4%B8%AD%E7%9A%84tty%E9%A9%B1%E5%8A%A8/tty%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.jpg\" alt=\"tty层次关系\"></p>\n<p>tty核心和线路规程由内核提供，驱动工程师只需要完成tty驱动部分代码就可以使用tty了；</p>\n<p>多数时候tty核心和tty驱动之间的数据传输会经历tty线路规程的转换，但是tty驱动和tty核心之间也可以直接传输数据；tty核心根据操作类型选择和线路规程和tty驱动交互；如：设置硬件的ioctl直接交给tty_driver处理；而read/write操作交给线路规程处理；</p>\n<p>1) 发送数据流程：tty核心从用户空间获取到将要发送给tty设备的数据，tty核心将数据传递给tty线路规程驱动，然后数据被传递到tty驱动，tty驱动将数据转换为可以发送给硬件的格式；</p>\n<p>2) 接收数据流程：tty硬件将接收到的数据上交给tty驱动，进入tty线路规程驱动，再进入tty核心，被传递给用户空间；</p>\n<p>tty驱动程序有三种类型：控制台、串口和pty；控制台和pty驱动程序已经在内核中稳定使用，使用tty核心与用户和系统交互的新驱动都可以看做是串口驱动程序；</p>\n<p>tty驱动代码位于drivers/tty目录；</p>\n<h3 id=\"1-tty核心\"><a href=\"#1-tty核心\" class=\"headerlink\" title=\"1. tty核心\"></a>1. tty核心</h3><p>tty核心是所有tty类型驱动的顶层架构，向应用层提供了统一的接口；用户态的open、close、read、write系统调用首先到达tty核心；</p>\n<p>tty核心在tty_io.c文件中由内核实现，定义了tty设备需要的核心数据结构，和一些需要操作；</p>\n<h4 id=\"1-1-tty重要数据结构\"><a href=\"#1-1-tty重要数据结构\" class=\"headerlink\" title=\"1.1 tty重要数据结构\"></a>1.1 tty重要数据结构</h4><p><strong>1) tty_driver</strong></p>\n<p>tty驱动程序的主要数据结构是struct tty_driver，规定了tty驱动程序和高层之间的编程接口，用来向tty核心注册和注销驱动程序；操作包含在头文件&lt;linux/tty_driver.h&gt;中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_driver.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> magic;      <span class=\"comment\">/* magic number for this structure */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kref</span> <span class=\"title\">kref</span>;</span>   <span class=\"comment\">/* Reference management */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> **<span class=\"title\">cdevs</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span>   *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *driver_name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>  *name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> name_base;  <span class=\"comment\">/* offset of printed name */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> major;      <span class=\"comment\">/* major device number */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> minor_start;    <span class=\"comment\">/* start of minor device number */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>    num;    <span class=\"comment\">/* number of devices allocated */</span></span><br><span class=\"line\">    short   type;       <span class=\"comment\">/* type of tty driver */</span></span><br><span class=\"line\">    short   subtype;    <span class=\"comment\">/* subtype of tty driver */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">init_termios</span>;</span> <span class=\"comment\">/* Initial termios */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>   flags;      <span class=\"comment\">/* tty driver flags */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc_dir_entry</span> *<span class=\"title\">proc_entry</span>;</span> <span class=\"comment\">/* /proc fs entry */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">other</span>;</span> <span class=\"comment\">/* only used for the PTY driver */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Pointer to the tty data structures</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> **<span class=\"title\">ttys</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> **<span class=\"title\">ports</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> **<span class=\"title\">termios</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *driver_state;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Driver methods</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">tty_drivers</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty设备的所有操作都包含在tty_driver结构体中，内核提供alloc_tty_driver()函数来分配tty_driver结构体，参数是该驱动支持的tty设备的数量；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配tty驱动程序</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">normal</span>;</span></span><br><span class=\"line\">normal = alloc_tty_driver(nr);</span><br></pre></td></tr></table></figure>\n\n\n<p>alloc_tty_driver()函数的实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> struct tty_driver *<span class=\"title\">alloc_tty_driver</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lines)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">ret</span> = <span class=\"title\">tty_alloc_driver</span>(<span class=\"title\">lines</span>, 0);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ERR(ret))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> tty_alloc_driver(lines, flags) \\</span></span><br><span class=\"line\">        __tty_alloc_driver(lines, THIS_MODULE, flags)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *__<span class=\"title\">tty_alloc_driver</span>(<span class=\"title\">unsigned</span> <span class=\"title\">int</span> <span class=\"title\">lines</span>, <span class=\"title\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>,</span></span><br><span class=\"line\"><span class=\"class\">         <span class=\"title\">unsigned</span> <span class=\"title\">long</span> <span class=\"title\">flags</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdriver = kzalloc(<span class=\"keyword\">sizeof</span>(struct tty_driver), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!driver)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERR_PTR(-ENOMEM);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>申请成功后，alloc_tty_driver()函数将申请到的tty_driver结构体作为返回值返回，之后，需要对tty_driver进行初始化，再通过调用tty_register_driver()来注册进内核；</p>\n<p><strong>2) tty_operations</strong></p>\n<p>tty_operations结构中包含所有的回调函数，被tty驱动程序设置，并被tty核心调用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_driver.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> * (*<span class=\"title\">lookup</span>)(<span class=\"title\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>,</span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"title\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">inode</span>, <span class=\"title\">int</span> <span class=\"title\">idx</span>);</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">remove</span>)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*<span class=\"built_in\">open</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">close</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">shutdown</span>)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*<span class=\"built_in\">write</span>)(struct tty_struct * tty,</span><br><span class=\"line\">              <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*put_char)(struct tty_struct *tty, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> ch);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class=\"line\">                 <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">stop</span>)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*start)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*break_ctl)(struct tty_struct *tty, <span class=\"keyword\">int</span> state);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class=\"keyword\">int</span> timeout);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*send_xchar)(struct tty_struct *tty, <span class=\"keyword\">char</span> ch);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">set</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">clear</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><strong>3) tty_struct</strong></p>\n<p>tty核心使用tty_struct结构保存当前特定tty端口的状态；除了个别成员外基本上所有成员都只能被tty核心使用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_driver.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> magic;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kref</span> <span class=\"title\">kref</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ld_semaphore</span> <span class=\"title\">ldisc_sem</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ldisc</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Termios values are protected by the termios rwsem */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">termios</span>, <span class=\"title\">termios_locked</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">termiox</span> *<span class=\"title\">termiox</span>;</span>    <span class=\"comment\">/* May be NULL for unsupported */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fasync_struct</span> *<span class=\"title\">fasync</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> alt_speed;      <span class=\"comment\">/* For magic substitution of 38400 bps */</span></span><br><span class=\"line\">    <span class=\"keyword\">wait_queue_head_t</span> write_wait;</span><br><span class=\"line\">    <span class=\"keyword\">wait_queue_head_t</span> read_wait;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *write_buf;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> write_cnt;</span><br><span class=\"line\">    <span class=\"comment\">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">work_struct</span> <span class=\"title\">SAK_work</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_port</span> *<span class=\"title\">port</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty端口的状态都包含在tty_struct结构体中，内核提供alloc_tty_struct()函数来分配tty_struct结构体，并对成员进行初始化操作，参数是该驱动的tty_driver和设备的索引号；该函数在tty核心中实现并调用，不需要在tty驱动中明确调用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配tty驱动程序</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">tty = alloc_tty_struct(driver, idx);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"1-2-tty的注册和卸载\"><a href=\"#1-2-tty的注册和卸载\" class=\"headerlink\" title=\"1.2 tty的注册和卸载\"></a>1.2 tty的注册和卸载</h4><p><strong>1) 注册</strong></p>\n<p>tty驱动的注册，由tty_register_driver()函数完成，用于将串口驱动tty_driver注册到内核；注册时会分配主设备号和次设备号，主设备号对应驱动程序，告知内核需要使用哪个驱动程序驱动该设备，次设备号对应具体的设备；</p>\n<p>tty_register_driver()函数用来向内核注册tty设备，根据tty_driver的所有次设备号，创建不同的sysfs文件；会使用fs/char_dev.c中提供的字符设备接口注册字符设备；使用fs/proc/proc_tty.c中的函数创建/proc/tty文件；在使用tty_register_driver()函数注册tty驱动之前，需要先对申请到的tty_driver结构体成员进行初始化；tty_register_driver()函数的参数是已经初始化过的tty_driver结构体指针；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_register_driver</span><span class=\"params\">(struct tty_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\talloc_chrdev_region();</span><br><span class=\"line\">    register_chrdev_region();</span><br><span class=\"line\">    tty_cdev_add();</span><br><span class=\"line\">    list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);</span><br><span class=\"line\">    <span class=\"comment\">// 注册所控制的设备</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; driver-&gt;num; i++) &#123;</span><br><span class=\"line\">            d = tty_register_device(driver, i, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (IS_ERR(d)) &#123;</span><br><span class=\"line\">                error = PTR_ERR(d);</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> err_unreg_devs;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty_cdev_add()函数中，将字符设备操作集指定为tty_fops，之后将tty_driver添加到tty_driver结构体中的tty_drivers链表中，可以通过设备号找到对应的driver；最后通过tty_register_device()函数注册tty驱动所控制的硬件设备；</p>\n<p><strong>2) 卸载</strong></p>\n<p>tty驱动的卸载，由tty_unregister_driver()函数完成，用于注销已注册的tty_driver；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_unregister_driver</span><span class=\"params\">(struct tty_driver *driver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    unregister_chrdev_region(MKDEV(driver-&gt;major, driver-&gt;minor_start),</span><br><span class=\"line\">                driver-&gt;num);</span><br><span class=\"line\">\tlist_del(&amp;driver-&gt;tty_drivers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>从注册过程中可以得知，tty设备所有的操作都包含在tty_fops结构体中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// drivers/tty/tty_io.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">tty_fops</span> = &#123;</span></span><br><span class=\"line\">    .llseek     = no_llseek,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>       = tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>      = tty_write,</span><br><span class=\"line\">    .poll       = tty_poll,</span><br><span class=\"line\">    .unlocked_ioctl = tty_ioctl,</span><br><span class=\"line\">    .compat_ioctl   = tty_compat_ioctl,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span>       = tty_open,</span><br><span class=\"line\">    .<span class=\"built_in\">release</span>    = tty_release,</span><br><span class=\"line\">    .fasync     = tty_fasync,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>特定的tty设备驱动的主要工作是填充tty_driver结构体中的成员；</p>\n<h4 id=\"1-3-tty的打开和关闭\"><a href=\"#1-3-tty的打开和关闭\" class=\"headerlink\" title=\"1.3 tty的打开和关闭\"></a>1.3 tty的打开和关闭</h4><p>tty设备的打开和关闭操作，在tty_io.c中实现通过tty_open和tty_release函数实现；tty_open和tty_release函数保持对tty打开的设备计数；</p>\n<p><strong>1) open</strong></p>\n<p>用户态使用open函数打开设备节点时，对应tty_fops结构体中的tty_open函数被调用；tty驱动程序一定要设置open成员操作，否则用户态调用open时，将返回-ENODEV；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tty_open</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span> device = inode-&gt;i_rdev;</span><br><span class=\"line\"></span><br><span class=\"line\">    nonseekable_open(inode, filp);</span><br><span class=\"line\"></span><br><span class=\"line\">retry_open:</span><br><span class=\"line\">    retval = tty_alloc_file(filp);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    tty = tty_open_current_tty(device, filp);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tty) &#123;</span><br><span class=\"line\">        mutex_lock(&amp;tty_mutex);</span><br><span class=\"line\">        driver = tty_lookup_driver(device, filp, &amp;noctty, &amp;index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* check whether we're reopening an existing tty */</span></span><br><span class=\"line\">        tty = tty_driver_lookup_tty(driver, inode, index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty) &#123;</span><br><span class=\"line\">            mutex_unlock(&amp;tty_mutex);</span><br><span class=\"line\">            retval = tty_lock_interruptible(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* safe to drop the kref from tty_driver_lookup_tty() */</span></span><br><span class=\"line\">            tty_kref_put(tty);</span><br><span class=\"line\">            retval = tty_reopen(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* Returns with the tty_lock held for now */</span></span><br><span class=\"line\">            tty = tty_init_dev(driver, index);</span><br><span class=\"line\">            mutex_unlock(&amp;tty_mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tty_driver_kref_put(driver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tty_add_file(tty, filp);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;<span class=\"built_in\">open</span>)</span><br><span class=\"line\">        retval = tty-&gt;ops-&gt;<span class=\"built_in\">open</span>(tty, filp);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        retval = -ENODEV;</span><br><span class=\"line\">    filp-&gt;f_flags = saved_flags;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty_alloc_file()函数</p>\n<p>每一个打开的tty都有一个私有数据tty_file_private结构，在tty_alloc_file()函数中用private_data指针指向该结构；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_alloc_file</span><span class=\"params\">(struct file *file)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_file_private</span> *<span class=\"title\">priv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priv = kmalloc(<span class=\"keyword\">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!priv)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    file-&gt;private_data = priv;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty.h</span></span><br><span class=\"line\"><span class=\"comment\">/* Each of a tty's open files has private_data pointing to tty_file_private */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_file_private</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> *<span class=\"title\">file</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty_lookup_driver()函数查找tty_driver链表，找到注册时添加的tty_driver，然后调用tty_driver的ops-&gt;open函数打开具体的tty设备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">driver</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">driver = tty_lookup_driver(device, filp, &amp;noctty, &amp;index);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct tty_driver *<span class=\"title\">tty_lookup_driver</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> device, struct file *filp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> *noctty, <span class=\"keyword\">int</span> *index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        driver = get_tty_driver(device, index);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!driver)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ERR_PTR(-ENODEV);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> driver;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct tty_driver *<span class=\"title\">get_tty_driver</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> device, <span class=\"keyword\">int</span> *index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry(p, &amp;tty_drivers, tty_drivers) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">dev_t</span> base = MKDEV(p-&gt;major, p-&gt;minor_start);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (device &lt; base || device &gt;= base + p-&gt;num)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        *index = device - base;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tty_driver_kref_get(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>tty_reopen()</p>\n<p>tty_init_dev()</p>\n<p><strong>2) release</strong></p>\n<p>tty_release()函数通过tty-&gt;ops-&gt;close操作来关闭tty设备；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_release</span><span class=\"params\">(struct inode *inode, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">filp</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">o_tty</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span>    timeout = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;<span class=\"built_in\">close</span>)</span><br><span class=\"line\">        tty-&gt;ops-&gt;<span class=\"built_in\">close</span>(tty, filp);</span><br><span class=\"line\"></span><br><span class=\"line\">    tty_del_file(filp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Ask the line discipline code to release its structures</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    tty_ldisc_release(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Wait for pending work before tty destruction commmences */</span></span><br><span class=\"line\">    tty_flush_works(tty);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"1-4-tty的读写\"><a href=\"#1-4-tty的读写\" class=\"headerlink\" title=\"1.4 tty的读写\"></a>1.4 tty的读写</h4><p><strong>1) write</strong></p>\n<p>在用户态调用write系统调用函数将数据发送给硬件时，内核将数据和大小发送给tty驱动程序的write操作；</p>\n<p>由于tty硬件速度和缓冲区大小等原因，当write时写操作程序处理的数据不能同时发送出去，write函数将返回发送给硬件的字符数；用户态可以通过write系统条用函数的返回值，判断是否写入了所有的数据；</p>\n<p>tty设备文件的写操作通过tty_fops结构体中的tty_write函数实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_write</span><span class=\"params\">(struct file *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty_paranoia_check(tty, file_inode(file), <span class=\"string\">\"tty_write\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tty || !tty-&gt;ops-&gt;<span class=\"built_in\">write</span> ||</span><br><span class=\"line\">        (test_bit(TTY_IO_ERROR, &amp;tty-&gt;flags)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">    <span class=\"comment\">/* Short term debug to catch buggy drivers */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;write_room == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        printk(KERN_ERR <span class=\"string\">\"tty driver %s lacks a write_room method.\\n\"</span>,</span><br><span class=\"line\">            tty-&gt;driver-&gt;name);</span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ld-&gt;ops-&gt;<span class=\"built_in\">write</span>)</span><br><span class=\"line\">        ret = -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = do_tty_write(ld-&gt;ops-&gt;<span class=\"built_in\">write</span>, tty, file, buf, count);</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_write()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，在do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;write函数，进行具体的写入操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">do_tty_write</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">ssize_t</span> (*<span class=\"built_in\">write</span>)(struct tty_struct *, struct file *, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *, <span class=\"keyword\">size_t</span>),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    chunk = <span class=\"number\">2048</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class=\"line\">        chunk = <span class=\"number\">65536</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy_from_user(tty-&gt;write_buf, buf, <span class=\"built_in\">size</span>))</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ret = <span class=\"built_in\">write</span>(tty, file, tty-&gt;write_buf, <span class=\"built_in\">size</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在调用do_tty_write()函数前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&amp;ld-&gt;tty-&gt;ldisc_sem锁；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldsem_down_read(&amp;tty-&gt;ldisc_sem, MAX_SCHEDULE_TIMEOUT);</span><br><span class=\"line\">ldsem_up_read(&amp;ld-&gt;tty-&gt;ldisc_sem);</span><br></pre></td></tr></table></figure>\n\n\n<p>在do_tty_write()函数中，默认一次写入数据大小为2048字节，如果设置了TTY_NO_WRITE_SPLIT，可以一次写入65536字节数据；</p>\n<p>tty-&gt;write_buf，是写操作的临时缓冲区，存放通过copy_from_user从用户空间获取的数据；</p>\n<p>tty-&gt;write_cnt，是临时缓冲区的大小；</p>\n<p>tty_write通过ld-&gt;ops-&gt;write操作来完成数据的写入操作；</p>\n<p><strong>2) read</strong></p>\n<p>tty设备文件的写操作通过tty_fops结构体中的tty_read函数实现；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">inode</span> = <span class=\"title\">file_inode</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty_paranoia_check(tty, inode, <span class=\"string\">\"tty_read\"</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tty || (test_bit(TTY_IO_ERROR, &amp;tty-&gt;flags)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We want to wait for the line discipline to sort out in this</span></span><br><span class=\"line\"><span class=\"comment\">       situation */</span></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;<span class=\"built_in\">read</span>)</span><br><span class=\"line\">        i = ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        i = -EIO;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        tty_update_time(&amp;inode-&gt;i_atime);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_read()函数通过file_tty(file)从file的私有数据中获取tty_struct结构；并通过tty_ldisc_ref_wait(tty)获取线路规程tty_ldisc结构指针，使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;read函数，进行具体的读取操作；</p>\n<p>ld-&gt;ops-&gt;read(tty, file, buf, count)</p>\n<p>在读取操作前后，会分别使用tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&amp;ld-&gt;tty-&gt;ldisc_sem锁；</p>\n<p>ldsem_down_read(&amp;tty-&gt;ldisc_sem, MAX_SCHEDULE_TIMEOUT);</p>\n<p>ldsem_up_read(&amp;ld-&gt;tty-&gt;ldisc_sem);</p>\n<p>tty_read通过ld-&gt;ops-&gt;read操作来完成数据的读取操作；</p>\n<h4 id=\"1-5-tty线路设置\"><a href=\"#1-5-tty线路设置\" class=\"headerlink\" title=\"1.5 tty线路设置\"></a>1.5 tty线路设置</h4><p>用户态要改变线路设置，或者获取当前的线路设置时，只需要调用多个termios用户空间库函数，或者对tty设备节点调用ioctl操作；在tty核心会把这两种操作转换为tty驱动程序的回调函数或ioctl操作；大部分temios用户空间函数会被库函数转换成对tty设备节点的ioctl调用；tty的ioctl调用会被tty核心转换成一系列的set_termios调用；所有的线路设置都封装在termios结构中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uapi/asm-generic/termbits.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_iflag;       <span class=\"comment\">/* input mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_oflag;       <span class=\"comment\">/* output mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_cflag;       <span class=\"comment\">/* control mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">tcflag_t</span> c_lflag;       <span class=\"comment\">/* local mode flags */</span></span><br><span class=\"line\">    <span class=\"keyword\">cc_t</span> c_line;            <span class=\"comment\">/* line discipline */</span></span><br><span class=\"line\">    <span class=\"keyword\">cc_t</span> c_cc[NCCS];        <span class=\"comment\">/* control characters */</span></span><br><span class=\"line\">    <span class=\"keyword\">speed_t</span> c_ispeed;       <span class=\"comment\">/* input speed */</span></span><br><span class=\"line\">    <span class=\"keyword\">speed_t</span> c_ospeed;       <span class=\"comment\">/* output speed */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>ktermios结构体用来提供一个线路设置集合，给tty设备提供一个特定的端口，用来设置波特率、数据大小、数据流控设置等；如果驱动中未初始化使用，驱动中会使用tty_std_termios结构体变量；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ktermios</span> <span class=\"title\">tty_std_termios</span> = &#123;</span> <span class=\"comment\">/* for the benefit of tty drivers  */</span></span><br><span class=\"line\">    .c_iflag = ICRNL | IXON,</span><br><span class=\"line\">    .c_oflag = OPOST | ONLCR,</span><br><span class=\"line\">    .c_cflag = B38400 | CS8 | CREAD | HUPCL,</span><br><span class=\"line\">    .c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |</span><br><span class=\"line\">           ECHOCTL | ECHOKE | IEXTEN,</span><br><span class=\"line\">    .c_cc = INIT_C_CC,</span><br><span class=\"line\">    .c_ispeed = <span class=\"number\">38400</span>,</span><br><span class=\"line\">    .c_ospeed = <span class=\"number\">38400</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>最终在内核空间tty驱动中会转换为对tty设备节点的ioctl调用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">tty_ioctl</span><span class=\"params\">(struct file *file, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;ops-&gt;ioctl) &#123;</span><br><span class=\"line\">        retval = tty-&gt;ops-&gt;ioctl(tty, cmd, arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retval != -ENOIOCTLCMD)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    retval = -EINVAL;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;ioctl) &#123;</span><br><span class=\"line\">        retval = ld-&gt;ops-&gt;ioctl(tty, file, cmd, arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retval == -ENOIOCTLCMD)</span><br><span class=\"line\">            retval = -ENOTTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-tty线路规程\"><a href=\"#2-tty线路规程\" class=\"headerlink\" title=\"2. tty线路规程\"></a>2. tty线路规程</h3><p>tty线路规程在tty_ldisc.c文件中由内核实现；不同的tty类型设备，具有不同的线路规程；tty线路规程由内核实现，不需要驱动工程师开发；</p>\n<p>在上文tty_read和tty_write函数中可以看出，最后调用了线路规程的read和write操作；</p>\n<p>内核用tty_ldisc_ops表示设备的线路规程信息；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty_ldisc.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> magic;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    *name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * The following routines are called from above.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*<span class=\"built_in\">open</span>)(struct tty_struct *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*<span class=\"built_in\">close</span>)(struct tty_struct *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*flush_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*<span class=\"built_in\">read</span>)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> nr);</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> (*<span class=\"built_in\">write</span>)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">             <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> nr);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*ioctl)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">             <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">long</span>    (*compat_ioctl)(struct tty_struct *tty, struct file *file,</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*set_termios)(struct tty_struct *tty, struct ktermios *old);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*poll)</span><span class=\"params\">(struct tty_struct *, struct file *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 struct poll_table_struct *)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*hangup)(struct tty_struct *tty);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * The following routines are called from below.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*receive_buf)(struct tty_struct *, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *cp,</span><br><span class=\"line\">                   <span class=\"keyword\">char</span> *fp, <span class=\"keyword\">int</span> count);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*write_wakeup)(struct tty_struct *);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*dcd_change)(struct tty_struct *, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>    (*fasync)(struct tty_struct *tty, <span class=\"keyword\">int</span> on);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*receive_buf2)(struct tty_struct *, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *cp,</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *fp, <span class=\"keyword\">int</span> count);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_ldisc_ops结构体中不仅有功上层调用的函数指针成员，如：open、read、write等，还有供下层往上层调用的函数指针成员，如：receive_buf、receive_buf2、write_wakeup等；</p>\n<p>内核中有一个tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]；NR_LDISCS的值是30，系统在初始化或者安装驱动模块时通过tty_register_ldisc()函数将有关的tty_ldisc_ops结构体注册登记到tty_ldiscs[NR_LDISCS]指针数组中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uapi/linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NR_LDISCS       30</span></span><br><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> *<span class=\"title\">tty_ldiscs</span>[<span class=\"title\">NR_LDISCS</span>];</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>控制终端在内核启动时进行初始化，并给显示提供驱动服务，本节以控制终端为例进行说明，控制台对应的tty_ldisc_ops的是tty_ldiscs指针数组中序号为N_TTY的tty_ldisc_N_TTY结构，其中包含了该线路规程的大部分操作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> <span class=\"title\">tty_ldisc_N_TTY</span> = &#123;</span></span><br><span class=\"line\">    .magic           = TTY_LDISC_MAGIC,</span><br><span class=\"line\">    .name            = <span class=\"string\">\"n_tty\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">open</span>            = n_tty_open,</span><br><span class=\"line\">    .<span class=\"built_in\">close</span>           = n_tty_close,</span><br><span class=\"line\">    .flush_buffer    = n_tty_flush_buffer,</span><br><span class=\"line\">    .chars_in_buffer = n_tty_chars_in_buffer,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>            = n_tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>           = n_tty_write,</span><br><span class=\"line\">    .ioctl           = n_tty_ioctl,</span><br><span class=\"line\">    .set_termios     = n_tty_set_termios,</span><br><span class=\"line\">    .poll            = n_tty_poll,</span><br><span class=\"line\">    .receive_buf     = n_tty_receive_buf,</span><br><span class=\"line\">    .write_wakeup    = n_tty_write_wakeup,</span><br><span class=\"line\">    .fasync      = n_tty_fasync,</span><br><span class=\"line\">    .receive_buf2    = n_tty_receive_buf2,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-1-注册和卸载\"><a href=\"#2-1-注册和卸载\" class=\"headerlink\" title=\"2.1 注册和卸载\"></a>2.1 注册和卸载</h4><p><strong>1) 注册</strong></p>\n<p>tty_register_ldisc()函数用来向内核注册一个新的线路规程，要注册的线路规程，将以索引的形式添加到tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中；</p>\n<p>一个串口可以对应多个已被注册的线路规程，最后调用到哪个线路规程，需要用户在打开串口后使用ioctl()选择；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_register_ldisc</span><span class=\"params\">(<span class=\"keyword\">int</span> disc, struct tty_ldisc_ops *new_ldisc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disc &lt; N_TTY || disc &gt;= NR_LDISCS)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    raw_spin_lock_irqsave(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\">    tty_ldiscs[disc] = new_ldisc;</span><br><span class=\"line\">    new_ldisc-&gt;num = disc;</span><br><span class=\"line\">    new_ldisc-&gt;refcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    raw_spin_unlock_irqrestore(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(tty_register_ldisc);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>在内核启动中kernel_start()函数中，通过console_init()函数初始化控制终端，之后显示屏或者串口打印信息才能够正常打印出来；console_init()函数是通过tty_ldisc_begin()来注册默认的线路规程tty_ldisc_N_TTY的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> __init <span class=\"title\">console_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">initcall_t</span> *call;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Setup the default TTY line discipline. */</span></span><br><span class=\"line\">    tty_ldisc_begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    call = __con_initcall_start;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class=\"line\">        (*call)();</span><br><span class=\"line\">        call++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_ldisc_begin()函数用来设置默认的tty线路规程，通过tty_register_ldisc()注册tty_ldisc_ops结构的tty_ldisc_N_TTY；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uapi/linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY       0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tty_ldisc_begin</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Setup the default TTY line discipline. */</span></span><br><span class=\"line\">    (<span class=\"keyword\">void</span>) tty_register_ldisc(N_TTY, &amp;tty_ldisc_N_TTY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><strong>2) 卸载</strong></p>\n<p>tty_unregister_ldisc()函数从内核注销一个线路规程；根据索引将要卸载的线路规程，在tty_ldiscs_ops结构体指针数组tty_ldiscs[NR_LDISCS]中指向NULL；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_ldisc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tty_unregister_ldisc</span><span class=\"params\">(<span class=\"keyword\">int</span> disc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disc &lt; N_TTY || disc &gt;= NR_LDISCS)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    raw_spin_lock_irqsave(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty_ldiscs[disc]-&gt;refcount)</span><br><span class=\"line\">        ret = -EBUSY;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        tty_ldiscs[disc] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    raw_spin_unlock_irqrestore(&amp;tty_ldiscs_lock, flags);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(tty_unregister_ldisc);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-2-打开和关闭\"><a href=\"#2-2-打开和关闭\" class=\"headerlink\" title=\"2.2 打开和关闭\"></a>2.2 打开和关闭</h4><p><strong>1) open</strong></p>\n<p>在tty核心的打开操作中会调用打开线路规程，该操作主要是申请一些资源，并对一些线路规程的数据进行初始化；申请n_tty_data结构体，read_buf成员作为读取缓冲区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">n_tty_open</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Currently a malloc failure here can panic */</span></span><br><span class=\"line\">    ldata = vzalloc(<span class=\"keyword\">sizeof</span>(*ldata));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ldata)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    ldata-&gt;overrun_time = jiffies;</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;atomic_read_lock);</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    tty-&gt;disc_data = ldata;</span><br><span class=\"line\">    tty-&gt;closing = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"comment\">/* indicate buffer work may resume */</span></span><br><span class=\"line\">    clear_bit(TTY_LDISC_HALTED, &amp;tty-&gt;flags);</span><br><span class=\"line\">    n_tty_set_termios(tty, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    tty_unthrottle(tty);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>n_tty_data结构体中的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* producer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* shared by producer and consumer */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> read_buf[N_TTY_BUF_SIZE];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* consumer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tty-&gt;read_buf[]\t<span class=\"comment\">// 环形缓冲区；</span></span><br><span class=\"line\">tty-&gt;read_tail\t<span class=\"comment\">// 指向缓冲区当前可以读取的第一个字符；</span></span><br><span class=\"line\">tty-&gt;read_head\t<span class=\"comment\">// 指向缓冲区当前可以写入的第一个地址；</span></span><br></pre></td></tr></table></figure>\n\n<p>tty_unthrottle()函数，打开缓冲区阀门，使缓冲区能够接收到硬件发送过来的数据；</p>\n<p><strong>2) close</strong></p>\n<p>同样线路规程的关闭操作中，主要是释放申请的变量资源；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">n_tty_close</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;link)</span><br><span class=\"line\">        n_tty_packet_mode_flush(tty);</span><br><span class=\"line\"></span><br><span class=\"line\">    vfree(ldata);</span><br><span class=\"line\">    tty-&gt;disc_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-3-写入和读取\"><a href=\"#2-3-写入和读取\" class=\"headerlink\" title=\"2.3 写入和读取\"></a>2.3 写入和读取</h4><p>从上文tty核心中的读写函数可以看出，tty_read和tty_write函数内部调用的是线路规程的read和write操作；</p>\n<p><strong>1) write</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_write</span><span class=\"params\">(struct file *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *buf,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ld-&gt;ops-&gt;<span class=\"built_in\">write</span>)</span><br><span class=\"line\">        ret = -EIO;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = do_tty_write(ld-&gt;ops-&gt;<span class=\"built_in\">write</span>, tty, file, buf, count);</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty_write()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，在do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count)函数中，使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;write函数完成tty的write操作；</p>\n<p>tty_ldisc_ref_wait()和tty_ldisc_deref()函数增加和减少ldsic的引用计数；因为内部分别调用了ldsem_down_read和ldsem_up_read函数操作&amp;ld-&gt;tty-&gt;ldisc_sem锁；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldsem_down_read(&amp;tty-&gt;ldisc_sem, MAX_SCHEDULE_TIMEOUT);</span><br><span class=\"line\">ldsem_up_read(&amp;ld-&gt;tty-&gt;ldisc_sem);</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>在默认的终端设备中，ld-&gt;ops-&gt;write对应的是tty_ldisc_N_TTY结构中的n_tty_write()函数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">n_tty_write</span><span class=\"params\">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">size_t</span> nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *b = buf;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (nr &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mutex_lock(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\">        c = tty-&gt;ops-&gt;<span class=\"built_in\">write</span>(tty, b, nr);</span><br><span class=\"line\">        mutex_unlock(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            retval = c;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> break_out;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!c)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        b += c;</span><br><span class=\"line\">        nr -= c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>n_tty_write()函数中通过tty-&gt;ops-&gt;write(tty, b, nr)将数据写入控制终端；</p>\n<p>以串口uart驱动为例；tty-&gt;ops-&gt;write，是tty_struct结构体中tty_operations中的write函数uart_write；而tty_operations结构体是在uart_register_driver()时，对tty_driver结构体初始化时，使用tty_set_operations()函数设置的；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// serial_core.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uart_register_driver</span><span class=\"params\">(struct uart_driver *drv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">normal</span>;</span></span><br><span class=\"line\">    normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!normal)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out_kfree;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    tty_set_operations(normal, &amp;uart_ops);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty_set_operations()函数就是将tty_operations结构体赋值给tty_driver结构体中的ops指针；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tty_set_operations</span><span class=\"params\">(struct tty_driver *driver,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">const</span> struct tty_operations *op)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    driver-&gt;ops = op;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>至于uart_write()函数的实现，在下一文uart驱动中进行说明，此处略过；</p>\n<p><strong>2) read</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We want to wait for the line discipline to sort out in this</span></span><br><span class=\"line\"><span class=\"comment\">       situation */</span></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;<span class=\"built_in\">read</span>)</span><br><span class=\"line\">        i = ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        i = -EIO;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> <span class=\"title\">tty_ldisc_N_TTY</span> = &#123;</span></span><br><span class=\"line\">    .name            = <span class=\"string\">\"n_tty\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>            = n_tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>           = n_tty_write,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>在控制台中，ld-&gt;ops-&gt;read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，n_tty_read()函数的详细，请参考下一文；</p>\n<p>在n_tty_read()函数中进行一些校验和读取进程的休眠和唤醒操作，最终通过canon_copy_from_read_buf()函数或canon_copy_from_read_buf()函数，将数据从缓冲区中读取到用户空间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">n_tty_read</span><span class=\"params\">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    \t......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) &#123;</span><br><span class=\"line\">            retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> uncopied;</span><br><span class=\"line\"></span><br><span class=\"line\">            uncopied = copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">            uncopied += copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (uncopied) &#123;</span><br><span class=\"line\">                retval = -EFAULT;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"3-tty驱动\"><a href=\"#3-tty驱动\" class=\"headerlink\" title=\"3. tty驱动\"></a>3. tty驱动</h3><p>具体的tty设备的驱动程序，由驱动开发者来实现；本文以创建一个小型tty驱动程序为例，能够加载、卸载，并对其进行读写操作；</p>\n<p>终端设备驱动都围绕tty_driver结构开始；终端设备驱动应包含：</p>\n<ol>\n<li><p>终端设备驱动模块加载函数和卸载函数，完成注册和注销tty_driver，初始化和释放终端设备对应的tty_driver结构体成员及硬件资源；</p>\n</li>\n<li><p>实现tty_operations结构体中的成员函数，主要实现open()、close()、read()、write()、tiocmget()、tiocmset()函数等；</p>\n</li>\n</ol>\n<h4 id=\"3-1-模块加载和卸载\"><a href=\"#3-1-模块加载和卸载\" class=\"headerlink\" title=\"3.1 模块加载和卸载\"></a>3.1 模块加载和卸载</h4><p>tty驱动的模块加载函数中通常需要分配和初始化tty_driver结构体，并申请必要的硬件资源；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tiny_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">tiny_tty_driver</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny_tty_driver)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    tiny_tty_driver-&gt;driver_name = <span class=\"string\">\"tiny_tty\"</span>;</span><br><span class=\"line\">    tiny_tty_driver-&gt;name        = <span class=\"string\">\"ttty\"</span>;</span><br><span class=\"line\">    tiny_tty_driver-&gt;major       = TINY_MAJOR;</span><br><span class=\"line\">    tiny_tty_driver-&gt;minor_start = TINY_MINOR;</span><br><span class=\"line\">    tiny_tty_driver-&gt;type        = TTY_DRIVER_TYPE_SERIAL;</span><br><span class=\"line\">    tiny_tty_driver-&gt;subtype     = SERIAL_TYPE_NORMAL;</span><br><span class=\"line\">    tiny_tty_driver-&gt;init_termios    = tty_std_termios;</span><br><span class=\"line\">    tiny_tty_driver-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class=\"line\">    tiny_tty_driver-&gt;init_termios.c_ispeed = <span class=\"number\">9600</span>;</span><br><span class=\"line\">    tiny_tty_driver-&gt;flags       = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class=\"line\">    tty_set_operations(tiny_tty_driver, &amp;tty_serial_ops);</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = tty_register_driver(tiny_tty_driver);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (retval) &#123;</span><br><span class=\"line\">        put_tty_driver(tiny_tty_driver);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> retval;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; TINY_TTY_MINORS; i++) &#123;</span><br><span class=\"line\">        tty_register_device(tiny_tty_driver, i, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_operations</span> <span class=\"title\">tiny_serial_ops</span> = &#123;</span></span><br><span class=\"line\">    .<span class=\"built_in\">open</span> = tiny_open,</span><br><span class=\"line\">    .<span class=\"built_in\">close</span> = tiny_close,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span> = tiny_write,</span><br><span class=\"line\">    .write_room = tiny_write_room,</span><br><span class=\"line\">    .set_termios = tiny_set_termios,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n<p>tty驱动的模块卸载函数，完成加载函数相反的工作；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tiny_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_driver</span> *<span class=\"title\">tiny_tty_driver</span> = <span class=\"title\">get_tty_driver</span>();</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; TINY_TTY_MINORS; i++) &#123;</span><br><span class=\"line\">        tty_unregister_device(tiny_tty_driver, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tty_unregister_driver(tiny_tty_driver);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-2-模块的打开和关闭\"><a href=\"#3-2-模块的打开和关闭\" class=\"headerlink\" title=\"3.2 模块的打开和关闭\"></a>3.2 模块的打开和关闭</h4><p><strong>1) open</strong></p>\n<p>在用户态使用open()系统调用函数操作tty驱动创建的设备节点时，tty核心tty_driver的file_operations结构体中的open()成员函数被调用；用户在执行open()函数后，可以得到一个表示该文件的句柄，用来表示该文件；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tiny_open</span><span class=\"params\">(struct tty_struct *tty, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> \t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> *<span class=\"title\">tiny</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_list</span> *<span class=\"title\">timer</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    tty-&gt;driver_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    index = tty-&gt;index;</span><br><span class=\"line\">    tiny = tiny_table[index];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tiny == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        tiny = kmalloc(<span class=\"keyword\">sizeof</span>(*tiny), GFP_KERNEL);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tiny) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        init_MUTEX(&amp;tiny-&gt;sem);</span><br><span class=\"line\">        tiny-&gt;open_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tiny-&gt;timer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        tiny_table[index] = tiny;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    down(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    </span><br><span class=\"line\">    tty-&gt;driver_data = tiny;</span><br><span class=\"line\">    tiny-&gt;tty = tty;</span><br><span class=\"line\">    ......    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty-&gt;driver_data保存了tiny_serial结构，该结构包含tiny模块所需要的一些成员，保存在tty_struct结构体的driver_data指针，以后在tiny模块中别的函数也可以很方便地使用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span>;</span>\t<span class=\"comment\">// 指向该设备的tty指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> open_count;\t<span class=\"comment\">// 该端口被打开的次数</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semaphore</span> <span class=\"title\">sem</span>;</span>\t<span class=\"comment\">// 锁，可以锁住该结构</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_list</span> *<span class=\"title\">timer</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>为了能使多个进程读写数据，tty驱动程序的open和close函数可能会被多次调用，因此需要使用open_count在open和close时进行计数；当端口第一次被打开时，可以对所需要的任何硬件初始化及分配所需要的内存，当端口最后一次被关闭时，可以关闭所有硬件，并清理掉所有分配的内存；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tiny-&gt;open_count++;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tiny-&gt;open_count == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 该端口第一次打开</span></span><br><span class=\"line\">       <span class=\"comment\">// 对所需要的任何硬件初始化及分配所需要的内存</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><strong>2) close</strong></p>\n<p>在open()时生成的文件句柄，在用户态使用close()系统调用操作该文件句柄时，tty_driver驱动中file_operations结构体中的close()成员函数被调用，此时设备将被关闭；和open()函数对应，close()函数可能多次调用，在close()中需要open_count进行计数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tiny_close</span><span class=\"params\">(struct tty_struct *tty, struct file *filp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> *<span class=\"title\">tiny</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    tiny = tty-&gt;driver_data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    down(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny-&gt;open_count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tiny-&gt;open_count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tiny-&gt;open_count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个用户已经关闭端口</span></span><br><span class=\"line\">        <span class=\"comment\">// 关闭所有硬件，并清理掉所有分配的内存</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        del_timer(tiny-&gt;timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">    up(&amp;tiny-&gt;sem);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"3-3-数据的发送和接收\"><a href=\"#3-3-数据的发送和接收\" class=\"headerlink\" title=\"3.3 数据的发送和接收\"></a>3.3 数据的发送和接收</h4><p><strong>1) write</strong></p>\n<p>在用户态使用write()系统调用发送数据给终端设备时，通过write–&gt;tty核心–&gt;tty线路规程调用–&gt;tty驱动，最终通过tty驱动程序中file_operations结构体中的write()成员函数来完成发送；</p>\n<p>有时由于tty硬件速度或缓存大小的原因，write()函数被调用时，写操作程序所处理的数据不能同时都发送出去，write()函数将返回发送给硬件的字符数；用户空间可以检查write()函数返回值判断是否写入了所有数据；</p>\n<p>tiny驱动并没有链接真正的硬件，只是在内核调试日志中记录需要写入的数据；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">tiny_write</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tiny_serial</span> *<span class=\"title\">tiny</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tiny = tty-&gt;driver_data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENODEV;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    down(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tiny-&gt;open_count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">\"%02x \"</span>, buf[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printk(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">    up(&amp;tiny-&gt;sem);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>tty子系统将数据传送到tty设备之外时可以使用write()函数；</p>\n<p><strong>2) read</strong></p>\n<p>tty_driver结构中没有提供read()函数，因为发送数据是用户主动发起的，而接收数据则是用户态读取一片缓冲区中已放好的数据；在tty核心中提供了缓冲逻辑，tty驱动中并不是必须实现自身的缓冲逻辑；</p>\n<h4 id=\"3-4-串口驱动举例\"><a href=\"#3-4-串口驱动举例\" class=\"headerlink\" title=\"3.4 串口驱动举例\"></a>3.4 串口驱动举例</h4><p>tty类型的驱动，以串口驱动为例，在serial_core.c文件中实现；</p>\n<p>参考下一文—-uart驱动；</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p><img src=\"/2020/08/02/linux-kernel%E4%B8%AD%E7%9A%84tty%E9%A9%B1%E5%8A%A8/tty%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B-1598176659467.png\" alt=\"tty读写过程中的函数调用流程\"></p>\n<h3 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5. 参考资料\"></a>5. 参考资料</h3><p>《Linux内核情景分析》—-控制态驱动</p>\n<p>《Linux设备驱动程序》</p>\n<p>笔记计划：</p>\n<ol>\n<li>tty驱动–&gt;控制台驱动</li>\n</ol>\n<ol start=\"2\">\n<li>uart驱动–&gt;8250驱动</li>\n</ol>\n<ol start=\"3\">\n<li>键盘驱动–&gt;PS/2键盘    –&gt;usb键盘</li>\n<li>usb转串口驱动</li>\n</ol>\n<p><a href=\"#目录\">回到目录</a></p>"},{"title":"控制台驱动中tty_read函数的实现过程","date":"2020-08-09T10:02:25.000Z","_content":"\n\n\ntty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；\n\n<!--more-->\n\n\n\n\n#### 0. 简述\n\n\ntty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；\n\n\ntty_write()函数通过ld->ops->write()从tty核心进入到下一层的线路规程，调用n_tty_write()函数，通过tty->ops->write()函数继续进入到下一层uart驱动，使用uart_write()函数将数据从用户空间写入到终端；\n\n\ntty_read()函数通过ld->ops->read()从tty核心进入到下一层的线路规程，调用n_tty_read()函数；在n_tty_read()函数中不需要通过下一层的uart_read()函数读取，而是从线路规程的数据环形缓冲区中读取数据到用户空间；\n\n\n本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；\n\n\n\n\n#### 1. tty_read\n\n\n```c\n// tty_io.c\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\n            loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    /* We want to wait for the line discipline to sort out in this\n       situation */\n    ld = tty_ldisc_ref_wait(tty);\n    if (ld->ops->read)\n        i = ld->ops->read(tty, file, buf, count);\n    else\n        i = -EIO;\n    tty_ldisc_deref(ld);\n\t......\n}\n```\n\n\n在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld->ops->read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；\n\n\n```c\nld->ops->read(tty, file, buf, count)\n```\n\n\n\n\n```c\n// n_tty.c\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n    .name            = \"n_tty\",\n    .read            = n_tty_read,\n    .write           = n_tty_write,\n};\n```\n\n\n\n\n#### 2. 控制台读取\n\n\n在控制台中，ld->ops->read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，为了尽可能多地详细解析该函数，下面将该函数截取成多段进行解析；\n\n\n```c\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n             unsigned char __user *buf, size_t nr)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    unsigned char __user *b = buf;\n    DEFINE_WAIT_FUNC(wait, woken_wake_function);\n    int c;\n    int minimum, time;\n    ssize_t retval = 0;\n    long timeout;\n    int packet;\n    size_t tail;\n\n    c = job_control(tty, file);\n    if (c < 0)\n        return c;\n\n    /*\n     *  Internal serialization of reads.\n     */\n    if (file->f_flags & O_NONBLOCK) {\n        if (!mutex_trylock(&ldata->atomic_read_lock))\n            return -EAGAIN;\n    } else {\n        if (mutex_lock_interruptible(&ldata->atomic_read_lock))\n            return -ERESTARTSYS;\n    }\n\n    down_read(&tty->termios_rwsem);\n```\n\n\nn_tty_read()函数的开始部分，用于一些数据的初始化和校验；\n\n\n```c\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n    down_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n    timeout = MAX_SCHEDULE_TIMEOUT;\n    if (!ldata->icanon) {\n        minimum = MIN_CHAR(tty);\n        if (minimum) {\n            time = (HZ / 10) * TIME_CHAR(tty);\n            if (time)\n                ldata->minimum_to_wake = 1;\n            else if (!waitqueue_active(&tty->read_wait) ||\n                 (ldata->minimum_to_wake > minimum))\n                ldata->minimum_to_wake = minimum;\n        } else {\n            timeout = (HZ / 10) * TIME_CHAR(tty);\n            ldata->minimum_to_wake = minimum = 1;\n        }\n    }\n\n    packet = tty->packet;\n    tail = ldata->read_tail;\n\n    add_wait_queue(&tty->read_wait, &wait);\n```\n\n\n当输入缓冲区中的数据超过了最低限度数据量minimum_to_wake时，要唤醒正在等待从该设备读取数据的进程；minimum_to_wake的值一般都是1，即缓冲区中的数据量超过1个，就要唤醒读取进程；\n\n\n#### 3. 单次读取限制\n\n\nminimum = MIN_CHAR(tty)操作，获取termios.c_cc[VMIN]数组的值，作为本次读取操作能够读取到的最大数据量；termios.c_cc[VMIN]数组的值，可以在打开控制台之后通过设置termios参数进行设置；\n\n\n```c\n// linux/tty.h\n#define MIN_CHAR(tty) ((tty)->termios.c_cc[VMIN])\n```\n\n\n从同一个终端设备读取的操作应该是互斥的，所以要放在临界区中；还要在当前进程的系统堆栈中准备一个wait_queue_t数据结构wait，并挂入到目标终端的读取等待队列read_wait中，使终端设备的驱动程序在有数据可以读取时可以唤醒这个进程；如果终端设备的输入缓冲区中已经有数据，不需要进入睡眠，可以在读取到了数据之后再把它从队列里去掉即可；\n\n\n```c\n    while (nr) {\n        /* First test for status change. */\n        if (packet && tty->link->ctrl_status) {\n            unsigned char cs;\n            if (b != buf)\n                break;\n            spin_lock_irq(&tty->link->ctrl_lock);\n            cs = tty->link->ctrl_status;\n            tty->link->ctrl_status = 0;\n            spin_unlock_irq(&tty->link->ctrl_lock);\n            if (tty_put_user(tty, cs, b++)) {\n                retval = -EFAULT;\n                b--;\n                break;\n            }\n            nr--;\n            break;\n        }\n```\n\n\n伪终端设备可以通过ioctl()系统调用将主从的通信方式设置为“packet”模式，此时packet值为1；此种情况和控制台没有什么关系，我也不懂，所以这部分跳过；\n\n\n```c\n\tunsigned char __user *b = buf;\n\t......\n\t\tif (((minimum - (b - buf)) < ldata->minimum_to_wake) &&\n            ((minimum - (b - buf)) >= 1))\n            ldata->minimum_to_wake = (minimum - (b - buf));\n```\n\n\n指针b定义时指向的是用户空间的buf缓存，用来保存读取到的数据，随着字符的读出而向后递增；（b-buf）是已经读出的字符数；ldata->minimum_to_wake的值在读取过程中会趋近于1；\n\n\n```c\n        if (!input_available_p(tty, 0)) {\n            up_read(&tty->termios_rwsem);\n            tty_buffer_flush_work(tty->port);\n            down_read(&tty->termios_rwsem);\n            if (!input_available_p(tty, 0)) {\n                if (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n                    retval = -EIO;\n                    break;\n                }\n                if (tty_hung_up_p(file))\n                    break;\n                if (!timeout)\n                    break;\n                if (file->f_flags & O_NONBLOCK) {\n                    retval = -EAGAIN;\n                    break;\n                }\n                if (signal_pending(current)) {\n                    retval = -ERESTARTSYS;\n                    break;\n                }\n                up_read(&tty->termios_rwsem);\n\n                timeout = wait_woken(&wait, TASK_INTERRUPTIBLE,\n                        timeout);\n\n                down_read(&tty->termios_rwsem);\n                continue;\n            }\n        }\n```\n\n\n在input_available_p()函数中会检查输入缓冲区中是否有数据，在“规范模式”下，检查的是经过加工后的数据数量，在原始模式下则是检查原始字符的数量；\n\n\n```c\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    int amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n    if (ldata->icanon && !L_EXTPROC(tty))\n        return ldata->canon_head != ldata->read_tail;\n    else\n        return ldata->commit_head - ldata->read_tail >= amt;\n}\n```\n\n\n如果缓冲区中没有数据可以读取，当前进程要休眠等待，直到缓冲区有数据可以读取时才会被唤醒；\n\n\n为了能够讲述这部分环境，假定此时缓冲区中没有数据，当前进程进入休眠；之后缓冲区有数据时，当前进程被唤醒并调度运行；\n\n\n```c\n        if (ldata->icanon && !L_EXTPROC(tty)) {\n            retval = canon_copy_from_read_buf(tty, &b, &nr);\n            if (retval)\n                break;\n```\n\n\n当前进程被唤醒时，此时缓冲区中应该有可以读取的数据；在规范模式下，缓冲区中的字符是经过加工了的，要累积到一个缓冲行才会唤醒等待读出的进程（缓冲行，即碰到'\\n'字符）；此时的读取操作在canon_copy_from_read_buf()函数中完成；canon_copy_from_read_buf()函数的实现在下文讲述；\n\n\n```c\n        } else {\n            int uncopied;\n\n            uncopied = copy_from_read_buf(tty, &b, &nr);\n            uncopied += copy_from_read_buf(tty, &b, &nr);\n            if (uncopied) {\n                retval = -EFAULT;\n                break;\n            }\n        }\n```\n\n\n在非规范模式下，缓冲区中的字符是未经加工的，不存在缓冲行的概念，在原始模式可以把字符'\\0'复制到用户空间，这里使用copy_from_read_buf()函数进行成片的拷贝；由于缓冲区是环形的，缓冲的字符可能跨越环形缓冲区的结尾，被分割成两部分，所以要使用copy_from_read_buf()函数两次；copy_from_read_buf()函数的实现在后面讲述；\n\n\n\n#### 4. 读取缓冲区\n\n在控制台的线路规程中，使用struct n_tty_data结构体表示该设备的数据；其中包含的read_buf成员作为读取的缓冲区使用；\n\n```c\n// n_tty.c\nstruct n_tty_data {\n    /* producer-published */\n    size_t read_head;\n    \n    /* shared by producer and consumer */\n    char read_buf[N_TTY_BUF_SIZE];\n    \n    /* consumer-published */\n    size_t read_tail;\n}\n```\n\nread_buf是一个N_TTY_BUF_SIZE字节的数组；\n\n```c\n// linux/tty.h\n#define N_TTY_BUF_SIZE 4096\n```\n\n定义的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；read_head成员是环形缓冲区空闲位置的开始，产生数据的进程从read_head位置开始往缓冲区写入数据；read_tail成员是环形缓冲区保存数据位置的开始，读取数据的进程从read_tail位置开始从缓冲区读取数据；\n\n以下针对具体的读取操作进行说明；\n\n```c\ntty->read_buf[]\t// 环形缓冲区；\ntty->read_tail\t// 指向缓冲区当前可以读取的第一个字符；\ntty->read_head\t// 指向缓冲区当前可以写入的第一个地址；\n```\n\nread_cnt是通过缓冲区的read_head-read_tail计算得到，表示缓冲行中的已保存字符个数；\n\n```c\n// n_tty.c\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n    return ldata->read_head - ldata->read_tail;\n}\n```\n\nn_tty_data结构体在线路规程被打开时申请结构体空间，并进行初始化；\n\n```c\n// n_tty.c\nstatic int n_tty_open(struct tty_struct *tty)\n{\n    struct n_tty_data *ldata;\n\n    /* Currently a malloc failure here can panic */\n    ldata = vzalloc(sizeof(*ldata));\n    if (!ldata)\n        return -ENOMEM;\n\n    ldata->overrun_time = jiffies;\n    mutex_init(&ldata->atomic_read_lock);\n    mutex_init(&ldata->output_lock);\n\n    tty->disc_data = ldata;\n    tty->closing = 0; \n    /* indicate buffer work may resume */\n    clear_bit(TTY_LDISC_HALTED, &tty->flags);\n    n_tty_set_termios(tty, NULL);\n    tty_unthrottle(tty);\n    return 0;\n}\n```\n\n\n\n\n#### 5. 缓冲区阀门\n\n\n```c\n        n_tty_check_unthrottle(tty);\n```\n\n\n缓冲区是环形的，空间也是有限的；如果缓冲区数据来的太快，应用程序来不及从缓冲区读取数据；为了防止环形缓冲区中的数据被覆盖，底层的驱动程序可能因为缓冲区已满而暂时关闭了“阀门”，禁止数据继续进入缓冲区；\n\n\n```c\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n    if (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n        if (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n            return;\n        if (!tty->count)\n            return;\n        n_tty_kick_worker(tty);\n        tty_wakeup(tty->link);\n        return;\n    }\n\n    while (1) {\n        int unthrottled;\n        tty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n        if (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n            break;\n        if (!tty->count)\n            break;\n        n_tty_kick_worker(tty);\n        unthrottled = tty_unthrottle_safe(tty);\n        if (!unthrottled)\n            break;\n    }\n    __tty_set_flow_change(tty, 0);\n}\n```\n\n\n在读取过程中，通过chars_in_buffer()检查缓冲区，如果缓冲区中剩余的字符数量减少到了关闭阀门的要求以下（数量小于TTY_THRESHOLD_UNTHROTTLE），则在n_tty_check_unthrottle()函数中通过调用tty_unthrottle_safe()函数重新打开“阀门”，数据就可以重新进入缓冲区；\n\n\n```c\n        if (b - buf >= minimum)\n            break;\n        if (time)\n            timeout = time;\n    }\n    if (tail != ldata->read_tail)\n        n_tty_kick_worker(tty);\n    up_read(&tty->termios_rwsem);\n\n    remove_wait_queue(&tty->read_wait, &wait);\n    if (!waitqueue_active(&tty->read_wait))\n        ldata->minimum_to_wake = minimum;\n\n    mutex_unlock(&ldata->atomic_read_lock);\n```\n\n\n当前进程已经读取到了所要求的输入，需要放在临界区的操作已完成，读取操作已经完成，将当前进程从等待read_wait中移除；\n\n\n```c\n    if (b - buf)\n        retval = b - buf;\n\n    return retval;\n}\n```\n\n\n指针buf指向用户空间的缓冲区，指针b指向该缓冲区中的下一个空闲位置，（b-buf）是已经读入buf缓冲区中的字符数量；如果(b - buf >= minimum)，则本次读取结束；\n\n\nn_tty_read()函数的参数nr是表示用户空间缓冲区的大小，是读取字符数量的上限；n_tty_read()函数以读取到的字符数量为返回值；\n\n\n\n#### 6. 数据读取\n\n\n\n\n以下针对具体的读取操作进行说明；\n\n\n\n\n##### 1) 规范模式下的读取\n\n\ncanon_copy_from_read_buf()函数只有在规范模式下会被调用，该函数按缓冲行将数据从tty缓冲区中读取到用户空间；\n\n\n```c\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\n                    unsigned char __user **b,\n                    size_t *nr)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    size_t n, size, more, c;\n    size_t eol;\n    size_t tail;\n    int ret, found = 0;\n\n    /* N.B. avoid overrun if nr == 0 */\n    if (!*nr)\n        return 0;\n\n    n = min(*nr + 1, smp_load_acquire(&ldata->canon_head) - ldata->read_tail);\n\n    tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n    size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n    n_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n            __func__, *nr, tail, n, size);\n\n    eol = find_next_bit(ldata->read_flags, size, tail);\n    more = n - (size - tail);\n    if (eol == N_TTY_BUF_SIZE && more) {\n        /* scan wrapped without finding set bit */\n        eol = find_next_bit(ldata->read_flags, more, 0);\n        if (eol != more)\n            found = 1;\n    } else if (eol != size)\n        found = 1;\n\n    size = N_TTY_BUF_SIZE - tail;\n    n = eol - tail;\n    if (n > N_TTY_BUF_SIZE)\n        n += N_TTY_BUF_SIZE;\n    c = n + found;\n\n    if (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {\n        c = min(*nr, c);\n        n = c;\n    }\n\n    n_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\",\n            __func__, eol, found, n, c, size, more);\n\n    if (n > size) {\n        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), size);\n        if (ret)\n            return -EFAULT;\n        ret = tty_copy_to_user(tty, *b + size, ldata->read_buf, n - size);\n    } else\n        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), n);\n\n    if (ret)\n        return -EFAULT;\n    *b += n;\n    *nr -= n;\n\n    if (found)\n        clear_bit(eol, ldata->read_flags);\n    smp_store_release(&ldata->read_tail, ldata->read_tail + c);\n\n    if (found) {\n        if (!ldata->push)\n            ldata->line_start = ldata->read_tail;\n        else\n            ldata->push = 0;\n        tty_audit_push(tty);\n    }\n    return 0;\n}\n```\n\n\n最终通过tty_copy_to_user()函数中的copy_to_user()函数完成数据的拷贝；\n\n\n```c\nstatic inline int tty_copy_to_user(struct tty_struct *tty,\n                    void __user *to,\n                    const void *from,\n                    unsigned long n)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n\n    tty_audit_add_data(tty, from, n, ldata->icanon);\n    return copy_to_user(to, from, n);\n}\n```\n\n\n\n\n##### 2) 非规范模式下的读取\n\n\ncopy_from_read_buf()函数在非规范模式下，将数据从tty缓冲区中直接读取到用户空间，该函数会被调用两次，第一次是从tty->disc_data->read_tail指针指向的位置到缓冲区结尾，第二次是从缓冲区开头，到tty->disc_data->read_head指针指向的位置；该函数的读取操作需要在ldata->atomic_read_lock信号锁的保护下进行；\n\n\n```c\nstatic int copy_from_read_buf(struct tty_struct *tty,\n                      unsigned char __user **b,\n                      size_t *nr)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    int retval;\n    size_t n;\n    bool is_eof;\n    size_t head = smp_load_acquire(&ldata->commit_head);\n    size_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\n    retval = 0;\n    n = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);\n    n = min(*nr, n);\n    if (n) {\n        retval = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n        n -= retval;\n        is_eof = n == 1 && read_buf(ldata, tail) == EOF_CHAR(tty);\n        tty_audit_add_data(tty, read_buf_addr(ldata, tail), n,\n                ldata->icanon);\n        smp_store_release(&ldata->read_tail, ldata->read_tail + n);\n        /* Turn single EOF into zero-length read */\n        if (L_EXTPROC(tty) && ldata->icanon && is_eof &&\n            (head == ldata->read_tail))\n            n = 0;\n        *b += n;\n        *nr -= n;\n    }\n    return retval;\n}\n```\n\n\n\n\n#### 7. 总结\n\n\n一般情况下，典型的读取终端过程可以分为以下三部分：\n\n\n1. 当前进程准备从终端缓冲区读取数据，但是缓冲区还没有足够字符可以读取，进入睡眠；\n\n2. 如果有输入字符，底层驱动将足够的字符写入缓冲区之后，把睡眠的进程唤醒；\n\n3. 睡眠的读取进程被唤醒后，开始完成读取操作；\n\n\n\n\n#### 8. 参考资料\n\n\n《Linux内核情景分析》----控制台驱动\n\n\n\n\n\n[回到目录](目录)\n\n","source":"_posts/控制台驱动中tty-read函数的实现过程.md","raw":"---\ntitle: 控制台驱动中tty_read函数的实现过程\ndate: 2020-08-09 18:02:25\ntags: tty\n---\n\n\n\ntty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；\n\n<!--more-->\n\n\n\n\n#### 0. 简述\n\n\ntty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；\n\n\ntty_write()函数通过ld->ops->write()从tty核心进入到下一层的线路规程，调用n_tty_write()函数，通过tty->ops->write()函数继续进入到下一层uart驱动，使用uart_write()函数将数据从用户空间写入到终端；\n\n\ntty_read()函数通过ld->ops->read()从tty核心进入到下一层的线路规程，调用n_tty_read()函数；在n_tty_read()函数中不需要通过下一层的uart_read()函数读取，而是从线路规程的数据环形缓冲区中读取数据到用户空间；\n\n\n本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；\n\n\n\n\n#### 1. tty_read\n\n\n```c\n// tty_io.c\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\n            loff_t *ppos)\n{\n    struct tty_struct *tty = file_tty(file);\n    struct tty_ldisc *ld;\n\n    /* We want to wait for the line discipline to sort out in this\n       situation */\n    ld = tty_ldisc_ref_wait(tty);\n    if (ld->ops->read)\n        i = ld->ops->read(tty, file, buf, count);\n    else\n        i = -EIO;\n    tty_ldisc_deref(ld);\n\t......\n}\n```\n\n\n在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld->ops->read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；\n\n\n```c\nld->ops->read(tty, file, buf, count)\n```\n\n\n\n\n```c\n// n_tty.c\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n    .name            = \"n_tty\",\n    .read            = n_tty_read,\n    .write           = n_tty_write,\n};\n```\n\n\n\n\n#### 2. 控制台读取\n\n\n在控制台中，ld->ops->read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，为了尽可能多地详细解析该函数，下面将该函数截取成多段进行解析；\n\n\n```c\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n             unsigned char __user *buf, size_t nr)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    unsigned char __user *b = buf;\n    DEFINE_WAIT_FUNC(wait, woken_wake_function);\n    int c;\n    int minimum, time;\n    ssize_t retval = 0;\n    long timeout;\n    int packet;\n    size_t tail;\n\n    c = job_control(tty, file);\n    if (c < 0)\n        return c;\n\n    /*\n     *  Internal serialization of reads.\n     */\n    if (file->f_flags & O_NONBLOCK) {\n        if (!mutex_trylock(&ldata->atomic_read_lock))\n            return -EAGAIN;\n    } else {\n        if (mutex_lock_interruptible(&ldata->atomic_read_lock))\n            return -ERESTARTSYS;\n    }\n\n    down_read(&tty->termios_rwsem);\n```\n\n\nn_tty_read()函数的开始部分，用于一些数据的初始化和校验；\n\n\n```c\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n    down_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n    timeout = MAX_SCHEDULE_TIMEOUT;\n    if (!ldata->icanon) {\n        minimum = MIN_CHAR(tty);\n        if (minimum) {\n            time = (HZ / 10) * TIME_CHAR(tty);\n            if (time)\n                ldata->minimum_to_wake = 1;\n            else if (!waitqueue_active(&tty->read_wait) ||\n                 (ldata->minimum_to_wake > minimum))\n                ldata->minimum_to_wake = minimum;\n        } else {\n            timeout = (HZ / 10) * TIME_CHAR(tty);\n            ldata->minimum_to_wake = minimum = 1;\n        }\n    }\n\n    packet = tty->packet;\n    tail = ldata->read_tail;\n\n    add_wait_queue(&tty->read_wait, &wait);\n```\n\n\n当输入缓冲区中的数据超过了最低限度数据量minimum_to_wake时，要唤醒正在等待从该设备读取数据的进程；minimum_to_wake的值一般都是1，即缓冲区中的数据量超过1个，就要唤醒读取进程；\n\n\n#### 3. 单次读取限制\n\n\nminimum = MIN_CHAR(tty)操作，获取termios.c_cc[VMIN]数组的值，作为本次读取操作能够读取到的最大数据量；termios.c_cc[VMIN]数组的值，可以在打开控制台之后通过设置termios参数进行设置；\n\n\n```c\n// linux/tty.h\n#define MIN_CHAR(tty) ((tty)->termios.c_cc[VMIN])\n```\n\n\n从同一个终端设备读取的操作应该是互斥的，所以要放在临界区中；还要在当前进程的系统堆栈中准备一个wait_queue_t数据结构wait，并挂入到目标终端的读取等待队列read_wait中，使终端设备的驱动程序在有数据可以读取时可以唤醒这个进程；如果终端设备的输入缓冲区中已经有数据，不需要进入睡眠，可以在读取到了数据之后再把它从队列里去掉即可；\n\n\n```c\n    while (nr) {\n        /* First test for status change. */\n        if (packet && tty->link->ctrl_status) {\n            unsigned char cs;\n            if (b != buf)\n                break;\n            spin_lock_irq(&tty->link->ctrl_lock);\n            cs = tty->link->ctrl_status;\n            tty->link->ctrl_status = 0;\n            spin_unlock_irq(&tty->link->ctrl_lock);\n            if (tty_put_user(tty, cs, b++)) {\n                retval = -EFAULT;\n                b--;\n                break;\n            }\n            nr--;\n            break;\n        }\n```\n\n\n伪终端设备可以通过ioctl()系统调用将主从的通信方式设置为“packet”模式，此时packet值为1；此种情况和控制台没有什么关系，我也不懂，所以这部分跳过；\n\n\n```c\n\tunsigned char __user *b = buf;\n\t......\n\t\tif (((minimum - (b - buf)) < ldata->minimum_to_wake) &&\n            ((minimum - (b - buf)) >= 1))\n            ldata->minimum_to_wake = (minimum - (b - buf));\n```\n\n\n指针b定义时指向的是用户空间的buf缓存，用来保存读取到的数据，随着字符的读出而向后递增；（b-buf）是已经读出的字符数；ldata->minimum_to_wake的值在读取过程中会趋近于1；\n\n\n```c\n        if (!input_available_p(tty, 0)) {\n            up_read(&tty->termios_rwsem);\n            tty_buffer_flush_work(tty->port);\n            down_read(&tty->termios_rwsem);\n            if (!input_available_p(tty, 0)) {\n                if (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n                    retval = -EIO;\n                    break;\n                }\n                if (tty_hung_up_p(file))\n                    break;\n                if (!timeout)\n                    break;\n                if (file->f_flags & O_NONBLOCK) {\n                    retval = -EAGAIN;\n                    break;\n                }\n                if (signal_pending(current)) {\n                    retval = -ERESTARTSYS;\n                    break;\n                }\n                up_read(&tty->termios_rwsem);\n\n                timeout = wait_woken(&wait, TASK_INTERRUPTIBLE,\n                        timeout);\n\n                down_read(&tty->termios_rwsem);\n                continue;\n            }\n        }\n```\n\n\n在input_available_p()函数中会检查输入缓冲区中是否有数据，在“规范模式”下，检查的是经过加工后的数据数量，在原始模式下则是检查原始字符的数量；\n\n\n```c\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    int amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n    if (ldata->icanon && !L_EXTPROC(tty))\n        return ldata->canon_head != ldata->read_tail;\n    else\n        return ldata->commit_head - ldata->read_tail >= amt;\n}\n```\n\n\n如果缓冲区中没有数据可以读取，当前进程要休眠等待，直到缓冲区有数据可以读取时才会被唤醒；\n\n\n为了能够讲述这部分环境，假定此时缓冲区中没有数据，当前进程进入休眠；之后缓冲区有数据时，当前进程被唤醒并调度运行；\n\n\n```c\n        if (ldata->icanon && !L_EXTPROC(tty)) {\n            retval = canon_copy_from_read_buf(tty, &b, &nr);\n            if (retval)\n                break;\n```\n\n\n当前进程被唤醒时，此时缓冲区中应该有可以读取的数据；在规范模式下，缓冲区中的字符是经过加工了的，要累积到一个缓冲行才会唤醒等待读出的进程（缓冲行，即碰到'\\n'字符）；此时的读取操作在canon_copy_from_read_buf()函数中完成；canon_copy_from_read_buf()函数的实现在下文讲述；\n\n\n```c\n        } else {\n            int uncopied;\n\n            uncopied = copy_from_read_buf(tty, &b, &nr);\n            uncopied += copy_from_read_buf(tty, &b, &nr);\n            if (uncopied) {\n                retval = -EFAULT;\n                break;\n            }\n        }\n```\n\n\n在非规范模式下，缓冲区中的字符是未经加工的，不存在缓冲行的概念，在原始模式可以把字符'\\0'复制到用户空间，这里使用copy_from_read_buf()函数进行成片的拷贝；由于缓冲区是环形的，缓冲的字符可能跨越环形缓冲区的结尾，被分割成两部分，所以要使用copy_from_read_buf()函数两次；copy_from_read_buf()函数的实现在后面讲述；\n\n\n\n#### 4. 读取缓冲区\n\n在控制台的线路规程中，使用struct n_tty_data结构体表示该设备的数据；其中包含的read_buf成员作为读取的缓冲区使用；\n\n```c\n// n_tty.c\nstruct n_tty_data {\n    /* producer-published */\n    size_t read_head;\n    \n    /* shared by producer and consumer */\n    char read_buf[N_TTY_BUF_SIZE];\n    \n    /* consumer-published */\n    size_t read_tail;\n}\n```\n\nread_buf是一个N_TTY_BUF_SIZE字节的数组；\n\n```c\n// linux/tty.h\n#define N_TTY_BUF_SIZE 4096\n```\n\n定义的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；read_head成员是环形缓冲区空闲位置的开始，产生数据的进程从read_head位置开始往缓冲区写入数据；read_tail成员是环形缓冲区保存数据位置的开始，读取数据的进程从read_tail位置开始从缓冲区读取数据；\n\n以下针对具体的读取操作进行说明；\n\n```c\ntty->read_buf[]\t// 环形缓冲区；\ntty->read_tail\t// 指向缓冲区当前可以读取的第一个字符；\ntty->read_head\t// 指向缓冲区当前可以写入的第一个地址；\n```\n\nread_cnt是通过缓冲区的read_head-read_tail计算得到，表示缓冲行中的已保存字符个数；\n\n```c\n// n_tty.c\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n    return ldata->read_head - ldata->read_tail;\n}\n```\n\nn_tty_data结构体在线路规程被打开时申请结构体空间，并进行初始化；\n\n```c\n// n_tty.c\nstatic int n_tty_open(struct tty_struct *tty)\n{\n    struct n_tty_data *ldata;\n\n    /* Currently a malloc failure here can panic */\n    ldata = vzalloc(sizeof(*ldata));\n    if (!ldata)\n        return -ENOMEM;\n\n    ldata->overrun_time = jiffies;\n    mutex_init(&ldata->atomic_read_lock);\n    mutex_init(&ldata->output_lock);\n\n    tty->disc_data = ldata;\n    tty->closing = 0; \n    /* indicate buffer work may resume */\n    clear_bit(TTY_LDISC_HALTED, &tty->flags);\n    n_tty_set_termios(tty, NULL);\n    tty_unthrottle(tty);\n    return 0;\n}\n```\n\n\n\n\n#### 5. 缓冲区阀门\n\n\n```c\n        n_tty_check_unthrottle(tty);\n```\n\n\n缓冲区是环形的，空间也是有限的；如果缓冲区数据来的太快，应用程序来不及从缓冲区读取数据；为了防止环形缓冲区中的数据被覆盖，底层的驱动程序可能因为缓冲区已满而暂时关闭了“阀门”，禁止数据继续进入缓冲区；\n\n\n```c\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n    if (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n        if (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n            return;\n        if (!tty->count)\n            return;\n        n_tty_kick_worker(tty);\n        tty_wakeup(tty->link);\n        return;\n    }\n\n    while (1) {\n        int unthrottled;\n        tty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n        if (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n            break;\n        if (!tty->count)\n            break;\n        n_tty_kick_worker(tty);\n        unthrottled = tty_unthrottle_safe(tty);\n        if (!unthrottled)\n            break;\n    }\n    __tty_set_flow_change(tty, 0);\n}\n```\n\n\n在读取过程中，通过chars_in_buffer()检查缓冲区，如果缓冲区中剩余的字符数量减少到了关闭阀门的要求以下（数量小于TTY_THRESHOLD_UNTHROTTLE），则在n_tty_check_unthrottle()函数中通过调用tty_unthrottle_safe()函数重新打开“阀门”，数据就可以重新进入缓冲区；\n\n\n```c\n        if (b - buf >= minimum)\n            break;\n        if (time)\n            timeout = time;\n    }\n    if (tail != ldata->read_tail)\n        n_tty_kick_worker(tty);\n    up_read(&tty->termios_rwsem);\n\n    remove_wait_queue(&tty->read_wait, &wait);\n    if (!waitqueue_active(&tty->read_wait))\n        ldata->minimum_to_wake = minimum;\n\n    mutex_unlock(&ldata->atomic_read_lock);\n```\n\n\n当前进程已经读取到了所要求的输入，需要放在临界区的操作已完成，读取操作已经完成，将当前进程从等待read_wait中移除；\n\n\n```c\n    if (b - buf)\n        retval = b - buf;\n\n    return retval;\n}\n```\n\n\n指针buf指向用户空间的缓冲区，指针b指向该缓冲区中的下一个空闲位置，（b-buf）是已经读入buf缓冲区中的字符数量；如果(b - buf >= minimum)，则本次读取结束；\n\n\nn_tty_read()函数的参数nr是表示用户空间缓冲区的大小，是读取字符数量的上限；n_tty_read()函数以读取到的字符数量为返回值；\n\n\n\n#### 6. 数据读取\n\n\n\n\n以下针对具体的读取操作进行说明；\n\n\n\n\n##### 1) 规范模式下的读取\n\n\ncanon_copy_from_read_buf()函数只有在规范模式下会被调用，该函数按缓冲行将数据从tty缓冲区中读取到用户空间；\n\n\n```c\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\n                    unsigned char __user **b,\n                    size_t *nr)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    size_t n, size, more, c;\n    size_t eol;\n    size_t tail;\n    int ret, found = 0;\n\n    /* N.B. avoid overrun if nr == 0 */\n    if (!*nr)\n        return 0;\n\n    n = min(*nr + 1, smp_load_acquire(&ldata->canon_head) - ldata->read_tail);\n\n    tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n    size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n    n_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n            __func__, *nr, tail, n, size);\n\n    eol = find_next_bit(ldata->read_flags, size, tail);\n    more = n - (size - tail);\n    if (eol == N_TTY_BUF_SIZE && more) {\n        /* scan wrapped without finding set bit */\n        eol = find_next_bit(ldata->read_flags, more, 0);\n        if (eol != more)\n            found = 1;\n    } else if (eol != size)\n        found = 1;\n\n    size = N_TTY_BUF_SIZE - tail;\n    n = eol - tail;\n    if (n > N_TTY_BUF_SIZE)\n        n += N_TTY_BUF_SIZE;\n    c = n + found;\n\n    if (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {\n        c = min(*nr, c);\n        n = c;\n    }\n\n    n_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\",\n            __func__, eol, found, n, c, size, more);\n\n    if (n > size) {\n        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), size);\n        if (ret)\n            return -EFAULT;\n        ret = tty_copy_to_user(tty, *b + size, ldata->read_buf, n - size);\n    } else\n        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), n);\n\n    if (ret)\n        return -EFAULT;\n    *b += n;\n    *nr -= n;\n\n    if (found)\n        clear_bit(eol, ldata->read_flags);\n    smp_store_release(&ldata->read_tail, ldata->read_tail + c);\n\n    if (found) {\n        if (!ldata->push)\n            ldata->line_start = ldata->read_tail;\n        else\n            ldata->push = 0;\n        tty_audit_push(tty);\n    }\n    return 0;\n}\n```\n\n\n最终通过tty_copy_to_user()函数中的copy_to_user()函数完成数据的拷贝；\n\n\n```c\nstatic inline int tty_copy_to_user(struct tty_struct *tty,\n                    void __user *to,\n                    const void *from,\n                    unsigned long n)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n\n    tty_audit_add_data(tty, from, n, ldata->icanon);\n    return copy_to_user(to, from, n);\n}\n```\n\n\n\n\n##### 2) 非规范模式下的读取\n\n\ncopy_from_read_buf()函数在非规范模式下，将数据从tty缓冲区中直接读取到用户空间，该函数会被调用两次，第一次是从tty->disc_data->read_tail指针指向的位置到缓冲区结尾，第二次是从缓冲区开头，到tty->disc_data->read_head指针指向的位置；该函数的读取操作需要在ldata->atomic_read_lock信号锁的保护下进行；\n\n\n```c\nstatic int copy_from_read_buf(struct tty_struct *tty,\n                      unsigned char __user **b,\n                      size_t *nr)\n{\n    struct n_tty_data *ldata = tty->disc_data;\n    int retval;\n    size_t n;\n    bool is_eof;\n    size_t head = smp_load_acquire(&ldata->commit_head);\n    size_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\n    retval = 0;\n    n = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);\n    n = min(*nr, n);\n    if (n) {\n        retval = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n        n -= retval;\n        is_eof = n == 1 && read_buf(ldata, tail) == EOF_CHAR(tty);\n        tty_audit_add_data(tty, read_buf_addr(ldata, tail), n,\n                ldata->icanon);\n        smp_store_release(&ldata->read_tail, ldata->read_tail + n);\n        /* Turn single EOF into zero-length read */\n        if (L_EXTPROC(tty) && ldata->icanon && is_eof &&\n            (head == ldata->read_tail))\n            n = 0;\n        *b += n;\n        *nr -= n;\n    }\n    return retval;\n}\n```\n\n\n\n\n#### 7. 总结\n\n\n一般情况下，典型的读取终端过程可以分为以下三部分：\n\n\n1. 当前进程准备从终端缓冲区读取数据，但是缓冲区还没有足够字符可以读取，进入睡眠；\n\n2. 如果有输入字符，底层驱动将足够的字符写入缓冲区之后，把睡眠的进程唤醒；\n\n3. 睡眠的读取进程被唤醒后，开始完成读取操作；\n\n\n\n\n#### 8. 参考资料\n\n\n《Linux内核情景分析》----控制台驱动\n\n\n\n\n\n[回到目录](目录)\n\n","slug":"控制台驱动中tty-read函数的实现过程","published":1,"updated":"2020-08-23T10:04:08.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke6xctqa0000kqg15t3e20kn","content":"<p>tty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；</p>\n<a id=\"more\"></a>\n\n\n\n\n<h4 id=\"0-简述\"><a href=\"#0-简述\" class=\"headerlink\" title=\"0. 简述\"></a>0. 简述</h4><p>tty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；</p>\n<p>tty_write()函数通过ld-&gt;ops-&gt;write()从tty核心进入到下一层的线路规程，调用n_tty_write()函数，通过tty-&gt;ops-&gt;write()函数继续进入到下一层uart驱动，使用uart_write()函数将数据从用户空间写入到终端；</p>\n<p>tty_read()函数通过ld-&gt;ops-&gt;read()从tty核心进入到下一层的线路规程，调用n_tty_read()函数；在n_tty_read()函数中不需要通过下一层的uart_read()函数读取，而是从线路规程的数据环形缓冲区中读取数据到用户空间；</p>\n<p>本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；</p>\n<h4 id=\"1-tty-read\"><a href=\"#1-tty-read\" class=\"headerlink\" title=\"1. tty_read\"></a>1. tty_read</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We want to wait for the line discipline to sort out in this</span></span><br><span class=\"line\"><span class=\"comment\">       situation */</span></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;<span class=\"built_in\">read</span>)</span><br><span class=\"line\">        i = ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        i = -EIO;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> <span class=\"title\">tty_ldisc_N_TTY</span> = &#123;</span></span><br><span class=\"line\">    .name            = <span class=\"string\">\"n_tty\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>            = n_tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>           = n_tty_write,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-控制台读取\"><a href=\"#2-控制台读取\" class=\"headerlink\" title=\"2. 控制台读取\"></a>2. 控制台读取</h4><p>在控制台中，ld-&gt;ops-&gt;read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，为了尽可能多地详细解析该函数，下面将该函数截取成多段进行解析；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">n_tty_read</span><span class=\"params\">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *b = buf;</span><br><span class=\"line\">    DEFINE_WAIT_FUNC(wait, woken_wake_function);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minimum, time;</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> retval = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> packet;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    c = job_control(tty, file);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     *  Internal serialization of reads.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mutex_trylock(&amp;ldata-&gt;atomic_read_lock))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mutex_lock_interruptible(&amp;ldata-&gt;atomic_read_lock))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -ERESTARTSYS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    down_read(&amp;tty-&gt;termios_rwsem);</span><br></pre></td></tr></table></figure>\n\n\n<p>n_tty_read()函数的开始部分，用于一些数据的初始化和校验；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_WAIT_FUNC(wait, woken_wake_function);</span><br><span class=\"line\">   down_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\"></span><br><span class=\"line\">minimum = time = <span class=\"number\">0</span>;</span><br><span class=\"line\">   timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!ldata-&gt;icanon) &#123;</span><br><span class=\"line\">       minimum = MIN_CHAR(tty);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (minimum) &#123;</span><br><span class=\"line\">           time = (HZ / <span class=\"number\">10</span>) * TIME_CHAR(tty);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (time)</span><br><span class=\"line\">               ldata-&gt;minimum_to_wake = <span class=\"number\">1</span>;</span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!waitqueue_active(&amp;tty-&gt;read_wait) ||</span><br><span class=\"line\">                (ldata-&gt;minimum_to_wake &gt; minimum))</span><br><span class=\"line\">               ldata-&gt;minimum_to_wake = minimum;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           timeout = (HZ / <span class=\"number\">10</span>) * TIME_CHAR(tty);</span><br><span class=\"line\">           ldata-&gt;minimum_to_wake = minimum = <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   packet = tty-&gt;packet;</span><br><span class=\"line\">   tail = ldata-&gt;read_tail;</span><br><span class=\"line\"></span><br><span class=\"line\">   add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);</span><br></pre></td></tr></table></figure>\n\n\n<p>当输入缓冲区中的数据超过了最低限度数据量minimum_to_wake时，要唤醒正在等待从该设备读取数据的进程；minimum_to_wake的值一般都是1，即缓冲区中的数据量超过1个，就要唤醒读取进程；</p>\n<h4 id=\"3-单次读取限制\"><a href=\"#3-单次读取限制\" class=\"headerlink\" title=\"3. 单次读取限制\"></a>3. 单次读取限制</h4><p>minimum = MIN_CHAR(tty)操作，获取termios.c_cc[VMIN]数组的值，作为本次读取操作能够读取到的最大数据量；termios.c_cc[VMIN]数组的值，可以在打开控制台之后通过设置termios参数进行设置；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MIN_CHAR(tty) ((tty)-&gt;termios.c_cc[VMIN])</span></span><br></pre></td></tr></table></figure>\n\n\n<p>从同一个终端设备读取的操作应该是互斥的，所以要放在临界区中；还要在当前进程的系统堆栈中准备一个wait_queue_t数据结构wait，并挂入到目标终端的读取等待队列read_wait中，使终端设备的驱动程序在有数据可以读取时可以唤醒这个进程；如果终端设备的输入缓冲区中已经有数据，不需要进入睡眠，可以在读取到了数据之后再把它从队列里去掉即可；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (nr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* First test for status change. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (packet &amp;&amp; tty-&gt;link-&gt;ctrl_status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> cs;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b != buf)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        spin_lock_irq(&amp;tty-&gt;link-&gt;ctrl_lock);</span><br><span class=\"line\">        cs = tty-&gt;link-&gt;ctrl_status;</span><br><span class=\"line\">        tty-&gt;link-&gt;ctrl_status = <span class=\"number\">0</span>;</span><br><span class=\"line\">        spin_unlock_irq(&amp;tty-&gt;link-&gt;ctrl_lock);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty_put_user(tty, cs, b++)) &#123;</span><br><span class=\"line\">            retval = -EFAULT;</span><br><span class=\"line\">            b--;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nr--;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>伪终端设备可以通过ioctl()系统调用将主从的通信方式设置为“packet”模式，此时packet值为1；此种情况和控制台没有什么关系，我也不懂，所以这部分跳过；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *b = buf;</span><br><span class=\"line\">......</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (((minimum - (b - buf)) &lt; ldata-&gt;minimum_to_wake) &amp;&amp;</span><br><span class=\"line\">           ((minimum - (b - buf)) &gt;= <span class=\"number\">1</span>))</span><br><span class=\"line\">           ldata-&gt;minimum_to_wake = (minimum - (b - buf));</span><br></pre></td></tr></table></figure>\n\n\n<p>指针b定义时指向的是用户空间的buf缓存，用来保存读取到的数据，随着字符的读出而向后递增；（b-buf）是已经读出的字符数；ldata-&gt;minimum_to_wake的值在读取过程中会趋近于1；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!input_available_p(tty, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    up_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\">    tty_buffer_flush_work(tty-&gt;port);</span><br><span class=\"line\">    down_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!input_available_p(tty, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) &#123;</span><br><span class=\"line\">            retval = -EIO;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty_hung_up_p(file))</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class=\"line\">            retval = -EAGAIN;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (signal_pending(current)) &#123;</span><br><span class=\"line\">            retval = -ERESTARTSYS;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        up_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\"></span><br><span class=\"line\">        timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span><br><span class=\"line\">                timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        down_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在input_available_p()函数中会检查输入缓冲区中是否有数据，在“规范模式”下，检查的是经过加工后的数据数量，在原始模式下则是检查原始字符的数量；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">input_available_p</span><span class=\"params\">(struct tty_struct *tty, <span class=\"keyword\">int</span> poll)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> amt = poll &amp;&amp; !TIME_CHAR(tty) &amp;&amp; MIN_CHAR(tty) ? MIN_CHAR(tty) : <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ldata-&gt;canon_head != ldata-&gt;read_tail;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ldata-&gt;commit_head - ldata-&gt;read_tail &gt;= amt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>如果缓冲区中没有数据可以读取，当前进程要休眠等待，直到缓冲区有数据可以读取时才会被唤醒；</p>\n<p>为了能够讲述这部分环境，假定此时缓冲区中没有数据，当前进程进入休眠；之后缓冲区有数据时，当前进程被唤醒并调度运行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) &#123;</span><br><span class=\"line\">    retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>当前进程被唤醒时，此时缓冲区中应该有可以读取的数据；在规范模式下，缓冲区中的字符是经过加工了的，要累积到一个缓冲行才会唤醒等待读出的进程（缓冲行，即碰到’\\n’字符）；此时的读取操作在canon_copy_from_read_buf()函数中完成；canon_copy_from_read_buf()函数的实现在下文讲述；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uncopied;</span><br><span class=\"line\"></span><br><span class=\"line\">    uncopied = copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">    uncopied += copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (uncopied) &#123;</span><br><span class=\"line\">        retval = -EFAULT;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在非规范模式下，缓冲区中的字符是未经加工的，不存在缓冲行的概念，在原始模式可以把字符’\\0’复制到用户空间，这里使用copy_from_read_buf()函数进行成片的拷贝；由于缓冲区是环形的，缓冲的字符可能跨越环形缓冲区的结尾，被分割成两部分，所以要使用copy_from_read_buf()函数两次；copy_from_read_buf()函数的实现在后面讲述；</p>\n<h4 id=\"4-读取缓冲区\"><a href=\"#4-读取缓冲区\" class=\"headerlink\" title=\"4. 读取缓冲区\"></a>4. 读取缓冲区</h4><p>在控制台的线路规程中，使用struct n_tty_data结构体表示该设备的数据；其中包含的read_buf成员作为读取的缓冲区使用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* producer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* shared by producer and consumer */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> read_buf[N_TTY_BUF_SIZE];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* consumer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>read_buf是一个N_TTY_BUF_SIZE字节的数组；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY_BUF_SIZE 4096</span></span><br></pre></td></tr></table></figure>\n\n<p>定义的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；read_head成员是环形缓冲区空闲位置的开始，产生数据的进程从read_head位置开始往缓冲区写入数据；read_tail成员是环形缓冲区保存数据位置的开始，读取数据的进程从read_tail位置开始从缓冲区读取数据；</p>\n<p>以下针对具体的读取操作进行说明；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tty-&gt;read_buf[]\t<span class=\"comment\">// 环形缓冲区；</span></span><br><span class=\"line\">tty-&gt;read_tail\t<span class=\"comment\">// 指向缓冲区当前可以读取的第一个字符；</span></span><br><span class=\"line\">tty-&gt;read_head\t<span class=\"comment\">// 指向缓冲区当前可以写入的第一个地址；</span></span><br></pre></td></tr></table></figure>\n\n<p>read_cnt是通过缓冲区的read_head-read_tail计算得到，表示缓冲行中的已保存字符个数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">read_cnt</span><span class=\"params\">(struct n_tty_data *ldata)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ldata-&gt;read_head - ldata-&gt;read_tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>n_tty_data结构体在线路规程被打开时申请结构体空间，并进行初始化；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">n_tty_open</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Currently a malloc failure here can panic */</span></span><br><span class=\"line\">    ldata = vzalloc(<span class=\"keyword\">sizeof</span>(*ldata));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ldata)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    ldata-&gt;overrun_time = jiffies;</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;atomic_read_lock);</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    tty-&gt;disc_data = ldata;</span><br><span class=\"line\">    tty-&gt;closing = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"comment\">/* indicate buffer work may resume */</span></span><br><span class=\"line\">    clear_bit(TTY_LDISC_HALTED, &amp;tty-&gt;flags);</span><br><span class=\"line\">    n_tty_set_termios(tty, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    tty_unthrottle(tty);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"5-缓冲区阀门\"><a href=\"#5-缓冲区阀门\" class=\"headerlink\" title=\"5. 缓冲区阀门\"></a>5. 缓冲区阀门</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n_tty_check_unthrottle(tty);</span><br></pre></td></tr></table></figure>\n\n\n<p>缓冲区是环形的，空间也是有限的；如果缓冲区数据来的太快，应用程序来不及从缓冲区读取数据；为了防止环形缓冲区中的数据被覆盖，底层的驱动程序可能因为缓冲区已满而暂时关闭了“阀门”，禁止数据继续进入缓冲区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">n_tty_check_unthrottle</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chars_in_buffer(tty) &gt; TTY_THRESHOLD_UNTHROTTLE)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tty-&gt;count)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        n_tty_kick_worker(tty);</span><br><span class=\"line\">        tty_wakeup(tty-&gt;link);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> unthrottled;</span><br><span class=\"line\">        tty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chars_in_buffer(tty) &gt; TTY_THRESHOLD_UNTHROTTLE)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tty-&gt;count)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        n_tty_kick_worker(tty);</span><br><span class=\"line\">        unthrottled = tty_unthrottle_safe(tty);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!unthrottled)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __tty_set_flow_change(tty, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在读取过程中，通过chars_in_buffer()检查缓冲区，如果缓冲区中剩余的字符数量减少到了关闭阀门的要求以下（数量小于TTY_THRESHOLD_UNTHROTTLE），则在n_tty_check_unthrottle()函数中通过调用tty_unthrottle_safe()函数重新打开“阀门”，数据就可以重新进入缓冲区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> (b - buf &gt;= minimum)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time)</span><br><span class=\"line\">        timeout = time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tail != ldata-&gt;read_tail)</span><br><span class=\"line\">    n_tty_kick_worker(tty);</span><br><span class=\"line\">up_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\"></span><br><span class=\"line\">remove_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!waitqueue_active(&amp;tty-&gt;read_wait))</span><br><span class=\"line\">    ldata-&gt;minimum_to_wake = minimum;</span><br><span class=\"line\"></span><br><span class=\"line\">mutex_unlock(&amp;ldata-&gt;atomic_read_lock);</span><br></pre></td></tr></table></figure>\n\n\n<p>当前进程已经读取到了所要求的输入，需要放在临界区的操作已完成，读取操作已经完成，将当前进程从等待read_wait中移除；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> (b - buf)</span><br><span class=\"line\">        retval = b - buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>指针buf指向用户空间的缓冲区，指针b指向该缓冲区中的下一个空闲位置，（b-buf）是已经读入buf缓冲区中的字符数量；如果(b - buf &gt;= minimum)，则本次读取结束；</p>\n<p>n_tty_read()函数的参数nr是表示用户空间缓冲区的大小，是读取字符数量的上限；n_tty_read()函数以读取到的字符数量为返回值；</p>\n<h4 id=\"6-数据读取\"><a href=\"#6-数据读取\" class=\"headerlink\" title=\"6. 数据读取\"></a>6. 数据读取</h4><p>以下针对具体的读取操作进行说明；</p>\n<h5 id=\"1-规范模式下的读取\"><a href=\"#1-规范模式下的读取\" class=\"headerlink\" title=\"1) 规范模式下的读取\"></a>1) 规范模式下的读取</h5><p>canon_copy_from_read_buf()函数只有在规范模式下会被调用，该函数按缓冲行将数据从tty缓冲区中读取到用户空间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">canon_copy_from_read_buf</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user **b,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">size_t</span> *nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> n, <span class=\"built_in\">size</span>, more, c;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> eol;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> tail;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret, found = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* N.B. avoid overrun if nr == 0 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*nr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">min</span>(*nr + <span class=\"number\">1</span>, smp_load_acquire(&amp;ldata-&gt;canon_head) - ldata-&gt;read_tail);</span><br><span class=\"line\"></span><br><span class=\"line\">    tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">size</span> = <span class=\"keyword\">min_t</span>(<span class=\"keyword\">size_t</span>, tail + n, N_TTY_BUF_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    n_tty_trace(<span class=\"string\">\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\"</span>,</span><br><span class=\"line\">            __func__, *nr, tail, n, <span class=\"built_in\">size</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    eol = find_next_bit(ldata-&gt;read_flags, <span class=\"built_in\">size</span>, tail);</span><br><span class=\"line\">    more = n - (<span class=\"built_in\">size</span> - tail);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eol == N_TTY_BUF_SIZE &amp;&amp; more) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* scan wrapped without finding set bit */</span></span><br><span class=\"line\">        eol = find_next_bit(ldata-&gt;read_flags, more, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eol != more)</span><br><span class=\"line\">            found = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eol != <span class=\"built_in\">size</span>)</span><br><span class=\"line\">        found = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">size</span> = N_TTY_BUF_SIZE - tail;</span><br><span class=\"line\">    n = eol - tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; N_TTY_BUF_SIZE)</span><br><span class=\"line\">        n += N_TTY_BUF_SIZE;</span><br><span class=\"line\">    c = n + found;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found || read_buf(ldata, eol) != __DISABLED_CHAR) &#123;</span><br><span class=\"line\">        c = <span class=\"built_in\">min</span>(*nr, c);</span><br><span class=\"line\">        n = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    n_tty_trace(<span class=\"string\">\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\"</span>,</span><br><span class=\"line\">            __func__, eol, found, n, c, <span class=\"built_in\">size</span>, more);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"built_in\">size</span>) &#123;</span><br><span class=\"line\">        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), <span class=\"built_in\">size</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">        ret = tty_copy_to_user(tty, *b + <span class=\"built_in\">size</span>, ldata-&gt;read_buf, n - <span class=\"built_in\">size</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">    *b += n;</span><br><span class=\"line\">    *nr -= n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found)</span><br><span class=\"line\">        clear_bit(eol, ldata-&gt;read_flags);</span><br><span class=\"line\">    smp_store_release(&amp;ldata-&gt;read_tail, ldata-&gt;read_tail + c);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ldata-&gt;push)</span><br><span class=\"line\">            ldata-&gt;line_start = ldata-&gt;read_tail;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ldata-&gt;push = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tty_audit_push(tty);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>最终通过tty_copy_to_user()函数中的copy_to_user()函数完成数据的拷贝；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">tty_copy_to_user</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">void</span> __user *to,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *from,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tty_audit_add_data(tty, from, n, ldata-&gt;icanon);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy_to_user(to, from, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-非规范模式下的读取\"><a href=\"#2-非规范模式下的读取\" class=\"headerlink\" title=\"2) 非规范模式下的读取\"></a>2) 非规范模式下的读取</h5><p>copy_from_read_buf()函数在非规范模式下，将数据从tty缓冲区中直接读取到用户空间，该函数会被调用两次，第一次是从tty-&gt;disc_data-&gt;read_tail指针指向的位置到缓冲区结尾，第二次是从缓冲区开头，到tty-&gt;disc_data-&gt;read_head指针指向的位置；该函数的读取操作需要在ldata-&gt;atomic_read_lock信号锁的保护下进行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">copy_from_read_buf</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user **b,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">size_t</span> *nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> retval;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_eof;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> head = smp_load_acquire(&amp;ldata-&gt;commit_head);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = <span class=\"number\">0</span>;</span><br><span class=\"line\">    n = <span class=\"built_in\">min</span>(head - ldata-&gt;read_tail, N_TTY_BUF_SIZE - tail);</span><br><span class=\"line\">    n = <span class=\"built_in\">min</span>(*nr, n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n) &#123;</span><br><span class=\"line\">        retval = copy_to_user(*b, read_buf_addr(ldata, tail), n);</span><br><span class=\"line\">        n -= retval;</span><br><span class=\"line\">        is_eof = n == <span class=\"number\">1</span> &amp;&amp; read_buf(ldata, tail) == EOF_CHAR(tty);</span><br><span class=\"line\">        tty_audit_add_data(tty, read_buf_addr(ldata, tail), n,</span><br><span class=\"line\">                ldata-&gt;icanon);</span><br><span class=\"line\">        smp_store_release(&amp;ldata-&gt;read_tail, ldata-&gt;read_tail + n);</span><br><span class=\"line\">        <span class=\"comment\">/* Turn single EOF into zero-length read */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (L_EXTPROC(tty) &amp;&amp; ldata-&gt;icanon &amp;&amp; is_eof &amp;&amp;</span><br><span class=\"line\">            (head == ldata-&gt;read_tail))</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        *b += n;</span><br><span class=\"line\">        *nr -= n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h4><p>一般情况下，典型的读取终端过程可以分为以下三部分：</p>\n<ol>\n<li><p>当前进程准备从终端缓冲区读取数据，但是缓冲区还没有足够字符可以读取，进入睡眠；</p>\n</li>\n<li><p>如果有输入字符，底层驱动将足够的字符写入缓冲区之后，把睡眠的进程唤醒；</p>\n</li>\n<li><p>睡眠的读取进程被唤醒后，开始完成读取操作；</p>\n</li>\n</ol>\n<h4 id=\"8-参考资料\"><a href=\"#8-参考资料\" class=\"headerlink\" title=\"8. 参考资料\"></a>8. 参考资料</h4><p>《Linux内核情景分析》—-控制台驱动</p>\n<p><a href=\"目录\">回到目录</a></p>\n","site":{"data":{}},"excerpt":"<p>tty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；</p>","more":"<h4 id=\"0-简述\"><a href=\"#0-简述\" class=\"headerlink\" title=\"0. 简述\"></a>0. 简述</h4><p>tty核心中的读写函数tty_read和tty_write，内部调用的是线路规程的read和write操作；</p>\n<p>tty_write()函数通过ld-&gt;ops-&gt;write()从tty核心进入到下一层的线路规程，调用n_tty_write()函数，通过tty-&gt;ops-&gt;write()函数继续进入到下一层uart驱动，使用uart_write()函数将数据从用户空间写入到终端；</p>\n<p>tty_read()函数通过ld-&gt;ops-&gt;read()从tty核心进入到下一层的线路规程，调用n_tty_read()函数；在n_tty_read()函数中不需要通过下一层的uart_read()函数读取，而是从线路规程的数据环形缓冲区中读取数据到用户空间；</p>\n<p>本文先忽略tty的写入操作，将重点解析tty线路规程中的n_tty_read()函数的操作；</p>\n<h4 id=\"1-tty-read\"><a href=\"#1-tty-read\" class=\"headerlink\" title=\"1. tty_read\"></a>1. tty_read</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tty_io.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">tty_read</span><span class=\"params\">(struct file *file, <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">loff_t</span> *ppos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_struct</span> *<span class=\"title\">tty</span> = <span class=\"title\">file_tty</span>(<span class=\"title\">file</span>);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc</span> *<span class=\"title\">ld</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* We want to wait for the line discipline to sort out in this</span></span><br><span class=\"line\"><span class=\"comment\">       situation */</span></span><br><span class=\"line\">    ld = tty_ldisc_ref_wait(tty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ld-&gt;ops-&gt;<span class=\"built_in\">read</span>)</span><br><span class=\"line\">        i = ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        i = -EIO;</span><br><span class=\"line\">    tty_ldisc_deref(ld);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在tty核心层的tty_read()函数中，通过tty_ldisc_ref_wait()函数从tty_struct结构体中获取到tty_ldisc结构指针，直接使用tty_ldisc_ops结构中的ld-&gt;ops-&gt;read函数完成tty的read操作，从而进入到驱动的下一层，tty线路规程；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-&gt;ops-&gt;<span class=\"built_in\">read</span>(tty, file, buf, count)</span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tty_ldisc_ops</span> <span class=\"title\">tty_ldisc_N_TTY</span> = &#123;</span></span><br><span class=\"line\">    .name            = <span class=\"string\">\"n_tty\"</span>,</span><br><span class=\"line\">    .<span class=\"built_in\">read</span>            = n_tty_read,</span><br><span class=\"line\">    .<span class=\"built_in\">write</span>           = n_tty_write,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2-控制台读取\"><a href=\"#2-控制台读取\" class=\"headerlink\" title=\"2. 控制台读取\"></a>2. 控制台读取</h4><p>在控制台中，ld-&gt;ops-&gt;read对应的是tty_ldisc_N_TTY结构中的n_tty_read()函数；n_tty_read()函数与n_tty_write()不同，不是通过下一层的read函数实现（如：uart_write），n_tty_read()函数是从缓冲区中读取数据的，函数实现比较长，为了尽可能多地详细解析该函数，下面将该函数截取成多段进行解析；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">ssize_t</span> <span class=\"title\">n_tty_read</span><span class=\"params\">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">             <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *buf, <span class=\"keyword\">size_t</span> nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *b = buf;</span><br><span class=\"line\">    DEFINE_WAIT_FUNC(wait, woken_wake_function);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minimum, time;</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> retval = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> packet;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    c = job_control(tty, file);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     *  Internal serialization of reads.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mutex_trylock(&amp;ldata-&gt;atomic_read_lock))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mutex_lock_interruptible(&amp;ldata-&gt;atomic_read_lock))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -ERESTARTSYS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    down_read(&amp;tty-&gt;termios_rwsem);</span><br></pre></td></tr></table></figure>\n\n\n<p>n_tty_read()函数的开始部分，用于一些数据的初始化和校验；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_WAIT_FUNC(wait, woken_wake_function);</span><br><span class=\"line\">   down_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\"></span><br><span class=\"line\">minimum = time = <span class=\"number\">0</span>;</span><br><span class=\"line\">   timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!ldata-&gt;icanon) &#123;</span><br><span class=\"line\">       minimum = MIN_CHAR(tty);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (minimum) &#123;</span><br><span class=\"line\">           time = (HZ / <span class=\"number\">10</span>) * TIME_CHAR(tty);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (time)</span><br><span class=\"line\">               ldata-&gt;minimum_to_wake = <span class=\"number\">1</span>;</span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!waitqueue_active(&amp;tty-&gt;read_wait) ||</span><br><span class=\"line\">                (ldata-&gt;minimum_to_wake &gt; minimum))</span><br><span class=\"line\">               ldata-&gt;minimum_to_wake = minimum;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           timeout = (HZ / <span class=\"number\">10</span>) * TIME_CHAR(tty);</span><br><span class=\"line\">           ldata-&gt;minimum_to_wake = minimum = <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   packet = tty-&gt;packet;</span><br><span class=\"line\">   tail = ldata-&gt;read_tail;</span><br><span class=\"line\"></span><br><span class=\"line\">   add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);</span><br></pre></td></tr></table></figure>\n\n\n<p>当输入缓冲区中的数据超过了最低限度数据量minimum_to_wake时，要唤醒正在等待从该设备读取数据的进程；minimum_to_wake的值一般都是1，即缓冲区中的数据量超过1个，就要唤醒读取进程；</p>\n<h4 id=\"3-单次读取限制\"><a href=\"#3-单次读取限制\" class=\"headerlink\" title=\"3. 单次读取限制\"></a>3. 单次读取限制</h4><p>minimum = MIN_CHAR(tty)操作，获取termios.c_cc[VMIN]数组的值，作为本次读取操作能够读取到的最大数据量；termios.c_cc[VMIN]数组的值，可以在打开控制台之后通过设置termios参数进行设置；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MIN_CHAR(tty) ((tty)-&gt;termios.c_cc[VMIN])</span></span><br></pre></td></tr></table></figure>\n\n\n<p>从同一个终端设备读取的操作应该是互斥的，所以要放在临界区中；还要在当前进程的系统堆栈中准备一个wait_queue_t数据结构wait，并挂入到目标终端的读取等待队列read_wait中，使终端设备的驱动程序在有数据可以读取时可以唤醒这个进程；如果终端设备的输入缓冲区中已经有数据，不需要进入睡眠，可以在读取到了数据之后再把它从队列里去掉即可；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (nr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* First test for status change. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (packet &amp;&amp; tty-&gt;link-&gt;ctrl_status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> cs;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b != buf)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        spin_lock_irq(&amp;tty-&gt;link-&gt;ctrl_lock);</span><br><span class=\"line\">        cs = tty-&gt;link-&gt;ctrl_status;</span><br><span class=\"line\">        tty-&gt;link-&gt;ctrl_status = <span class=\"number\">0</span>;</span><br><span class=\"line\">        spin_unlock_irq(&amp;tty-&gt;link-&gt;ctrl_lock);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty_put_user(tty, cs, b++)) &#123;</span><br><span class=\"line\">            retval = -EFAULT;</span><br><span class=\"line\">            b--;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nr--;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>伪终端设备可以通过ioctl()系统调用将主从的通信方式设置为“packet”模式，此时packet值为1；此种情况和控制台没有什么关系，我也不懂，所以这部分跳过；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user *b = buf;</span><br><span class=\"line\">......</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (((minimum - (b - buf)) &lt; ldata-&gt;minimum_to_wake) &amp;&amp;</span><br><span class=\"line\">           ((minimum - (b - buf)) &gt;= <span class=\"number\">1</span>))</span><br><span class=\"line\">           ldata-&gt;minimum_to_wake = (minimum - (b - buf));</span><br></pre></td></tr></table></figure>\n\n\n<p>指针b定义时指向的是用户空间的buf缓存，用来保存读取到的数据，随着字符的读出而向后递增；（b-buf）是已经读出的字符数；ldata-&gt;minimum_to_wake的值在读取过程中会趋近于1；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!input_available_p(tty, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    up_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\">    tty_buffer_flush_work(tty-&gt;port);</span><br><span class=\"line\">    down_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!input_available_p(tty, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) &#123;</span><br><span class=\"line\">            retval = -EIO;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tty_hung_up_p(file))</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class=\"line\">            retval = -EAGAIN;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (signal_pending(current)) &#123;</span><br><span class=\"line\">            retval = -ERESTARTSYS;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        up_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\"></span><br><span class=\"line\">        timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span><br><span class=\"line\">                timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        down_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在input_available_p()函数中会检查输入缓冲区中是否有数据，在“规范模式”下，检查的是经过加工后的数据数量，在原始模式下则是检查原始字符的数量；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">input_available_p</span><span class=\"params\">(struct tty_struct *tty, <span class=\"keyword\">int</span> poll)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> amt = poll &amp;&amp; !TIME_CHAR(tty) &amp;&amp; MIN_CHAR(tty) ? MIN_CHAR(tty) : <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ldata-&gt;canon_head != ldata-&gt;read_tail;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ldata-&gt;commit_head - ldata-&gt;read_tail &gt;= amt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>如果缓冲区中没有数据可以读取，当前进程要休眠等待，直到缓冲区有数据可以读取时才会被唤醒；</p>\n<p>为了能够讲述这部分环境，假定此时缓冲区中没有数据，当前进程进入休眠；之后缓冲区有数据时，当前进程被唤醒并调度运行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) &#123;</span><br><span class=\"line\">    retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retval)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>当前进程被唤醒时，此时缓冲区中应该有可以读取的数据；在规范模式下，缓冲区中的字符是经过加工了的，要累积到一个缓冲行才会唤醒等待读出的进程（缓冲行，即碰到’\\n’字符）；此时的读取操作在canon_copy_from_read_buf()函数中完成；canon_copy_from_read_buf()函数的实现在下文讲述；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uncopied;</span><br><span class=\"line\"></span><br><span class=\"line\">    uncopied = copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">    uncopied += copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (uncopied) &#123;</span><br><span class=\"line\">        retval = -EFAULT;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在非规范模式下，缓冲区中的字符是未经加工的，不存在缓冲行的概念，在原始模式可以把字符’\\0’复制到用户空间，这里使用copy_from_read_buf()函数进行成片的拷贝；由于缓冲区是环形的，缓冲的字符可能跨越环形缓冲区的结尾，被分割成两部分，所以要使用copy_from_read_buf()函数两次；copy_from_read_buf()函数的实现在后面讲述；</p>\n<h4 id=\"4-读取缓冲区\"><a href=\"#4-读取缓冲区\" class=\"headerlink\" title=\"4. 读取缓冲区\"></a>4. 读取缓冲区</h4><p>在控制台的线路规程中，使用struct n_tty_data结构体表示该设备的数据；其中包含的read_buf成员作为读取的缓冲区使用；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* producer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* shared by producer and consumer */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> read_buf[N_TTY_BUF_SIZE];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* consumer-published */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> read_tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>read_buf是一个N_TTY_BUF_SIZE字节的数组；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux/tty.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N_TTY_BUF_SIZE 4096</span></span><br></pre></td></tr></table></figure>\n\n<p>定义的read_buf缓冲区是线性数组，但是却是作为环形缓冲区使用的；read_head成员是环形缓冲区空闲位置的开始，产生数据的进程从read_head位置开始往缓冲区写入数据；read_tail成员是环形缓冲区保存数据位置的开始，读取数据的进程从read_tail位置开始从缓冲区读取数据；</p>\n<p>以下针对具体的读取操作进行说明；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tty-&gt;read_buf[]\t<span class=\"comment\">// 环形缓冲区；</span></span><br><span class=\"line\">tty-&gt;read_tail\t<span class=\"comment\">// 指向缓冲区当前可以读取的第一个字符；</span></span><br><span class=\"line\">tty-&gt;read_head\t<span class=\"comment\">// 指向缓冲区当前可以写入的第一个地址；</span></span><br></pre></td></tr></table></figure>\n\n<p>read_cnt是通过缓冲区的read_head-read_tail计算得到，表示缓冲行中的已保存字符个数；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">read_cnt</span><span class=\"params\">(struct n_tty_data *ldata)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ldata-&gt;read_head - ldata-&gt;read_tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>n_tty_data结构体在线路规程被打开时申请结构体空间，并进行初始化；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n_tty.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">n_tty_open</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Currently a malloc failure here can panic */</span></span><br><span class=\"line\">    ldata = vzalloc(<span class=\"keyword\">sizeof</span>(*ldata));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ldata)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">    ldata-&gt;overrun_time = jiffies;</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;atomic_read_lock);</span><br><span class=\"line\">    mutex_init(&amp;ldata-&gt;output_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    tty-&gt;disc_data = ldata;</span><br><span class=\"line\">    tty-&gt;closing = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"comment\">/* indicate buffer work may resume */</span></span><br><span class=\"line\">    clear_bit(TTY_LDISC_HALTED, &amp;tty-&gt;flags);</span><br><span class=\"line\">    n_tty_set_termios(tty, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    tty_unthrottle(tty);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"5-缓冲区阀门\"><a href=\"#5-缓冲区阀门\" class=\"headerlink\" title=\"5. 缓冲区阀门\"></a>5. 缓冲区阀门</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n_tty_check_unthrottle(tty);</span><br></pre></td></tr></table></figure>\n\n\n<p>缓冲区是环形的，空间也是有限的；如果缓冲区数据来的太快，应用程序来不及从缓冲区读取数据；为了防止环形缓冲区中的数据被覆盖，底层的驱动程序可能因为缓冲区已满而暂时关闭了“阀门”，禁止数据继续进入缓冲区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">n_tty_check_unthrottle</span><span class=\"params\">(struct tty_struct *tty)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chars_in_buffer(tty) &gt; TTY_THRESHOLD_UNTHROTTLE)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tty-&gt;count)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        n_tty_kick_worker(tty);</span><br><span class=\"line\">        tty_wakeup(tty-&gt;link);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> unthrottled;</span><br><span class=\"line\">        tty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chars_in_buffer(tty) &gt; TTY_THRESHOLD_UNTHROTTLE)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tty-&gt;count)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        n_tty_kick_worker(tty);</span><br><span class=\"line\">        unthrottled = tty_unthrottle_safe(tty);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!unthrottled)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __tty_set_flow_change(tty, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在读取过程中，通过chars_in_buffer()检查缓冲区，如果缓冲区中剩余的字符数量减少到了关闭阀门的要求以下（数量小于TTY_THRESHOLD_UNTHROTTLE），则在n_tty_check_unthrottle()函数中通过调用tty_unthrottle_safe()函数重新打开“阀门”，数据就可以重新进入缓冲区；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> (b - buf &gt;= minimum)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time)</span><br><span class=\"line\">        timeout = time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tail != ldata-&gt;read_tail)</span><br><span class=\"line\">    n_tty_kick_worker(tty);</span><br><span class=\"line\">up_read(&amp;tty-&gt;termios_rwsem);</span><br><span class=\"line\"></span><br><span class=\"line\">remove_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!waitqueue_active(&amp;tty-&gt;read_wait))</span><br><span class=\"line\">    ldata-&gt;minimum_to_wake = minimum;</span><br><span class=\"line\"></span><br><span class=\"line\">mutex_unlock(&amp;ldata-&gt;atomic_read_lock);</span><br></pre></td></tr></table></figure>\n\n\n<p>当前进程已经读取到了所要求的输入，需要放在临界区的操作已完成，读取操作已经完成，将当前进程从等待read_wait中移除；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> (b - buf)</span><br><span class=\"line\">        retval = b - buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>指针buf指向用户空间的缓冲区，指针b指向该缓冲区中的下一个空闲位置，（b-buf）是已经读入buf缓冲区中的字符数量；如果(b - buf &gt;= minimum)，则本次读取结束；</p>\n<p>n_tty_read()函数的参数nr是表示用户空间缓冲区的大小，是读取字符数量的上限；n_tty_read()函数以读取到的字符数量为返回值；</p>\n<h4 id=\"6-数据读取\"><a href=\"#6-数据读取\" class=\"headerlink\" title=\"6. 数据读取\"></a>6. 数据读取</h4><p>以下针对具体的读取操作进行说明；</p>\n<h5 id=\"1-规范模式下的读取\"><a href=\"#1-规范模式下的读取\" class=\"headerlink\" title=\"1) 规范模式下的读取\"></a>1) 规范模式下的读取</h5><p>canon_copy_from_read_buf()函数只有在规范模式下会被调用，该函数按缓冲行将数据从tty缓冲区中读取到用户空间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">canon_copy_from_read_buf</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user **b,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">size_t</span> *nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> n, <span class=\"built_in\">size</span>, more, c;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> eol;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> tail;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret, found = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* N.B. avoid overrun if nr == 0 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*nr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">min</span>(*nr + <span class=\"number\">1</span>, smp_load_acquire(&amp;ldata-&gt;canon_head) - ldata-&gt;read_tail);</span><br><span class=\"line\"></span><br><span class=\"line\">    tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">size</span> = <span class=\"keyword\">min_t</span>(<span class=\"keyword\">size_t</span>, tail + n, N_TTY_BUF_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    n_tty_trace(<span class=\"string\">\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\"</span>,</span><br><span class=\"line\">            __func__, *nr, tail, n, <span class=\"built_in\">size</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    eol = find_next_bit(ldata-&gt;read_flags, <span class=\"built_in\">size</span>, tail);</span><br><span class=\"line\">    more = n - (<span class=\"built_in\">size</span> - tail);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eol == N_TTY_BUF_SIZE &amp;&amp; more) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* scan wrapped without finding set bit */</span></span><br><span class=\"line\">        eol = find_next_bit(ldata-&gt;read_flags, more, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eol != more)</span><br><span class=\"line\">            found = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eol != <span class=\"built_in\">size</span>)</span><br><span class=\"line\">        found = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">size</span> = N_TTY_BUF_SIZE - tail;</span><br><span class=\"line\">    n = eol - tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; N_TTY_BUF_SIZE)</span><br><span class=\"line\">        n += N_TTY_BUF_SIZE;</span><br><span class=\"line\">    c = n + found;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found || read_buf(ldata, eol) != __DISABLED_CHAR) &#123;</span><br><span class=\"line\">        c = <span class=\"built_in\">min</span>(*nr, c);</span><br><span class=\"line\">        n = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    n_tty_trace(<span class=\"string\">\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\"</span>,</span><br><span class=\"line\">            __func__, eol, found, n, c, <span class=\"built_in\">size</span>, more);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"built_in\">size</span>) &#123;</span><br><span class=\"line\">        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), <span class=\"built_in\">size</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">        ret = tty_copy_to_user(tty, *b + <span class=\"built_in\">size</span>, ldata-&gt;read_buf, n - <span class=\"built_in\">size</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">    *b += n;</span><br><span class=\"line\">    *nr -= n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found)</span><br><span class=\"line\">        clear_bit(eol, ldata-&gt;read_flags);</span><br><span class=\"line\">    smp_store_release(&amp;ldata-&gt;read_tail, ldata-&gt;read_tail + c);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ldata-&gt;push)</span><br><span class=\"line\">            ldata-&gt;line_start = ldata-&gt;read_tail;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ldata-&gt;push = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tty_audit_push(tty);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>最终通过tty_copy_to_user()函数中的copy_to_user()函数完成数据的拷贝；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">tty_copy_to_user</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">void</span> __user *to,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *from,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tty_audit_add_data(tty, from, n, ldata-&gt;icanon);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy_to_user(to, from, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h5 id=\"2-非规范模式下的读取\"><a href=\"#2-非规范模式下的读取\" class=\"headerlink\" title=\"2) 非规范模式下的读取\"></a>2) 非规范模式下的读取</h5><p>copy_from_read_buf()函数在非规范模式下，将数据从tty缓冲区中直接读取到用户空间，该函数会被调用两次，第一次是从tty-&gt;disc_data-&gt;read_tail指针指向的位置到缓冲区结尾，第二次是从缓冲区开头，到tty-&gt;disc_data-&gt;read_head指针指向的位置；该函数的读取操作需要在ldata-&gt;atomic_read_lock信号锁的保护下进行；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">copy_from_read_buf</span><span class=\"params\">(struct tty_struct *tty,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> __user **b,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">size_t</span> *nr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">n_tty_data</span> *<span class=\"title\">ldata</span> = <span class=\"title\">tty</span>-&gt;<span class=\"title\">disc_data</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> retval;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_eof;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> head = smp_load_acquire(&amp;ldata-&gt;commit_head);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    retval = <span class=\"number\">0</span>;</span><br><span class=\"line\">    n = <span class=\"built_in\">min</span>(head - ldata-&gt;read_tail, N_TTY_BUF_SIZE - tail);</span><br><span class=\"line\">    n = <span class=\"built_in\">min</span>(*nr, n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n) &#123;</span><br><span class=\"line\">        retval = copy_to_user(*b, read_buf_addr(ldata, tail), n);</span><br><span class=\"line\">        n -= retval;</span><br><span class=\"line\">        is_eof = n == <span class=\"number\">1</span> &amp;&amp; read_buf(ldata, tail) == EOF_CHAR(tty);</span><br><span class=\"line\">        tty_audit_add_data(tty, read_buf_addr(ldata, tail), n,</span><br><span class=\"line\">                ldata-&gt;icanon);</span><br><span class=\"line\">        smp_store_release(&amp;ldata-&gt;read_tail, ldata-&gt;read_tail + n);</span><br><span class=\"line\">        <span class=\"comment\">/* Turn single EOF into zero-length read */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (L_EXTPROC(tty) &amp;&amp; ldata-&gt;icanon &amp;&amp; is_eof &amp;&amp;</span><br><span class=\"line\">            (head == ldata-&gt;read_tail))</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        *b += n;</span><br><span class=\"line\">        *nr -= n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h4><p>一般情况下，典型的读取终端过程可以分为以下三部分：</p>\n<ol>\n<li><p>当前进程准备从终端缓冲区读取数据，但是缓冲区还没有足够字符可以读取，进入睡眠；</p>\n</li>\n<li><p>如果有输入字符，底层驱动将足够的字符写入缓冲区之后，把睡眠的进程唤醒；</p>\n</li>\n<li><p>睡眠的读取进程被唤醒后，开始完成读取操作；</p>\n</li>\n</ol>\n<h4 id=\"8-参考资料\"><a href=\"#8-参考资料\" class=\"headerlink\" title=\"8. 参考资料\"></a>8. 参考资料</h4><p>《Linux内核情景分析》—-控制台驱动</p>\n<p><a href=\"目录\">回到目录</a></p>"}],"PostAsset":[{"_id":"source/_posts/Linux-kernel中的i2c-dev驱动/Linux的I2C子系统框架.png","slug":"Linux的I2C子系统框架.png","post":"ckauufkut0005dqg10ofo0yvk","modified":0,"renderable":0},{"_id":"source/_posts/Linux块设备驱动/块设备驱动系统架构.png","slug":"块设备驱动系统架构.png","post":"ckauufkuy0009dqg1bhvqhda8","modified":0,"renderable":0},{"_id":"source/_posts/Linux块设备驱动/20141116085400721.png","slug":"20141116085400721.png","post":"ckauufkuy0009dqg1bhvqhda8","modified":0,"renderable":0},{"_id":"source/_posts/Linux块设备驱动/Linux的块IO.png","slug":"Linux的块IO.png","post":"ckauufkuy0009dqg1bhvqhda8","modified":0,"renderable":0},{"_id":"source/_posts/Linux块设备驱动/块设备数据结构间的关系.png","slug":"块设备数据结构间的关系.png","post":"ckauufkuy0009dqg1bhvqhda8","modified":0,"renderable":0},{"_id":"source/_posts/Linux块设备驱动/块设备驱动架构图.jpg","slug":"块设备驱动架构图.jpg","post":"ckauufkuy0009dqg1bhvqhda8","modified":0,"renderable":0},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image.png","slug":"Image.png","post":"ckauufkul0001dqg1enw8gid2","modified":0,"renderable":0},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image1.png","slug":"Image1.png","post":"ckauufkul0001dqg1enw8gid2","modified":0,"renderable":0},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image2.png","slug":"Image2.png","post":"ckauufkul0001dqg1enw8gid2","modified":0,"renderable":0},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image3.JPG","slug":"Image3.JPG","post":"ckauufkul0001dqg1enw8gid2","modified":0,"renderable":0},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image4.png","slug":"Image4.png","post":"ckauufkul0001dqg1enw8gid2","modified":0,"renderable":0},{"_id":"source/_posts/Hexo-Github搭建个人博客/Image5.png","slug":"Image5.png","post":"ckauufkul0001dqg1enw8gid2","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image.png","slug":"Image.png","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image1.png","slug":"Image1.png","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image2.png","slug":"Image2.png","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image3.JPG","slug":"Image3.JPG","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image4.png","slug":"Image4.png","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/Image5.png","slug":"Image5.png","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Ubuntu-Hexo-Github搭建个人博客/themes-yilia.png","slug":"themes-yilia.png","post":"ckauufkv4000jdqg15jj06p3p","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Address-Register2.png","slug":"I2C-Address-Register2.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Control-Register.png","slug":"I2C-Control-Register.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Data-IO-Register.png","slug":"I2C-Data-IO-Register.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Frequency-Divider-Register.png","slug":"I2C-Frequency-Divider-Register.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-Status-Register.png","slug":"I2C-Status-Register.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2C-memory-map.png","slug":"I2C-memory-map.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions.png","slug":"I2Cx_I2CR-field-descriptions.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2CR-field-descriptions2.png","slug":"I2Cx_I2CR-field-descriptions2.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions.png","slug":"I2Cx_I2SR-field-descriptions.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions2.png","slug":"I2Cx_I2SR-field-descriptions2.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中I2C的master_xfer驱动实现-基于imx6/I2Cx_I2SR-field-descriptions3.png","slug":"I2Cx_I2SR-field-descriptions3.png","post":"ckauufkuo0003dqg19hxs55xt","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C总线层和设备层的关系.png","slug":"I2C总线层和设备层的关系.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C数据结构间的关系.png","slug":"I2C数据结构间的关系.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C注册匹配过程.png","slug":"I2C注册匹配过程.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/I2C设备和驱动的关系.png","slug":"I2C设备和驱动的关系.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/Linux的I2C体系结构-1587651297877.png","slug":"Linux的I2C体系结构-1587651297877.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/Linux的I2C体系结构.png","slug":"Linux的I2C体系结构.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/Linux-kernel中的I2C子系统/Linux的I2C子系统框架.png","slug":"Linux的I2C子系统框架.png","post":"ckauufkwc0012dqg11pjdaq9f","modified":0,"renderable":0},{"_id":"source/_posts/u-boot的tftp命令解析/tftp流程.jpg","slug":"tftp流程.jpg","post":"ckbx7tt8f0000k8g1fyw03twi","modified":0,"renderable":0},{"_id":"source/_posts/linux-kernel中的tty驱动/tty层次关系-1598176659466.jpg","slug":"tty层次关系-1598176659466.jpg","post":"cke6x5hyv000097g1etjuedbu","modified":0,"renderable":0},{"_id":"source/_posts/linux-kernel中的tty驱动/tty层次关系.jpg","slug":"tty层次关系.jpg","post":"cke6x5hyv000097g1etjuedbu","modified":0,"renderable":0},{"_id":"source/_posts/linux-kernel中的tty驱动/tty读写过程中的函数调用流程-1598176659467.png","slug":"tty读写过程中的函数调用流程-1598176659467.png","post":"cke6x5hyv000097g1etjuedbu","modified":0,"renderable":0},{"_id":"source/_posts/linux-kernel中的tty驱动/tty读写过程中的函数调用流程.png","slug":"tty读写过程中的函数调用流程.png","post":"cke6x5hyv000097g1etjuedbu","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckauufkue0000dqg111p2755q","tag_id":"ckauufkun0002dqg15yjwhb0h","_id":"ckauufkux0007dqg170x86vp0"},{"post_id":"ckauufkul0001dqg1enw8gid2","tag_id":"ckauufkun0002dqg15yjwhb0h","_id":"ckauufkv0000bdqg112a9hdss"},{"post_id":"ckauufkuo0003dqg19hxs55xt","tag_id":"ckauufkuz000adqg189t95mif","_id":"ckauufkv2000gdqg1738z7579"},{"post_id":"ckauufkut0005dqg10ofo0yvk","tag_id":"ckauufkuz000adqg189t95mif","_id":"ckauufkv4000kdqg1ekqp3y6p"},{"post_id":"ckauufkv4000jdqg15jj06p3p","tag_id":"ckauufkun0002dqg15yjwhb0h","_id":"ckauufkv6000ndqg1dhd44n4m"},{"post_id":"ckauufkux0008dqg1g7d7hb83","tag_id":"ckauufkv3000idqg1gtrkadap","_id":"ckauufkv7000pdqg154hd3zky"},{"post_id":"ckauufkuy0009dqg1bhvqhda8","tag_id":"ckauufkv6000mdqg1ffwz39cj","_id":"ckauufkv8000sdqg1g8wi79f4"},{"post_id":"ckauufkv0000cdqg17mvg93ay","tag_id":"ckauufkv6000mdqg1ffwz39cj","_id":"ckauufkv9000udqg121dc4ss2"},{"post_id":"ckauufkv1000ddqg17qp5eh1n","tag_id":"ckauufkv8000tdqg12ykn47f5","_id":"ckauufkva000wdqg1h9c5edc8"},{"post_id":"ckauufkv2000fdqg1gbargmpl","tag_id":"ckauufkv6000mdqg1ffwz39cj","_id":"ckauufkva000ydqg160p8559b"},{"post_id":"ckauufkv3000hdqg1949q71rj","tag_id":"ckauufkv8000tdqg12ykn47f5","_id":"ckauufkvb0010dqg17238bddj"},{"post_id":"ckauufkv6000odqg1g3wt7gs9","tag_id":"ckauufkvb000zdqg1c1u56xqa","_id":"ckauufkvb0011dqg1dkos0am8"},{"post_id":"ckauufkwc0012dqg11pjdaq9f","tag_id":"ckauufkuz000adqg189t95mif","_id":"ckauufkwh0013dqg176ij1zsc"},{"post_id":"ckav0s7fb0000xag174588apg","tag_id":"ckav0s7fh0001xag1ek8ihjnm","_id":"ckav0s7fo0002xag1fg02dxrp"},{"post_id":"cke6x5hyv000097g1etjuedbu","tag_id":"cke6x5hz2000197g1apw439uk","_id":"cke6x5hza000297g1hv6wgb4a"},{"post_id":"cke6xctqa0000kqg15t3e20kn","tag_id":"cke6x5hz2000197g1apw439uk","_id":"cke6xctqi0001kqg1cvop45i3"}],"Tag":[{"name":"Hexo","_id":"ckauufkun0002dqg15yjwhb0h"},{"name":"i2c","_id":"ckauufkuz000adqg189t95mif"},{"name":"Kernel","_id":"ckauufkv3000idqg1gtrkadap"},{"name":"Driver","_id":"ckauufkv6000mdqg1ffwz39cj"},{"name":"Qemu","_id":"ckauufkv8000tdqg12ykn47f5"},{"name":"u-boot","_id":"ckauufkvb000zdqg1c1u56xqa"},{"name":"busybox","_id":"ckav0s7fh0001xag1ek8ihjnm"},{"name":"tty","_id":"cke6x5hz2000197g1apw439uk"}]}}