<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mshrimp.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核启动流程-基于ARM64">
<meta property="og:url" content="http://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/index.html">
<meta property="og:site_name" content="Mshrimp blog">
<meta property="og:description" content="以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；">
<meta property="article:published_time" content="2020-04-19T15:13:03.000Z">
<meta property="article:modified_time" content="2020-05-07T14:20:30.640Z">
<meta property="article:author" content="micro虾米">
<meta property="article:tag" content="Kernel">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>Linux内核启动流程-基于ARM64 | Mshrimp blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mshrimp blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">micro虾米</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="micro虾米">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mshrimp blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux内核启动流程-基于ARM64
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-19 23:13:03" itemprop="dateCreated datePublished" datetime="2020-04-19T23:13:03+08:00">2020-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-07 22:20:30" itemprop="dateModified" datetime="2020-05-07T22:20:30+08:00">2020-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>以arm64为例，简单讲述Linux在ARM64架构设备上系统启动的重要流程；</p>
<a id="more"></a>



<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p>
<h3 id="0-简述"><a href="#0-简述" class="headerlink" title="0. 简述"></a>0. 简述</h3><p>以arm64为例，讲述Linux在ARM64架构设备上的系统启动流程；</p>
<p>上电启动，系统启动要经过uboot、kernel、filesystem、ADM几个过程，如下：</p>
<pre class="mermaid">graph LR
    uboot(uboot)-->kernel(kernel)
    -->filesystem(filesystem)
    -->Software(Software)</pre>






<p>在大多数系统中，内核镜像在uboot阶段被加载到内存中，并获得控制权开始内核的启动流程；</p>
<pre class="mermaid">graph LR
    uboot(uboot)-->kernel(kernel)</pre>




<p>Linux内核版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux-4.9.115</span><br><span class="line"><span class="meta">#</span><span class="bash"> uname -a</span></span><br><span class="line">Linux vexpress 4.9.115 #2 SMP Wed Apr 1 22:49:35 CST 2020 aarch64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：由于Linux内核系统庞大繁杂，要想把内核启动中的每个细节都描述清楚，基本上不可能，更何况作者能力水平也达不到；因此，就在追踪内核启动流程代码的同时，只描述比较重要的几个部分；可以在以后的工作、学习中，随着水平的提高，不断地增加内容；</p>
<h3 id="1-目标文件"><a href="#1-目标文件" class="headerlink" title="1. 目标文件"></a>1. 目标文件</h3><p>内核编译后生成的目标文件是ELF格式的vmlinux，vmlinux文件是各个源代码按照vmlinux.lds设定的规则，链接后得到的Object文件，并不是一个可执行的文件，不能在ARM平台上运行；通常会对其压缩，生成zImage或bzImage；通常内核映像以压缩格式存储，并不是一个可执行的内核；因此内核阶段需要先对内核映像自解压，他们的文件头部打包有解压缩程序；</p>
<h4 id="1-1-vmlinux-lds"><a href="#1-1-vmlinux-lds" class="headerlink" title="1.1 vmlinux.lds"></a>1.1 vmlinux.lds</h4><p>vmlinux.lds文件是在内核编译时生成的，是被禁止编辑的；vmlinux.lds文件是在编译时，由vmlinux.lds.S文件对链接器ld的输出进行排序后生成；vmlinux.lds.S是用来对输出文件中的段进行排序，并定义相关的符号名；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S</span><br></pre></td></tr></table></figure>


<p>在项目中通过make时指定的参数-O，将内核编译生成的所有目标文件，包括vmlinux.lds文件重定向输出到以下目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch/arm64/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>


<p>vmlinux.lds文件是链接脚本，在内核编译时，作为Makefile的链接器脚本，参与链接生成内核映像vmlinux；</p>
<p>总之：vmlinux是按照vmlinux.lds链接生成的，而vmlinux.lds是由vmlinux.lds.S生成的；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/vmlinux.lds</span></span><br><span class="line">OUTPUT_ARCH(aarch64)	<span class="comment">// 指定架构为aarch64</span></span><br><span class="line">ENTRY(_text)			<span class="comment">// 定义入口为_text</span></span><br><span class="line">jiffies = jiffies_64;	<span class="comment">// 定义为64位计数器</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 指定链接地址</span></span><br><span class="line">    . = ((((<span class="number">0xffffffffffffffff</span> - (<span class="number">1</span> &lt;&lt; (<span class="number">48</span>)) + <span class="number">1</span>) + (<span class="number">0</span>)) + (<span class="number">0x08000000</span>))) + <span class="number">0x00080000</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>关于段的信息</p>
<blockquote>
<p>text段，代码段，用来存放程序执行代码的一块内存区域；大小在程序运行前确定；</p>
<p>data段，数据段，用来存放程序中已初始化的全局变量的内存区域；数据段属于静态内存分配；</p>
<p>bss段，用来存放程序中未初始化的全局变量和静态变量的一块内存区域；属于静态内存分配；</p>
<p>init段，Linux定义的一种初始化过程中才能用到的段；初始化完成后，该段内存会被释放；</p>
</blockquote>
<p>关于地址的信息</p>
<blockquote>
<p>加载地址：程序中指令和变量等加载到RAM上的地址；</p>
<p>运行地址：CPU执行一条程序的指令时的执行地址，即PC寄存器的值；就是要寻址到一个指令或变量所使用的地址；</p>
<p>链接地址：链接过程中链接器为指令和变量分配的地址；</p>
</blockquote>
<h4 id="1-2-内核映像"><a href="#1-2-内核映像" class="headerlink" title="1.2 内核映像"></a>1.2 内核映像</h4><p>vmlinux是未压缩的内核，是生成的纯内核二进制文件，具有用户定义的所有内核组件，但是这个vmlinux二进制文件是无法启动系统的；为了将Linux内核映像加载到内存并处于可执行状态，内核构建系统使用objcopy命令清除不必要的节区，压缩ELF格式的vmlinux，通过引导程序加载项和链接，生成可启动的最终的二进制文件zImage；</p>
<p>vmlinux通过gzip压缩成piggy.o，和head.o、misc.o链接生成zImage二进制文件；</p>
<p>vmlinuz是vmlinux的压缩文件</p>
<p>zImage默认的压缩内核映像文件，压缩vmlinux，加上一段解压启动代码，压缩而成；</p>
<p>uImage是u-boot使用bootm命令引导的Linux压缩内核映像文件格式，是使用mkimage工具对普通的压缩内核映像文件（zImage）加工而成；</p>
<p>uImage是uboot专用的内核映像文件，是在zImage之前加上一个长度为64字节的“头”，说明内核的版本、加载位置、生成时间、大小等信息；在地址0x40之后的部分，和zImage一样；其大小比zImage大64字节；</p>
<h4 id="1-3-设备树文件"><a href="#1-3-设备树文件" class="headerlink" title="1.3 设备树文件"></a>1.3 设备树文件</h4><p>Linux内核从3.x版本开始引入设备树的概念，用于实现驱动代码与设备信息分离；设备树出现之前，所有关于设备的具体信息都写在驱动中，外围设备变化，驱动代码就要跟着修改甚至是重写；引入设备树之后，驱动代码只负责处理驱动代码的逻辑，而关于设备的具体信息存放到设备树文件中，这样硬件接口信息变化时，只需要修改设备树文件信息，不需要修改驱动代码就可以；</p>
<p>一般情况下，在编译设备树之前，先在scripts/dtc/目录下，编译生成dtc工具scripts/dtc/dtc，再使用生成的dtc工具编译设备树源码，生成设备树文件；设备树源码和目标文件在arch/arm64/boot/dts/freescale/目录；</p>
<p>在Lx2160板项目中，目标文件会被重定向输出到target目录；</p>
<p>具体的设备树文件的加载、解析过程，会在下文setup_arch部分描述；</p>
<h3 id="2-内核启动第一阶段"><a href="#2-内核启动第一阶段" class="headerlink" title="2. 内核启动第一阶段"></a>2. 内核启动第一阶段</h3><p>Linux内核启动第一阶段，也就是我们常说的汇编阶段，也就是stext函数的实现内容；这部分主要完成的工作：CPU ID检查，machine ID检查，创建初始化页表，设置C代码运行环境，跳转到内核第一个真正的C函数start_kernel执行；</p>
<p>设置为SVC模式，关闭所有中断</p>
<p>获取CPUID，提取相应的proc info</p>
<p>验证tags或dtb</p>
<p>创建页表项</p>
<p>head.S文件中，</p>
<p>校验启动合法性</p>
<p>建立段式映射的页表并开启MMU</p>
<p>构建C运行环境，跳入C阶段</p>
<h4 id="2-1-内核启动入口点"><a href="#2-1-内核启动入口点" class="headerlink" title="2.1 内核启动入口点"></a>2.1 内核启动入口点</h4><p>内核是一个庞大的系统，通过vmlinux反向追踪启动入口点</p>
<p>Lx2160le板的交叉编译工具链：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure>




<p>通过对目标文件vmlinux的反向追溯，找到Linux执行的入口；</p>
<p>使用readelf命令可以查看vmlinux的入口地址为：0xffff000008080000</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> readelf -h vmlinux</span></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0xffff000008080000</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          267014976 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         4</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         39</span><br><span class="line">  Section header string table index: 36</span><br></pre></td></tr></table></figure>




<p>这个入口地址是怎么来的，对应内核代码中的哪个部分，可以通过反汇编来分析；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> aarch64-linux-gnu-objdump -dxh vmlinux &gt; vmlinux.s</span></span><br></pre></td></tr></table></figure>




<p>在得到的汇编文件vmlinux.s中查找入口地址：0xffff000008080000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start address <span class="number">0xffff000008080000</span></span><br><span class="line"></span><br><span class="line">Disassembly of section .head.<span class="built_in">text</span>:</span><br><span class="line"></span><br><span class="line">ffff000008080000 &lt;_text&gt;:</span><br><span class="line">ffff000008080000:       <span class="number">91005</span>a4d        add     x13, x18, #<span class="number">0x16</span></span><br><span class="line">ffff000008080004:       <span class="number">14437f</span>ff        b       ffff000009160000 &lt;stext&gt;</span><br></pre></td></tr></table></figure>




<p>可以得到，Linux入口的第一条指令为：add     x13, x18, #0x16；对应的符号是：.head.text  _text；</p>
<p>而.head.text段，通过include/linux/init.h文件中的宏定义__HEAD来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For assembly routines */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HEAD      .section    <span class="meta-string">".head.text"</span>,<span class="meta-string">"ax"</span>	<span class="comment">// "ax"表示所在段区域有可执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INIT      .section    <span class="meta-string">".init.text"</span>,<span class="meta-string">"ax"</span></span></span><br></pre></td></tr></table></figure>




<p>内核启动的入口点，在arch/arm64/kernel/head.S文件中；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    __HEAD</span><br><span class="line">_head:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EFI</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This add instruction has no meaningful effect except that</span></span><br><span class="line"><span class="comment">     * its opcode forms the magic "MZ" signature required by UEFI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    add x13, x18, #<span class="number">0x16</span></span><br><span class="line">    b   stext</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    b   stext               <span class="comment">// branch to kernel start, magic</span></span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">0</span>               <span class="comment">// reserved</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>到此，已经找到，目标文件vmlinux的入口是arch/arm64/kernel/head.S文件中的__HEAD，在执行完第一条语句（add x13, x18, #0x16）之后，跳转到stext函数执行（b   stext）；所以，加载vmlinux后，第一个运行的函数是stext；</p>
<h4 id="2-2-stext函数"><a href="#2-2-stext函数" class="headerlink" title="2.2 stext函数"></a>2.2 stext函数</h4><p>启动过程中的汇编阶段，是从arch/arm64/kernel/head.S文件开始，执行的起点是stext函数，入口函数是通过vmlinux.lds链接而成，在head.S中ENTRY(stext)指定；</p>
<p>在汇编代码中，宏定义ENTRY和ENDPROC是成对出现的，表示定义的一个函数，同时也要指明当前代码所在的段，如：__INIT；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INIT      .section    <span class="meta-string">".init.text"</span>,<span class="meta-string">"ax"</span></span></span><br><span class="line"></span><br><span class="line">	__INIT</span><br><span class="line">ENTRY(stext)</span><br><span class="line">	......</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>




<p>内核启动的必要条件：MMU关闭，D-cache关闭，x0是传递给FDT blob的物理地址；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* The requirements are:</span><br><span class="line">*   MMU = off, D-cache = off, I-cache = on <span class="keyword">or</span> off,</span><br><span class="line">*   x0 = physical address to the FDT blob.</span><br></pre></td></tr></table></figure>



<p>stext函数开始执行；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">	__INIT</span><br><span class="line">ENTRY(stext)</span><br><span class="line">    bl  preserve_boot_args	<span class="comment">// Preserve the arguments passed by the bootloader in x0 ... x3</span></span><br><span class="line">    bl  el2_setup           <span class="comment">// Drop to EL1, w0=cpu_boot_mode</span></span><br><span class="line">    adrp    x23, __PHYS_OFFSET</span><br><span class="line">    <span class="keyword">and</span> x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span>    <span class="comment">// KASLR offset, defaults to 0</span></span><br><span class="line">    bl  set_cpu_boot_mode_flag</span><br><span class="line">    bl  __create_page_tables</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span></span><br><span class="line"><span class="comment">   * details.</span></span><br><span class="line"><span class="comment">   * On return, the CPU will be ready for the MMU to be turned on and</span></span><br><span class="line"><span class="comment">   * the TCR will have been set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">     bl  __cpu_setup         <span class="comment">// initialise processor</span></span><br><span class="line">     b   __primary_switch</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>



<h5 id="1-preserve-boot-args"><a href="#1-preserve-boot-args" class="headerlink" title="1. preserve_boot_args"></a>1. preserve_boot_args</h5><p>保存从bootloader传递过来的x0 ~ x3参数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">preserve_boot_args:</span><br><span class="line">    mov x21, x0				<span class="comment">// 将dtb的地址暂存在x21寄存器，释放出x0使用</span></span><br><span class="line">    adr_l   x0, boot_args	<span class="comment">// x0保存boot_args变量的地址</span></span><br><span class="line">    stp x21, x1, [x0]		<span class="comment">// 将x0、x1的值保存到boot_args[0]、boot_args[1]</span></span><br><span class="line">    stp x2, x3, [x0, #<span class="number">16</span>]	<span class="comment">// 将x2、x3的值保存到boot_args[2]、boot_args[3]</span></span><br><span class="line"></span><br><span class="line">    dmb sy              <span class="comment">// needed before dc ivac with</span></span><br><span class="line">                        <span class="comment">// MMU off</span></span><br><span class="line"></span><br><span class="line">    add x1, x0, #<span class="number">0x20</span>		<span class="comment">// x0、x1作为nval_cache_range函数的参数</span></span><br><span class="line">    b   __inval_cache_range     <span class="comment">// tail call</span></span><br><span class="line">ENDPROC(preserve_boot_args)</span><br></pre></td></tr></table></figure>




<h5 id="2-el2-setup"><a href="#2-el2-setup" class="headerlink" title="2. el2_setup"></a>2. el2_setup</h5><p>到此，CPU处于哪个exception level？根据ARM64 boot protocol，CPU处于EL2（推荐）或者secure EL1；如果处于EL2，需要将CPU退回到EL1；此部分还没有搞明白，暂时先跳过；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">ENTRY(el2_setup)</span><br><span class="line">	......</span><br><span class="line">ENDPROC(el2_setup)</span><br></pre></td></tr></table></figure>




<h5 id="3-set-cpu-boot-mode-flag"><a href="#3-set-cpu-boot-mode-flag" class="headerlink" title="3. set_cpu_boot_mode_flag"></a>3. set_cpu_boot_mode_flag</h5><p>set_cpu_boot_mode_flag函数，用来设置__boot_cpu_mode flag；需要一个前提条件：w20寄存器中保存了CPU启动时的异常等级（Exception level）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">set_cpu_boot_mode_flag:</span><br><span class="line">    adr_l   x1, __boot_cpu_mode</span><br><span class="line">    cmp w0, #BOOT_CPU_MODE_EL2</span><br><span class="line">    b.ne    <span class="number">1f</span></span><br><span class="line">    add x1, x1, #<span class="number">4</span></span><br><span class="line"><span class="number">1</span>:  str w0, [x1]            <span class="comment">// This CPU has booted in EL1</span></span><br><span class="line">    dmb sy</span><br><span class="line">    dc  ivac, x1            <span class="comment">// Invalidate potentially stale cache line</span></span><br><span class="line">    ret</span><br><span class="line">ENDPROC(set_cpu_boot_mode_flag)</span><br></pre></td></tr></table></figure>


<p>由于系统启动之后，需要了解CPU启动时候的Exception level，因此需要一个全局变量__boot_cpu_mode来保存启动时的CPU mode；</p>
<p>全局变量__boot_cpu_mode定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__boot_cpu_mode)</span><br><span class="line">    .<span class="keyword">long</span>   BOOT_CPU_MODE_EL2</span><br><span class="line">    .<span class="keyword">long</span>   BOOT_CPU_MODE_EL1</span><br></pre></td></tr></table></figure>




<h5 id="4-create-page-tables"><a href="#4-create-page-tables" class="headerlink" title="4. __create_page_tables"></a>4. __create_page_tables</h5><p>建立页表初始化的过程；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">__create_page_tables:</span><br><span class="line">	......</span><br><span class="line">ENDPROC(__create_page_tables)</span><br></pre></td></tr></table></figure>




<h5 id="5-cpu-setup"><a href="#5-cpu-setup" class="headerlink" title="5. __cpu_setup"></a>5. __cpu_setup</h5><p>CPU的初始化设置；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/mm/proc.S</span></span><br><span class="line">ENTRY(__cpu_setup)</span><br><span class="line">	......</span><br><span class="line">ENDPROC(__cpu_setup)</span><br></pre></td></tr></table></figure>


<p>主要的内容包括：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、cache和TLB的处理</span><br><span class="line">2、Memory attributes lookup table的创建</span><br><span class="line">3、SCTLR_EL1、TCR_EL1的设定</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="6-primary-switch"><a href="#6-primary-switch" class="headerlink" title="6. __primary_switch"></a>6. __primary_switch</h5><p>主要工作是为打开MMU做准备；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">__primary_switch:</span><br><span class="line">	......</span><br><span class="line">	bl  __enable_mmu			<span class="comment">// 开启MMU</span></span><br><span class="line">	......</span><br><span class="line">    ldr x8, =__primary_switched</span><br><span class="line">    adrp    x0, __PHYS_OFFSET</span><br><span class="line">    blr x8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure>


<p>在函数中通过__enable_mmu函数来开启MMU，并调用__primary_switched函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">__primary_switched:</span><br><span class="line">	......</span><br><span class="line">    b   start_kernel</span><br><span class="line">ENDPROC(__primary_switched)</span><br></pre></td></tr></table></figure>


<p>在__primary_switched函数中，进行一些C环境的准备，并在最后，调用执行start_kernel函数，内核的启动进入到C语言环境阶段；</p>
<pre class="mermaid">graph TB
    subgraph 入口函数
    A_Explain(保存boot参数)
    -->
    B_Explain(EL2设置)
    -->
    C_Explain(设置CPU启动模式flag)
    -->
    D_Explain(创建页表)
    -->
    E_Explain(CPU配置)
    -->
    F_Explain(主要的转换操作)
    -->
    G_Explain(运行start_kernel函数)
    end

    subgraph stext
    A_func(preserve_boot_args)
    -->
    B_func(el2_setup)
    -->
    C_func(set_cpu_boot_mode_flag)
    -->
    D_func(__create_page_tables)
    -->
    E_func(__cpu_setup)
    -->
    F_func(__primary_switch)
    -->
    G_func(start_kernel)
    end</pre>




<h4 id="2-3-参考资料"><a href="#2-3-参考资料" class="headerlink" title="2.3 参考资料"></a>2.3 参考资料</h4><p><a href="https://blog.csdn.net/xiaohua0877/article/details/78615776" target="_blank" rel="noopener">https://blog.csdn.net/xiaohua0877/article/details/78615776</a></p>
<p><a href="http://www.wowotech.net/sort/armv8a_arch" target="_blank" rel="noopener">http://www.wowotech.net/sort/armv8a_arch</a></p>
<h3 id="3-内核启动第二阶段"><a href="#3-内核启动第二阶段" class="headerlink" title="3. 内核启动第二阶段"></a>3. 内核启动第二阶段</h3><p>Linux内核启动的第二阶段也就是常说的C语言阶段，从start_kernel()函数开始；start_kernel()函数是所有Linux平台进入系统内核初始化后的入口函数；主要完成剩余的与硬件平台相关的初始化工作，这些初始化操作，有的是公共的，有的是需要配置才会执行的；内核工作需要的模块的初始化依次被调用，如：内存管理、调度系统、异常处理等；</p>
<pre class="mermaid">graph TB
    A(start_kernel)-->B(一系列的初始化操作)
    subgraph start_kernel
    B(一系列的初始化操作)
    -->
    C(setup_arch)
    -->
    D(一系列的初始化操作)
    -->
    E(rest_init)
    end</pre>




<h4 id="3-1-start-kernel"><a href="#3-1-start-kernel" class="headerlink" title="3.1 start_kernel"></a>3.1 start_kernel</h4><p>start_kernel()函数在init/main.c文件中，主要完成Linux子系统的初始化工作；此部分初始化内容繁多，暂时先略过，此处省略好多字；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pr_notice(<span class="string">"%s"</span>, linux_banner);</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> linux_banner[] =</span><br><span class="line">    <span class="string">"Linux version "</span> UTS_RELEASE <span class="string">" ("</span> LINUX_COMPILE_BY <span class="string">"@"</span></span><br><span class="line">    LINUX_COMPILE_HOST <span class="string">") ("</span> LINUX_COMPILER <span class="string">") "</span> UTS_VERSION <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>


<p>执行的效果是，在内核启动初期，打印内核版本号和构建信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.9.115 (root@localhost.localdomain) (gcc version 6.2.0 20170314 ZTE Embsys-TSP V3.06.40 (GCC) ) #2 SMP PREEMPT Tue Mar 10 11:21:00 CST 2020</span><br></pre></td></tr></table></figure>




<h4 id="3-2-setup-arch"><a href="#3-2-setup-arch" class="headerlink" title="3.2 setup_arch"></a>3.2 setup_arch</h4><p>setup_arch()函数，是体系结构相关的，该函数根据处理器、硬件平台具体型号设置系统；及解析系统命令行，系统内存管理初始化，统计并注册系统各种资源等；每个体系都有自己的setup_arch()函数，是由顶层Makefile中的ARCH变量定义的，我们使用的是ARCH=arm64，因此，这里的setup_arch()函数，也是arm64的体系结构相关的；参数是未被初始化的内部变量command_line；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	setup_arch(&amp;command_line);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>setup_arch()函数中的初始化内容比较多，目前<strong>只对设备树相关的部分进行简要描述</strong>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/setup.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">setup_arch</span><span class="params">(<span class="keyword">char</span> **cmdline_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	setup_machine_fdt(__fdt_pointer);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">        unflatten_device_tree();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<pre class="mermaid">graph LR
    A(setup_arch)-->B(加载设备树)
    B(加载设备树)-->C(setup_machine_fdt)
    B(加载设备树)-->D(unflatten_device_tree)</pre>




<h5 id="1-setup-machine-fdt"><a href="#1-setup-machine-fdt" class="headerlink" title="1. setup_machine_fdt"></a>1. setup_machine_fdt</h5><p>setup_machine_fdt()函数的输入参数是设备树（DTB）首地址；uboot启动程序把设备树读取到内存中，之后在启动内核的同时，将设备树首地址传给内核，setup_machine_fdt()函数的参数__fdt_pointer就是uboot传给内核的设备树地址；函数中的fdt(flat device tree)表示，设备树在内存中是在一块连续地址存储的；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/setup.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">setup_machine_fdt</span><span class="params">(<span class="keyword">phys_addr_t</span> dt_phys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *dt_virt = fixmap_remap_fdt(dt_phys);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">"%s (DT)"</span>, of_flat_dt_get_machine_name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/setup.c</span></span><br><span class="line"><span class="keyword">phys_addr_t</span> __fdt_pointer __initdata;</span><br></pre></td></tr></table></figure>


<p>全局变量__fdt_pointer指向内存中的DTB，是设备树的物理地址；这个物理地址是由bootloader传递给内核的，在内核中使用，是需要转换为虚拟地址才能访问，而这个转换，由fixmap_remap_fdt()函数来完成；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/of/fdt.c</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> __init <span class="title">early_init_dt_scan</span><span class="params">(<span class="keyword">void</span> *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> status;</span><br><span class="line"></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来调用的early_init_dt_scan()函数，通过进一步调用early_init_dt_verify()函数来检查DTB数据是否完整，经过内存映射之后，就可以直接访问DTB中的内容了；</p>
<h5 id="2-unflatten-device-tree"><a href="#2-unflatten-device-tree" class="headerlink" title="2. unflatten_device_tree"></a>2. unflatten_device_tree</h5><p>unflatten_device_tree()函数完成对设备树的解析，所做的工作是将设备树各节点转换成相应的struct device_node结构体；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/of/fdt.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">unflatten_device_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/of/base.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_root</span>;</span></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__unflatten_device_tree(<span class="keyword">const</span> <span class="keyword">void</span> *blob,</span><br><span class="line">                     struct device_node *dad,</span><br><span class="line">                     struct device_node **mynodes,</span><br><span class="line">                     <span class="keyword">void</span> *(*dt_alloc)(u64 <span class="built_in">size</span>, u64 align),</span><br><span class="line">                     <span class="keyword">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">/* First pass, scan for size */</span></span><br><span class="line">	<span class="built_in">size</span> = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">/* Allocate memory for the expanded device tree */</span></span><br><span class="line">	mem = dt_alloc(<span class="built_in">size</span> + <span class="number">4</span>, __alignof__(struct device_node));</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">/* Second pass, do actual unflattening */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>__unflatten_device_tree()函数中主要的解析函数是unflatten_dt_nodes()，在这里被调用了两次，第一次是扫描出设备树转换成struct device_node所需要的空间，然后系统申请内存空间，第二次是进行真正解析的工作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/of/fdt.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unflatten_dt_nodes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *blob,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *mem,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct device_node *dad,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct device_node **nodepp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">         offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">         offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		fpsizes[depth+<span class="number">1</span>] = populate_node(blob, offset, &amp;mem,</span><br><span class="line">                         nps[depth],</span><br><span class="line">                         fpsizes[depth],</span><br><span class="line">                         &amp;nps[depth+<span class="number">1</span>], dryrun);</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>unflatten_dt_nodes()函数，就是从根节点开始，对子节点依次调用populate_node()，为当前节点申请内存空间，并对node进行初始化；并根据读取到的dtb中的内容，按节点进行填充；设备树由dtb二进制文件，经过解析为每一个节点生成一个struct device_node结构体，就完成了dtb的加载过程；</p>
<h4 id="3-3-console-init"><a href="#3-3-console-init" class="headerlink" title="3.3 console_init"></a>3.3 console_init</h4><p>console_init()函数执行控制台的初始化操作；在console_init()函数执行之前的printk打印信息，需要在console_init()函数执行之后才能打印出来；因为在console_inie()函数之前，printk的打印信息都保存在一个缓存区中，等到console_init()函数执行之后，控制台被初始化完成，就可以将缓冲区中的内容打印出来；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/tty/tty_io.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">console_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">initcall_t</span> *call;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the default TTY line discipline. */</span></span><br><span class="line">    n_tty_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set up the console device so that later boot sequences can</span></span><br><span class="line"><span class="comment">     * inform about problems etc..</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    call = __con_initcall_start;</span><br><span class="line">    <span class="keyword">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class="line">        (*call)();</span><br><span class="line">        call++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在console_init()函数中，指定initcall_t类型的函数指针，从__con_initcall_start开始，到__con_initcall_end结束，遍历这个范围之间的函数，依次运行；</p>
<p>__con_initcall_start和__con_initcall_end这两个地址，可以在vmlinux.lds文件找到；如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vmlinux.lds</span></span><br><span class="line">__con_initcall_start = .;</span><br><span class="line">KEEP(*(.con_initcall.init))</span><br><span class="line">__con_initcall_end = .;</span><br></pre></td></tr></table></figure>


<p>这两个地址之间，存放的是.con_initcall.init段的内容；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/init.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> console_initcall(fn)                    \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">initcall_t</span> __initcall_#<span class="meta">#fn           \</span></span><br><span class="line">    __used __section(.con_initcall.init) = fn</span><br></pre></td></tr></table></figure>


<p>通过宏定义console_initcall(fn)，将initcall_t类型的函数指针fn，存放到.con_initcall.init段；之后在调用console_init()函数时，就会通过遍历<em>\</em>con_initcall_start到__con_initcall_end的地址区域，依次运行存放在其中的函数fn；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/tty/serial/8250/8250_core.c</span></span><br><span class="line">console_initcall(univ8250_console_init);</span><br></pre></td></tr></table></figure>

<h4 id="3-4-rest-init"><a href="#3-4-rest-init" class="headerlink" title="3.4 rest_init"></a>3.4 rest_init</h4><p>在进行一系列与内核相关的初始化后，在rest_init()函数中，启动了三个进程：idle、kernel_init、kthreadd，来开始操作系统的正式运行；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line">rest_init()</span><br><span class="line">    kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);	<span class="comment">// 创建kernel_init内核线程，即init，1号进程；</span></span><br><span class="line">    pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);	<span class="comment">// 创建kthreadd内核线程，2号进程，用于管理和调度其他内核线程；</span></span><br><span class="line">    ......</span><br><span class="line">    init_idle_bootup_task(current);	<span class="comment">// 设置当前进程（0号进程）为idle进程；</span></span><br><span class="line">    schedule_preempt_disabled();	<span class="comment">// 调用进程调度，并禁止内核抢占；</span></span><br><span class="line">    <span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">    cpu_startup_entry(CPUHP_ONLINE);	<span class="comment">// 0号进程完成kernel初始化工作，进入idle循环，编程idle进程；</span></span><br></pre></td></tr></table></figure>


<pre class="mermaid">graph TB
    A(rest_init)-->B(idle进程)
    A(rest_init)-->C(kernel_init进程)
    A(rest_init)-->D(kthreadd进程)</pre>



<blockquote>
<ul>
<li>idle进程是操作系统的空闲进程，CPU空闲的时候会去运行它；</li>
<li>kernel_init进程最开始只是一个函数，作为进程被启动，init进程是永远存在的，PID是1；</li>
<li>kthreadd是内核守护进程，始终运行在内核空间，负责所有内核线程的调度和管理，PID是2；</li>
</ul>
</blockquote>
<p>也就是说，系统启动后的第一个进程是idle，idle进程是唯一没有通过kernel_thread或fork产生的进程；idle创建了kernel_init进程作为1号进程，创建了kthreadd进程作为2号进程；</p>
<pre class="mermaid">graph TB
    A(idle进程)-->B(kernel_init进程)
    A(idle进程)-->C(kthreadd进程)</pre>




<h4 id="3-5-kernel-init"><a href="#3-5-kernel-init" class="headerlink" title="3.5 kernel_init"></a>3.5 kernel_init</h4><p>kernel_init()函数在创建kernel_init进程时，作为进程被启动；虽然kernel_init最开始只是一个函数，但是在最后，通过系统调用，将读取根文件系统下的init进程，完成从内核态到用户态的转变，转变为用户态的1号进程；这个init进程是所有用户态进程的父进程，产生了大量的子进程；init进程是1号进程，是永远存在的；</p>
<pre class="mermaid">graph TB
    A(kernel_init)-->B(kernel_init_freeable)
    subgraph kernel_init
        B(kernel_init_freeable)
        -->C(free_initmem)
        -->D(ramdisk_execute_command)
        -->E(execute_command)
        -->F(用户空间init进程)
    end</pre>




<h4 id="3-6-kernel-init-freeable"><a href="#3-6-kernel-init-freeable" class="headerlink" title="3.6 kernel_init_freeable"></a>3.6 kernel_init_freeable</h4><p>等待内核线程kthreadd创建完成、注册内核驱动模块do_basic_setup、启动默认控制台/dev/console</p>
<p>完成设备初始化以及模块加载工作；</p>
<pre class="mermaid">graph TB
    A(kernel_init_freeable)-->B(wait_for_completion)
    subgraph kernel_init_freeable
        B(wait_for_completion)
        -->C(set_mems_allowed)
        -->D(do_basic_setup)
        -->E(open console)    
        -->X(ramdisk_execute_command)
    end</pre>




<h5 id="3-6-1-wait-for-completion"><a href="#3-6-1-wait-for-completion" class="headerlink" title="3.6.1 wait_for_completion"></a>3.6.1 wait_for_completion</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line">kernel_init_freeable()</span><br><span class="line">&#123;</span><br><span class="line">	wait_for_completion(&amp;kthreadd_done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用完成量等待kthreadd_done，等待内核线程kthreadd创建完成；虽然kernel_init进程先创建，但是要在kthreadd线程创建完成才能执行；在threadd线程创建完成后才唤醒完成量，开始kernel_init进程的工作；</p>
<h5 id="3-6-2-do-basic-setup"><a href="#3-6-2-do-basic-setup" class="headerlink" title="3.6.2 do_basic_setup"></a>3.6.2 do_basic_setup</h5><pre class="mermaid">graph TB
    A(do_basic_setup)-->C(driver_init)
    subgraph do_basic_setup
    C(driver_init)
    -->D(do_initcalls)
    end</pre>







<h6 id="2-driver-init"><a href="#2-driver-init" class="headerlink" title="2. driver_init"></a>2. driver_init</h6><p>driver_init()函数完成与驱动程序相关的所有子系统的构建，实现了Linux设备驱动的一个整体框架，但是它只是建立了目录结构，是设备驱动程序初始化的第一部分，具体驱动模块的装载在do_initcalls()函数中实现；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/init.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* These are the core pieces */</span></span><br><span class="line">    devtmpfs_init();	<span class="comment">// 注册devtmpfs文件系统，启动devtmpfsd进程</span></span><br><span class="line">    devices_init();		<span class="comment">// 初始化驱动模型中的部分子系统，/dev/devices, /dev/char, /dev/block</span></span><br><span class="line">    buses_init();		<span class="comment">// 初始化驱动模型中的bus子系统</span></span><br><span class="line">    classes_init();		<span class="comment">// 初始化驱动模型中的class子系统</span></span><br><span class="line">    firmware_init();	<span class="comment">// 初始化驱动模型中的firmware子系统</span></span><br><span class="line">    hypervisor_init();	<span class="comment">// 初始化驱动模型中的hypervisor子系统</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are also core pieces, but must come after the</span></span><br><span class="line"><span class="comment">     * core core pieces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    platform_bus_init();	<span class="comment">// 初始化驱动模型中的bus/platform子系统，此节点是所有platform设备和驱动的总线模型；所有platform设备和驱动都会挂载到这个总线上；</span></span><br><span class="line">    cpu_dev_init();		<span class="comment">// 初始化驱动模型中的device/system/cpu子系统，该节点包含CPU相关属性；</span></span><br><span class="line">    memory_dev_init();	<span class="comment">// 初始化驱动模型中的device/system/memory子系统，该节点包含了内存相关属性；</span></span><br><span class="line">    container_dev_init();	<span class="comment">// 初始化系统总线类型为容器；</span></span><br><span class="line">    of_core_init();		<span class="comment">// 初始化创建，访问和结时设备树的过程；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h6 id="3-do-initcalls"><a href="#3-do-initcalls" class="headerlink" title="3. do_initcalls"></a>3. do_initcalls</h6><p>编译器在编译内核时，将一系列模块初始化函数的起始地址按照一定顺序，放在名为section的段中；在内核启动的初始化阶段，do_initcalls()函数中以函数指针的形式取出这些函数的其实地址，依次运行，以完成相应模块的初始化操作，是设备驱动程序初始化的第二部分；由于内核模块可能存在依赖关系，即某些模块的初始化需要依赖其他模块的初始化来完成，因此这些模块的初始化顺序非常重要；</p>
<p>依次调用不同等级的初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">do_initcalls</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次调用不同level等级的初始化函数</span></span><br><span class="line">    <span class="keyword">for</span> (level = <span class="number">0</span>; level &lt; ARRAY_SIZE(initcall_levels) - <span class="number">1</span>; level++)</span><br><span class="line">        do_initcall_level(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>对于同一个level等级下的函数，依次遍历执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">initcall_t</span> *fn;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(initcall_command_line, saved_command_line);</span><br><span class="line">    parse_args(initcall_level_names[level],</span><br><span class="line">           initcall_command_line, __start___param,</span><br><span class="line">           __stop___param - __start___param,</span><br><span class="line">           level, level,</span><br><span class="line">           <span class="literal">NULL</span>, &amp;repair_env_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于同一个level等级下的函数，依次遍历执行；</span></span><br><span class="line">    <span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line">        do_one_initcall(*fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>开始执行某一个确定的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init_or_module <span class="title">do_one_initcall</span><span class="params">(<span class="keyword">initcall_t</span> fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = preempt_count();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> msgbuf[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initcall_blacklisted(fn))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initcall_debug)</span><br><span class="line">        ret = do_one_initcall_debug(fn);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = fn();</span><br><span class="line"></span><br><span class="line">    msgbuf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preempt_count() != count) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(msgbuf, <span class="string">"preemption imbalance "</span>);</span><br><span class="line">        preempt_count_set(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (irqs_disabled()) &#123;</span><br><span class="line">        strlcat(msgbuf, <span class="string">"disabled interrupts "</span>, <span class="keyword">sizeof</span>(msgbuf));</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">    WARN(msgbuf[<span class="number">0</span>], <span class="string">"initcall %pF returned with %s\n"</span>, fn, msgbuf);</span><br><span class="line"></span><br><span class="line">    add_latent_entropy();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>编译到内核中的模块，是按照执行的level等级，将模块的初始化函数指针地址，分别放到相对应level等级的section中的；</p>
<p>initcall_t是一个函数指针类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">initcall_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/init.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __define_initcall(fn, id) \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">initcall_t</span> __initcall_#<span class="meta">#fn##id __used \</span></span><br><span class="line">    __attribute__((__section__(<span class="string">".initcall"</span> #id <span class="string">".init"</span>))) = fn;</span><br></pre></td></tr></table></figure>


<p>__attribute__((__section__())) 表示把对象放在这个由括号中的名称所指代的section中；</p>
<p>__define_initcall()宏的含义是：</p>
<blockquote>
<ol>
<li>声明一个名称为__initcall_##fn的函数指针（其中##表示将两边的变量连接为一个变量）；</li>
<li>将这个函数指针初始化为fn；</li>
<li>编译时，要将这个函数指针变量放到名称为”.initcall” #id “.init”的section中；（比如：level=”2”，表示这个section的名称为”.initcall2.init”）</li>
</ol>
</blockquote>
<blockquote>
<p>举例：</p>
<pre><code>\_\_define\_initcall(6, pci\_init)</code></pre><p>含义：</p>
<ol>
<li>声明一个函数指针，并赋值：__initcall_pci_init = pci_init；</li>
<li><ol start="2">
<li>编译时要将函数指针变量__initcall_pci_init放到名称为initcall6.init的section中；（其实就是将pci_init函数的首地址放到名称为initcall6.init的section中）</li>
</ol>
</li>
</ol>
</blockquote>
<p>__define_initcall()宏并不会直接使用，而是被定义为其他的宏定义形式使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/init.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pure_initcall(fn)       __define_initcall(fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn)       __define_initcall(fn, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn)      __define_initcall(fn, 1s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn)       __define_initcall(fn, 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn)  __define_initcall(fn, 2s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn)       __define_initcall(fn, 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall_sync(fn)      __define_initcall(fn, 3s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn)     __define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn)    __define_initcall(fn, 4s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn)         __define_initcall(fn, 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn)        __define_initcall(fn, 5s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn)     __define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn)     __define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn)    __define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn)       __define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn)      __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>


<p>通过core_initcall()来声明的函数指针，将被放到名为.initcall1.init的section中；通过postcore_initcall()来声明的函数指针，将被放到名为.initcall2.init的section中；以此类推；</p>
<blockquote>
<p>举例：</p>
<pre><code>device_initcall(pci_init);</code></pre><p>含义：</p>
<ol>
<li>声明一个函数指针，并赋值：__initcall_pci_init = pci_init；</li>
<li>编译时要将函数指针变量__initcall_pci_init放到名称为initcall6.init的section中；（其实就是将pci_init函数的首地址放到名称为initcall6.init的section中）</li>
</ol>
</blockquote>
<p>在编译生成的vmlinux.lds文件中，可以找到initcall相关的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmp/bsp/DBG/BOARDLX2160LE/ARMQORIQLE/kernel/kernels/linux-4.9.115-cgel/arch/arm64/kernel/vmlinux.lds</span></span><br><span class="line">  __initcall_start = .; KEEP(*(.initcallearly.init))</span><br><span class="line">  __initcall0_start = .; KEEP(*(.initcall0.init)) KEEP(*(.initcall0s.init))</span><br><span class="line">  __initcall1_start = .; KEEP(*(.initcall1.init)) KEEP(*(.initcall1s.init))</span><br><span class="line">  __initcall2_start = .; KEEP(*(.initcall2.init)) KEEP(*(.initcall2s.init))</span><br><span class="line">  __initcall3_start = .; KEEP(*(.initcall3.init)) KEEP(*(.initcall3s.init))</span><br><span class="line">  __initcall4_start = .; KEEP(*(.initcall4.init)) KEEP(*(.initcall4s.init))</span><br><span class="line">  __initcall5_start = .; KEEP(*(.initcall5.init)) KEEP(*(.initcall5s.init))</span><br><span class="line">  __initcallrootfs_start = .; KEEP(*(.initcallrootfs.init)) KEEP(*(.init     callrootfss.init))</span><br><span class="line">  __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init))</span><br><span class="line">  __initcall7_start = .; KEEP(*(.initcall7.init)) KEEP(*(.initcall7s.init))</span><br><span class="line">  __initcall_end = .;</span><br></pre></td></tr></table></figure>


<p>在这些section中，总的开始位置被标识为__initcall_start，而在结尾被标识为__initcall_end；</p>
<p>do_initcalls()函数，会从这些section中依次取出所有的函数指针，并按顺序调用这些函数指针调用的函数，来分别完成内核中驱动模块的初始化操作；</p>
<p>函数指针被放到哪个section中，是由宏定义__define_initcall(fn, id)的参数id，也就是level决定的，对应level更小的子section的位置更靠前；而位于同一个子section中的函数指针顺序不定，由编译器按照编译顺序随机决定；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">initcall_t</span> *initcall_levels[] __initdata = &#123;</span><br><span class="line">    __initcall0_start,</span><br><span class="line">    __initcall1_start,</span><br><span class="line">    __initcall2_start,</span><br><span class="line">    __initcall3_start,</span><br><span class="line">    __initcall4_start,</span><br><span class="line">    __initcall5_start,</span><br><span class="line">    __initcall6_start,</span><br><span class="line">    __initcall7_start,</span><br><span class="line">    __initcall_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h5 id="3-6-3-ramdisk-execute-command"><a href="#3-6-3-ramdisk-execute-command" class="headerlink" title="3.6.3 ramdisk_execute_command"></a>3.6.3 ramdisk_execute_command</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line">	<span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">        ramdisk_execute_command = <span class="string">"/init"</span>;</span><br></pre></td></tr></table></figure>


<p>kernel_init_freeable()函数会去判断ramdisk_execute_command是否为空，如果不为空，就直接运行ramdisk_execute_command指定的程序；ramdisk_execute_command的取值分以下情况：</p>
<blockquote>
<ol>
<li>如果命令行参数中指定了“rdinit=…”，则ramdisk_execute_command等于这个参数指定的程序；</li>
<li>否则，如果/init程序存在，ramdisk_execute_command=/init；</li>
<li>否则，ramdisk_execute_command为空；</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="keyword">if</span> (sys_access((<span class="keyword">const</span> <span class="keyword">char</span> __user *) ramdisk_execute_command, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ramdisk_execute_command = <span class="literal">NULL</span>;</span><br><span class="line">    prepare_namespace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="3-7-free-initmem"><a href="#3-7-free-initmem" class="headerlink" title="3.7 free_initmem"></a>3.7 free_initmem</h4><p>free_initmem()函数用来释放所有init.段中的内存；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/mm/init.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_initmem</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_reserved_area(__va(__pa(__init_begin)), __va(__pa(__init_end)),</span><br><span class="line">               <span class="number">0</span>, <span class="string">"unused kernel"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Unmap the __init region but leave the VM area in place. This</span></span><br><span class="line"><span class="comment">     * prevents the region from being reused for kernel modules, which</span></span><br><span class="line"><span class="comment">     * is not supported by kallsyms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unmap_kernel_range((u64)__init_begin, (u64)(__init_end - __init_egin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="3-8-启动用户态init进程"><a href="#3-8-启动用户态init进程" class="headerlink" title="3.8 启动用户态init进程"></a>3.8 启动用户态init进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/init/main.c</span></span><br><span class="line">kernel_init()</span><br><span class="line">    <span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">        ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pr_err(<span class="string">"Failed to execute %s (error %d)\n"</span>,</span><br><span class="line">               ramdisk_execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">        ret = run_init_process(execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        panic(<span class="string">"Requested init %s failed (error %d)."</span>,</span><br><span class="line">              execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">"/etc/init"</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">"/bin/init"</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">"/bin/sh"</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = run_init_process(init_filename);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line">    <span class="keyword">return</span> do_execve(getname_kernel(init_filename),</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)argv_init,</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在大多数系统中，bootloader会传递参数给内核的main函数，而这些参数中会包含init=/linuxrc参数，于是在kernel_init进程中，如果有execute_command = “linuxrc”，在经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行，通过do_execve()函数进入用户态，开始文件系统的初始化init进程；</p>
<p>如果boot没有传递init=/linuxrc参数给内核，ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">panic(<span class="string">"No working init found.  Try passing init= option to kernel. "</span></span><br><span class="line">          <span class="string">"See Linux Documentation/init.txt for guidance."</span>);</span><br></pre></td></tr></table></figure>


<p>出现这种异常错误，可能是以下几个原因造成：</p>
<blockquote>
<ol>
<li>启动参数配置错误，指定了init，但是未找到；</li>
<li>文件系统挂载出错；</li>
<li>四个应用程序找不到，或者没有可执行权限；</li>
</ol>
</blockquote>
<p>到此，Linux内核部分启动结束，下一步会在文件系统中启动用户空间的init进程，并进行下一步的启动操作；</p>
<h3 id="4-filesystem启动"><a href="#4-filesystem启动" class="headerlink" title="4. filesystem启动"></a>4. filesystem启动</h3><pre class="mermaid">graph LR
    kernel_init("kernel_init()")--"init=linuxrc"-->linuxrc(linuxrc)
    --链接-->busybox("/bin/busybox")
    kernel_init("kernel_init()")--default-->init("/sbin/init")
    --链接-->busybox("/bin/busybox")
    --inittab-->rcS("/etc/init.d/rcS")</pre>


<h4 id="4-1-filesystem构建"><a href="#4-1-filesystem构建" class="headerlink" title="4.1 filesystem构建"></a>4.1 filesystem构建</h4><p>文件系统可以通过busybox工具来构建；构建成功之后，一般情况下是不需要修改的；我们使用的文件系统，由成研提供；具体的构建方法此处先省略，有时间再补上；</p>
<h4 id="4-2-busybox程序"><a href="#4-2-busybox程序" class="headerlink" title="4.2 busybox程序"></a>4.2 busybox程序</h4><p>在Kernel挂载文件系统后，通过kernel_init()函数，准备运行init进程；</p>
<p>在kernel/init/main.c文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/init/main.c</span></span><br><span class="line">kernel_init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">        ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pr_err(<span class="string">"Failed to execute %s (error %d)\n"</span>,</span><br><span class="line">               ramdisk_execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">        ret = run_init_process(execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        panic(<span class="string">"Requested init %s failed (error %d)."</span>,</span><br><span class="line">              execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">"/etc/init"</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">"/bin/init"</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">"/bin/sh"</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>经过run_init_process()函数的解析之后，得到需要运行的linuxrc，于是linuxrc程序在run_init_process()函数中被执行；而linuxrc文件是一个指向/bin/busybox的链接，也就是说，系统启动后运行的第一个程序是/bin/busybox；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls linuxrc -l</span></span><br><span class="line">lrwxrwxrwx 1 root root 11 Mar  4 10:04 linuxrc -&gt; bin/busybox</span><br></pre></td></tr></table></figure>


<p>如果ramdisk_execute_command和execute_command都为空，则开始按顺序执行/sbin/init、/etc/init、/bin/init、/bin/sh程序，只要有一个可以执行，系统就能够继续运行；而/sbin/init文件也是链接到/bin/busybox的，最终还是会执行/bin/busybox程序；创建用户空间运行的第一个进程；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /sbin/init -l</span></span><br><span class="line">lrwxrwxrwx    1 root     root            14 Dec 12  2019 /sbin/init -&gt; ../bin/busybox</span><br></pre></td></tr></table></figure>




<h4 id="4-3-init进程"><a href="#4-3-init进程" class="headerlink" title="4.3 init进程"></a>4.3 init进程</h4><p>busybox程序运行，会启动init进程，init进程在Linux系统中是最早运行的进程，也就是1号进程；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps -aux | grep init</span></span><br><span class="line">root         1  0.8  0.0   2080    12 ?        Ss   18:47   0:20 init</span><br></pre></td></tr></table></figure>




<p>init进程进行的工作：</p>
<blockquote>
<ol>
<li>为init设置信号处理过程</li>
<li>初始化控制台</li>
<li>解析/etc/inittab文件</li>
<li>执行系统初始化命令，一般情况下会使用/etc/init.d/rcS</li>
<li>执行所有导致init暂停的inittab命令（动作类型：wait）</li>
<li>执行所有仅执行一次的inittab命令（动作类型：once）</li>
</ol>
</blockquote>
<p>执行完以上工作后，init进程会循环执行以下进程：</p>
<blockquote>
<p>1.执行所有终止时必须重新启动的inittab命令（动作类型：respawn）</p>
<p>2.执行所有终止时必须重新启动但启动前必须询问用户的inittab命令（动作类型：askfirst）</p>
</blockquote>
<h4 id="4-4-inittab"><a href="#4-4-inittab" class="headerlink" title="4.4 inittab"></a>4.4 inittab</h4><p>busybox程序解析/etc/inittab文件，而/etc/inittab是进行初始化的配置文件；busybox运行时会按照格式解析inittab文件，根据解析内容决定具体工作；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/inittab</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta">#</span><span class="bash">::once:/bin/sw &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">The followed sentence does<span class="string">'t need password.</span></span></span><br><span class="line">::respawn:-/bin/ash</span><br><span class="line"><span class="meta">#</span><span class="bash">The followed sentence does need password.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">::respawn:-/bin/login</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tty2::askfirst:-/bin/ash</span></span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure>




<p>inittab的内容以行为单位，行与行之间没有关联，每行都是一个独立的配置项；每一行的配置项都是由3个冒号分隔开的4个配置值组成，冒号是分隔符，分隔开各个部分；</p>
<p>inittab文件里的代码格式：</p>
<p>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</p>
<p>说明：</p>
<blockquote>
<p>id：/dev/id，用作终端terminal：stdin、stdout、stderr、printf、scanf、err</p>
<p>runlevels：</p>
<p>action：执行时机；包括：sysinit、respawd、askfirst、wait、once、restart、ctrialtdel、shutdown</p>
<p>process：应用程序和脚本</p>
</blockquote>
<h4 id="4-5-rcS"><a href="#4-5-rcS" class="headerlink" title="4.5 rcS"></a>4.5 rcS</h4><p>在/etc/inittab配置文件中，action为sysinit的行，表示在Linux系统初始化文件系统时执行的第一个脚本，即：/etc/init.d/rcS；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br></pre></td></tr></table></figure>


<p>主要进行一些初始化工作：启动交换分区、检查磁盘、设置主机名、检查并挂载文件系统、加载并初始化硬件模块等；</p>
<p>/etc/init.d/rcS文件是Linux运行时非常重要的一个脚本程序；其他的配置在rcS文件中进行，rcS文件中的配置可以根据需求进行扩展；/etc/init.d/rcS完成各个文件系统的挂载（mount），以及文件硬件模块的初始化；</p>
<h3 id="5-应用进程启动"><a href="#5-应用进程启动" class="headerlink" title="5. 应用进程启动"></a>5. 应用进程启动</h3><p>应用进程，可以在文件系统的/etc/init.d/rcS脚本运行时，调用xxx.sh脚本拉起来的；</p>
<p><a href="#目录">跳转到目录</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kernel/" rel="tag"># Kernel</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/19/u-boot%E5%BC%95%E5%AF%BCkernel%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" rel="prev" title="u-boot引导kernel启动过程">
      <i class="fa fa-chevron-left"></i> u-boot引导kernel启动过程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/" rel="next" title="Linux-kernel中I2C的master_xfer驱动实现----基于imx6">
      Linux-kernel中I2C的master_xfer驱动实现----基于imx6 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-简述"><span class="nav-text">0. 简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-目标文件"><span class="nav-text">1. 目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-vmlinux-lds"><span class="nav-text">1.1 vmlinux.lds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-内核映像"><span class="nav-text">1.2 内核映像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-设备树文件"><span class="nav-text">1.3 设备树文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内核启动第一阶段"><span class="nav-text">2. 内核启动第一阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-内核启动入口点"><span class="nav-text">2.1 内核启动入口点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-stext函数"><span class="nav-text">2.2 stext函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-preserve-boot-args"><span class="nav-text">1. preserve_boot_args</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-el2-setup"><span class="nav-text">2. el2_setup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-set-cpu-boot-mode-flag"><span class="nav-text">3. set_cpu_boot_mode_flag</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-create-page-tables"><span class="nav-text">4. __create_page_tables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-cpu-setup"><span class="nav-text">5. __cpu_setup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-primary-switch"><span class="nav-text">6. __primary_switch</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-参考资料"><span class="nav-text">2.3 参考资料</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-内核启动第二阶段"><span class="nav-text">3. 内核启动第二阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-start-kernel"><span class="nav-text">3.1 start_kernel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-setup-arch"><span class="nav-text">3.2 setup_arch</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-setup-machine-fdt"><span class="nav-text">1. setup_machine_fdt</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-unflatten-device-tree"><span class="nav-text">2. unflatten_device_tree</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-console-init"><span class="nav-text">3.3 console_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-rest-init"><span class="nav-text">3.4 rest_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-kernel-init"><span class="nav-text">3.5 kernel_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-kernel-init-freeable"><span class="nav-text">3.6 kernel_init_freeable</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-1-wait-for-completion"><span class="nav-text">3.6.1 wait_for_completion</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-2-do-basic-setup"><span class="nav-text">3.6.2 do_basic_setup</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-driver-init"><span class="nav-text">2. driver_init</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-do-initcalls"><span class="nav-text">3. do_initcalls</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-3-ramdisk-execute-command"><span class="nav-text">3.6.3 ramdisk_execute_command</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-free-initmem"><span class="nav-text">3.7 free_initmem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-启动用户态init进程"><span class="nav-text">3.8 启动用户态init进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-filesystem启动"><span class="nav-text">4. filesystem启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-filesystem构建"><span class="nav-text">4.1 filesystem构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-busybox程序"><span class="nav-text">4.2 busybox程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-init进程"><span class="nav-text">4.3 init进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-inittab"><span class="nav-text">4.4 inittab</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-rcS"><span class="nav-text">4.5 rcS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-应用进程启动"><span class="nav-text">5. 应用进程启动</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">micro虾米</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">micro虾米</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '1ec7eee73ee4f91e15a1',
      clientSecret: '971b3c9439c2a8fa2fcb12307657ad50aee6ed0c',
      repo        : 'mshrimp_blog_talk',
      owner       : 'mshrimp',
      admin       : ['mshrimp'],
      id          : '1f2c6f344c3601eb99247271058140b2',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
