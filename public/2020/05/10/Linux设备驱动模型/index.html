<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mshrimp.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="未完成 Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux设备驱动模型">
<meta property="og:url" content="http://mshrimp.github.io/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Mshrimp blog">
<meta property="og:description" content="未完成 Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；">
<meta property="og:image" content="http://mshrimp.github.io/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.PNG">
<meta property="og:image" content="http://mshrimp.github.io/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/bus_register%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8Cbus1%E6%80%BB%E7%BA%BF%E6%97%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.PNG">
<meta property="article:published_time" content="2020-05-10T13:31:28.000Z">
<meta property="article:modified_time" content="2020-05-16T14:10:44.610Z">
<meta property="article:author" content="micro虾米">
<meta property="article:tag" content="Driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mshrimp.github.io/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.PNG">

<link rel="canonical" href="http://mshrimp.github.io/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>Linux设备驱动模型 | Mshrimp blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mshrimp blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">micro虾米</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://mshrimp.github.io/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="micro虾米">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mshrimp blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux设备驱动模型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-10 21:31:28" itemprop="dateCreated datePublished" datetime="2020-05-10T21:31:28+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-16 22:10:44" itemprop="dateModified" datetime="2020-05-16T22:10:44+08:00">2020-05-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>未完成</p>
<p>Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；</p>
<a id="more"></a>




<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>[TOC]</p>
<h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><p>Linux设备驱动模型，由总线（bus）、设备（device）、驱动（driver）三部分组成；总线是处理器与设备之间的通道，在设备模型中，所有的设备都通过总线相连；总线作为Linux设备驱动模型的核心架构，系统中的设备和驱动都挂接在相应的总线上，来完成各自的工作；</p>
<p>Linux设备驱动模型中的总线，既可以是实际物理总线的抽象（如：PCI总线、I2C总线、USB总线），也可以是虚拟总线，一个符合Linux设备驱动模型的设备和驱动都必须挂接在一根总线上，无论是实际存在的总线还是系统模拟的总线；</p>
<p>Linux设备模型中，最底层每一个设备都用一个device结构的实例来表示；而驱动是使总线上的设备能够完成一些功能；系统中有很多种总线，如：PCI总线、I2C总线、USB总线、scsi总线等；</p>
<pre class="mermaid">graph LR
    driver_init(driver_init)-->
    buses_init(buses_init)</pre>


<p>buses_init()函数在sysfs文件系统的根目录下建立一个bus目录，即/sys/bus，是系统中后续注册总线的连接点；</p>
<p>Linux设备模型中一组很重要的概念：总线、设备、驱动，即：bus、device、driver；分别对应数据结构struct bus_type，struct device，struct device_driver；</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>对应的数据结构</th>
<th>代码文件</th>
</tr>
</thead>
<tbody><tr>
<td>总线</td>
<td>bus</td>
<td>struct bus_type</td>
<td>drivers/base/bus.c</td>
</tr>
<tr>
<td>设备</td>
<td>device</td>
<td>struct device</td>
<td>drivers/base/core.c</td>
</tr>
<tr>
<td>驱动</td>
<td>driver</td>
<td>struct device_driver</td>
<td>drivers/base/driver.c</td>
</tr>
</tbody></table>
<pre class="mermaid">graph TB
    Bus(bus)-->Device(device)
    Bus-->Driver(device_driver)</pre>


<p>Linux设备驱动模型中，总线、设备、驱动都有对于的属性信息；</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>属性数据结构</th>
<th>设置属性方法</th>
</tr>
</thead>
<tbody><tr>
<td>bus</td>
<td>bus_attribute</td>
<td>BUS_ATTR()</td>
</tr>
<tr>
<td>device</td>
<td>device_attribute</td>
<td>DEVICE_ATTR()</td>
</tr>
<tr>
<td>driver</td>
<td>driver_attribute</td>
<td>手动设置driver_attribute</td>
</tr>
</tbody></table>
<p>Linux系统在启动时的初始化阶段，通过在driver_init()中调用buses_init()函数，完成所有总线的最初操作，创建出bus的祖先；</p>
<pre class="mermaid">graph TB
    driver_init(driver_init)
    -->buses_init(buses_init)</pre>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">bus_kset</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">buses_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_kset = kset_create_and_add(<span class="string">"bus"</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    system_kset = kset_create_and_add(<span class="string">"system"</span>, <span class="literal">NULL</span>, &amp;devices_kset-&gt;kobj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>buses_init()函数创建一个名为”bus”的kset，并将其加入到sysfs文件系统树中，在sysfs中的根目录创建bus，即/sys/bus目录；</p>
<h4 id="1-总线-bus"><a href="#1-总线-bus" class="headerlink" title="1. 总线(bus)"></a>1. 总线(bus)</h4><p>内核用struct bus_type结构体来描述总线信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;	<span class="comment">// 总线名称，在/sys/bus下出现</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *dev_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">remove</span>)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct device *dev);</span><br><span class="line">	......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span>	<span class="comment">// 用来管理bus中设备和驱动关系的结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<p>总线用struct subsys_private结构体来管理总线中设备和驱动的关系；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drivers/base/base.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>		<span class="comment">// 表示bus所在的子系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span>		<span class="comment">// 表示bus上所有设备的集合</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>		<span class="comment">// 表示bus上所有驱动的集合</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span>		<span class="comment">// 表示bus上所有设备的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span>		<span class="comment">// 表示bus上所有驱动的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>struct kset subsys：表示bus所在的子系统</p>
<p>unsigned int drivers_autoprobe:1  表示向系统总线中注册设备或驱动时，是否进行设备和驱动的绑定操作；</p>
<p>struct kset *devices_kset和struct kset *drivers_kset分别表示bus上所有设备和驱动的集合；是在向系统注册当前新总线时动态生成的容纳该总线上所有驱动和设备的kset；</p>
<p>struct klist klist_devices和struct klist klist_drivers分别表示该总线上所有设备和驱动的链表；两个klist成员以链表的形式将该总线上所有的驱动与设备链接到一起；总线、设备、驱动的关系如下图所示：</p>
<p><img src="/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.PNG" alt="总线设备驱动之间的关系"></p>
<h5 id="1-1-总线的注册"><a href="#1-1-总线的注册" class="headerlink" title="1.1 总线的注册"></a>1.1 总线的注册</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span>;</span><br></pre></td></tr></table></figure>


<p>bus_register()函数用来注册一个bus总线子系统，可能会失败，必须检查返回值；注册成功后，可以在/sys/bus/目录下看到该总线；之后就可以向总线中添加设备了；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">    priv-&gt;bus = bus;</span><br><span class="line">    bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">"%s"</span>, bus-&gt;name);	<span class="comment">// 为bus设定名字</span></span><br><span class="line"></span><br><span class="line">    priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">    priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line">    retval = kset_register(&amp;priv-&gt;subsys);	<span class="comment">// 在/sys/bus目录下为当前注册的bus生成目录</span></span><br><span class="line"></span><br><span class="line">    retval = bus_create_file(bus, &amp;bus_attr_uevent);	<span class="comment">// 生成bus的属性文件</span></span><br><span class="line">    priv-&gt;devices_kset = kset_create_and_add(<span class="string">"devices"</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);	<span class="comment">// 为bus生成容纳设备的kset容器</span></span><br><span class="line">    priv-&gt;drivers_kset = kset_create_and_add(<span class="string">"drivers"</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);	<span class="comment">// // 为bus生成容纳驱动的kset容器</span></span><br><span class="line"></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">    klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	<span class="comment">// 初始化bus上的设备和驱动链表</span></span><br><span class="line"></span><br><span class="line">    retval = add_probe_files(bus);	<span class="comment">// 为bus增加probe相关的属性文件</span></span><br><span class="line">    retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>


<p>bus_register()函数，分配一个subsys_private结构体，通过kobject_set_name()函数为bus所在的内核对象设定名称，该名称在sysfs文件系统树中显示，再完成对subsys_private结构体成员参数的初始化操作，同时在创建了devices和drivers两个属性文件夹，/sys/bus/devices和/sys/bus/drivers；</p>
<p>kset_register()函数将当前操作的bus所对应的kset加入到sysfs文件系统树中；</p>
<p>bus_create_file()函数为bus创建一个属性文件；</p>
<p>kset_create_and_add()函数生成一个kset对象，并将其加入到sysfs文件系统树中；parent参数为&amp;priv-&gt;subsys.kobj，将在当前正在向系统注册的新bus目录下生成两个kset目录，对应新bus的devices和drivers，即/sys/bus/bus_name/devices和/sys/bus/bus_name/drivers；</p>
<p>举例：通过bus_register()函数注册一个新的bus1总线，如下图所示：</p>
<p><img src="/2020/05/10/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/bus_register%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8Cbus1%E6%80%BB%E7%BA%BF%E6%97%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.PNG" alt="bus_register函数注册bus1总线时的层次关系"></p>
<p>图中虚线部分，是将bus1总线通过bus_register()函数注册进系统时的层次结构：</p>
<p>首先生成一个表示bus1的kset对象，并加入到sysfs文件系统中，该kset的parent内核对象为buses_init()函数中产生的bus_kset；</p>
<p>其次，bus_register()函数，通过kset_create_and_add()函数，生成连接到bus1总线上的devices_kset和drivers_kset的集合，对应在sysfs系统中，会在/sys/bus/bus1目录下生成devices和drivers两个目录；</p>
<p>最后，bus_register()函数，通过bus_create_file()函数，为bus1总线在/sys/bus/bus1目录下生成一些属性文件；</p>
<p>属性文件实际上向用户空间提供了一些接口，用户程序可以通过这些属性文件获取或者设置属性内核对象的属性；</p>
<h5 id="1-2-总线的注销"><a href="#1-2-总线的注销" class="headerlink" title="1.2 总线的注销"></a>1.2 总线的注销</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_unregister</span><span class="params">(struct bus_type *bus)</span></span>;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_unregister</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_debug(<span class="string">"bus: '%s': unregistering\n"</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (bus-&gt;dev_root)</span><br><span class="line">        device_unregister(bus-&gt;dev_root);</span><br><span class="line">    bus_remove_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">    remove_probe_files(bus);</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">    bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">    kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_unregister);</span><br></pre></td></tr></table></figure>






<h5 id="1-3-总线方法"><a href="#1-3-总线方法" class="headerlink" title="1.3 总线方法"></a>1.3 总线方法</h5><p>在struct bus_type结构体中定义了一些方法；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br></pre></td></tr></table></figure>


<p>match方法：当总线上添加新设备或新驱动程序时，会多次调用match方法，将device和device_driver进行匹配，如果匹配成功，说明指定的驱动程序能够处理指定的设备，match方法返回非零值；</p>
<p>创建一个名为ldd的虚拟总线为例；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">ldd_bus_type</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"ldd"</span>,</span><br><span class="line">    .match = ldd_match,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = bus_register(&amp;ldd_bus_type);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    printk(<span class="string">"%s, bus_register failed\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus_unregister(&amp;ldd_bus_type);</span><br></pre></td></tr></table></figure>








<p>在lddbus中添加一个简单的match方法，只是简单地比较设备和驱动程序的名字；在真实的总线驱动中，match方法可能会进行更加复杂的比较；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(dev-&gt;kobj.name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<p>验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># lsmod</span></span><br><span class="line">ldd_bus <span class="number">16384</span> <span class="number">0</span> - Live <span class="number">0xffff000000c90000</span> (O)</span><br></pre></td></tr></table></figure>






<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls /sys/bus/ldd/</span></span><br><span class="line">devices            drivers_autoprobe  uevent</span><br><span class="line">drivers            drivers_probe</span><br></pre></td></tr></table></figure>








<h5 id="1-4-总线属性"><a href="#1-4-总线属性" class="headerlink" title="1.4 总线属性"></a>1.4 总线属性</h5><p>总线属性表示该总线的特有信息和配置，通过sysfs文件系统为总线生成属性文件，用户空间可以通过该属性文件接口，获取或者设置总线的属性；</p>
<p>总线属性用struct bus_attribute结构体表示；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct bus_type *bus, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct bus_type *bus, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>show和store用来获取和设置总线的属性信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sysfs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;</span><br><span class="line">    <span class="keyword">umode_t</span>         mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>为总线定义属性可以使用BUS_ATTR()宏定义；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR(_name, _mode, _show, _store)   \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> <span class="title">bus_attr_</span>##_<span class="title">name</span> = __<span class="title">ATTR</span>(_<span class="title">name</span>, _<span class="title">mode</span>, _<span class="title">show</span>, _<span class="title">store</span>)</span></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sysfs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ATTR(_name, _mode, _show, _store) &#123;               \</span></span><br><span class="line">    .attr = &#123;.name = __stringify(_name),                \</span><br><span class="line">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \</span><br><span class="line">    .show   = _show,                        \</span><br><span class="line">    .store  = _store,                       \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>BUS_ATTR()宏，定义一个以bus_attr_开头的总线属性，生成总线属性文件需要使用bus_create_file()函数来完成；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_create_file</span><span class="params">(struct bus_type *bus, struct bus_attribute *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus_get(bus)) &#123;</span><br><span class="line">        error = sysfs_create_file(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr);</span><br><span class="line">        bus_put(bus);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        error = -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_create_file);</span><br></pre></td></tr></table></figure>










<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BUS_ATTR</span><span class="params">(drivers_autoprobe, S_IWUSR | S_IRUGO,</span></span></span><br><span class="line"><span class="function"><span class="params">        show_drivers_autoprobe, store_drivers_autoprobe)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">show_drivers_autoprobe</span><span class="params">(struct bus_type *bus, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%d\n"</span>, bus-&gt;p-&gt;drivers_autoprobe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">store_drivers_autoprobe</span><span class="params">(struct bus_type *bus,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">        bus-&gt;p-&gt;drivers_autoprobe = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bus-&gt;p-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<p>自己实现一个属性文件如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">ldd_show_bus_version</span><span class="params">(struct bus_type *bus, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, PAGE_SIZE, <span class="string">"%s\n"</span>, VERSION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUS_ATTR(version, S_IRUGO, ldd_show_bus_version, <span class="literal">NULL</span>);</span><br><span class="line">ret = bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br></pre></td></tr></table></figure>


<p>之后可以看到/sys/bus/ldd/version属性；</p>
<h4 id="2-设备-device"><a href="#2-设备-device" class="headerlink" title="2. 设备(device)"></a>2. 设备(device)</h4><p>设备代表真实的具体的物理器件，</p>
<p>总线实际上也是一个设备，因此也要以设备形式被单独注册；这个ldd总线是一个顶层总线，因此parent和bus成员是NULL，总线名字是ldd；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>       *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>   *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>       <span class="comment">/* type of bus device is on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>   <span class="comment">/* which driver has allocated this device */</span></span><br><span class="line">    <span class="keyword">void</span>        *driver_data;   <span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">                       dev_set/get_drvdata */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>  *<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line">    <span class="keyword">void</span>    (*<span class="built_in">release</span>)(struct device *dev);</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h5 id="2-1-设备注册"><a href="#2-1-设备注册" class="headerlink" title="2.1 设备注册"></a>2.1 设备注册</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_initialize(dev);		<span class="comment">// 初始化device</span></span><br><span class="line">    <span class="keyword">return</span> device_add(dev);		<span class="comment">// 将device添加到系统中</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>


<p>device_register()函数用来注册设备，可能会失败，必须检查返回值；注册成功后，可以在/sys/devices目录下看到该设备；以后添加到改总线上的任何设备都可以在/sys/devices/ldd目录下显示；</p>
<p>创建一个名为ldd的设备为例；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">ldd_bus_dev</span> = &#123;</span></span><br><span class="line">    .init_name = <span class="string">"ldd"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = device_register(&amp;ldd_bus_dev);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    printk(<span class="string">"%s, device_register failed\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="2-2-设备注销"><a href="#2-2-设备注销" class="headerlink" title="2.2 设备注销"></a>2.2 设备注销</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_unregister</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_debug(<span class="string">"device: '%s': %s\n"</span>, dev_name(dev), __func__);</span><br><span class="line">    device_del(dev);	<span class="comment">// 从子系统中删除</span></span><br><span class="line">    put_device(dev);	<span class="comment">// 减少引用计数</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_unregister);</span><br></pre></td></tr></table></figure>


<p>用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_unregister(&amp;ldd_bus_dev);</span><br></pre></td></tr></table></figure>




<h5 id="2-3-设备属性"><a href="#2-3-设备属性" class="headerlink" title="2.3 设备属性"></a>2.3 设备属性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> <span class="title">dev_attr_</span>##_<span class="title">name</span> = __<span class="title">ATTR</span>(_<span class="title">name</span>, _<span class="title">mode</span>, _<span class="title">show</span>, _<span class="title">store</span>)</span></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sysfs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ATTR(_name, _mode, _show, _store) &#123;               \</span></span><br><span class="line">    .attr = &#123;.name = __stringify(_name),                \</span><br><span class="line">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \</span><br><span class="line">    .show   = _show,                        \</span><br><span class="line">    .store  = _store,                       \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_create_file</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> struct device_attribute *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_remove_file</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> struct device_attribute *attr)</span></span>;</span><br></pre></td></tr></table></figure>






<h5 id="2-4-设备结构的封装"><a href="#2-4-设备结构的封装" class="headerlink" title="2.4 设备结构的封装"></a>2.4 设备结构的封装</h5><p>在device结构体中已经包含了设备模型核心，用来模拟系统的信息；对于大多数系统来说，还需要包含一些系统其它的信息，因此需要对封装一个ldd_device，包含device结构体以及其它一些重要的信息；在ldd总线的每一个设备都需要使用ldd_device结构体来抽象；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldd_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldd_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))</span></span><br></pre></td></tr></table></figure>


<p>ldd_device结构体可以作为ldd总线上设备的一个抽象，包含一个device结构体，一个指向驱动程序的结构体指针；还可以根据需要添加信息，如：供应商信息、设备模型、设备配置、使用的资源等；</p>
<p>to_ldd_device()宏定义，用来方便地用device结构体找到ldd_device结构体；</p>
<p>ldd总线下的设备注册功能可以使用以下封装的ldd_device_register()函数来实现；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_device_register</span><span class="params">(struct ldd_device *ldddev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ldddev-&gt;dev.bus = &amp;ldd_bus_type;</span><br><span class="line">    ldddev-&gt;dev.parent = &amp;ldd_bus;</span><br><span class="line">    ldddev-&gt;dev.<span class="built_in">release</span> = ldd_dev_release;</span><br><span class="line">    <span class="built_in">strncpy</span>(ldddev-&gt;dev.kobj.name, ldddev-&gt;name, <span class="built_in">strlen</span>(ldddev-&gt;name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> device_register(&amp;ldddev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ldd_device_register);</span><br></pre></td></tr></table></figure>


<p>ldd_device_register()函数简单地初始化了ldd_device结构体中的device结构体成员，并向驱动程序核心注册该device结构体设备；</p>
<h5 id="2-5-举例"><a href="#2-5-举例" class="headerlink" title="2.5 举例"></a>2.5 举例</h5><h4 id="3-设备驱动-device-driver"><a href="#3-设备驱动-device-driver" class="headerlink" title="3. 设备驱动(device_driver)"></a>3. 设备驱动(device_driver)</h4><p>设备驱动用device_driver结构体来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;	<span class="comment">// 驱动程序的名字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>     *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>   *<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">remove</span>) (struct device *dev);</span><br><span class="line">	......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>name：驱动程序的名字，会显示在sysfs中</p>
<p>bus：该驱动程序的总线类型</p>
<h5 id="3-1-设备驱动注册"><a href="#3-1-设备驱动注册" class="headerlink" title="3.1 设备驱动注册"></a>3.1 设备驱动注册</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/driver.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(struct device_driver *drv)</span></span>;</span><br></pre></td></tr></table></figure>




<h5 id="3-2-设备驱动注销"><a href="#3-2-设备驱动注销" class="headerlink" title="3.2 设备驱动注销"></a>3.2 设备驱动注销</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/driver.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_unregister</span><span class="params">(struct device_driver *drv)</span></span>;</span><br></pre></td></tr></table></figure>






<h5 id="3-3-设备驱动属性"><a href="#3-3-设备驱动属性" class="headerlink" title="3.3 设备驱动属性"></a>3.3 设备驱动属性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/device.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct device_driver *driver, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct device_driver *driver, <span class="keyword">const</span> <span class="keyword">char</span> *buf,</span><br><span class="line">             <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> <span class="title">driver_attr_</span>##_<span class="title">name</span> = __<span class="title">ATTR</span>(_<span class="title">name</span>, _<span class="title">mode</span>, _<span class="title">show</span>, _<span class="title">store</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// <span class="title">include</span>/<span class="title">linux</span>/<span class="title">sysfs</span>.<span class="title">h</span></span></span><br><span class="line"><span class="class">#<span class="title">define</span> __<span class="title">ATTR</span>(_<span class="title">name</span>, _<span class="title">mode</span>, _<span class="title">show</span>, _<span class="title">store</span>) &#123;</span>               \</span><br><span class="line">    .attr = &#123;.name = __stringify(_name),                \</span><br><span class="line">    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,     \</span><br><span class="line">    .show   = _show,                        \</span><br><span class="line">    .store  = _store,                       \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>属性文件的创建和删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/driver.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_create_file</span><span class="params">(struct device_driver *drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct driver_attribute *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_remove_file</span><span class="params">(struct device_driver *drv,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct driver_attribute *attr)</span></span>;</span><br></pre></td></tr></table></figure>




<h5 id="3-4-驱动程序结构的封装"><a href="#3-4-驱动程序结构的封装" class="headerlink" title="3.4 驱动程序结构的封装"></a>3.4 驱动程序结构的封装</h5><p>对于大多数驱动程序来说，device_driver结构通常被包含在高层和总线相关的结构中，因此对于ldd子系统需要定义一个ldd_driver结构，包含device_driver结构体和一些需要的信息；在ldd总线的每一个驱动都需要使用ldd_driver结构体来抽象；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldd_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *version;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> <span class="title">version_attr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))</span></span><br></pre></td></tr></table></figure>


<p>ldd_driver结构体可以作为ldd总线上设备驱动的一个抽象，包含一个device_driver结构体；还可以根据需要添加一些别的信息；</p>
<p>to_ldd_driver()宏定义，用来方便地用device_driver结构体找到ldd_driver结构体；</p>
<p>ldd总线下的设备驱动注册功能可以使用以下封装的ldd_driver_register()函数来实现；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_driver_register</span><span class="params">(struct ldd_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    driver-&gt;driver.bus = &amp;ldd_bus_type;</span><br><span class="line">    ret = driver_register(&amp;driver-&gt;driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, driver_register failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    driver-&gt;version_attr.attr.name = <span class="string">"version"</span>;</span><br><span class="line">    driver-&gt;version_attr.attr.mode = S_IRUGO;</span><br><span class="line">    driver-&gt;version_attr.show = show_version;</span><br><span class="line">    driver-&gt;version_attr.store = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ldd_driver_register);</span><br></pre></td></tr></table></figure>


<p>ldd_driver_register()函数简单地初始化了ldd_driver结构体中的device_driver结构体成员，并向驱动程序核心注册该device_driver结构体设备驱动，同时还设置了驱动的版本号属性信息；因为驱动的版本号信息是在系统运行时建立的，所以必须手动设置driver_attribute结构体，而不能使用DRIVER_ATTR()宏；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">show_version</span><span class="params">(struct device_driver *driver, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldd_driver</span> *<span class="title">ldd_drv</span> = <span class="title">to_ldd_driver</span>(<span class="title">driver</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%s\n"</span>, ldd_drv-&gt;version);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="3-5-举例"><a href="#3-5-举例" class="headerlink" title="3.5 举例"></a>3.5 举例</h5><h4 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h4><p>驱动工程师在驱动开发过程中，都是使用内核中已经封装好的总线，以及设备驱动模型接口，很少会需要添加一条总线，本节为了验证创建总线的过程，创建一条简单的总线ldd，用做测试；</p>
<h5 id="4-1-注册总线"><a href="#4-1-注册总线" class="headerlink" title="4.1 注册总线"></a>4.1 注册总线</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ret = bus_register(&amp;ldd_bus_type);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, bus_register failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, bus_create_file failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = device_register(&amp;ldd_bus_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, device_register failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ldd_bus_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_unregister(&amp;ldd_bus_dev);</span><br><span class="line">    bus_remove_file(&amp;ldd_bus_type, &amp;bus_attr_version);</span><br><span class="line">    bus_unregister(&amp;ldd_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ldd_bus_init);</span><br><span class="line">module_exit(ldd_bus_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>






<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">ldd_show_bus_version</span><span class="params">(struct bus_type *bus, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, PAGE_SIZE, <span class="string">"%s\n"</span>, VERSION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUS_ATTR(version, S_IRUGO, ldd_show_bus_version, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">ldd_bus_dev</span> = &#123;</span></span><br><span class="line">    .init_name = <span class="string">"ldd"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(dev-&gt;kobj.name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">ldd_bus_type</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"ldd"</span>,</span><br><span class="line">    .match = ldd_match,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(ldd_bus_type);</span><br></pre></td></tr></table></figure>




<h5 id="4-2-封装设备接口"><a href="#4-2-封装设备接口" class="headerlink" title="4.2 封装设备接口"></a>4.2 封装设备接口</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ldd_bus_release</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s, %d\n"</span>, __func__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">ldd_bus</span> = &#123;</span></span><br><span class="line">    .init_name = <span class="string">"ldd"</span>,</span><br><span class="line">    .<span class="built_in">release</span> = ldd_bus_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldd_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldd_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_ldd_device(dev)  (container_of((dev), struct ldd_device, dev))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ldd_dev_release</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s, %d\n"</span>, __func__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_device_register</span><span class="params">(struct ldd_device *ldddev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ldddev-&gt;dev.bus = &amp;ldd_bus_type;</span><br><span class="line">    ldddev-&gt;dev.parent = &amp;ldd_bus;</span><br><span class="line">    ldddev-&gt;dev.<span class="built_in">release</span> = ldd_dev_release;</span><br><span class="line">    <span class="built_in">strncpy</span>(ldddev-&gt;dev.kobj.name, ldddev-&gt;name, <span class="built_in">strlen</span>(ldddev-&gt;name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> device_register(&amp;ldddev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ldd_device_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================</span></span><br></pre></td></tr></table></figure>




<h5 id="4-3-封装驱动接口"><a href="#4-3-封装驱动接口" class="headerlink" title="4.3 封装驱动接口"></a>4.3 封装驱动接口</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldd_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *version;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> <span class="title">version_attr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_ldd_driver(drv)  (container_of((drv), struct ldd_driver, driver))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">show_version</span><span class="params">(struct device_driver *driver, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldd_driver</span> *<span class="title">ldd_drv</span> = <span class="title">to_ldd_driver</span>(<span class="title">driver</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%s\n"</span>, ldd_drv-&gt;version);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldd_driver_register</span><span class="params">(struct ldd_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    driver-&gt;driver.bus = &amp;ldd_bus_type;</span><br><span class="line">    ret = driver_register(&amp;driver-&gt;driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, driver_register failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    driver-&gt;version_attr.attr.name = <span class="string">"version"</span>;</span><br><span class="line">    <span class="comment">//driver-&gt;version_attr.attr.owner = driver-&gt;module;</span></span><br><span class="line">    driver-&gt;version_attr.attr.mode = S_IRUGO;</span><br><span class="line">    driver-&gt;version_attr.show = show_version;</span><br><span class="line">    driver-&gt;version_attr.store = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ldd_driver_register);</span><br></pre></td></tr></table></figure>






<h5 id="4-4-添加设备和驱动"><a href="#4-4-添加设备和驱动" class="headerlink" title="4.4 添加设备和驱动"></a>4.4 添加设备和驱动</h5><h5 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5 测试"></a>4.5 测试</h5><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><h4 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h4><p>《Linux设备驱动程序》</p>
<p>《深入Linux设备驱动程序内核机制》</p>
<p><a href="!目录">回到目录</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Driver/" rel="tag"># Driver</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/23/Linux-kernel%E4%B8%ADI2C%E7%9A%84master_xfer%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8Eimx6/" rel="prev" title="Linux-kernel中I2C的master_xfer驱动实现----基于imx6">
      <i class="fa fa-chevron-left"></i> Linux-kernel中I2C的master_xfer驱动实现----基于imx6
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/17/platform%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/" rel="next" title="platform总线设备驱动模型">
      platform总线设备驱动模型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#目录"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0-简介"><span class="nav-text">0. 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-总线-bus"><span class="nav-text">1. 总线(bus)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-总线的注册"><span class="nav-text">1.1 总线的注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-总线的注销"><span class="nav-text">1.2 总线的注销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-总线方法"><span class="nav-text">1.3 总线方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-总线属性"><span class="nav-text">1.4 总线属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-设备-device"><span class="nav-text">2. 设备(device)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-设备注册"><span class="nav-text">2.1 设备注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-设备注销"><span class="nav-text">2.2 设备注销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-设备属性"><span class="nav-text">2.3 设备属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-设备结构的封装"><span class="nav-text">2.4 设备结构的封装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-举例"><span class="nav-text">2.5 举例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-设备驱动-device-driver"><span class="nav-text">3. 设备驱动(device_driver)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-设备驱动注册"><span class="nav-text">3.1 设备驱动注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-设备驱动注销"><span class="nav-text">3.2 设备驱动注销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-设备驱动属性"><span class="nav-text">3.3 设备驱动属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-驱动程序结构的封装"><span class="nav-text">3.4 驱动程序结构的封装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-举例"><span class="nav-text">3.5 举例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-实例"><span class="nav-text">4. 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-注册总线"><span class="nav-text">4.1 注册总线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-封装设备接口"><span class="nav-text">4.2 封装设备接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-封装驱动接口"><span class="nav-text">4.3 封装驱动接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-添加设备和驱动"><span class="nav-text">4.4 添加设备和驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-测试"><span class="nav-text">4.5 测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-总结"><span class="nav-text">5. 总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-参考资料"><span class="nav-text">6. 参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">micro虾米</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">micro虾米</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '1ec7eee73ee4f91e15a1',
      clientSecret: '971b3c9439c2a8fa2fcb12307657ad50aee6ed0c',
      repo        : 'mshrimp_blog_talk',
      owner       : 'mshrimp',
      admin       : ['mshrimp'],
      id          : '2390267aaecc1cfeb768be675b9e9366',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
