<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mshrimp.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux块设备驱动Linux块设备驱动">
<meta name="keywords" content="Driver">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux块设备驱动">
<meta property="og:url" content="http://mshrimp.github.io/2020/04/19/Linux块设备驱动/index.html">
<meta property="og:site_name" content="Mshrimp blog">
<meta property="og:description" content="Linux块设备驱动Linux块设备驱动">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-04-19T02:58:00.276Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux块设备驱动">
<meta name="twitter:description" content="Linux块设备驱动Linux块设备驱动">

<link rel="canonical" href="http://mshrimp.github.io/2020/04/19/Linux块设备驱动/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>Linux块设备驱动 | Mshrimp blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mshrimp blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">micro虾米</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://mshrimp.github.io/2020/04/19/Linux块设备驱动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="micro虾米">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mshrimp blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux块设备驱动
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 10:40:13 / Modified: 10:58:00" itemprop="dateCreated datePublished" datetime="2020-04-19T10:40:13+08:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Linux块设备驱动"><a href="#Linux块设备驱动" class="headerlink" title="Linux块设备驱动"></a>Linux块设备驱动</h2><p>Linux块设备驱动</p>
<a id="more"></a>




<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p>
<h3 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h3><p>字符设备</p>
<p>字符设备是一种顺序的数据流设备，对字符设备的读写是以字节为单位进行的，这些字符连续地形成一个数据流，字符设备没有缓存区，对于字符设备的读写是实时的；</p>
<p>块设备</p>
<p>块设备是一种具有一定结构的随机存取设备，对块设备的读写是以块为单位进行的，块设备使用缓存区来存放数据，待条件满足后，将数据从缓存区一次性写入到设备，或者从设备一次性读取到缓存区；</p>
<p>为了创建一个块设备驱动程序，实现一个基于内存的块设备驱动程序；</p>
<h4 id="1-块设备结构"><a href="#1-块设备结构" class="headerlink" title="1. 块设备结构"></a>1. 块设备结构</h4><p><strong>段（Segments）</strong>：由若干个块组成；是Linux内存管理机制中一个内存页或内存页的一部分；</p>
<p><strong>块（Blocks）</strong>：由Linux制定对内核或文件系统等数据处理的基本单位；通常通常为4096个字节，由1个或多个扇区组成；</p>
<p><strong>扇区（Sectors）</strong>：块设备的基本单位，是一个固定的硬件单位，制定了设备最少能够传输的数据量；通常在512字节到32768字节之间，默认：512字节；</p>
<p>块是连续扇区的序列，块长度总是扇区长度的整数倍；块的最大长度，受特定体系结构的内存页长度限制；</p>
<p>块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备；</p>
<p>![块设备层](Linux kernel中的块设备驱动/块设备层.PNG)</p>
<h4 id="2-块设备驱动框架"><a href="#2-块设备驱动框架" class="headerlink" title="2. 块设备驱动框架"></a>2. 块设备驱动框架</h4><p>![块设备驱动框架图](Linux kernel中的块设备驱动/块设备驱动框架图.jpg)</p>
<h3 id="1-重要操作"><a href="#1-重要操作" class="headerlink" title="1. 重要操作"></a>1. 重要操作</h3><h4 id="1-注册块设备驱动程序"><a href="#1-注册块设备驱动程序" class="headerlink" title="1. 注册块设备驱动程序"></a>1. 注册块设备驱动程序</h4><p>向内核注册块设备驱动程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_blkdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：设备名字，是在/proc/devices中显示的名字</p>
<p>major：设备的主设备号，如果major=0，则分配一个主设备号</p>
</blockquote>
<p>该函数的调用是可选的，完成的工作：</p>
<blockquote>
<ol>
<li>如果需要的话分配一个动态的主设备号</li>
<li><ol start="2">
<li>在/proc/devices中创建一个入口项</li>
</ol>
</li>
</ol>
</blockquote>
<p>注销块设备驱动程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_blkdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如下用例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sbull_major = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sbull_major = register_blkdev(sbull_major, <span class="string">"sbull"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sbull_major &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">	printk(KERN_WARNNING <span class="string">"sbull: unable to get major number\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// include/linux/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dev_t</span>           bd_dev;  <span class="comment">/* not a kdev_t - it's a search key */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         bd_openers;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *      <span class="title">bd_inode</span>;</span>   <span class="comment">/* will die */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *    <span class="title">bd_super</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">bd_mutex</span>;</span>   <span class="comment">/* open/close mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *          bd_claiming;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *          bd_holder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         bd_holders;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>            bd_write_holder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">bd_holder_disks</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *   <span class="title">bd_contains</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>        bd_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> *  <span class="title">bd_part</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* number of times partitions within this device have been opened. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>        bd_part_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         bd_invalidated;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *    <span class="title">bd_disk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *  <span class="title">bd_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">bd_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * Private data.  You must have bd_claim'ed the block_device</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * to use this.  <span class="doctag">NOTE:</span>  bd_claim allows an owner to claim</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * the same device multiple times, the owner must take special</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * care to not mess up bd_private for that case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       bd_private;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The counter of freeze processes */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         bd_fsfreeze_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mutex for freeze */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">bd_fsfreeze_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-块设备操作"><a href="#2-块设备操作" class="headerlink" title="2. 块设备操作"></a>2. 块设备操作</h4><p>字符设备使用file_operations结构，来告诉系统字符设备驱动的操作接口；</p>
<p>块设备使用block_device_operations结构，来告诉系统块设备驱动的操作接口；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// include/linux/blkdev.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">open</span>) (struct block_device *, <span class="keyword">fmode_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">release</span>) (struct gendisk *, <span class="keyword">fmode_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*rw_page)(struct block_device *, <span class="keyword">sector_t</span>, struct page *, <span class="keyword">bool</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*ioctl) (struct block_device *, <span class="keyword">fmode_t</span>, <span class="keyword">unsigned</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*compat_ioctl) (struct block_device *, <span class="keyword">fmode_t</span>, <span class="keyword">unsigned</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> (*direct_access)(struct block_device *, <span class="keyword">sector_t</span>, <span class="keyword">void</span> **, <span class="keyword">pfn_t</span> *,</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*check_events)</span> <span class="params">(struct gendisk *disk,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> clearing)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*media_changed) (struct gendisk *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*unlock_native_capacity) (struct gendisk *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*revalidate_disk) (struct gendisk *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*getgeo)(struct block_device *, struct hd_geometry *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this callback is with swap_lock and sometimes page table lock held */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*swap_slot_free_notify) (struct block_device *, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pr_ops</span> *<span class="title">pr_ops</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和字符设备驱动不同，块设备驱动的block_device_operations操作集中没有负责读和写数据的函数；在块设备驱动中，这些操作是由request函数处理的；</p>
<h4 id="3-注册磁盘"><a href="#3-注册磁盘" class="headerlink" title="3. 注册磁盘"></a>3. 注册磁盘</h4><p>为了管理独立的磁盘，需要使用struct gendisk结构体，内核使用gendisk结构表示一个独立的磁盘设备，还可以表示分区；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/genhd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> major;          <span class="comment">/* major number of driver */</span></span><br><span class="line">    <span class="keyword">int</span> first_minor;</span><br><span class="line">    <span class="keyword">int</span> minors;                     <span class="comment">/* maximum number of minors, =1 for</span></span><br><span class="line"><span class="comment">                                         * disks that can't be partitioned. */</span></span><br><span class="line">    <span class="keyword">char</span> disk_name[DISK_NAME_LEN];  <span class="comment">/* name of major driver */</span></span><br><span class="line">    <span class="keyword">char</span> *(*devnode)(struct gendisk *gd, <span class="keyword">umode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>major：指定驱动程序的主设备号</p>
<p>first_minor和minors：从设备号的可能范围</p>
<p>disk_name：磁盘名称，在/proc/partitions 和 sysfs 中表示该磁盘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> disk_name[DISK_NAME_LEN];</span><br></pre></td></tr></table></figure>

<p>显示在/proc/partitions 和 sysfs 中</p>
<p>对于每一个分区来说，都有一个hd_struct结构体，用于描述该分区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/genhd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">sector_t</span> start_sect;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * nr_sects is protected by sequence counter. One might extend a</span></span><br><span class="line"><span class="comment">     * partition while IO is happening to it and update of nr_sects</span></span><br><span class="line"><span class="comment">     * can be non-atomic on 32bit machines with 64bit sector_t.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">sector_t</span> nr_sects;</span><br><span class="line">    <span class="keyword">seqcount_t</span> nr_sects_seq;</span><br><span class="line">    <span class="keyword">sector_t</span> alignment_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> discard_alignment;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">holder_dir</span>;</span></span><br><span class="line">    <span class="keyword">int</span> policy, partno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">partition_meta_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIL_MAKE_REQUEST</span></span><br><span class="line">    <span class="keyword">int</span> make_it_fail;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stamp;</span><br><span class="line">    <span class="keyword">atomic_t</span> in_flight[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  CONFIG_SMP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_stats</span> __<span class="title">percpu</span> *<span class="title">dkstats</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_stats</span> <span class="title">dkstats</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span> <span class="title">ref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>start_sect和nr_sects：定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区</p>
<p>拥有了设备内存和请求队列，就可以分配、初始化及安装gendisk结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genhd.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>struct gendisk是动态分配的结构，需要内核进行初始化，驱动必须通过alloc_disk分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct gendisk *<span class="title">alloc_disk</span><span class="params">(<span class="keyword">int</span> minors)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>minors：是该磁盘使用的从设备号的数目；</p>
</blockquote>
<p>卸载磁盘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_gendisk</span><span class="params">(struct gendisk *disk)</span></span></span><br></pre></td></tr></table></figure>

<p>gendisk是一个引用计数结构，get_disk和put_disk函数负责处理引用计数；调用del_gendisk后，该结构可能继续存在；</p>
<p>为了使gendisk结构的磁盘设备生效，需要初始化结构，并将磁盘或分区信息添加到内核链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_disk</span><span class="params">(struct gendisk *gd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用add_disk后，磁盘设备将被激活，并随时会调用它提供的操作方法，因此在驱动程序完全被初始化并且能够响应对磁盘的请求前，不要调用add_disk；</p>
<h4 id="4-请求队列"><a href="#4-请求队列" class="headerlink" title="4. 请求队列"></a>4. 请求队列</h4><p>块设备的读写请求放置在请求队列中，在struct gendisk中，通过struct request_queue *queue指针指向请求队列；请求队列用数据结构struct request_queue表示；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/blkdev.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">queue_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>      *<span class="title">last_merge</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span>   *<span class="title">elevator</span>;</span></span><br><span class="line">    <span class="keyword">int</span>         nr_rqs[<span class="number">2</span>];  <span class="comment">/* # allocated [a]sync rqs */</span></span><br><span class="line">    <span class="keyword">int</span>         nr_rqs_elvpriv; <span class="comment">/* # allocated rqs w/ elvpriv */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_list</span> <span class="title">root_rl</span>;</span></span><br><span class="line"></span><br><span class="line">    request_fn_proc     *request_fn;</span><br><span class="line">    make_request_fn     *make_request_fn;</span><br><span class="line">    prep_rq_fn      *prep_rq_fn;</span><br><span class="line">    unprep_rq_fn        *unprep_rq_fn;</span><br><span class="line">    softirq_done_fn     *softirq_done_fn;</span><br><span class="line">    rq_timed_out_fn     *rq_timed_out_fn;</span><br><span class="line">    dma_drain_needed_fn *dma_drain_needed;</span><br><span class="line">    lld_busy_fn     *lld_busy_fn;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ops</span>   *<span class="title">mq_ops</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        *mq_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sw queues */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ctx</span> __<span class="title">percpu</span>  *<span class="title">queue_ctx</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_queues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hw dispatch queues */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span>    **<span class="title">queue_hw_ctx</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_hw_queues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sector_t</span>        end_sector;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>      *<span class="title">boundary_rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">delay_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> <span class="title">backing_dev_info</span>;</span></span><br><span class="line">    <span class="keyword">void</span>            *queuedata;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       queue_flags;</span><br><span class="line">    <span class="keyword">int</span>         id;</span><br><span class="line">    <span class="keyword">gfp_t</span>           bounce_gfp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span>      __queue_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      *queue_lock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">mq_kobj</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_integrity</span> <span class="title">integrity</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* CONFIG_BLK_DEV_INTEGRITY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>       *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span>         rpm_status;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_pending;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_requests;    <span class="comment">/* Max # of requests */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_congestion_on;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_congestion_off;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_batching;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        dma_drain_size;</span><br><span class="line">    <span class="keyword">void</span>            *dma_drain_buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        dma_pad_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        dma_alignment;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_queue_tag</span>    *<span class="title">queue_tags</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">tag_busy_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_sorted;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        in_flight[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        request_fn_active;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        rq_timeout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>   <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>  <span class="title">timeout_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">timeout_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">icq_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">    DECLARE_BITMAP      (blkcg_pols, BLKCG_MAX_POLS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span>     *<span class="title">root_blkg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">blkg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_limits</span> <span class="title">limits</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        sg_timeout;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        sg_reserved_size;</span><br><span class="line">    <span class="keyword">int</span>         node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_trace</span>    *<span class="title">blk_trace</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_flush_queue</span>  *<span class="title">fq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">requeue_list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      requeue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">requeue_work</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">sysfs_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         bypass_depth;</span><br><span class="line">    <span class="keyword">atomic_t</span>        mq_freeze_depth;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BLK_DEV_BSG)</span></span><br><span class="line">    bsg_job_fn      *bsg_job_fn;</span><br><span class="line">    <span class="keyword">int</span>         bsg_job_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bsg_class_device</span> <span class="title">bsg_dev</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_THROTTLING</span></span><br><span class="line">    <span class="comment">/* Throttle data */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">throtl_data</span> *<span class="title">td</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">rcu_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">swait_queue_head</span> <span class="title">mq_freeze_wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span>   <span class="title">q_usage_counter</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">all_q_node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_tag_set</span>   *<span class="title">tag_set</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">tag_set_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span>      *<span class="title">bio_split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>            mq_sysfs_init_done;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>queue_head：表头，用于构建一个IO请求的双链表；链表每个元素代表向块设备读取数据的一个请求；内核会重排该链表，以得到更好的IO性能；</p>
<p>与每个块设备驱动程序相关的I/O请求队列用request_queue结构体描述，而每个request_queue队列中的请求用request结构体描述；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/blkdev.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queuelist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ctx</span> *<span class="title">mq_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following two fields are internal, NEVER access directly */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __data_len;    <span class="comment">/* total data len */</span></span><br><span class="line">    <span class="keyword">sector_t</span> __sector;      <span class="comment">/* sector cursor */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">biotail</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">next_rq</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>request结构体关联了struct bio，struct bio结构体是块I/O操作在页级粒度的底层描述；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/blk_types.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>      *<span class="title">bi_next</span>;</span>   <span class="comment">/* request queue link */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span>         bi_error;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_opf;     <span class="comment">/* bottom bits req flags,</span></span><br><span class="line"><span class="comment">                         * top bits REQ_OP. Use</span></span><br><span class="line"><span class="comment">                         * accessors.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short      bi_flags;   <span class="comment">/* status, command, etc */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short      bi_ioprio;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span>    <span class="title">bi_iter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_phys_segments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_front_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_back_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_t</span>        __bi_remaining;</span><br><span class="line">    <span class="keyword">bio_end_io_t</span>        *bi_end_io;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> short      bi_vcnt;    <span class="comment">/* how many bio_vec's */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short      bi_max_vecs;    <span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>      *<span class="title">bi_io_vec</span>;</span> <span class="comment">/* the actual vec list */</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>块数据通过bio_vec结构体数组在内部被表示成I/O向量；每个bio_vec数组元素由三元组组成（即，页、页偏移、长度），表示该块I/O的一个段；</p>
<p>块设备驱动程序的核心是请求函数，包含请求处理过程；</p>
<h3 id="2-块设备驱动的初始化"><a href="#2-块设备驱动的初始化" class="headerlink" title="2. 块设备驱动的初始化"></a>2. 块设备驱动的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(block_init);</span><br><span class="line">module_exit(block_exit);</span><br></pre></td></tr></table></figure>

<p>块设备驱动程序的初始化方法在block_init()函数中；</p>
<h4 id="1-注册块设备"><a href="#1-注册块设备" class="headerlink" title="1. 注册块设备"></a>1. 注册块设备</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">major = register_blkdev(major, <span class="string">"my_blk"</span>);</span><br></pre></td></tr></table></figure>

<p>为块设备驱动分配一个未使用的主设备号，并在/proc/devies中添加一个入口；</p>
<h4 id="2-注册请求队列"><a href="#2-注册请求队列" class="headerlink" title="2. 注册请求队列"></a>2. 注册请求队列</h4><p>注册请求队列的操作，将一个请求的操作方法与该设备相关联，通过blk_init_queue()函数实现；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">blkdev_queue</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(blk_lock)</span></span>;</span><br><span class="line">blkdev_queue = blk_init_queue(blkdev_request, &amp;blk_lock);</span><br></pre></td></tr></table></figure>

<p>blk_init_queue()函数返回请求队列request_queue；将blkdev_request()函数指针方式关联到设备；而第二个参数是自旋锁，用来保护request_queue队列不被同时访问；</p>
<h4 id="3-设置读写块大小"><a href="#3-设置读写块大小" class="headerlink" title="3. 设置读写块大小"></a>3. 设置读写块大小</h4><p>硬件执行磁盘是以扇区为单位的，而文件系统是以块为单位处理数据；通常，扇区大小为512字节，块大小为4096字节；需要将硬件支持的扇区大小和驱动程序在一次请求中能接收的最大扇区数通知块层；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/blkdev.h</span></span><br><span class="line"><span class="keyword">int</span> my_blkdev_sect_size = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// blk_queue_hardsect_size(blkdev_queue, my_blkdev_sect_size);</span></span><br><span class="line">blk_queue_logical_block_size(blkdev_queue, my_blkdev_sect_size);</span><br></pre></td></tr></table></figure>

<h4 id="4-创建磁盘"><a href="#4-创建磁盘" class="headerlink" title="4. 创建磁盘"></a>4. 创建磁盘</h4><p>使用alloc_disk()函数分配一个与设备对应的磁盘gendisk结构体，并初始化其成员；需要初始化的成员有：block_device_operations、存储容量（单位是扇区）、请求队列、主设备号、磁盘名称等；设置存储容量通过set_capacity()函数来完成；</p>
<p>调用add_disk()函数将磁盘添加到块I/O层；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blkdev_disk = alloc_disk(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(blkdev_disk-&gt;disk_name, <span class="string">"my_blkdev"</span>);</span><br><span class="line">blkdev_disk-&gt;fops = &amp;blkdev_fops;</span><br><span class="line">blkdev_disk-&gt;<span class="built_in">queue</span> = blkdev_queue;</span><br><span class="line">blkdev_disk-&gt;major = major;</span><br><span class="line">blkdev_disk-&gt;first_minor = <span class="number">0</span>;</span><br><span class="line">set_capacity(blkdev_disk, blkdev_size * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">add_disk(mcy_blkdev_disk);</span><br></pre></td></tr></table></figure>

<p>到这里，设备/dev/my_blkdev就可以使用了，如果设备支持多个磁盘分区，会显示为/dev/my_blkdevX，X是分区号；</p>
<h3 id="3-队列请求"><a href="#3-队列请求" class="headerlink" title="3. 队列请求"></a>3. 队列请求</h3><p>每个块设备，都有一个请求队列，当请求队列生成时，请求函数request()就与该队列绑定，这个操作在blk_init_queue()函数完成；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct request_queue *<span class="title">blk_init_queue</span><span class="params">(request_fn_proc *rfn, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-块设备的注册"><a href="#4-块设备的注册" class="headerlink" title="4. 块设备的注册"></a>4. 块设备的注册</h3><p>注册一个块设备驱动，需要以下步骤：</p>
<blockquote>
<p>创建一个块设备 </p>
<p>分配一个申请队列</p>
<p>分配一个gendisk结构体</p>
<p>设置gendisk结构体成员</p>
<p>注册gendisk结构体</p>
</blockquote>
<h4 id="块设备的注册过程"><a href="#块设备的注册过程" class="headerlink" title="块设备的注册过程"></a>块设备的注册过程</h4><pre class="mermaid">graph TB
    A("注册设备(register_blkdev)(可选)")-->B("分配磁盘(alloc_disk)")
    B-->C("不使用请求队列(blk_init_queue)")-->E
    B-->D("使用请求队列(blk_alloc_queue)")-->E
    E("设置磁盘属性(gendisk)")-->F("激活磁盘(add_disk)")</pre>


<ol>
<li><p>通过register_blkdev()函数注册设备，是个可选操作；</p>
</li>
<li><p>使用alloc_disk()函数分配通用磁盘gendisk结构体；</p>
</li>
<li><p>根据是否需要I/O调度，分两种情况，一种是使用请求队列进行数据传输，一种是不使用请求队列进行数据传输；</p>
</li>
<li><p>初始化gendisk结构体的数据成员，包括：major、fops、queue等；</p>
</li>
<li><p>使用add_disk()函数激活磁盘设备，调用该函数之前要做好所有的准备工作；</p>
</li>
</ol>
<p>分配一个gendisk结构体</p>
<p>设置一个队列，将访问请求放到队列里</p>
<p>设置gendisk结构体的属性，如：名称、容量、操作集等</p>
<p>添加gendisk结构体</p>
<p>另外分配一块内存空间，当做块设备，在request函数中使用memcpy访问，模仿块设备读写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">mcy_blkdev_queue</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">mcy_blkdev_disk</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(mcy_blk_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mcy_blkdev_size = <span class="number">256</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> mcy_blkdev_sect_size = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mcy_block_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    major = register_blkdev(major, <span class="string">"mcy_blk"</span>);</span><br><span class="line">    <span class="keyword">if</span> (major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, register_blkdev failed, major: %d\n"</span>, __func__, major);</span><br><span class="line">        <span class="keyword">goto</span> register_blkdev_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s, major: %d\n"</span>, __func__, major);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// blk_queue_make_request</span></span><br><span class="line">    mcy_blkdev_queue = blk_init_queue(mcy_blkdev_request, &amp;mcy_blk_lock);</span><br><span class="line">    <span class="keyword">if</span> (!mcy_blkdev_queue) &#123;</span><br><span class="line">        printk(<span class="string">"%s, blk_init_queue failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> init_queue_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mcy_blkdev_disk = alloc_disk(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mcy_blkdev_disk) &#123;</span><br><span class="line">        printk(<span class="string">"%s, alloc_disk failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> alloc_disk_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(mcy_blkdev_disk-&gt;disk_name, <span class="string">"mcy_blkdev_disk"</span>);</span><br><span class="line">    mcy_blkdev_disk-&gt;fops = &amp;mcy_blkdev_fops;</span><br><span class="line">    mcy_blkdev_disk-&gt;<span class="built_in">queue</span> = mcy_blkdev_queue;</span><br><span class="line">    mcy_blkdev_disk-&gt;major = major;</span><br><span class="line">    mcy_blkdev_disk-&gt;first_minor = <span class="number">0</span>;</span><br><span class="line">    set_capacity(mcy_blkdev_disk, mcy_blkdev_size * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    add_disk(mcy_blkdev_disk);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s, mcy_blkdev_disk add success!\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">alloc_disk_err:</span><br><span class="line">    blk_cleanup_queue(mcy_blkdev_queue);</span><br><span class="line">init_queue_err:</span><br><span class="line">    unregister_blkdev(major, <span class="string">"mcy_blk"</span>);</span><br><span class="line">register_blkdev_err:</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">mcy_blkdev_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .<span class="built_in">open</span> = mcy_blkdev_open,</span><br><span class="line">    .<span class="built_in">release</span> = mcy_blkdev_release,</span><br><span class="line">    .ioctl = mcy_blkdev_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="块设备的卸载过程"><a href="#块设备的卸载过程" class="headerlink" title="块设备的卸载过程"></a>块设备的卸载过程</h4><pre class="mermaid">graph TB
    A("删除gendisk(del_gendisk)")-->
    B("删除gendisk的引用(put_disk)")-->
    C("清除请求队列(blk_cleanup_queue)")-->
    D("注销块设备(unregister_blkdev)")</pre>


<ol>
<li><p>使用del_gendisk()函数删除gendisk设备（磁盘）；</p>
</li>
<li><p>使用put_disk()函数删除gendisk设备的引用；</p>
</li>
<li><p>使用blk_cleanup_queue()函数清除请求队列，释放请求队列占用的资源；</p>
</li>
<li><p>使用unregister_blkdev()函数注销设备，并释放对设备的引用，可选操作，与register_blkdev()函数配合使用；</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mcy_block_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    del_gendisk(mcy_blkdev_disk);</span><br><span class="line">    put_disk(mcy_blkdev_disk);</span><br><span class="line">    blk_cleanup_queue(mcy_blkdev_queue);</span><br><span class="line">    unregister_blkdev(major, <span class="string">"mcy_blk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls /dev/my_blkdev -l</span></span><br><span class="line">brw-rw----    <span class="number">1</span> root     root      <span class="number">253</span>,   <span class="number">0</span> Oct <span class="number">21</span> <span class="number">08</span>:<span class="number">18</span> /dev/my_blkdev</span><br></pre></td></tr></table></figure>

<h3 id="5-测试验证"><a href="#5-测试验证" class="headerlink" title="5. 测试验证"></a>5. 测试验证</h3><p>测试步骤：</p>
<blockquote>
<p>加载驱动：insmod ramblock.ko</p>
<p>格式化：mkdosfs /dev/ramblock</p>
<p>挂载：mount /dev/ramblock /mnt</p>
<p>读写文件：cd /mnt，创建文件</p>
<p>卸载：umount /mnt</p>
<p>cat /dev/ramblock &gt; /mnt/ramblock.bin</p>
<p>在PC上查看/mnt/ramblock.bin，sudo mount -o loop ramblock.bin /mnt</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/big-devil/p/8590007.html">https://www.cnblogs.com/big-devil/p/8590007.html</a></p>
<p><a href="#目录">回到目录</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Driver/" rel="tag"># Driver</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/17/Linux内核启动流程-基于ARM64/" rel="prev" title="Linux内核启动流程-基于ARM64">
      <i class="fa fa-chevron-left"></i> Linux内核启动流程-基于ARM64
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux块设备驱动"><span class="nav-text">Linux块设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-简介"><span class="nav-text">0. 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-块设备结构"><span class="nav-text">1. 块设备结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-块设备驱动框架"><span class="nav-text">2. 块设备驱动框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-重要操作"><span class="nav-text">1. 重要操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-注册块设备驱动程序"><span class="nav-text">1. 注册块设备驱动程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-块设备操作"><span class="nav-text">2. 块设备操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-注册磁盘"><span class="nav-text">3. 注册磁盘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-请求队列"><span class="nav-text">4. 请求队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-块设备驱动的初始化"><span class="nav-text">2. 块设备驱动的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-注册块设备"><span class="nav-text">1. 注册块设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-注册请求队列"><span class="nav-text">2. 注册请求队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-设置读写块大小"><span class="nav-text">3. 设置读写块大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-创建磁盘"><span class="nav-text">4. 创建磁盘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-队列请求"><span class="nav-text">3. 队列请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-块设备的注册"><span class="nav-text">4. 块设备的注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#块设备的注册过程"><span class="nav-text">块设备的注册过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#块设备的卸载过程"><span class="nav-text">块设备的卸载过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-测试验证"><span class="nav-text">5. 测试验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">micro虾米</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">micro虾米</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


  <script src='https://unpkg.com/mermaid@/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
