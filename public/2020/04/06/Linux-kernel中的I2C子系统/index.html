<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mshrimp.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；">
<meta name="keywords" content="i2c">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux kernel中的I2C子系统">
<meta property="og:url" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/index.html">
<meta property="og:site_name" content="Mshrimp blog">
<meta property="og:description" content="Linux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png">
<meta property="og:image" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/I2C%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/I2C%E6%80%BB%E7%BA%BF%E5%B1%82%E5%92%8C%E8%AE%BE%E5%A4%87%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/I2C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/I2C%E6%B3%A8%E5%86%8C%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png">
<meta property="og:updated_time" content="2020-04-25T11:09:53.451Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux kernel中的I2C子系统">
<meta name="twitter:description" content="Linux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；">
<meta name="twitter:image" content="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png">

<link rel="canonical" href="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>Linux kernel中的I2C子系统 | Mshrimp blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mshrimp blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">micro虾米</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://mshrimp.github.io/2020/04/06/Linux-kernel中的I2C子系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="micro虾米">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mshrimp blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux kernel中的I2C子系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-06 14:36:52" itemprop="dateCreated datePublished" datetime="2020-04-06T14:36:52+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 19:09:53" itemprop="dateModified" datetime="2020-04-25T19:09:53+08:00">2020-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Linux系统定义了I2C驱动体系结构，在Linux内核中的I2C子系统中，I2C驱动共有3部分组成：I2C核心、I2C总线驱动、I2C设备驱动，这三部分组成了I2C的框架；I2C子系统中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；</p>
<a id="more"></a>



<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p>
<p>Linux内核中的I2C驱动代码位于：drivers/i2c目录；</p>
<h3 id="0-简述"><a href="#0-简述" class="headerlink" title="0. 简述"></a>0. 简述</h3><p>Linux内核中的I2C驱动代码位于：drivers/i2c目录；</p>
<p>Linux设备模型由bus、device、driver组成；</p>
<p>I2C驱动中有4个重要内容：I2C总线、I2C设备、I2C驱动、I2C适配器；</p>
<blockquote>
<p>I2C总线：维护I2C驱动和I2C设备两个链表，管理I2C驱动和I2C设备的匹配、删除等；</p>
<p>I2C设备：具体硬件设备的一个抽象；</p>
<p>I2C驱动：对应I2C设备的驱动程序；</p>
<p>I2C适配器：用于I2C驱动和I2C设备间通信，是SOC上I2C控制器的一个抽象；</p>
</blockquote>
<p>I2C总线上有两个链表，分别是i2c_driver和i2c_client三链表；当任何一个driver或client注册时，I2C总线都会调用match函数，对client.name和driver.id_table.name进行遍历匹配；如果driver.id_table中所有的id都匹配不成功，说明client没有找到对应的driver；如果匹配成功，说明client和driver是配套的，那么I2C总线就会调用自己的probe函数，然后probe函数调用driver中提供的probe函数，driver中的probe函数会对设备进行硬件初始化和后续工作；</p>
<p>i2c_add_adapter    // 注册adapter</p>
<p>i2c_add_driver        // 注册driver</p>
<p>i2c_new_device        // 注册client</p>
<h3 id="1-I2C驱动框架"><a href="#1-I2C驱动框架" class="headerlink" title="1. I2C驱动框架"></a>1. I2C驱动框架</h3><p>Linux的I2C体系结构分为3个部分：</p>
<blockquote>
<p>I2C核心</p>
<p>I2C总线驱动</p>
<p>I2C设备驱动</p>
</blockquote>
<p><img src="/2020/04/06/Linux-kernel中的I2C子系统/Linux%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png" alt="Linux的I2C子系统框架"></p>
<h4 id="1-1-I2C核心"><a href="#1-1-I2C核心" class="headerlink" title="1.1 I2C核心"></a>1.1 I2C核心</h4><p>I2C核心（i2c_core）维护了i2c_bus结构体，提供了：</p>
<blockquote>
<p>I2C总线驱动和设备驱动的注册、注销方法</p>
<p>I2C的通信方法（i2c_algorithm）</p>
<p>上层的与具体适配器无关的代码</p>
<p>探测设备、检测设备地址的上层代码</p>
</blockquote>
<p>此部分代码由Linux内核提供；</p>
<h4 id="1-2-I2C总线驱动"><a href="#1-2-I2C总线驱动" class="headerlink" title="1.2 I2C总线驱动"></a>1.2 I2C总线驱动</h4><p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器由CPU控制，或者直接集成在CPU内部；</p>
<p>I2C总线驱动主要包含：</p>
<blockquote>
<p>I2C适配器数据结构i2c_adapter</p>
<p>I2C适配器的控制算法数据结构i2c_algorithm</p>
<p>控制I2C适配器产生通信信号的函数</p>
</blockquote>
<p>通过I2C总线驱动代码，可以控制I2C适配器，以主设备方式产生开始位、停止位、读写周期，以及以从设备方式读写、产生ACK等；</p>
<p>此部分代码由具体的芯片厂商提供，如：高通、Samsung等；</p>
<h4 id="1-3-I2C设备驱动"><a href="#1-3-I2C设备驱动" class="headerlink" title="1.3 I2C设备驱动"></a>1.3 I2C设备驱动</h4><p>I2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在I2C控制器（适配器）上，通过I2C适配器与CPU交换数据；</p>
<p>I2C设备驱动主要包含i2c_client和i2c_driver结构体，实现和用户交互的文件操作集fops、cdev等；</p>
<p>这两个数据结构中的成员函数，需要由驱动开发者根据具体设备去实现；</p>
<h3 id="2-核心数据结构"><a href="#2-核心数据结构" class="headerlink" title="2. 核心数据结构"></a>2. 核心数据结构</h3><p>I2C驱动中最核心的4个数据结构：</p>
<blockquote>
<p>struct i2c_client</p>
<p>struct i2c_driver</p>
<p>struct i2c_adapter</p>
<p>struct i2c_algorithm</p>
</blockquote>
<h4 id="2-1-设备层"><a href="#2-1-设备层" class="headerlink" title="2.1 设备层"></a>2.1 设备层</h4><h5 id="2-1-1-I2C设备（i2c-client）"><a href="#2-1-1-I2C设备（i2c-client）" class="headerlink" title="2.1.1 I2C设备（i2c_client）"></a>2.1.1 I2C设备（i2c_client）</h5><p>硬件上连接到I2C的SDA、SCL总线上的设备都是I2C设备，每一个I2C设备由一个i2c_client结构体进行描述；i2c_client对应真实的I2C物理设备，是具体硬件设备的抽象；一个i2c_client对象，表示连接到i2c总线的一个设备；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/i2c.h</span><br><span class="line">struct i2c_client &#123;</span><br><span class="line">    unsigned short flags;       /* div., see below      */</span><br><span class="line">    unsigned short addr;        /* chip address - NOTE: 7bit    */</span><br><span class="line">    char name[I2C_NAME_SIZE];</span><br><span class="line">    struct i2c_adapter *adapter;    /* the adapter we sit on    */</span><br><span class="line">    struct device dev;      /* the device structure     */</span><br><span class="line">    int irq;            /* irq issued by device     */</span><br><span class="line">    struct list_head detected;</span><br><span class="line">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class="line">    i2c_slave_cb_t slave_cb;    /* callback for slave mode  */</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>unsigned short addr：表示7bit的设备芯片地址，地址被保存在低7bits</p>
<p>struct i2c_adapter *adapter：表示这个i2c_client从属的i2c_adapter对象，驱动中使用这个指针操作发送</p>
<p>struct device dev：表示device信息</p>
<p>struct list_head detected：设备链表，将所有的i2c_client组成链表</p>
</blockquote>
<p>i2c_client结构不是驱动开发者创建的，而是通过以下方式自动创建：</p>
<blockquote>
<p>分配、设置、注册i2c_board_info</p>
<p>获取i2c_adapter，调用i2c_new_device</p>
<p>通过设备树（DeviceTree）创建</p>
</blockquote>
<h5 id="2-1-2-I2C驱动（i2c-driver）"><a href="#2-1-2-I2C驱动（i2c-driver）" class="headerlink" title="2.1.2 I2C驱动（i2c_driver）"></a>2.1.2 I2C驱动（i2c_driver）</h5><p>i2c_driver结构用于管理I2C的驱动和I2C设备的匹配探测，实现与用户层交互的文件操作集fops、cdev等；每一个I2C设备都对应一个I2C驱动，因此，每一个i2c_client结构，都对应一个i2c_driver结构，通过指针相连；编写一个i2c驱动的本质，就是要构造一个i2c_driver对象，并将其注册到内核；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/i2c.h</span><br><span class="line">struct i2c_driver &#123;</span><br><span class="line">    unsigned int class;</span><br><span class="line"></span><br><span class="line">    int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">    /* Standard driver model interfaces */</span><br><span class="line">    int (*probe)(struct i2c_client *, const struct i2c_device_id *); </span><br><span class="line">    int (*remove)(struct i2c_client *); </span><br><span class="line"></span><br><span class="line">    void (*shutdown)(struct i2c_client *); </span><br><span class="line">    void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol,</span><br><span class="line">              unsigned int data);</span><br><span class="line"></span><br><span class="line">    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br><span class="line"></span><br><span class="line">    struct device_driver driver;</span><br><span class="line">    const struct i2c_device_id *id_table;</span><br><span class="line"></span><br><span class="line">    /* Device detection callback for automatic device creation */</span><br><span class="line">    int (*detect)(struct i2c_client *, struct i2c_board_info *); </span><br><span class="line">    const unsigned short *address_list;</span><br><span class="line">    struct list_head clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>probe：探测函数，匹配成功后执行，会将匹配到的i2c_client对象传入，完成申请资源、初始化、提供接口等操作</p>
<p>remove：移除函数，设备消失时或驱动模块被卸载时会被调用，和probe操作相反</p>
<p>struct device_driver driver：表明是一个设备的驱动类，用于匹配设备树的of_match_table域</p>
<p>const struct i2c_device_id *id_table：用于使用平台文件或模块编写设备信息时进行匹配</p>
<p>struct list_head clients：用于将所有i2c_driver联系到一起的链表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)</span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-总线和设备关系"><a href="#2-1-3-总线和设备关系" class="headerlink" title="2.1.3 总线和设备关系"></a>2.1.3 总线和设备关系</h5><p><img src="/2020/04/06/Linux-kernel中的I2C子系统/I2C%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="I2C设备和驱动的关系"></p>
<h4 id="2-2-总线层"><a href="#2-2-总线层" class="headerlink" title="2.2 总线层"></a>2.2 总线层</h4><h5 id="2-2-1-I2C适配器（i2c-adapter）"><a href="#2-2-1-I2C适配器（i2c-adapter）" class="headerlink" title="2.2.1 I2C适配器（i2c_adapter）"></a>2.2.1 I2C适配器（i2c_adapter）</h5><p>I2C适配器，即SOC中的I2C控制器，对应struct i2c_adapter结构体；Linux中用i2c_adapter来表示一个I2C控制器，一个i2c_adapter结构体对应的就是SOC上的I2C控制器；所有的设备驱动都需要经过i2c_adapter对象的处理才能和物理设备通信；通过i2c_core层将I2C设备与i2c adapter关联起来，用来完成i2c总线控制器相关的数据通信，此结构体在芯片厂商提供的代码中维护；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/i2c.h</span><br><span class="line">struct i2c_adapter &#123;</span><br><span class="line">    struct module *owner;</span><br><span class="line">    unsigned int class;       /* classes to allow probing for */</span><br><span class="line">    const struct i2c_algorithm *algo; /* the algorithm to access the bus */</span><br><span class="line">    void *algo_data;</span><br><span class="line"></span><br><span class="line">    /* data fields that are valid for all devices   */</span><br><span class="line">    const struct i2c_lock_operations *lock_ops;</span><br><span class="line">    struct rt_mutex bus_lock;</span><br><span class="line">    struct rt_mutex mux_lock;</span><br><span class="line"></span><br><span class="line">    int timeout;            /* in jiffies */</span><br><span class="line">    int retries;</span><br><span class="line">    struct device dev;      /* the adapter device */</span><br><span class="line"></span><br><span class="line">    int nr;</span><br><span class="line">    char name[48];</span><br><span class="line">    struct completion dev_released;</span><br><span class="line"></span><br><span class="line">    struct mutex userspace_clients_lock;</span><br><span class="line">    struct list_head userspace_clients;</span><br><span class="line"></span><br><span class="line">    struct i2c_bus_recovery_info *bus_recovery_info;</span><br><span class="line">    const struct i2c_adapter_quirks *quirks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-I2C总线算法（i2c-algorithm）"><a href="#2-2-2-I2C总线算法（i2c-algorithm）" class="headerlink" title="2.2.2 I2C总线算法（i2c_algorithm）"></a>2.2.2 I2C总线算法（i2c_algorithm）</h5><p>I2C总线数据通信算法，通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；</p>
<p>struct i2c_algorithm数据结构，是i2c控制器数据通信需要的控制算法，对应的是I2C的时序；通过管理I2C总线控制器，实现对I2C总线上数据的发送和接收等操作；用来描述适配器和设备之间的通信方法，由芯片厂商实现；</p>
<p>最重要的成员是master_xfer()函数，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/i2c.h</span><br><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">               int num);</span><br><span class="line">    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">               unsigned short flags, char read_write,</span><br><span class="line">               u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    /* To determine what the adapter supports */</span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span><br><span class="line">    int (*reg_slave)(struct i2c_client *client);</span><br><span class="line">    int (*unreg_slave)(struct i2c_client *client);</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>master_xfer：最重要的接口，这个接口是硬件相关的，操作内容都是I2C控制器的寄存器，最终完成将数据发送到物理I2C控制器；该函数返回成功发送的消息数，错误返回负数；</p>
</blockquote>
<p>device_driver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/device.h</span><br><span class="line">struct device_driver &#123;</span><br><span class="line">    const char      *name;</span><br><span class="line">    struct bus_type     *bus;</span><br><span class="line"></span><br><span class="line">    struct module       *owner;</span><br><span class="line">    const char      *mod_name;  /* used for built-in modules */</span><br><span class="line"></span><br><span class="line">    bool suppress_bind_attrs;   /* disables bind/unbind via sysfs */</span><br><span class="line">    enum probe_type probe_type;</span><br><span class="line"></span><br><span class="line">    const struct of_device_id   *of_match_table;</span><br><span class="line">    const struct acpi_device_id *acpi_match_table;</span><br><span class="line"></span><br><span class="line">    int (*probe) (struct device *dev);</span><br><span class="line">    int (*remove) (struct device *dev);</span><br><span class="line">    void (*shutdown) (struct device *dev);</span><br><span class="line">    int (*suspend) (struct device *dev, pm_message_t state);</span><br><span class="line">    int (*resume) (struct device *dev);</span><br><span class="line">    const struct attribute_group **groups;</span><br><span class="line"></span><br><span class="line">    const struct dev_pm_ops *pm; </span><br><span class="line"></span><br><span class="line">    struct driver_private *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-I2C总线类型"><a href="#2-2-3-I2C总线类型" class="headerlink" title="2.2.3 I2C总线类型"></a>2.2.3 I2C总线类型</h5><p>I2C总线对应着/bus/目录下的一个总线；维护I2C设备和I2C驱动两个链表，管理I2C设备和I2C的匹配和删除；是SOC上I2C控制器的抽象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/device.h</span><br><span class="line">struct bus_type &#123;</span><br><span class="line">    const char      *name;</span><br><span class="line">    const char      *dev_name;</span><br><span class="line">    struct device       *dev_root;</span><br><span class="line">    struct device_attribute *dev_attrs; /* use dev_groups instead */</span><br><span class="line">    const struct attribute_group **bus_groups;</span><br><span class="line">    const struct attribute_group **dev_groups;</span><br><span class="line">    const struct attribute_group **drv_groups;</span><br><span class="line"></span><br><span class="line">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    int (*probe)(struct device *dev);</span><br><span class="line">    int (*remove)(struct device *dev);</span><br><span class="line">    void (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    int (*online)(struct device *dev);</span><br><span class="line">    int (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class="line">    int (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    const struct dev_pm_ops *pm; </span><br><span class="line"></span><br><span class="line">    const struct iommu_ops *iommu_ops;</span><br><span class="line"></span><br><span class="line">    struct subsys_private *p;</span><br><span class="line">    struct lock_class_key lock_key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">struct bus_type i2c_bus_type = &#123;</span><br><span class="line">    .name       = &quot;i2c&quot;,</span><br><span class="line">    .match      = i2c_device_match,</span><br><span class="line">    .probe      = i2c_device_probe,</span><br><span class="line">    .remove     = i2c_device_remove,</span><br><span class="line">    .shutdown   = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>

<p>I2C总线bus_type结构体管理着i2c设备和i2c驱动的匹配、删除操作，i2c会调用i2c_device_match函数对比i2c设备和i2c驱动是否匹配，如果匹配就调用i2c_device_probe函数，进而调用i2c驱动的probe函数；</p>
<h4 id="2-3-总线层和设备层关系"><a href="#2-3-总线层和设备层关系" class="headerlink" title="2.3 总线层和设备层关系"></a>2.3 总线层和设备层关系</h4><p>在设备层，i2c_client通过adapter指针，指向总线层的i2c_adapter，和总线层存在关系；</p>
<p>在总线层，i2c_adapter通过algo指针，指向i2c_algorithm，进一步调用i2c_algorithm中的算法，如：master_xfer()，进行实际的数据发送和接收；</p>
<p>总线层</p>
<p>struct i2c_adapter       I2C适配器（主机CPU的I2C控制器）</p>
<p>struct i2c_algorithm       I2C算法（I2C的收、发时序控制）</p>
<p>设备层</p>
<p>struct i2c_client       I2C（从机）设备信息</p>
<p>struct i2c_driver       I2C（从机）设备驱动信息</p>
<p><img src="/2020/04/06/Linux-kernel中的I2C子系统/I2C%E6%80%BB%E7%BA%BF%E5%B1%82%E5%92%8C%E8%AE%BE%E5%A4%87%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="I2C总线层和设备层的关系"></p>
<h4 id="2-4-数据结构间的关系"><a href="#2-4-数据结构间的关系" class="headerlink" title="2.4 数据结构间的关系"></a>2.4 数据结构间的关系</h4><p><img src="/2020/04/06/Linux-kernel中的I2C子系统/I2C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="I2C数据结构间的关系"></p>
<h3 id="3-重要的操作函数"><a href="#3-重要的操作函数" class="headerlink" title="3. 重要的操作函数"></a>3. 重要的操作函数</h3><h4 id="3-1-I2C子系统初始化"><a href="#3-1-I2C子系统初始化" class="headerlink" title="3.1 I2C子系统初始化"></a>3.1 I2C子系统初始化</h4><h5 id="3-1-1-I2C总线初始化"><a href="#3-1-1-I2C总线初始化" class="headerlink" title="3.1.1 I2C总线初始化"></a>3.1.1 I2C总线初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/init.h</span><br><span class="line">#define postcore_initcall(fn)       __define_initcall(fn, 2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/init.h</span><br><span class="line">#define __define_initcall(fn, id) \</span><br><span class="line">    static initcall_t __initcall_##fn##id __used \</span><br><span class="line">    __attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) = fn;</span><br></pre></td></tr></table></figure>

<p>postcore_initcall(i2c_init)操作，会在编译内核时，将函数指针变量__initcall_i2c_init放到名称为initcall2.init的section中；即将i2c_init()函数的首地址放到名称为initcall2.init的section中；</p>
<p>Linux设备启动时，会在do_basic_setup()函数中，通过driver_init()和do_initcalls()函数，调用到i2c_init()函数，对I2C总线初始化；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    retval = bus_register(&amp;i2c_bus_type);</span><br><span class="line">    ......</span><br><span class="line">    i2c_adapter_compat_class = class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">    ......</span><br><span class="line">    retval = i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过bus_register()函数，在系统中注册一个新的总线i2c_bus_type，name: i2c；适配器设备、I2C设备、I2C设备驱动程序都会连接到这条总线上；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">struct bus_type i2c_bus_type = &#123;</span><br><span class="line">    .name       = &quot;i2c&quot;,</span><br><span class="line">    .match      = i2c_device_match,</span><br><span class="line">    .probe      = i2c_device_probe,</span><br><span class="line">    .remove     = i2c_device_remove,</span><br><span class="line">    .shutdown   = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>

<p>通过i2c_add_driver()函数，向I2C总线注册一个空的I2C设备驱动程序；可以不用关心；</p>
<pre class="mermaid">graph TB
    i2c_init1(i2c_init)-->bus_register1(bus_register)
    subgraph i2c_init
        bus_register1(bus_register)-->
        class_compat_register(class_compat_register)-->
        i2c_add_driver(i2c_add_driver)
    end</pre>



<p>注册过程中发生异常错误时，需要使用对应的函数进行反向操作：</p>
<pre class="mermaid">graph TB
    class_compat_register(class_compat_register)
    class_compat_unregister(class_compat_unregister)</pre>



<pre class="mermaid">graph TB
    bus_register(bus_register) 
    bus_unregister(bus_unregister)</pre>



<h5 id="3-1-2-I2C总线退出"><a href="#3-1-2-I2C总线退出" class="headerlink" title="3.1.2 I2C总线退出"></a>3.1.2 I2C总线退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">static void __exit i2c_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (IS_ENABLED(CONFIG_ACPI))</span><br><span class="line">        WARN_ON(acpi_reconfig_notifier_unregister(&amp;i2c_acpi_notifier));</span><br><span class="line">    if (IS_ENABLED(CONFIG_OF_DYNAMIC))</span><br><span class="line">        WARN_ON(of_reconfig_notifier_unregister(&amp;i2c_of_notifier));</span><br><span class="line">    i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">#endif</span><br><span class="line">    bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">    tracepoint_synchronize_unregister();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_del_driver()函数，用来从I2C总线注销设备驱动程序；和i2c_add_driver()函数功能相反；</p>
<pre class="mermaid">graph TB
    i2c_add_driver(i2c_add_driver) 
    i2c_del_driver(i2c_del_driver)</pre>



<h4 id="3-2-适配器驱动"><a href="#3-2-适配器驱动" class="headerlink" title="3.2 适配器驱动"></a>3.2 适配器驱动</h4><p>适配器驱动程序是I2C设备驱动程序需要实现的主要驱动程序，需要根据具体的适配器硬件编写；</p>
<p>使用内核提供的框架函数向I2C子系统中添加一个新的适配器；i2c_adapter结构体为描述各种I2C适配器提供了通用的封装，但是i2c_adapter结构体只是所有适配器的共有属性，并不能代表所有类型的适配器；</p>
<p>添加新的适配器的过程：</p>
<blockquote>
<p>分配一个I2C适配器，并初始化一个i2c_adapter结构体，及相应的变量</p>
<p>使用i2c_add_adapter()函数向I2C子系统添加适配器结构体i2c_adapter</p>
</blockquote>
<h5 id="3-2-1-添加适配器驱动"><a href="#3-2-1-添加适配器驱动" class="headerlink" title="3.2.1 添加适配器驱动"></a>3.2.1 添加适配器驱动</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(struct i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">        id = of_alias_get_id(dev-&gt;of_node, <span class="string">"i2c"</span>);</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">            adapter-&gt;nr = id;</span><br><span class="line">            <span class="keyword">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">               __i2c_first_dynamic_bus_num, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    <span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">"couldn't get idr"</span>))</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">    adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2c_register_adapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_add_adapter);</span><br></pre></td></tr></table></figure>

<p>通过i2c_register_adapter()函数，向内核注册一个适配器设备adapter；</p>
<pre class="mermaid">graph TB
    i2c_add_adapter(i2c_add_adapter)
    -->i2c_register_adapter(i2c_register_adapter)</pre>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_register_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -EINVAL;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">/* Sanity checks */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN(!adap-&gt;name[<span class="number">0</span>], <span class="string">"i2c adapter has no name"</span>))</span><br><span class="line">        <span class="keyword">goto</span> out_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!adap-&gt;algo) &#123;</span><br><span class="line">        pr_err(<span class="string">"adapter '%s': no algo supplied!\n"</span>, adap-&gt;name);</span><br><span class="line">        <span class="keyword">goto</span> out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!adap-&gt;lock_ops)</span><br><span class="line">        adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;timeout == <span class="number">0</span>)</span><br><span class="line">        adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">    dev_set_name(&amp;adap-&gt;dev, <span class="string">"i2c-%d"</span>, adap-&gt;nr);</span><br><span class="line">    adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">    adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class="line">    res = device_register(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">    pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span><br><span class="line">    pm_suspend_ignore_children(&amp;adap-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">    pm_runtime_enable(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">    res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">                       adap-&gt;dev.parent);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    i2c_init_recovery(adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    of_i2c_register_devices(adap);</span><br><span class="line">    i2c_acpi_register_devices(adap);</span><br><span class="line">    i2c_acpi_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">        i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify drivers */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_drv(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap, __process_new_adapter);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-注销适配器驱动"><a href="#3-2-2-注销适配器驱动" class="headerlink" title="3.2.2 注销适配器驱动"></a>3.2.2 注销适配器驱动</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // drivers/i2c/i2c-core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_del_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">found</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First make sure that this adapter was ever added */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    found = idr_find(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    <span class="keyword">if</span> (found != adap) &#123;</span><br><span class="line">        pr_debug(<span class="string">"attempting to delete unregistered adapter [%s]\n"</span>, adap-&gt;name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i2c_acpi_remove_space_handler(adap);</span><br><span class="line">    <span class="comment">/* Tell drivers about this removal */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_drv(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap,</span><br><span class="line">                   __process_removed_adapter);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove devices instantiated from sysfs */</span></span><br><span class="line">    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">              i2c_adapter_depth(adap));</span><br><span class="line">    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">                 detected) &#123;</span><br><span class="line">        list_del(&amp;client-&gt;detected);</span><br><span class="line">        i2c_unregister_device(client);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    device_for_each_child(&amp;adap-&gt;dev, <span class="literal">NULL</span>, __unregister_client);</span><br><span class="line">    device_for_each_child(&amp;adap-&gt;dev, <span class="literal">NULL</span>, __unregister_dummy);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">    class_compat_remove_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">                 adap-&gt;dev.parent);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    pm_runtime_disable(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">    init_completion(&amp;adap-&gt;dev_released);</span><br><span class="line">    device_unregister(&amp;adap-&gt;dev);</span><br><span class="line">    wait_for_completion(&amp;adap-&gt;dev_released);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free bus id */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear the device structure in case this adapter is ever going to be</span></span><br><span class="line"><span class="comment">       added again */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;adap-&gt;dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(adap-&gt;dev));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_del_adapter);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-注册I2C驱动"><a href="#3-3-注册I2C驱动" class="headerlink" title="3.3 注册I2C驱动"></a>3.3 注册I2C驱动</h4><p>注册I2C驱动需要完成的操作：</p>
<blockquote>
<p>将I2C驱动添加到I2C总线的驱动链表中</p>
<p>遍历I2C总线上的I2C设备链表，根据i2c_device_match函数进行匹配，如果匹配就调用i2c_device_probe函数</p>
<p>i2c_device_probe函数会调用I2C驱动的probe函数</p>
</blockquote>
<h5 id="3-3-1-注册I2C驱动"><a href="#3-3-1-注册I2C驱动" class="headerlink" title="3.3.1 注册I2C驱动"></a>3.3.1 注册I2C驱动</h5><p>在I2C驱动程序中，通过i2c_add_driver()函数，来注册驱动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/i2c.h</span><br><span class="line">#define i2c_add_driver(driver) \</span><br><span class="line">    i2c_register_driver(THIS_MODULE, driver)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">    /* add the driver to the list of i2c drivers in the driver core */</span><br><span class="line">    driver-&gt;driver.owner = owner;</span><br><span class="line">    driver-&gt;driver.bus = &amp;i2c_bus_type;		// 绑定I2C总线 </span><br><span class="line">    INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line"></span><br><span class="line">    res = driver_register(&amp;driver-&gt;driver);		// 向I2C总线注册驱动</span><br><span class="line">	......</span><br><span class="line">    i2c_for_each_dev(driver, __process_new_driver);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_register_driver);</span><br></pre></td></tr></table></figure>

<p>在i2c_add_driver()函数中，做了三件事：</p>
<blockquote>
<p>绑定总线</p>
<p>向总线注册驱动 —- 重点</p>
<p>遍历总线的设备，调用__process_new_driver</p>
</blockquote>
<p>driver_register</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device_driver *other;</span><br><span class="line">	......</span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">	......</span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line"></span><br><span class="line">    ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(driver_register);</span><br></pre></td></tr></table></figure>

<p>driver_find()函数，在I2C总线中，找到name对应的I2C device_driver；</p>
<p>bus_add_driver()函数，将驱动添加到总线上；</p>
<pre class="mermaid">graph TB
    i2c_add_driver(i2c_add_driver)-->
    i2c_register_driver(i2c_register_driver)-->
    driver_register(driver_register)-->
    bus_add_driver(bus_add_driver)</pre>







<h5 id="3-3-2-注销I2C驱动"><a href="#3-3-2-注销I2C驱动" class="headerlink" title="3.3.2 注销I2C驱动"></a>3.3.2 注销I2C驱动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_for_each_dev(driver, __process_removed_driver);</span><br><span class="line"></span><br><span class="line">    driver_unregister(&amp;driver-&gt;driver);</span><br><span class="line">    pr_debug(&quot;driver [%s] unregistered\n&quot;, driver-&gt;driver.name);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_del_driver);</span><br></pre></td></tr></table></figure>

<h4 id="3-4-注册I2C设备"><a href="#3-4-注册I2C设备" class="headerlink" title="3.4 注册I2C设备"></a>3.4 注册I2C设备</h4><h5 id="3-4-1-注册I2C设备"><a href="#3-4-1-注册I2C设备" class="headerlink" title="3.4.1 注册I2C设备"></a>3.4.1 注册I2C设备</h5><p>I2C通过i2c_new_device()函数，来添加一个I2C设备；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">struct i2c_client *</span><br><span class="line">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client;</span><br><span class="line">    int         status;</span><br><span class="line"></span><br><span class="line">    client = kzalloc(sizeof *client, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    client-&gt;adapter = adap;		// 指定设备的适配器</span><br><span class="line"></span><br><span class="line">    client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line"></span><br><span class="line">    if (info-&gt;archdata)</span><br><span class="line">        client-&gt;dev.archdata = *info-&gt;archdata;</span><br><span class="line"></span><br><span class="line">    client-&gt;flags = info-&gt;flags;</span><br><span class="line">    client-&gt;addr = info-&gt;addr;</span><br><span class="line">    client-&gt;irq = info-&gt;irq;</span><br><span class="line"></span><br><span class="line">    strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));</span><br><span class="line"></span><br><span class="line">    status = i2c_check_addr_validity(client-&gt;addr, client-&gt;flags);</span><br><span class="line"></span><br><span class="line">	/* Check for address business */</span><br><span class="line">    status = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));</span><br><span class="line"></span><br><span class="line">    client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">    client-&gt;dev.bus = &amp;i2c_bus_type;	// 绑定I2C总线</span><br><span class="line">    client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">    client-&gt;dev.of_node = info-&gt;of_node;</span><br><span class="line">    client-&gt;dev.fwnode = info-&gt;fwnode;</span><br><span class="line"></span><br><span class="line">    i2c_dev_set_name(adap, client);</span><br><span class="line">    status = device_register(&amp;client-&gt;dev);		// 向总线注册设备</span><br><span class="line">	......</span><br><span class="line">    return client;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_new_device);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/i2c.h</span><br><span class="line">struct i2c_board_info &#123;</span><br><span class="line">    char        type[I2C_NAME_SIZE];	// 设备名称，用于与驱动匹配</span><br><span class="line">    unsigned short  flags;</span><br><span class="line">    unsigned short  addr;	// 设备地址</span><br><span class="line">    void        *platform_data;</span><br><span class="line">    struct dev_archdata *archdata;</span><br><span class="line">    struct device_node *of_node;</span><br><span class="line">    struct fwnode_handle *fwnode;</span><br><span class="line">    int     irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct i2c_board_info结构体描述了设备的硬件信息；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/core.c</span><br><span class="line">int device_register(struct device *dev)</span><br><span class="line">&#123;   </span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    return device_add(dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
    i2c_new_device(i2c_new_device)-->
    device_register(device_register)-->
    device_initialize(device_initialize)
    device_register-->device_add(device_add)</pre>



<p>device_initialize()函数用来初始化I2C设备的device结构体；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/core.c</span><br><span class="line">void device_initialize(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    dev-&gt;kobj.kset = devices_kset;</span><br><span class="line">    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">    mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">    spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">    device_pm_init(dev);</span><br><span class="line">    set_dev_node(dev, -1);</span><br><span class="line">#ifdef CONFIG_GENERIC_MSI_IRQ</span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_initialize);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">int device_add(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct device *parent = NULL;</span><br><span class="line">    struct kobject *kobj;</span><br><span class="line">    struct class_interface *class_intf;</span><br><span class="line">    int error = -EINVAL;</span><br><span class="line">    struct kobject *glue_dir = NULL;</span><br><span class="line"></span><br><span class="line">    dev = get_device(dev);</span><br><span class="line"></span><br><span class="line">    if (!dev-&gt;p) &#123;</span><br><span class="line">        error = device_private_init(dev);</span><br><span class="line">        if (error)</span><br><span class="line">            goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dev-&gt;init_name) &#123;</span><br><span class="line">        dev_set_name(dev, &quot;%s&quot;, dev-&gt;init_name);</span><br><span class="line">        dev-&gt;init_name = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">        dev_set_name(dev, &quot;%s%u&quot;, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line"></span><br><span class="line">    parent = get_device(dev-&gt;parent);</span><br><span class="line">    kobj = get_device_parent(dev, parent);</span><br><span class="line"></span><br><span class="line">    if (kobj)</span><br><span class="line">        dev-&gt;kobj.parent = kobj;</span><br><span class="line">    if (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE))</span><br><span class="line">        set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">    error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);</span><br><span class="line"></span><br><span class="line">    if (platform_notify)</span><br><span class="line">        platform_notify(dev);</span><br><span class="line"></span><br><span class="line">    error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"></span><br><span class="line">    error = device_add_class_symlinks(dev);</span><br><span class="line"></span><br><span class="line">    error = device_add_attrs(dev);</span><br><span class="line"></span><br><span class="line">    error = bus_add_device(dev);</span><br><span class="line"></span><br><span class="line">    error = dpm_sysfs_add(dev);</span><br><span class="line"></span><br><span class="line">    device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">    if (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line"></span><br><span class="line">        error = device_create_sys_dev_entry(dev);</span><br><span class="line"></span><br><span class="line">        devtmpfs_create_node(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line"></span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line">    if (parent)</span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">                   &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">    if (dev-&gt;class) &#123;</span><br><span class="line">        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">        klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">        list_for_each_entry(class_intf,</span><br><span class="line">                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">            if (class_intf-&gt;add_dev)</span><br><span class="line">                class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_add);</span><br></pre></td></tr></table></figure>

<p>device_addbus_add_devicebus_probe_device</p>
<h5 id="3-4-2-注销I2C设备"><a href="#3-4-2-注销I2C设备" class="headerlink" title="3.4.2 注销I2C设备"></a>3.4.2 注销I2C设备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">void i2c_unregister_device(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    if (client-&gt;dev.of_node)</span><br><span class="line">        of_node_clear_flag(client-&gt;dev.of_node, OF_POPULATED);</span><br><span class="line">    if (ACPI_COMPANION(&amp;client-&gt;dev))</span><br><span class="line">        acpi_device_clear_enumerated(ACPI_COMPANION(&amp;client-&gt;dev));</span><br><span class="line">    device_unregister(&amp;client-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_unregister_device);</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
    i2c_new_device(i2c_new_device)
    i2c_unregister_device(i2c_unregister_device)</pre>





<h4 id="3-5-适配器和设备通信"><a href="#3-5-适配器和设备通信" class="headerlink" title="3.5 适配器和设备通信"></a>3.5 适配器和设备通信</h4><p>I2C总线通信方式是对特定的I2C适配器使用i2c_transfer()函数，调用i2c_algothrim的master_xfer()方法实现i2c_msg消息的传输；不同的适配器，对应的master_xfer()方法由控制器的硬件决定，由芯片厂商提供；</p>
<h5 id="3-5-1-i2c-transfer"><a href="#3-5-1-i2c-transfer" class="headerlink" title="3.5.1 i2c_transfer"></a>3.5.1 i2c_transfer</h5><p>在I2C设备和I2C驱动匹配之后，驱动程序和设备的通讯，通过i2c_transfer()函数来给设备发送信息；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    if (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">		......</span><br><span class="line">        ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>

<p>i2c_transfer()函数是i2c核心提供给设备驱动的发送方法，该函数发送的数据需要被打包成i2c_msg结构，该函数最终会回调i2c_adapter-&gt;i2c_algorithm-&gt;master_xfer()函数，将i2c_msg对象发送到i2c的物理控制器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long orig_jiffies;</span><br><span class="line">    int ret, try;</span><br><span class="line"></span><br><span class="line">    if (adap-&gt;quirks &amp;&amp; i2c_check_for_quirks(adap, msgs, num))</span><br><span class="line">        return -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">    if (static_key_false(&amp;i2c_trace_msg)) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; num; i++)</span><br><span class="line">            if (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">                trace_i2c_read(adap, &amp;msgs[i], i);</span><br><span class="line">            else</span><br><span class="line">                trace_i2c_write(adap, &amp;msgs[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    orig_jiffies = jiffies;</span><br><span class="line">    for (ret = 0, try = 0; try &lt;= adap-&gt;retries; try++) &#123;</span><br><span class="line">        ret = adap-&gt;algo-&gt;master_xfer(adap, msgs, num);		// 发送、接收信息操作</span><br><span class="line">        if (ret != -EAGAIN)</span><br><span class="line">            break;</span><br><span class="line">        if (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__i2c_transfer);</span><br></pre></td></tr></table></figure>

<p>最终，通过adap-&gt;algo-&gt;master_xfer()函数，将struct i2c_msg结构体类型的消息，通过适配器的struct i2c_adapter发送给设备，或者从设备中读取信息；</p>
<h5 id="3-5-2-消息格式"><a href="#3-5-2-消息格式" class="headerlink" title="3.5.2 消息格式"></a>3.5.2 消息格式</h5><p>经过mster_xfer()函数发送、接收的消息类型应该按照struct i2c_msg结构体格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/i2c.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">    __u16 addr; <span class="comment">/* slave address            */</span></span><br><span class="line">    __u16 flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  <span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    __u16 len;      <span class="comment">/* msg length               */</span></span><br><span class="line">    __u8 *buf;      <span class="comment">/* pointer to msg data          */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I2C传输数据是以字节为单位的，具体到i2c_msg结构体，buf表示要传输的数据，len表示传输的数据字节数；</p>
<p>I2C读取，即封装的xxx_i2c_read()函数，需要两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>
<p>I2C写入，即封装的xxx_i2c_write()函数，仅由一个i2c_msg组成；i2c_msg的buf，保存从slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；</p>
</blockquote>
<p>注意：以数组格式定义i2c_msg是为了访问连续，因为数组是连续内存存储的；</p>
<h5 id="3-5-3-消息发送、接收函数"><a href="#3-5-3-消息发送、接收函数" class="headerlink" title="3.5.3 消息发送、接收函数"></a>3.5.3 消息发送、接收函数</h5><h6 id="1）发送函数"><a href="#1）发送函数" class="headerlink" title="1）发送函数"></a>1）发送函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">int i2c_master_send(const struct i2c_client *client, const char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.len = count;</span><br><span class="line">    msg.buf = (char *)buf;</span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(adap, &amp;msg, 1);</span><br><span class="line"></span><br><span class="line">    return (ret == 1) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_master_send);</span><br></pre></td></tr></table></figure>

<p>I2C发送消息操作时，仅需要一个i2c_msg；i2c_msg的buf，保存slave的目标寄存器地址和要写入的数据，len表示期望写入的数据字节长度；如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2c_master_send(client, data, len);</span><br></pre></td></tr></table></figure>

<h6 id="2）接收函数"><a href="#2）接收函数" class="headerlink" title="2）接收函数"></a>2）接收函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">int i2c_master_recv(const struct i2c_client *client, char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.flags |= I2C_M_RD;</span><br><span class="line">    msg.len = count;</span><br><span class="line">    msg.buf = buf;</span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(adap, &amp;msg, 1);</span><br><span class="line"></span><br><span class="line">    return (ret == 1) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_master_recv);</span><br></pre></td></tr></table></figure>

<p>I2C接收消息操作时，需要给从设备发送两个i2c_msg组成的数组；第一个i2c_msg的buf，保存master向slave发出目标寄存器地址，并使用buf指针指向这个地址，len表示寄存器地址字节长度；第二个i2c_msg的buf，用来接收slave向master返回的数据，len表示期望读到的数据字节长度；</p>
<p>也可以分两次，先使用i2c_master_send()函数，向slave发出目标寄存器地址，在使用i2c_master_recv()函数，用来接收读取到的数据消息；如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2c_master_send(client, reg, <span class="number">2</span>); </span><br><span class="line">i2c_master_recv(client, data, len);</span><br></pre></td></tr></table></figure>

<h3 id="4-添加设备"><a href="#4-添加设备" class="headerlink" title="4. 添加设备"></a>4. 添加设备</h3><p>在内核中的Documentation/i2c/instantiating-devices文件中，讲述了添加设备的方法；</p>
<p>i2c_client结构是通过以下方式自动创建：</p>
<blockquote>
<p>分配、设置、注册i2c_board_info</p>
<p>获取i2c_adapter，调用i2c_new_device</p>
<p>通过设备树（DeviceTree）创建</p>
</blockquote>
<h4 id="4-1-添加设备树"><a href="#4-1-添加设备树" class="headerlink" title="4.1 添加设备树"></a>4.1 添加设备树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Image-fsl-lx2160a-rdb-new.dts</span><br><span class="line">        i2c@2030000 &#123;</span><br><span class="line">            compatible = &quot;fsl,vf610-i2c&quot;;</span><br><span class="line">            #address-cells = &lt;0x1&gt;;</span><br><span class="line">            #size-cells = &lt;0x0&gt;;</span><br><span class="line">            reg = &lt;0x0 0x2030000 0x0 0x10000&gt;;</span><br><span class="line">            interrupts = &lt;0x0 0x23 0x4&gt;;</span><br><span class="line">            scl-gpios=&lt;&amp;gpio4 8 0x0&gt;;</span><br><span class="line">            clock-names = &quot;i2c&quot;;</span><br><span class="line">            clocks = &lt;0x2 0x4 0x7&gt;;</span><br><span class="line">            status = &quot;okay&quot;;</span><br><span class="line">            rtc@32 &#123;</span><br><span class="line">                compatible = &quot;Micro Crystal,rv8803&quot;;</span><br><span class="line">                reg = &lt;0x32&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            eeprom_mcy@51 &#123;</span><br><span class="line">                compatible = &quot;mcy,eeprom_mcy&quot;;</span><br><span class="line">                reg = &lt;0x51&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># ls /sys/bus/i2c/devices/</span><br><span class="line">2-0032  2-0051  i2c-0   i2c-1   i2c-2   i2c-3 </span><br><span class="line"># ls /sys/bus/i2c/devices/ -l</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0032 -&gt; ../../../devices/platform/soc/2030000.i2c/i2c-2/2-0032</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 2-0051 -&gt; ../../../devices/platform/soc/2030000.i2c/i2c-2/2-0051</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-0 -&gt; ../../../devices/platform/soc/2000000.i2c/i2c-0</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-1 -&gt; ../../../devices/platform/soc/2010000.i2c/i2c-1</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-2 -&gt; ../../../devices/platform/soc/2030000.i2c/i2c-2</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:26 i2c-3 -&gt; ../../../devices/platform/soc/2050000.i2c/i2c-3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ls /sys/bus/i2c/devices/2-0051/</span><br><span class="line">consumers  modalias   name       of_node    subsystem  suppliers  uevent</span><br><span class="line"># ls /sys/bus/i2c/devices/2-0051/ -l</span><br><span class="line">total 0</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 15 03:27 consumers</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 15 03:27 modalias</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 15 03:27 name</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:27 of_node -&gt; ../../../../../../firmware/devicetree/base/soc/i2c@2030000/eeprom_mcy@51</span><br><span class="line">lrwxrwxrwx    1 root     root             0 Oct 15 03:27 subsystem -&gt; ../../../../../../bus/i2c</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 15 03:27 suppliers</span><br><span class="line">-rw-r--r--    1 root     root          4096 Oct 15 03:27 uevent</span><br><span class="line"># cat /sys/bus/i2c/devices/2-0051/name</span><br><span class="line">eeprom_mcy</span><br></pre></td></tr></table></figure>

<h4 id="4-2-i2c-new-device添加"><a href="#4-2-i2c-new-device添加" class="headerlink" title="4.2 i2c_new_device添加"></a>4.2 i2c_new_device添加</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">eeprom_info</span> = &#123;</span> </span><br><span class="line">    I2C_BOARD_INFO(<span class="string">"eeprom_device"</span>, <span class="number">0x51</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eeprom_device_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    adap = i2c_get_adapter(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!adap) &#123;</span><br><span class="line">        printk(<span class="string">"%s, i2c_get_adapter failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    client = i2c_new_device(adap, &amp;eeprom_info);</span><br><span class="line">    <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">        printk(<span class="string">"%s, i2c_new_device failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    i2c_put_adapter(adap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eeprom_device_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    i2c_unregister_device(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(eeprom_device_init);</span><br><span class="line">module_exit(eeprom_device_exit);</span><br></pre></td></tr></table></figure>

<h4 id="4-3-静态注册I2C设备"><a href="#4-3-静态注册I2C设备" class="headerlink" title="4.3 静态注册I2C设备"></a>4.3 静态注册I2C设备</h4><p>内核提供了一种静态注册I2C设备的方法，通过i2c_register_board_info()函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-boardinfo.c</span><br><span class="line">int i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    if (busnum &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num = busnum + 1;</span><br><span class="line"></span><br><span class="line">    for (status = 0; len; len--, info++) &#123;</span><br><span class="line">        struct i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum = busnum;</span><br><span class="line">        devinfo-&gt;board_info = *info;</span><br><span class="line">        list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);</span><br><span class="line">    &#125;   </span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在系统初始化过程中，可以通过i2c_register_board_info()函数，将需要的I2C设备添加到__i2c_board_list链表；系统在成功加载I2C适配器adapter后，会对这个__i2c_board_list链表中所有的设备逐一完成i2c_client的注册；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.h</span><br><span class="line">struct i2c_devinfo &#123;</span><br><span class="line">    struct list_head    list;</span><br><span class="line">    int         busnum;</span><br><span class="line">    struct i2c_board_info   board_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>系统初始化时，根据I2C设备配置信息，创建I2C设备（i2c_client），并添加到I2C子系统；</p>
<p>最终是在i2c_scan_static_board_info()函数中，通过调用i2c_new_device()函数来实现添加设备；i2c_scan_static_board_info()函数一般在初始化时工作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">static void i2c_scan_static_board_info(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(devinfo, &amp;__i2c_board_list, list) &#123;</span><br><span class="line">        if (devinfo-&gt;busnum == adapter-&gt;nr</span><br><span class="line">                &amp;&amp; !i2c_new_device(adapter,</span><br><span class="line">                        &amp;devinfo-&gt;board_info))</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-添加驱动"><a href="#5-添加驱动" class="headerlink" title="5. 添加驱动"></a>5. 添加驱动</h3><p>以eeprom为例；</p>
<h4 id="5-1-I2C设备驱动框架"><a href="#5-1-I2C设备驱动框架" class="headerlink" title="5.1 I2C设备驱动框架"></a>5.1 I2C设备驱动框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mcy_eeprom_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    i2c_add_driver(&amp;mcy_eeprom_driver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mcy_eeprom_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    i2c_del_driver(&amp;mcy_eeprom_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mcy_eeprom_init);</span><br><span class="line">module_exit(mcy_eeprom_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">mcy_eeprom_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .name = <span class="string">"mcy_eeprom"</span>,</span><br><span class="line">        <span class="comment">//.of_match_table = mcy_eeprom_table,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = mcy_eeprom_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = mcy_eeprom_remove,</span><br><span class="line">    .id_table = mcy_eeprom_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
    eeprom_init(eeprom_init)-->
    i2c_add_driver(i2c_add_driver)-->eeprom_driver(eeprom_driver)
    eeprom_driver-->driver(driver)
    eeprom_driver-->probe(probe)
    eeprom_driver-->remove(remove)
    eeprom_driver-->id_table(id_table)</pre>



<h4 id="5-2-probe函数"><a href="#5-2-probe函数" class="headerlink" title="5.2 probe函数"></a>5.2 probe函数</h4><h5 id="1）注册字符设备"><a href="#1）注册字符设备" class="headerlink" title="1）注册字符设备"></a>1）注册字符设备</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcy_eeprom_probe</span><span class="params">(struct i2c_client *client, <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    eeprom_driver.client = client;</span><br><span class="line"></span><br><span class="line">    ret = alloc_chrdev_region(&amp;devnum, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"mcy_eeprom_chrdev"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, alloc_chrdev_region failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> chrdev_err;</span><br><span class="line">    &#125;   </span><br><span class="line">    printk(<span class="string">"%s, alloc_chrdev_region, devnum: %d\n"</span>, __func__, devnum);</span><br><span class="line"></span><br><span class="line">    cdev = cdev_alloc();</span><br><span class="line">    cdev_init(cdev, &amp;mcy_eeprom_fops);</span><br><span class="line">    ret = cdev_add(cdev, devnum, <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">"%s, cdev_add failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> cdev_err;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// /sys/class</span></span><br><span class="line">    dev_class = class_create(THIS_MODULE, <span class="string">"mcy_eeprom_class"</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev_class)) &#123;</span><br><span class="line">        printk(<span class="string">"%s, dev_class class_create failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> class_err;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// /dev</span></span><br><span class="line">    device_create(dev_class, <span class="literal">NULL</span>, devnum, <span class="literal">NULL</span>, <span class="string">"mcy_eeprom0"</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s, OK!\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line">    cdev_del(cdev);</span><br><span class="line">cdev_err:</span><br><span class="line">    unregister_chrdev_region(devnum, <span class="number">1</span>); </span><br><span class="line">chrdev_err:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）卸载函数"><a href="#2）卸载函数" class="headerlink" title="2）卸载函数"></a>2）卸载函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcy_eeprom_remove</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    device_destroy(dev_class, devnum);</span><br><span class="line">    class_destroy(dev_class);</span><br><span class="line">    cdev_del(cdev);</span><br><span class="line">    unregister_chrdev_region(devnum, <span class="number">1</span>);</span><br><span class="line">    kfree(cdev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）字符设备操作集"><a href="#3）字符设备操作集" class="headerlink" title="3）字符设备操作集"></a>3）字符设备操作集</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mcy_eeprom_fops</span>= &#123;</span></span><br><span class="line">    .<span class="built_in">open</span> = eeprom_driver_open,</span><br><span class="line">    .<span class="built_in">release</span> = eeprom_driver_release,</span><br><span class="line">    .<span class="built_in">read</span> = eeprom_driver_read,</span><br><span class="line">    .<span class="built_in">write</span> = eeprom_driver_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-读写函数"><a href="#5-3-读写函数" class="headerlink" title="5.3 读写函数"></a>5.3 读写函数</h4><p>I2C数据的发送和接收，是通过I2C驱动中file_operations的write和read系统调用来实现的；驱动中read和write的封装，是需要封装调用i2c_transfer()函数来完成i2d_msg消息的通信；read和write函数的封装，有两种方法；</p>
<h5 id="5-3-1-内核函数调用"><a href="#5-3-1-内核函数调用" class="headerlink" title="5.3.1 内核函数调用"></a>5.3.1 内核函数调用</h5><p>使用i2c-core.c提供的i2c_master_send()和i2c_master_recv()函数实现I2C信息的发送和接收；</p>
<h6 id="1）发送"><a href="#1）发送" class="headerlink" title="1）发送"></a>1）发送</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2c_master_send(client, data, len);</span><br></pre></td></tr></table></figure>

<p>I2C发送，直接调用i2c_master_send()函数，一次完成I2C数据的发送；</p>
<p>data：要发送的数据信息数组；其中data最前边的地址存放的是I2C从设备寄存器的地址，如果地址是8bits，就占用data[0]，如果地址是16bits，占用data[0]和data[1]；在地址之后，紧接着存放要发送的数据内容；</p>
<p>len：要发送的数据长度；包含I2C从设备寄存器地址和数据内容的总数据长度；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">eeprom_driver_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">18</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_from_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;data[<span class="number">2</span>], eeprom_data.data, eeprom_data.len);</span><br><span class="line">    data[<span class="number">0</span>] = (<span class="keyword">char</span>)((eeprom_data.reg &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    data[<span class="number">1</span>] = (<span class="keyword">char</span>)(eeprom_data.reg &amp; <span class="number">0x000000ff</span>);</span><br><span class="line">    len = eeprom_data.len + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        printk(<span class="string">"%s, data[%d]: 0x%2x\n"</span>, __func__, i, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    ret = i2c_master_send(eeprom_driver.client, data, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2）接收"><a href="#2）接收" class="headerlink" title="2）接收"></a>2）接收</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2c_master_send(client, reg, reg_len); </span><br><span class="line">i2c_master_recv(client, data, data_len);</span><br></pre></td></tr></table></figure>

<p>I2C接收不同于发送，需要两步来完成，先使用i2c_master_send()函数向I2C从设备发送要读取的寄存器地址；再使用i2c_master_recv()函数，从I2C从设备指定寄存器地址读取数据；</p>
<p>reg：要读取的从设备寄存器地址数组；如果地址是8bits，reg_len为1；如果地址是16bits，reg_len为2；</p>
<p>data：要读取的数据信息存放的指针地址；data_len为要读取的寄存器个数；</p>
<p>###### </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">eeprom_driver_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reg[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_from_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reg[<span class="number">0</span>] = (<span class="keyword">char</span>)((eeprom_data.reg &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>); </span><br><span class="line">    reg[<span class="number">1</span>] = (<span class="keyword">char</span>)(eeprom_data.reg &amp; <span class="number">0x000000ff</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    ret = i2c_master_send(eeprom_driver.client, reg, <span class="number">2</span>); </span><br><span class="line">    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eeprom_data.len; i++) &#123;</span><br><span class="line">        printk(<span class="string">"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\n"</span>, __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_to_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-直接封装"><a href="#5-3-2-直接封装" class="headerlink" title="5.3.2 直接封装"></a>5.3.2 直接封装</h5><p>直接通过封装i2c_msg消息，通过i2c_transfer()函数实现I2C信息的发送和接收；</p>
<h6 id="1）发送-1"><a href="#1）发送-1" class="headerlink" title="1）发送"></a>1）发送</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_send_bytes</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, <span class="keyword">unsigned</span> short reg, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    data = kmalloc(count + <span class="number">2</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        printk(<span class="string">"%s, kmalloc failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data[<span class="number">0</span>] = (<span class="keyword">char</span>)((reg &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    data[<span class="number">1</span>] = (<span class="keyword">char</span>)(reg &amp; <span class="number">0x000000ff</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;data[<span class="number">2</span>], buf, count);</span><br><span class="line">    len = count + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = <span class="number">0</span>;</span><br><span class="line">    msg.len = count;</span><br><span class="line">    msg.buf = data;</span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        kfree(data);</span><br><span class="line">        data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">eeprom_driver_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_from_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = i2c_send_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2）接收-1"><a href="#2）接收-1" class="headerlink" title="2）接收"></a>2）接收</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_recv_bytes</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, <span class="keyword">unsigned</span> short reg, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2] = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> txbuf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    txbuf[<span class="number">0</span>] = (<span class="keyword">char</span>)((reg &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    txbuf[<span class="number">1</span>] = (<span class="keyword">char</span>)(reg &amp; <span class="number">0x000000ff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg[<span class="number">0</span>].addr = client-&gt;addr;</span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;</span><br><span class="line">    msg[<span class="number">0</span>].len = <span class="number">2</span>;</span><br><span class="line">    msg[<span class="number">0</span>].buf = txbuf;</span><br><span class="line"></span><br><span class="line">    msg[<span class="number">1</span>].addr = client-&gt;addr;</span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;</span><br><span class="line">    msg[<span class="number">1</span>].len = count;</span><br><span class="line">    msg[<span class="number">1</span>].buf = buf;</span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">eeprom_driver_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_from_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = i2c_recv_bytes(eeprom_driver.client, eeprom_data.reg, eeprom_data.data, eeprom_data.len);</span><br><span class="line"></span><br><span class="line">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_to_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-驱动和设备匹配"><a href="#6-驱动和设备匹配" class="headerlink" title="6. 驱动和设备匹配"></a>6. 驱动和设备匹配</h3><p>设备和驱动的关系</p>
<p>对于一个驱动程序，有两个必不可少的元素，即：设备和驱动，驱动是通过设备名和驱动名建立联系；在i2c_adapter注册时会遍历i2c_board_info结构，会完成驱动和设备的匹配；</p>
<p>一个驱动程序，可以有多个名字，即一个驱动程序可以支持多个设备，该机制通过由i2c_device_id结构体组成的数组实现；该数组是在驱动中建立；I2C架构会扫描该结构体数组，逐一与设备进行匹配，匹配成功就会调用相应的probe函数；</p>
<p>进入驱动中的probe函数，要先进入总线的probe函数，而前提是设备与驱动的match匹配成功；</p>
<p>bus_add_driver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/bus.c</span><br><span class="line">int bus_add_driver(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    struct bus_type *bus;</span><br><span class="line">    struct driver_private *priv;</span><br><span class="line">    int error = 0; </span><br><span class="line"></span><br><span class="line">    bus = bus_get(drv-&gt;bus);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);</span><br><span class="line">    priv-&gt;driver = drv; </span><br><span class="line">    drv-&gt;p = priv;</span><br><span class="line">    priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">    error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,</span><br><span class="line">                     &quot;%s&quot;, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">    if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        if (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">            async_schedule(driver_attach_async, drv);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            error = driver_attach(drv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">    error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line"></span><br><span class="line">    error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line"></span><br><span class="line">    if (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">        error = add_bind_files(drv);</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/dd.c</span><br><span class="line">int driver_attach(struct device_driver *drv)</span><br><span class="line">&#123;               </span><br><span class="line">    return bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);</span><br><span class="line">&#125;       </span><br><span class="line">EXPORT_SYMBOL_GPL(driver_attach);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/bus.c</span><br><span class="line">int bus_for_each_dev(struct bus_type *bus, struct device *start,</span><br><span class="line">             void *data, int (*fn)(struct device *, void *))</span><br><span class="line">&#123;</span><br><span class="line">    struct klist_iter i;</span><br><span class="line">    struct device *dev;</span><br><span class="line">    int error = 0;</span><br><span class="line"></span><br><span class="line">    if (!bus || !bus-&gt;p)</span><br><span class="line">        return -EINVAL;</span><br><span class="line"></span><br><span class="line">    klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,</span><br><span class="line">                 (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));</span><br><span class="line">    while ((dev = next_device(&amp;i)) &amp;&amp; !error)</span><br><span class="line">        error = fn(dev, data);</span><br><span class="line">    klist_iter_exit(&amp;i);</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_for_each_dev);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/dd.c</span><br><span class="line">static int __driver_attach(struct device *dev, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    struct device_driver *drv = data;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    ret = driver_match_device(drv, dev);</span><br><span class="line">	......</span><br><span class="line">    if (!dev-&gt;driver)</span><br><span class="line">        driver_probe_device(drv, dev);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/base.h</span><br><span class="line">static inline int driver_match_device(struct device_driver *drv,</span><br><span class="line">                      struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/dd.c</span><br><span class="line">int driver_probe_device(struct device_driver *drv, struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    if (!device_is_registered(dev))</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    pr_debug(&quot;bus: &apos;%s&apos;: %s: matched device %s with driver %s\n&quot;,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    if (dev-&gt;parent)</span><br><span class="line">        pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    pm_runtime_barrier(dev);</span><br><span class="line">    ret = really_probe(dev, drv);</span><br><span class="line">    pm_request_idle(dev);</span><br><span class="line"></span><br><span class="line">    if (dev-&gt;parent)</span><br><span class="line">        pm_runtime_put(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// drivers/base/dd.c</span><br><span class="line">static int really_probe(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">        ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">    &#125; else if (drv-&gt;probe) &#123;</span><br><span class="line">        ret = drv-&gt;probe(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
    bus_add_driver(bus_add_driver)-->
    driver_attach(driver_attach)--bus_for_each_dev-->
    __driver_attach(__driver_attach)-->
    driver_match_device(driver_match_device)-->
    bus_match(drv->bus->match)
    __driver_attach-->driver_probe_device(driver_probe_device)-->
    really_probe(really_probe)-->
    bus_probe(dev->bus->probe)</pre>







<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c </span><br><span class="line">struct bus_type i2c_bus_type = &#123;</span><br><span class="line">    .name       = &quot;i2c&quot;,</span><br><span class="line">    .match      = i2c_device_match,</span><br><span class="line">    .probe      = i2c_device_probe,</span><br><span class="line">    .remove     = i2c_device_remove,</span><br><span class="line">    .shutdown   = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br></pre></td></tr></table></figure>

<h4 id="6-1-match"><a href="#6-1-match" class="headerlink" title="6.1 match"></a>6.1 match</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c </span><br><span class="line">static int i2c_device_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client = i2c_verify_client(dev);</span><br><span class="line">    struct i2c_driver   *driver;</span><br><span class="line"></span><br><span class="line">    if (!client)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    /* Attempt an OF style match */</span><br><span class="line">    if (of_driver_match_device(dev, drv))</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    /* Then ACPI style match */</span><br><span class="line">    if (acpi_driver_match_device(dev, drv))</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    driver = to_i2c_driver(drv);</span><br><span class="line">    /* match on an id table if there is one */</span><br><span class="line">    if (driver-&gt;id_table)</span><br><span class="line">        return i2c_match_id(driver-&gt;id_table, client) != NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph LR
    i2c_device_match(i2c_device_match)
    i2c_device_match-->of_driver_match_device(of_driver_match_device)
    i2c_device_match-->acpi_driver_match_device(acpi_driver_match_device)
    i2c_device_match--id_table-->i2c_match_id(i2c_match_id)</pre>




<p>从i2c_device_match()函数的定义可以得出，i2c的match函数，优先选择设备树匹配（of_driver_match_device），如果设备树匹配成功，函数就返回；否则，会进行下一个。。。。。。，最后，如果定义了id_table，就会通过i2c_match_id()函数进行id_table匹配；如果三者全都匹配不成功，才算是匹配失败；</p>
<p>从i2c_device_match函数来看，配置了设备树，就不需要id_table的定义了；但是实际上还是需要id_table的定义的，因为在后边的probe函数中需要判断id_table是否定义，如果定义了才能执行driver-&gt;probe函数；</p>
<p>设备树的匹配过程如下：</p>
<pre class="mermaid">graph TB
    of_driver_match_device(of_driver_match_device)-->
    of_match_device(of_match_device)-->
    of_match_node(of_match_node)-->
    __of_match_node(__of_match_node)-->
    __of_device_is_compatible(__of_device_is_compatible)
    __of_device_is_compatible--compatible-->of_compat_cmp(of_compat_cmp)
    __of_device_is_compatible--type-->of_compat_cmp
    __of_device_is_compatible--name-->of_compat_cmp
    of_compat_cmp-->
    strcasecmp(strcasecmp)</pre>




<p>__of_match_node()函数，把device_driver的of_match_table（struct of_device_id）和device里的of_node（struct device_node）进行匹配；</p>
<p>匹配方式是，在__of_device_is_compatible()函数里，分别调用of_compat_cmp()函数对两者的compatible、type、name字符串进行对比，compatible、type、name字符串要同时相同；一般情况下，name、type为空，只比较compatible字符串；比较compatible字符串时是比较整个字符串；这里的比较不是单纯的比较，是采用的加分制；</p>
<h4 id="6-2-probe"><a href="#6-2-probe" class="headerlink" title="6.2 probe"></a>6.2 probe</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// drivers/i2c/i2c-core.c</span><br><span class="line">static int i2c_device_probe(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client = i2c_verify_client(dev);</span><br><span class="line">    struct i2c_driver   *driver;</span><br><span class="line">    int status;</span><br><span class="line">    ......</span><br><span class="line">    driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line">    if (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">        return -ENODEV;</span><br><span class="line">	......</span><br><span class="line">    status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_device_probe()函数中，如果配置了设备树，i2c总线在match函数中，就不需要id_table的定义了；但是在probe函数中，还是需要id_table的定义的，因为在probe函数中需要判断id_table是否定义，如果定义了才能执行driver-&gt;probe函数；</p>
<h4 id="6-3-I2C注册匹配过程"><a href="#6-3-I2C注册匹配过程" class="headerlink" title="6.3 I2C注册匹配过程"></a>6.3 I2C注册匹配过程</h4><p><img src="/2020/04/06/Linux-kernel中的I2C子系统/I2C%E6%B3%A8%E5%86%8C%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="I2C注册匹配过程"></p>
<h3 id="7-实例"><a href="#7-实例" class="headerlink" title="7. 实例"></a>7. 实例</h3><p>以添加eeprom驱动为例讲解I2C驱动在eeprom芯片中的使用；</p>
<h4 id="7-1-添加设备"><a href="#7-1-添加设备" class="headerlink" title="7.1 添加设备"></a>7.1 添加设备</h4><h5 id="1）添加设备树"><a href="#1）添加设备树" class="headerlink" title="1）添加设备树"></a>1）添加设备树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// arch/arm/boot/dts/vexpress-v2m.dtsi</span><br><span class="line">			v2m_i2c_dvi: i2c@16000 &#123;</span><br><span class="line">                compatible = &quot;arm,versatile-i2c&quot;;</span><br><span class="line">                reg = &lt;0x16000 0x1000&gt;;</span><br><span class="line"></span><br><span class="line">                #address-cells = &lt;1&gt;;</span><br><span class="line">                #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">                dvi-transmitter@39 &#123;</span><br><span class="line">                    compatible = &quot;sil,sii9022-tpi&quot;, &quot;sil,sii9022&quot;;</span><br><span class="line">                    reg = &lt;0x39&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                dvi-transmitter@60 &#123;</span><br><span class="line">                    compatible = &quot;sil,sii9022-cpi&quot;, &quot;sil,sii9022&quot;;</span><br><span class="line">                    reg = &lt;0x60&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                eeprom@51 &#123;</span><br><span class="line">                    compatible = &quot;mcy,mcy_eeprom&quot;;</span><br><span class="line">                    reg = &lt;0x51&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2）i2c-new-device"><a href="#2）i2c-new-device" class="headerlink" title="2）i2c_new_device"></a>2）i2c_new_device</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcy_eeprom_device.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">eeprom_info</span> = &#123;</span> </span><br><span class="line">    I2C_BOARD_INFO(<span class="string">"eeprom_device"</span>, <span class="number">0x51</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eeprom_device_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    adap = i2c_get_adapter(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!adap) &#123;</span><br><span class="line">        printk(<span class="string">"%s, i2c_get_adapter failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client = i2c_new_device(adap, &amp;eeprom_info);</span><br><span class="line">    <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">        printk(<span class="string">"%s, i2c_new_device failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    i2c_put_adapter(adap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eeprom_device_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_unregister_device(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(eeprom_device_init);</span><br><span class="line">module_exit(eeprom_device_exit);</span><br></pre></td></tr></table></figure>

<h4 id="7-2-添加驱动"><a href="#7-2-添加驱动" class="headerlink" title="7.2 添加驱动"></a>7.2 添加驱动</h4><h5 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcy_eeprom_driver.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eeprom_data_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> reg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">16</span>];</span><br><span class="line">&#125; <span class="keyword">eeprom_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eeprom_driver_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span> devnum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line">&#125; <span class="keyword">eeprom_driver_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line"><span class="keyword">eeprom_driver_t</span> eeprom_driver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eeprom_driver_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eeprom_driver_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">eeprom_driver_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reg[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_from_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reg[<span class="number">0</span>] = (<span class="keyword">char</span>)((eeprom_data.reg &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    reg[<span class="number">1</span>] = (<span class="keyword">char</span>)(eeprom_data.reg &amp; <span class="number">0x000000ff</span>);</span><br><span class="line"></span><br><span class="line">    ret = i2c_master_send(eeprom_driver.client, reg, <span class="number">2</span>);</span><br><span class="line">    ret = i2c_master_recv(eeprom_driver.client, eeprom_data.data, eeprom_data.len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eeprom_data.len; i++) &#123;</span><br><span class="line">        printk(<span class="string">"%s, i2c_master_recv, reg[%d]: 0x%x, data: 0x%2x\n"</span>, __func__, i, eeprom_data.reg + i, eeprom_data.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = copy_to_user(buf, &amp;eeprom_data, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_to_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">eeprom_driver_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">18</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    ret = copy_from_user(&amp;eeprom_data, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, copy_from_user failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;data[<span class="number">2</span>], eeprom_data.data, eeprom_data.len);</span><br><span class="line">    data[<span class="number">0</span>] = (<span class="keyword">char</span>)((eeprom_data.reg &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    data[<span class="number">1</span>] = (<span class="keyword">char</span>)(eeprom_data.reg &amp; <span class="number">0x000000ff</span>);</span><br><span class="line">    len = eeprom_data.len + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        printk(<span class="string">"%s, data[%d]: 0x%2x\n"</span>, __func__, i, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = i2c_master_send(eeprom_driver.client, data, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">eeprom_driver_fops</span> = &#123;</span></span><br><span class="line">    .<span class="built_in">open</span> = eeprom_driver_open,</span><br><span class="line">    .<span class="built_in">release</span> = eeprom_driver_release,</span><br><span class="line">    .<span class="built_in">read</span> = eeprom_driver_read,</span><br><span class="line">    .<span class="built_in">write</span> = eeprom_driver_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eeprom_driver_probe</span><span class="params">(struct i2c_client *client, <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    eeprom_driver.client = client;</span><br><span class="line"></span><br><span class="line">    ret = alloc_chrdev_region(&amp;eeprom_driver.devnum, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"eeprom_driver_chrdev"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, alloc_chrdev_region failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> chrdev_err;</span><br><span class="line">    &#125;</span><br><span class="line">    major = MAJOR(eeprom_driver.devnum);</span><br><span class="line">    printk(<span class="string">"%s, alloc_chrdev_region, devnum: 0x%x, major: %d\n"</span>, __func__, eeprom_driver.devnum, major);</span><br><span class="line"></span><br><span class="line">    eeprom_driver.cdev = cdev_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!eeprom_driver.cdev) &#123;</span><br><span class="line">        printk(<span class="string">"%s, cdev_alloc failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> cdev_alloc_err;</span><br><span class="line">    &#125;</span><br><span class="line">    cdev_init(eeprom_driver.cdev, &amp;eeprom_driver_fops);</span><br><span class="line">    ret = cdev_add(eeprom_driver.cdev, eeprom_driver.devnum, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">"%s, cdev_add failed!\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> cdev_add_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// /sys/class</span></span><br><span class="line">    eeprom_driver<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, "<span class="title">eeprom_driver_class</span>");</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(eeprom_driver.class)) &#123;</span><br><span class="line">        printk(<span class="string">"%s, class_create failed!\n"</span>, __func__);</span><br><span class="line">        ret = PTR_ERR(eeprom_driver.class);</span><br><span class="line">        <span class="keyword">goto</span> class_create_err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// /dev</span></span><br><span class="line">    eeprom_driver.dev = device_create(eeprom_driver.class, <span class="literal">NULL</span>, eeprom_driver.devnum, <span class="literal">NULL</span>, <span class="string">"eeprom_driver"</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(eeprom_driver.dev)) &#123;</span><br><span class="line">        printk(<span class="string">"%s, device_create failed!\n"</span>, __func__);</span><br><span class="line">        ret = PTR_ERR(eeprom_driver.dev);</span><br><span class="line">        <span class="keyword">goto</span> device_create_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">device_create_err:</span><br><span class="line">    class_destroy(eeprom_driver.class);</span><br><span class="line">class_create_err:</span><br><span class="line">    cdev_del(eeprom_driver.cdev);</span><br><span class="line">cdev_add_err:</span><br><span class="line">    kfree(eeprom_driver.cdev);</span><br><span class="line">cdev_alloc_err:</span><br><span class="line">    unregister_chrdev_region(eeprom_driver.devnum, <span class="number">1</span>);</span><br><span class="line">chrdev_err:</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eeprom_driver_remove</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(eeprom_driver.class, eeprom_driver.devnum);</span><br><span class="line">    class_destroy(eeprom_driver.class);</span><br><span class="line"></span><br><span class="line">    cdev_del(eeprom_driver.cdev);</span><br><span class="line"></span><br><span class="line">    kfree(eeprom_driver.cdev);</span><br><span class="line">    unregister_chrdev_region(eeprom_driver.devnum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">eeprom_driver_id</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"mcy_eeprom"</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">eeprom_driver_table</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//.name = "mcy_eeprom",</span></span><br><span class="line">        .compatible = <span class="string">"mcy,mcy_eeprom"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">eeprom_i2c_driver</span>= &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .name = <span class="string">"mcy_eeprom"</span>,</span><br><span class="line">        <span class="comment">//.of_match_table = eeprom_driver_table,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = eeprom_driver_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = eeprom_driver_remove,</span><br><span class="line">    .id_table = eeprom_driver_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eeprom_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_add_driver(&amp;eeprom_i2c_driver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eeprom_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_del_driver(&amp;eeprom_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(eeprom_driver_init);</span><br><span class="line">module_exit(eeprom_driver_exit);</span><br></pre></td></tr></table></figure>

<h4 id="7-3-应用程序"><a href="#7-3-应用程序" class="headerlink" title="7.3 应用程序"></a>7.3 应用程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eeprom_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> reg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">16</span>];</span><br><span class="line">&#125; <span class="keyword">eeprom_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eeprom_read</span><span class="params">(<span class="keyword">int</span> reg, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, len: %d over range!\n"</span>, __func__, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    eeprom_data.reg = reg;</span><br><span class="line">    eeprom_data.len = len;</span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">read</span>(fd, &amp;eeprom_data, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, read failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, reg[%d]: %d, data: 0x%2x\n"</span>, __func__, i, reg + i, eeprom_data.data[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eeprom_write</span><span class="params">(<span class="keyword">int</span> reg, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">eeprom_data_t</span> eeprom_data;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, len: %d over range!\n"</span>, __func__, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;eeprom_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    eeprom_data.reg = reg;</span><br><span class="line">    eeprom_data.len = len;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">write</span>(fd, &amp;eeprom_data, <span class="keyword">sizeof</span>(<span class="keyword">eeprom_data_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, read failed, ret: %d\n"</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, reg[%d]: %d, data: 0x%2x\n"</span>, __func__, i, reg + i, eeprom_data.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> reg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/eeprom_driver"</span>, O_RDWR | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open failed, fd: %d\n"</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = eeprom_write(reg, len, buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"eeprom_write failed, ret: %d\n"</span>, ret);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = eeprom_read(reg, len);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"eeprom_read failed, ret: %d\n"</span>, ret);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-Makefile"><a href="#7-4-Makefile" class="headerlink" title="7.4 Makefile"></a>7.4 Makefile</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line">    obj-m := mcy_eeprom_driver.o mcy_eeprom_device.o</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">generate the path</span></span><br><span class="line">CURRENT_PATH:=$(shell pwd)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">the absolute path</span></span><br><span class="line">LINUX_KERNEL_PATH := /home/xiami/tool/linux-4.9.115</span><br><span class="line"></span><br><span class="line">CROSS_COMPILE := arm-linux-gnueabi-</span><br><span class="line">CC := $(CROSS_COMPILE)gcc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">complie object</span></span><br><span class="line">all:</span><br><span class="line">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">clean:</span><br><span class="line">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</span><br><span class="line">    -rm main -rf</span><br><span class="line">app:</span><br><span class="line">    $(CC) main.c -o main</span><br><span class="line">install:</span><br><span class="line">    -chmod a+x *.ko</span><br><span class="line">    -cp *.ko /home/xiami/qemu/nfs_root/mcy -rfp</span><br><span class="line">    -cp main /home/xiami/qemu/nfs_root/mcy -rfp</span><br><span class="line">    -chmod a+x /home/xiami/qemu/nfs_root/mcy/* main</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>I2C总线维护两个链表，一个是I2C驱动链表，一个是I2C设备链表，每当注册一个驱动（或设备），就会将其添加到I2C总线上相对应的I2C驱动链表（或I2C设备链表），然后遍历I2C总线的I2C设备（或I2C驱动）链表的所有设备（或驱动），通过I2C总线的匹配函数判断是否匹配，如果匹配，就调用驱动的probe函数，然后就可以在probe函数中注册字符设备，创建设备节点，实现设备操作集fops等，为应用调用提供接口；</p>
<p>参考资料</p>
<p><a href="https://blog.csdn.net/shichaog/article/details/41169981">https://blog.csdn.net/shichaog/article/details/41169981</a></p>
<p>《Linux设备驱动开发详解》</p>
<p>《精通linux设备驱动程序开发》</p>
<p><a href="#目录">回到目录</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/i2c/" rel="tag"># i2c</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/20/Qemu搭建ARM-vexpress开发环境(二)----u-boot启动kernel/" rel="prev" title="Qemu搭建ARM vexpress开发环境(二)----u-boot启动kernel">
      <i class="fa fa-chevron-left"></i> Qemu搭建ARM vexpress开发环境(二)----u-boot启动kernel
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/12/Linux-kernel中的i2c-dev驱动/" rel="next" title="Linux-kernel中的i2c-dev驱动">
      Linux-kernel中的i2c-dev驱动 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-简述"><span class="nav-text">0. 简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-I2C驱动框架"><span class="nav-text">1. I2C驱动框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-I2C核心"><span class="nav-text">1.1 I2C核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-I2C总线驱动"><span class="nav-text">1.2 I2C总线驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-I2C设备驱动"><span class="nav-text">1.3 I2C设备驱动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-核心数据结构"><span class="nav-text">2. 核心数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-设备层"><span class="nav-text">2.1 设备层</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-I2C设备（i2c-client）"><span class="nav-text">2.1.1 I2C设备（i2c_client）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-I2C驱动（i2c-driver）"><span class="nav-text">2.1.2 I2C驱动（i2c_driver）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-总线和设备关系"><span class="nav-text">2.1.3 总线和设备关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-总线层"><span class="nav-text">2.2 总线层</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-I2C适配器（i2c-adapter）"><span class="nav-text">2.2.1 I2C适配器（i2c_adapter）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-I2C总线算法（i2c-algorithm）"><span class="nav-text">2.2.2 I2C总线算法（i2c_algorithm）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-I2C总线类型"><span class="nav-text">2.2.3 I2C总线类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-总线层和设备层关系"><span class="nav-text">2.3 总线层和设备层关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-数据结构间的关系"><span class="nav-text">2.4 数据结构间的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-重要的操作函数"><span class="nav-text">3. 重要的操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-I2C子系统初始化"><span class="nav-text">3.1 I2C子系统初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-I2C总线初始化"><span class="nav-text">3.1.1 I2C总线初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-I2C总线退出"><span class="nav-text">3.1.2 I2C总线退出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-适配器驱动"><span class="nav-text">3.2 适配器驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-添加适配器驱动"><span class="nav-text">3.2.1 添加适配器驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-注销适配器驱动"><span class="nav-text">3.2.2 注销适配器驱动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-注册I2C驱动"><span class="nav-text">3.3 注册I2C驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-注册I2C驱动"><span class="nav-text">3.3.1 注册I2C驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-注销I2C驱动"><span class="nav-text">3.3.2 注销I2C驱动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-注册I2C设备"><span class="nav-text">3.4 注册I2C设备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-注册I2C设备"><span class="nav-text">3.4.1 注册I2C设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-注销I2C设备"><span class="nav-text">3.4.2 注销I2C设备</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-适配器和设备通信"><span class="nav-text">3.5 适配器和设备通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-1-i2c-transfer"><span class="nav-text">3.5.1 i2c_transfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-消息格式"><span class="nav-text">3.5.2 消息格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-3-消息发送、接收函数"><span class="nav-text">3.5.3 消息发送、接收函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）发送函数"><span class="nav-text">1）发送函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）接收函数"><span class="nav-text">2）接收函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-添加设备"><span class="nav-text">4. 添加设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-添加设备树"><span class="nav-text">4.1 添加设备树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-i2c-new-device添加"><span class="nav-text">4.2 i2c_new_device添加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-静态注册I2C设备"><span class="nav-text">4.3 静态注册I2C设备</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-添加驱动"><span class="nav-text">5. 添加驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-I2C设备驱动框架"><span class="nav-text">5.1 I2C设备驱动框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-probe函数"><span class="nav-text">5.2 probe函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1）注册字符设备"><span class="nav-text">1）注册字符设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2）卸载函数"><span class="nav-text">2）卸载函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3）字符设备操作集"><span class="nav-text">3）字符设备操作集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-读写函数"><span class="nav-text">5.3 读写函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-内核函数调用"><span class="nav-text">5.3.1 内核函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）发送"><span class="nav-text">1）发送</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）接收"><span class="nav-text">2）接收</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-直接封装"><span class="nav-text">5.3.2 直接封装</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）发送-1"><span class="nav-text">1）发送</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）接收-1"><span class="nav-text">2）接收</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-驱动和设备匹配"><span class="nav-text">6. 驱动和设备匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-match"><span class="nav-text">6.1 match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-probe"><span class="nav-text">6.2 probe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-I2C注册匹配过程"><span class="nav-text">6.3 I2C注册匹配过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-实例"><span class="nav-text">7. 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-添加设备"><span class="nav-text">7.1 添加设备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1）添加设备树"><span class="nav-text">1）添加设备树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2）i2c-new-device"><span class="nav-text">2）i2c_new_device</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-添加驱动"><span class="nav-text">7.2 添加驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实例代码"><span class="nav-text">实例代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-应用程序"><span class="nav-text">7.3 应用程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-Makefile"><span class="nav-text">7.4 Makefile</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-总结"><span class="nav-text">8. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">micro虾米</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">micro虾米</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


  <script src='https://unpkg.com/mermaid@/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '1ec7eee73ee4f91e15a1',
      clientSecret: '971b3c9439c2a8fa2fcb12307657ad50aee6ed0c',
      repo        : 'mshrimp_blog_talk',
      owner       : 'mshrimp',
      admin       : ['mshrimp'],
      id          : 'f09465bc99eef87bebd3c6fd53effe3c',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
